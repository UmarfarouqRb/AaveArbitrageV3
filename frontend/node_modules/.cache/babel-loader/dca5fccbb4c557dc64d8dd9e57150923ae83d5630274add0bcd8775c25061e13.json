{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"contract\", \"events\", \"blockRange\", \"useIndexer\"];\nimport { formatLog } from \"viem\";\nimport { resolveContractAbi } from \"../../contract/actions/resolve-abi.js\";\nimport { getContractEvents as getContractEventsInsight } from \"../../insight/get-events.js\";\nimport { eth_blockNumber } from \"../../rpc/actions/eth_blockNumber.js\";\nimport { eth_getLogs } from \"../../rpc/actions/eth_getLogs.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { numberToHex } from \"../../utils/encoding/hex.js\";\nimport { prepareEvent } from \"../prepare-event.js\";\nimport { isAbiEvent } from \"../utils.js\";\nimport { parseEventLogs } from \"./parse-logs.js\";\n/**\n * Retrieves events from a contract based on the provided options.\n * @param options - The options for retrieving events.\n * @returns A promise that resolves to an array of parsed event logs.\n * Note: toBlock and fromBlock are both inclusive.\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * const events = await getContractEvents({\n *  contract: myContract,\n *  fromBlock: 123456n,\n *  toBlock: 123456n,\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @example\n * Optionally specify a blockRange as the number of blocks to retrieve. toBlock will default to the current block number.\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * const events = await getContractEvents({\n *  contract: myContract,\n *  blockRange: 123456n,\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @example\n * Use fromBlock with blockRange for pagination.\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * const events = await getContractEvents({\n *  contract: myContract,\n *  fromBlock: lastBlockFetched,\n *  blockRange: 123456n,\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @example\n * Retrieve events for a specific block hash.\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * const events = await getContractEvents({\n *  contract: myContract,\n *  blockHash: \"0x...\",\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @contract\n */\nexport async function getContractEvents(options) {\n  const {\n      contract,\n      events,\n      blockRange,\n      useIndexer = true\n    } = options,\n    restParams = _objectWithoutProperties(options, _excluded);\n  const rpcRequest = getRpcClient(contract);\n  if (restParams.blockHash && (blockRange || restParams.fromBlock || restParams.toBlock)) {\n    throw new Error(\"Cannot specify blockHash and range simultaneously,\");\n  }\n  const latestBlockNumber = await eth_blockNumber(rpcRequest);\n  // Compute toBlock and fromBlock if blockRange was passed\n  if (blockRange) {\n    const {\n      fromBlock,\n      toBlock\n    } = restParams;\n    // Make sure the inputs were properly defined\n    if (fromBlock !== undefined && toBlock !== undefined && BigInt(toBlock) - BigInt(fromBlock) !== BigInt(blockRange)) {\n      throw new Error(\"Incompatible blockRange with specified fromBlock and toBlock. Please only define fromBlock or toBlock when specifying blockRange.\");\n    }\n    if (fromBlock !== undefined) {\n      restParams.toBlock = BigInt(fromBlock) + BigInt(blockRange) - 1n; // Subtract one because toBlock is inclusive\n    } else if (toBlock !== undefined) {\n      restParams.fromBlock = BigInt(toBlock) - BigInt(blockRange) + 1n; // Add one because fromBlock is inclusive\n    } else {\n      // If no from or to block specified, use the latest block as the to block\n      restParams.toBlock = latestBlockNumber;\n      restParams.fromBlock = latestBlockNumber - BigInt(blockRange) + 1n; // Add one because fromBlock is inclusive\n    }\n  }\n  let resolvedEvents = events !== null && events !== void 0 ? events : [];\n  // if we have an abi on the contract, we can encode the topics with it\n  if (!(events !== null && events !== void 0 && events.length) && !!contract) {\n    var _contract$abi;\n    if (useIndexer) {\n      // fetch all events from the indexer, no need to get events from ABI\n      const events = await getContractEventsInsight({\n        chains: [contract.chain],\n        client: contract.client,\n        contractAddress: contract.address,\n        decodeLogs: true,\n        queryOptions: {\n          filter_block_hash: restParams.blockHash,\n          filter_block_number_gte: restParams.fromBlock,\n          filter_block_number_lte: restParams.toBlock,\n          limit: 500\n        }\n      }).catch(() => {\n        // chain might not support indexer\n        return null;\n      });\n      if (events) {\n        return toLog(events);\n      }\n    }\n    // if we have a contract *WITH* an abi we can use that\n    if ((_contract$abi = contract.abi) !== null && _contract$abi !== void 0 && _contract$abi.length) {\n      // @ts-expect-error - we can't make typescript happy here, but we know this is an abi event\n      resolvedEvents = contract.abi.filter(isAbiEvent).map(abiEvent => prepareEvent({\n        signature: abiEvent\n      }));\n    } else {\n      const runtimeAbi = await resolveContractAbi(contract);\n      // @ts-expect-error - we can't make typescript happy here, but we know this is an abi event\n      resolvedEvents = runtimeAbi.filter(isAbiEvent).map(abiEvent => prepareEvent({\n        signature: abiEvent\n      }));\n    }\n  }\n  const logsParams = events && events.length > 0 ?\n  // if we have events passed in then we use those\n  events.map(e => _objectSpread(_objectSpread({}, restParams), {}, {\n    address: getAddress(contract.address),\n    topics: e.topics\n  })) :\n  // otherwise we want \"all\" events (aka not pass any topics at all)\n  [_objectSpread(_objectSpread({}, restParams), {}, {\n    address: getAddress(contract.address)\n  })];\n  let logs = [];\n  // try fetching from insight if available\n  if (useIndexer) {\n    try {\n      logs = await Promise.all(logsParams.map(p => getLogsFromInsight({\n        contract,\n        params: p\n      })));\n    } catch (e) {\n      console.warn(\"Error fetching from insight, falling back to rpc\", e);\n      // fetch from rpc\n      logs = await Promise.all(logsParams.map(ethLogParams => eth_getLogs(rpcRequest, ethLogParams)));\n    }\n  } else {\n    // fetch from rpc\n    logs = await Promise.all(logsParams.map(ethLogParams => eth_getLogs(rpcRequest, ethLogParams)));\n  }\n  const flattenLogs = logs.flat().sort((a, b) => {\n    var _a$blockNumber, _b$blockNumber;\n    return Number(((_a$blockNumber = a.blockNumber) !== null && _a$blockNumber !== void 0 ? _a$blockNumber : 0n) - ((_b$blockNumber = b.blockNumber) !== null && _b$blockNumber !== void 0 ? _b$blockNumber : 0n));\n  });\n  return parseEventLogs({\n    events: resolvedEvents,\n    logs: flattenLogs\n  });\n}\nasync function getLogsFromInsight(options) {\n  var _params$topics, _params$topics2, _params$topics3, _params$topics4;\n  const {\n    params,\n    contract\n  } = options;\n  const fromBlock = typeof params.fromBlock === \"bigint\" ? Number(params.fromBlock) : undefined;\n  const toBlock = typeof params.toBlock === \"bigint\" ? Number(params.toBlock) : undefined;\n  const r = await getContractEventsInsight({\n    chains: [contract.chain],\n    client: contract.client,\n    contractAddress: contract.address,\n    queryOptions: {\n      filter_block_hash: params.blockHash,\n      filter_block_number_gte: fromBlock,\n      filter_block_number_lte: toBlock,\n      filter_topic_0: (_params$topics = params.topics) === null || _params$topics === void 0 ? void 0 : _params$topics[0],\n      filter_topic_1: (_params$topics2 = params.topics) === null || _params$topics2 === void 0 ? void 0 : _params$topics2[1],\n      filter_topic_2: (_params$topics3 = params.topics) === null || _params$topics3 === void 0 ? void 0 : _params$topics3[2],\n      filter_topic_3: (_params$topics4 = params.topics) === null || _params$topics4 === void 0 ? void 0 : _params$topics4[3],\n      limit: 500\n    }\n  });\n  return toLog(r);\n}\nfunction toLog(r) {\n  const cleanedEventData = r.map(tx => _objectSpread({\n    address: tx.address,\n    blockHash: tx.block_hash,\n    blockNumber: numberToHex(Number(tx.block_number)),\n    blockTimestamp: tx.block_timestamp,\n    chainId: tx.chain_id,\n    data: tx.data,\n    logIndex: numberToHex(tx.log_index),\n    topics: tx.topics,\n    transactionHash: tx.transaction_hash,\n    transactionIndex: numberToHex(tx.transaction_index)\n  }, tx.decoded ? {\n    args: _objectSpread(_objectSpread({}, tx.decoded.indexed_params), tx.decoded.non_indexed_params),\n    eventName: tx.decoded.name\n  } : {}));\n  return cleanedEventData.map(e => formatLog(e)).sort((a, b) => {\n    var _a$blockNumber2, _b$blockNumber2;\n    return Number(((_a$blockNumber2 = a.blockNumber) !== null && _a$blockNumber2 !== void 0 ? _a$blockNumber2 : 0n) - ((_b$blockNumber2 = b.blockNumber) !== null && _b$blockNumber2 !== void 0 ? _b$blockNumber2 : 0n));\n  });\n}","map":{"version":3,"names":["formatLog","resolveContractAbi","getContractEvents","getContractEventsInsight","eth_blockNumber","eth_getLogs","getRpcClient","getAddress","numberToHex","prepareEvent","isAbiEvent","parseEventLogs","options","contract","events","blockRange","useIndexer","restParams","_objectWithoutProperties","_excluded","rpcRequest","blockHash","fromBlock","toBlock","Error","latestBlockNumber","undefined","BigInt","resolvedEvents","length","_contract$abi","chains","chain","client","contractAddress","address","decodeLogs","queryOptions","filter_block_hash","filter_block_number_gte","filter_block_number_lte","limit","catch","toLog","abi","filter","map","abiEvent","signature","runtimeAbi","logsParams","e","_objectSpread","topics","logs","Promise","all","p","getLogsFromInsight","params","console","warn","ethLogParams","flattenLogs","flat","sort","a","b","_a$blockNumber","_b$blockNumber","Number","blockNumber","_params$topics","_params$topics2","_params$topics3","_params$topics4","r","filter_topic_0","filter_topic_1","filter_topic_2","filter_topic_3","cleanedEventData","tx","block_hash","block_number","blockTimestamp","block_timestamp","chainId","chain_id","data","logIndex","log_index","transactionHash","transaction_hash","transactionIndex","transaction_index","decoded","args","indexed_params","non_indexed_params","eventName","name","_a$blockNumber2","_b$blockNumber2"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/event/actions/get-events.ts"],"sourcesContent":["import type {\n  Abi,\n  AbiEvent,\n  ExtractAbiEvent,\n  ExtractAbiEventNames,\n} from \"abitype\";\nimport { formatLog, type Log } from \"viem\";\nimport { resolveContractAbi } from \"../../contract/actions/resolve-abi.js\";\nimport type { ThirdwebContract } from \"../../contract/contract.js\";\nimport {\n  type ContractEvent,\n  getContractEvents as getContractEventsInsight,\n} from \"../../insight/get-events.js\";\nimport { eth_blockNumber } from \"../../rpc/actions/eth_blockNumber.js\";\nimport {\n  eth_getLogs,\n  type GetLogsBlockParams,\n  type GetLogsParams,\n} from \"../../rpc/actions/eth_getLogs.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { type Hex, numberToHex } from \"../../utils/encoding/hex.js\";\nimport type { Prettify } from \"../../utils/type-utils.js\";\nimport { type PreparedEvent, prepareEvent } from \"../prepare-event.js\";\nimport { isAbiEvent } from \"../utils.js\";\nimport { type ParseEventLogsResult, parseEventLogs } from \"./parse-logs.js\";\n\nexport type GetContractEventsOptionsDirect<\n  abi extends Abi,\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n> = {\n  contract: ThirdwebContract<abi>;\n  events?: abiEvents;\n  strict?: TStrict;\n  useIndexer?: boolean;\n};\n\nexport type GetContractEventsOptions<\n  abi extends Abi,\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n> = Prettify<\n  GetContractEventsOptionsDirect<abi, abiEvents, TStrict> & GetLogsBlockParams\n>;\n\nexport type GetContractEventsResult<\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n> = ParseEventLogsResult<abiEvents, TStrict>;\n\ntype GetLogsParamsExtra = {\n  signature?: string;\n} & GetLogsParams;\n\n/**\n * Retrieves events from a contract based on the provided options.\n * @param options - The options for retrieving events.\n * @returns A promise that resolves to an array of parsed event logs.\n * Note: toBlock and fromBlock are both inclusive.\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * const events = await getContractEvents({\n *  contract: myContract,\n *  fromBlock: 123456n,\n *  toBlock: 123456n,\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @example\n * Optionally specify a blockRange as the number of blocks to retrieve. toBlock will default to the current block number.\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * const events = await getContractEvents({\n *  contract: myContract,\n *  blockRange: 123456n,\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @example\n * Use fromBlock with blockRange for pagination.\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * const events = await getContractEvents({\n *  contract: myContract,\n *  fromBlock: lastBlockFetched,\n *  blockRange: 123456n,\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @example\n * Retrieve events for a specific block hash.\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * const events = await getContractEvents({\n *  contract: myContract,\n *  blockHash: \"0x...\",\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @contract\n */\nexport async function getContractEvents<\n  const abi extends Abi,\n  const abiEvents extends PreparedEvent<AbiEvent>[] = PreparedEvent<\n    ExtractAbiEvent<abi, ExtractAbiEventNames<abi>>\n  >[],\n  const TStrict extends boolean = true,\n>(\n  options: GetContractEventsOptions<abi, abiEvents, TStrict>,\n): Promise<GetContractEventsResult<abiEvents, TStrict>> {\n  const {\n    contract,\n    events,\n    blockRange,\n    useIndexer = true,\n    ...restParams\n  } = options;\n\n  const rpcRequest = getRpcClient(contract);\n\n  if (\n    restParams.blockHash &&\n    (blockRange || restParams.fromBlock || restParams.toBlock)\n  ) {\n    throw new Error(\"Cannot specify blockHash and range simultaneously,\");\n  }\n\n  const latestBlockNumber = await eth_blockNumber(rpcRequest);\n\n  // Compute toBlock and fromBlock if blockRange was passed\n  if (blockRange) {\n    const { fromBlock, toBlock } = restParams;\n\n    // Make sure the inputs were properly defined\n    if (\n      fromBlock !== undefined &&\n      toBlock !== undefined &&\n      BigInt(toBlock) - BigInt(fromBlock) !== BigInt(blockRange)\n    ) {\n      throw new Error(\n        \"Incompatible blockRange with specified fromBlock and toBlock. Please only define fromBlock or toBlock when specifying blockRange.\",\n      );\n    }\n\n    if (fromBlock !== undefined) {\n      restParams.toBlock = BigInt(fromBlock) + BigInt(blockRange) - 1n; // Subtract one because toBlock is inclusive\n    } else if (toBlock !== undefined) {\n      restParams.fromBlock = BigInt(toBlock) - BigInt(blockRange) + 1n; // Add one because fromBlock is inclusive\n    } else {\n      // If no from or to block specified, use the latest block as the to block\n      restParams.toBlock = latestBlockNumber;\n      restParams.fromBlock = latestBlockNumber - BigInt(blockRange) + 1n; // Add one because fromBlock is inclusive\n    }\n  }\n\n  let resolvedEvents = events ?? [];\n\n  // if we have an abi on the contract, we can encode the topics with it\n  if (!events?.length && !!contract) {\n    if (useIndexer) {\n      // fetch all events from the indexer, no need to get events from ABI\n      const events = await getContractEventsInsight({\n        chains: [contract.chain],\n        client: contract.client,\n        contractAddress: contract.address,\n        decodeLogs: true,\n        queryOptions: {\n          filter_block_hash: restParams.blockHash,\n          filter_block_number_gte: restParams.fromBlock,\n          filter_block_number_lte: restParams.toBlock,\n          limit: 500,\n        },\n      }).catch(() => {\n        // chain might not support indexer\n        return null;\n      });\n      if (events) {\n        return toLog(events) as GetContractEventsResult<abiEvents, TStrict>;\n      }\n    }\n\n    // if we have a contract *WITH* an abi we can use that\n    if (contract.abi?.length) {\n      // @ts-expect-error - we can't make typescript happy here, but we know this is an abi event\n      resolvedEvents = contract.abi\n        .filter(isAbiEvent)\n        .map((abiEvent) => prepareEvent({ signature: abiEvent }));\n    } else {\n      const runtimeAbi = await resolveContractAbi(contract);\n      // @ts-expect-error - we can't make typescript happy here, but we know this is an abi event\n      resolvedEvents = runtimeAbi\n        .filter(isAbiEvent)\n        .map((abiEvent) => prepareEvent({ signature: abiEvent }));\n    }\n  }\n\n  const logsParams: GetLogsParamsExtra[] =\n    events && events.length > 0\n      ? // if we have events passed in then we use those\n        events.map((e) => ({\n          ...restParams,\n          address: getAddress(contract.address),\n          topics: e.topics,\n        }))\n      : // otherwise we want \"all\" events (aka not pass any topics at all)\n        [{ ...restParams, address: getAddress(contract.address) }];\n\n  let logs: Log[][] = [];\n\n  // try fetching from insight if available\n  if (useIndexer) {\n    try {\n      logs = await Promise.all(\n        logsParams.map((p) =>\n          getLogsFromInsight({\n            contract,\n            params: p,\n          }),\n        ),\n      );\n    } catch (e) {\n      console.warn(\"Error fetching from insight, falling back to rpc\", e);\n      // fetch from rpc\n      logs = await Promise.all(\n        logsParams.map((ethLogParams) => eth_getLogs(rpcRequest, ethLogParams)),\n      );\n    }\n  } else {\n    // fetch from rpc\n    logs = await Promise.all(\n      logsParams.map((ethLogParams) => eth_getLogs(rpcRequest, ethLogParams)),\n    );\n  }\n\n  const flattenLogs = logs\n    .flat()\n    .sort((a, b) => Number((a.blockNumber ?? 0n) - (b.blockNumber ?? 0n)));\n  return parseEventLogs({\n    events: resolvedEvents,\n    logs: flattenLogs,\n  });\n}\n\nasync function getLogsFromInsight(options: {\n  params: GetLogsParamsExtra;\n  contract: ThirdwebContract<Abi>;\n}): Promise<Log[]> {\n  const { params, contract } = options;\n\n  const fromBlock =\n    typeof params.fromBlock === \"bigint\" ? Number(params.fromBlock) : undefined;\n\n  const toBlock =\n    typeof params.toBlock === \"bigint\" ? Number(params.toBlock) : undefined;\n\n  const r = await getContractEventsInsight({\n    chains: [contract.chain],\n    client: contract.client,\n    contractAddress: contract.address,\n    queryOptions: {\n      filter_block_hash: params.blockHash,\n      filter_block_number_gte: fromBlock,\n      filter_block_number_lte: toBlock,\n      filter_topic_0: params.topics?.[0] as Hex | undefined,\n      filter_topic_1: params.topics?.[1] as Hex | undefined,\n      filter_topic_2: params.topics?.[2] as Hex | undefined,\n      filter_topic_3: params.topics?.[3] as Hex | undefined,\n      limit: 500,\n    },\n  });\n\n  return toLog(r);\n}\n\nfunction toLog(r: ContractEvent[]) {\n  const cleanedEventData = r.map((tx) => ({\n    address: tx.address as Hex,\n    blockHash: tx.block_hash as Hex,\n    blockNumber: numberToHex(Number(tx.block_number)),\n    blockTimestamp: tx.block_timestamp,\n    chainId: tx.chain_id,\n    data: tx.data as Hex,\n    logIndex: numberToHex(tx.log_index),\n    topics: tx.topics as [`0x${string}`, ...`0x${string}`[]] | [] | undefined,\n    transactionHash: tx.transaction_hash as Hex,\n    transactionIndex: numberToHex(tx.transaction_index),\n    ...(tx.decoded\n      ? {\n          args: {\n            ...tx.decoded.indexed_params,\n            ...tx.decoded.non_indexed_params,\n          },\n          eventName: tx.decoded.name,\n        }\n      : {}),\n  }));\n\n  return cleanedEventData\n    .map((e) => formatLog(e))\n    .sort((a, b) => Number((a.blockNumber ?? 0n) - (b.blockNumber ?? 0n)));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}