{"ast":null,"code":"import { cacheChains } from \"../../chains/utils.js\";\nimport { computedStore } from \"../../reactive/computedStore.js\";\nimport { effect } from \"../../reactive/effect.js\";\nimport { createStore } from \"../../reactive/store.js\";\nimport { stringify } from \"../../utils/json.js\";\nimport { deleteConnectParamsFromStorage } from \"../../utils/storage/walletStorage.js\";\nimport { isSmartWallet } from \"../smart/index.js\";\nimport { smartWallet } from \"../smart/smart-wallet.js\";\nconst CONNECTED_WALLET_IDS = \"thirdweb:connected-wallet-ids\";\nconst LAST_ACTIVE_EOA_ID = \"thirdweb:active-wallet-id\";\nconst LAST_ACTIVE_CHAIN = \"thirdweb:active-chain\";\n/**\n * Create a connection manager for Wallet connections\n * @param storage - An instance of type [`AsyncStorage`](https://portal.thirdweb.com/references/typescript/v5/AsyncStorage)\n * @example\n * ```ts\n * const manager = createConnectionManager();\n * ```\n * @returns A connection manager object\n * @walletUtils\n */\nexport function createConnectionManager(storage) {\n  // stores\n  // active wallet/account\n  const activeWalletStore = createStore(undefined);\n  const activeAccountStore = createStore(undefined);\n  const activeWalletChainStore = createStore(undefined);\n  const activeWalletConnectionStatusStore = createStore(\"unknown\");\n  const definedChainsStore = createStore(new Map());\n  // update global cachedChains when defined Chains store updates\n  effect(() => {\n    cacheChains([...definedChainsStore.getValue().values()]);\n  }, [definedChainsStore]);\n  // change the active chain object to use the defined chain object\n  effect(() => {\n    const chainVal = activeWalletChainStore.getValue();\n    if (!chainVal) {\n      return;\n    }\n    const definedChain = definedChainsStore.getValue().get(chainVal.id);\n    if (!definedChain || definedChain === chainVal) {\n      return;\n    }\n    // update active chain store\n    activeWalletChainStore.setValue(definedChain);\n  }, [definedChainsStore, activeWalletChainStore]);\n  // other connected accounts\n  const walletIdToConnectedWalletMap = createStore(new Map());\n  const isAutoConnecting = createStore(false);\n  const connectedWallets = computedStore(() => {\n    return Array.from(walletIdToConnectedWalletMap.getValue().values());\n  }, [walletIdToConnectedWalletMap]);\n  // actions\n  const addConnectedWallet = wallet => {\n    const oldValue = walletIdToConnectedWalletMap.getValue();\n    if (oldValue.has(wallet.id)) {\n      return;\n    }\n    const newValue = new Map(oldValue);\n    newValue.set(wallet.id, wallet);\n    walletIdToConnectedWalletMap.setValue(newValue);\n  };\n  const removeConnectedWallet = wallet => {\n    const oldValue = walletIdToConnectedWalletMap.getValue();\n    const newValue = new Map(oldValue);\n    newValue.delete(wallet.id);\n    walletIdToConnectedWalletMap.setValue(newValue);\n  };\n  const onWalletDisconnect = wallet => {\n    deleteConnectParamsFromStorage(storage, wallet.id);\n    removeConnectedWallet(wallet);\n    // if disconnecting the active wallet\n    if (activeWalletStore.getValue() === wallet) {\n      storage.removeItem(LAST_ACTIVE_EOA_ID);\n      activeAccountStore.setValue(undefined);\n      activeWalletChainStore.setValue(undefined);\n      activeWalletStore.setValue(undefined);\n      activeWalletConnectionStatusStore.setValue(\"disconnected\");\n    }\n  };\n  const disconnectWallet = wallet => {\n    onWalletDisconnect(wallet);\n    wallet.disconnect();\n  };\n  // handle the connection logic, but don't set the wallet as active\n  const handleConnection = async (wallet, options) => {\n    const account = wallet.getAccount();\n    if (!account) {\n      throw new Error(\"Cannot set a wallet without an account as active\");\n    }\n    const activeWallet = await (async () => {\n      if (options !== null && options !== void 0 && options.accountAbstraction && !isSmartWallet(wallet)) {\n        return await handleSmartWalletConnection(wallet, options.client, options.accountAbstraction, onWalletDisconnect);\n      } else {\n        return wallet;\n      }\n    })();\n    await storage.setItem(LAST_ACTIVE_EOA_ID, wallet.id);\n    // add personal wallet to connected wallets list even if it's not the active one\n    addConnectedWallet(wallet);\n    if ((options === null || options === void 0 ? void 0 : options.setWalletAsActive) !== false) {\n      handleSetActiveWallet(activeWallet);\n    }\n    wallet.subscribe(\"accountChanged\", async () => {\n      var _options$onConnect;\n      // We reimplement connect here to prevent memory leaks\n      const newWallet = await handleConnection(wallet, options);\n      options === null || options === void 0 || (_options$onConnect = options.onConnect) === null || _options$onConnect === void 0 || _options$onConnect.call(options, newWallet);\n    });\n    return activeWallet;\n  };\n  const connect = async (wallet, options) => {\n    var _options$onConnect2;\n    // connectedWallet can be either wallet or smartWallet\n    const connectedWallet = await handleConnection(wallet, options);\n    options === null || options === void 0 || (_options$onConnect2 = options.onConnect) === null || _options$onConnect2 === void 0 || _options$onConnect2.call(options, connectedWallet);\n    return connectedWallet;\n  };\n  const handleSetActiveWallet = activeWallet => {\n    const account = activeWallet.getAccount();\n    if (!account) {\n      throw new Error(\"Cannot set a wallet without an account as active\");\n    }\n    // also add it to connected wallets if it's not already there\n    addConnectedWallet(activeWallet);\n    // update active states\n    activeWalletStore.setValue(activeWallet);\n    activeAccountStore.setValue(account);\n    activeWalletChainStore.setValue(activeWallet.getChain());\n    activeWalletConnectionStatusStore.setValue(\"connected\");\n    // setup listeners\n    const onAccountsChanged = newAccount => {\n      activeAccountStore.setValue(newAccount);\n    };\n    const unsubAccounts = activeWallet.subscribe(\"accountChanged\", onAccountsChanged);\n    const unsubChainChanged = activeWallet.subscribe(\"chainChanged\", chain => activeWalletChainStore.setValue(chain));\n    const unsubDisconnect = activeWallet.subscribe(\"disconnect\", () => {\n      handleDisconnect();\n    });\n    const handleDisconnect = () => {\n      onWalletDisconnect(activeWallet);\n      unsubAccounts();\n      unsubChainChanged();\n      unsubDisconnect();\n    };\n  };\n  const setActiveWallet = async activeWallet => {\n    handleSetActiveWallet(activeWallet);\n    // do not set smart wallet as last active EOA\n    if (activeWallet.id !== \"smart\") {\n      await storage.setItem(LAST_ACTIVE_EOA_ID, activeWallet.id);\n    }\n  };\n  // side effects\n  effect(() => {\n    const _chain = activeWalletChainStore.getValue();\n    if (_chain) {\n      storage.setItem(LAST_ACTIVE_CHAIN, stringify(_chain));\n    } else {\n      storage.removeItem(LAST_ACTIVE_CHAIN);\n    }\n  }, [activeWalletChainStore], false);\n  // save last connected wallet ids to storage\n  effect(async () => {\n    const accounts = connectedWallets.getValue();\n    const ids = accounts.map(acc => acc === null || acc === void 0 ? void 0 : acc.id).filter(c => !!c);\n    storage.setItem(CONNECTED_WALLET_IDS, stringify(Array.from(new Set([...ids]))));\n  }, [connectedWallets], false);\n  const switchActiveWalletChain = async chain => {\n    const wallet = activeWalletStore.getValue();\n    if (!wallet) {\n      throw new Error(\"No active wallet found\");\n    }\n    if (!wallet.switchChain) {\n      throw new Error(\"Wallet does not support switching chains\");\n    }\n    if (isSmartWallet(wallet)) {\n      // also switch personal wallet\n      const personalWalletId = await getStoredActiveWalletId(storage);\n      if (personalWalletId) {\n        const personalWallet = connectedWallets.getValue().find(w => w.id === personalWalletId);\n        if (personalWallet) {\n          await personalWallet.switchChain(chain);\n          await wallet.switchChain(chain);\n          // reset the active wallet as switch chain recreates a new smart account\n          handleSetActiveWallet(wallet);\n          return;\n        }\n      }\n      // If we couldn't find the personal wallet, just switch the smart wallet\n      await wallet.switchChain(chain);\n      handleSetActiveWallet(wallet);\n    } else {\n      await wallet.switchChain(chain);\n    }\n    // for wallets that dont implement events, just set it manually\n    activeWalletChainStore.setValue(wallet.getChain());\n  };\n  function defineChains(chains) {\n    const currentMapVal = definedChainsStore.getValue();\n    // if all chains to be defined are already defined, no need to update the definedChains map\n    const allChainsSame = chains.every(c => {\n      const definedChain = currentMapVal.get(c.id);\n      // basically a deep equal check\n      return stringify(definedChain) === stringify(c);\n    });\n    if (allChainsSame) {\n      return;\n    }\n    const newMapVal = new Map(currentMapVal);\n    for (const c of chains) {\n      newMapVal.set(c.id, c);\n    }\n    definedChainsStore.setValue(newMapVal);\n  }\n  return {\n    activeAccountStore,\n    activeWalletChainStore,\n    activeWalletConnectionStatusStore,\n    activeWalletStore,\n    addConnectedWallet,\n    connect,\n    connectedWallets,\n    defineChains,\n    disconnectWallet,\n    handleConnection,\n    isAutoConnecting,\n    removeConnectedWallet,\n    setActiveWallet,\n    switchActiveWalletChain\n  };\n}\n/**\n *\n * @internal\n */\nexport async function getStoredConnectedWalletIds(storage) {\n  try {\n    const value = await storage.getItem(CONNECTED_WALLET_IDS);\n    if (value) {\n      return JSON.parse(value);\n    }\n    return [];\n  } catch (_unused) {\n    return [];\n  }\n}\n/**\n * @internal\n */\nexport async function getStoredActiveWalletId(storage) {\n  try {\n    const value = await storage.getItem(LAST_ACTIVE_EOA_ID);\n    if (value) {\n      return value;\n    }\n  } catch (_unused2) {}\n  return null;\n}\n/**\n * @internal\n */\nexport async function getLastConnectedChain(storage) {\n  try {\n    const value = await storage.getItem(LAST_ACTIVE_CHAIN);\n    if (value) {\n      return JSON.parse(value);\n    }\n  } catch (_unused3) {}\n  return null;\n}\n/**\n * @internal\n */\nexport const handleSmartWalletConnection = async (eoaWallet, client, options, onWalletDisconnect) => {\n  const signer = eoaWallet.getAccount();\n  if (!signer) {\n    throw new Error(\"Cannot set a wallet without an account as active\");\n  }\n  const wallet = smartWallet(options);\n  await wallet.connect({\n    chain: options.chain,\n    client: client,\n    personalAccount: signer\n  });\n  // Disconnect the active wallet when the EOA disconnects if it the active wallet is a smart wallet\n  const disconnectUnsub = eoaWallet.subscribe(\"disconnect\", () => {\n    handleDisconnect();\n  });\n  const handleDisconnect = () => {\n    disconnectUnsub();\n    onWalletDisconnect(wallet);\n  };\n  return wallet;\n};","map":{"version":3,"names":["cacheChains","computedStore","effect","createStore","stringify","deleteConnectParamsFromStorage","isSmartWallet","smartWallet","CONNECTED_WALLET_IDS","LAST_ACTIVE_EOA_ID","LAST_ACTIVE_CHAIN","createConnectionManager","storage","activeWalletStore","undefined","activeAccountStore","activeWalletChainStore","activeWalletConnectionStatusStore","definedChainsStore","Map","getValue","values","chainVal","definedChain","get","id","setValue","walletIdToConnectedWalletMap","isAutoConnecting","connectedWallets","Array","from","addConnectedWallet","wallet","oldValue","has","newValue","set","removeConnectedWallet","delete","onWalletDisconnect","removeItem","disconnectWallet","disconnect","handleConnection","options","account","getAccount","Error","activeWallet","accountAbstraction","handleSmartWalletConnection","client","setItem","setWalletAsActive","handleSetActiveWallet","subscribe","_options$onConnect","newWallet","onConnect","call","connect","_options$onConnect2","connectedWallet","getChain","onAccountsChanged","newAccount","unsubAccounts","unsubChainChanged","chain","unsubDisconnect","handleDisconnect","setActiveWallet","_chain","accounts","ids","map","acc","filter","c","Set","switchActiveWalletChain","switchChain","personalWalletId","getStoredActiveWalletId","personalWallet","find","w","defineChains","chains","currentMapVal","allChainsSame","every","newMapVal","getStoredConnectedWalletIds","value","getItem","JSON","parse","_unused","_unused2","getLastConnectedChain","_unused3","eoaWallet","signer","personalAccount","disconnectUnsub"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/wallets/manager/index.ts"],"sourcesContent":["import type { Chain } from \"../../chains/types.js\";\nimport { cacheChains } from \"../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { computedStore } from \"../../reactive/computedStore.js\";\nimport { effect } from \"../../reactive/effect.js\";\nimport { createStore } from \"../../reactive/store.js\";\nimport { stringify } from \"../../utils/json.js\";\nimport type { AsyncStorage } from \"../../utils/storage/AsyncStorage.js\";\nimport { deleteConnectParamsFromStorage } from \"../../utils/storage/walletStorage.js\";\nimport type { Account, Wallet } from \"../interfaces/wallet.js\";\nimport { isSmartWallet } from \"../smart/index.js\";\nimport { smartWallet } from \"../smart/smart-wallet.js\";\nimport type { SmartWalletOptions } from \"../smart/types.js\";\nimport type { WalletId } from \"../wallet-types.js\";\n\ntype WalletIdToConnectedWalletMap = Map<string, Wallet>;\nexport type ConnectionStatus =\n  | \"connected\"\n  | \"disconnected\"\n  | \"connecting\"\n  | \"unknown\";\n\nconst CONNECTED_WALLET_IDS = \"thirdweb:connected-wallet-ids\";\nconst LAST_ACTIVE_EOA_ID = \"thirdweb:active-wallet-id\";\nconst LAST_ACTIVE_CHAIN = \"thirdweb:active-chain\";\n\nexport type ConnectionManager = ReturnType<typeof createConnectionManager>;\nexport type ConnectManagerOptions = {\n  client: ThirdwebClient;\n  accountAbstraction?: SmartWalletOptions;\n  setWalletAsActive?: boolean;\n  onConnect?: (wallet: Wallet) => void;\n};\n\n/**\n * Create a connection manager for Wallet connections\n * @param storage - An instance of type [`AsyncStorage`](https://portal.thirdweb.com/references/typescript/v5/AsyncStorage)\n * @example\n * ```ts\n * const manager = createConnectionManager();\n * ```\n * @returns A connection manager object\n * @walletUtils\n */\nexport function createConnectionManager(storage: AsyncStorage) {\n  // stores\n\n  // active wallet/account\n  const activeWalletStore = createStore<Wallet | undefined>(undefined);\n  const activeAccountStore = createStore<Account | undefined>(undefined);\n  const activeWalletChainStore = createStore<Chain | undefined>(undefined);\n  const activeWalletConnectionStatusStore =\n    createStore<ConnectionStatus>(\"unknown\");\n\n  const definedChainsStore = createStore<Map<number, Chain>>(new Map());\n\n  // update global cachedChains when defined Chains store updates\n  effect(() => {\n    cacheChains([...definedChainsStore.getValue().values()]);\n  }, [definedChainsStore]);\n\n  // change the active chain object to use the defined chain object\n  effect(() => {\n    const chainVal = activeWalletChainStore.getValue();\n    if (!chainVal) {\n      return;\n    }\n\n    const definedChain = definedChainsStore.getValue().get(chainVal.id);\n\n    if (!definedChain || definedChain === chainVal) {\n      return;\n    }\n\n    // update active chain store\n    activeWalletChainStore.setValue(definedChain);\n  }, [definedChainsStore, activeWalletChainStore]);\n\n  // other connected accounts\n  const walletIdToConnectedWalletMap =\n    createStore<WalletIdToConnectedWalletMap>(new Map());\n\n  const isAutoConnecting = createStore(false);\n\n  const connectedWallets = computedStore(() => {\n    return Array.from(walletIdToConnectedWalletMap.getValue().values());\n  }, [walletIdToConnectedWalletMap]);\n\n  // actions\n  const addConnectedWallet = (wallet: Wallet) => {\n    const oldValue = walletIdToConnectedWalletMap.getValue();\n    if (oldValue.has(wallet.id)) {\n      return;\n    }\n    const newValue = new Map(oldValue);\n    newValue.set(wallet.id, wallet);\n    walletIdToConnectedWalletMap.setValue(newValue);\n  };\n\n  const removeConnectedWallet = (wallet: Wallet) => {\n    const oldValue = walletIdToConnectedWalletMap.getValue();\n    const newValue = new Map(oldValue);\n    newValue.delete(wallet.id);\n    walletIdToConnectedWalletMap.setValue(newValue);\n  };\n\n  const onWalletDisconnect = (wallet: Wallet) => {\n    deleteConnectParamsFromStorage(storage, wallet.id);\n    removeConnectedWallet(wallet);\n\n    // if disconnecting the active wallet\n    if (activeWalletStore.getValue() === wallet) {\n      storage.removeItem(LAST_ACTIVE_EOA_ID);\n      activeAccountStore.setValue(undefined);\n      activeWalletChainStore.setValue(undefined);\n      activeWalletStore.setValue(undefined);\n      activeWalletConnectionStatusStore.setValue(\"disconnected\");\n    }\n  };\n\n  const disconnectWallet = (wallet: Wallet) => {\n    onWalletDisconnect(wallet);\n    wallet.disconnect();\n  };\n\n  // handle the connection logic, but don't set the wallet as active\n  const handleConnection = async (\n    wallet: Wallet,\n    options?: ConnectManagerOptions,\n  ) => {\n    const account = wallet.getAccount();\n    if (!account) {\n      throw new Error(\"Cannot set a wallet without an account as active\");\n    }\n\n    const activeWallet = await (async () => {\n      if (options?.accountAbstraction && !isSmartWallet(wallet)) {\n        return await handleSmartWalletConnection(\n          wallet,\n          options.client,\n          options.accountAbstraction,\n          onWalletDisconnect,\n        );\n      } else {\n        return wallet;\n      }\n    })();\n\n    await storage.setItem(LAST_ACTIVE_EOA_ID, wallet.id);\n\n    // add personal wallet to connected wallets list even if it's not the active one\n    addConnectedWallet(wallet);\n\n    if (options?.setWalletAsActive !== false) {\n      handleSetActiveWallet(activeWallet);\n    }\n\n    wallet.subscribe(\"accountChanged\", async () => {\n      // We reimplement connect here to prevent memory leaks\n      const newWallet = await handleConnection(wallet, options);\n      options?.onConnect?.(newWallet);\n    });\n\n    return activeWallet;\n  };\n\n  const connect = async (wallet: Wallet, options?: ConnectManagerOptions) => {\n    // connectedWallet can be either wallet or smartWallet\n    const connectedWallet = await handleConnection(wallet, options);\n    options?.onConnect?.(connectedWallet);\n    return connectedWallet;\n  };\n\n  const handleSetActiveWallet = (activeWallet: Wallet) => {\n    const account = activeWallet.getAccount();\n    if (!account) {\n      throw new Error(\"Cannot set a wallet without an account as active\");\n    }\n\n    // also add it to connected wallets if it's not already there\n    addConnectedWallet(activeWallet);\n\n    // update active states\n    activeWalletStore.setValue(activeWallet);\n    activeAccountStore.setValue(account);\n    activeWalletChainStore.setValue(activeWallet.getChain());\n    activeWalletConnectionStatusStore.setValue(\"connected\");\n\n    // setup listeners\n\n    const onAccountsChanged = (newAccount: Account) => {\n      activeAccountStore.setValue(newAccount);\n    };\n\n    const unsubAccounts = activeWallet.subscribe(\n      \"accountChanged\",\n      onAccountsChanged,\n    );\n\n    const unsubChainChanged = activeWallet.subscribe(\"chainChanged\", (chain) =>\n      activeWalletChainStore.setValue(chain),\n    );\n    const unsubDisconnect = activeWallet.subscribe(\"disconnect\", () => {\n      handleDisconnect();\n    });\n\n    const handleDisconnect = () => {\n      onWalletDisconnect(activeWallet);\n      unsubAccounts();\n      unsubChainChanged();\n      unsubDisconnect();\n    };\n  };\n\n  const setActiveWallet = async (activeWallet: Wallet) => {\n    handleSetActiveWallet(activeWallet);\n    // do not set smart wallet as last active EOA\n    if (activeWallet.id !== \"smart\") {\n      await storage.setItem(LAST_ACTIVE_EOA_ID, activeWallet.id);\n    }\n  };\n\n  // side effects\n\n  effect(\n    () => {\n      const _chain = activeWalletChainStore.getValue();\n      if (_chain) {\n        storage.setItem(LAST_ACTIVE_CHAIN, stringify(_chain));\n      } else {\n        storage.removeItem(LAST_ACTIVE_CHAIN);\n      }\n    },\n    [activeWalletChainStore],\n    false,\n  );\n\n  // save last connected wallet ids to storage\n  effect(\n    async () => {\n      const accounts = connectedWallets.getValue();\n      const ids = accounts.map((acc) => acc?.id).filter((c) => !!c) as string[];\n\n      storage.setItem(\n        CONNECTED_WALLET_IDS,\n        stringify(Array.from(new Set([...ids]))),\n      );\n    },\n    [connectedWallets],\n    false,\n  );\n\n  const switchActiveWalletChain = async (chain: Chain) => {\n    const wallet = activeWalletStore.getValue();\n    if (!wallet) {\n      throw new Error(\"No active wallet found\");\n    }\n\n    if (!wallet.switchChain) {\n      throw new Error(\"Wallet does not support switching chains\");\n    }\n\n    if (isSmartWallet(wallet)) {\n      // also switch personal wallet\n      const personalWalletId = await getStoredActiveWalletId(storage);\n      if (personalWalletId) {\n        const personalWallet = connectedWallets\n          .getValue()\n          .find((w) => w.id === personalWalletId);\n        if (personalWallet) {\n          await personalWallet.switchChain(chain);\n          await wallet.switchChain(chain);\n          // reset the active wallet as switch chain recreates a new smart account\n          handleSetActiveWallet(wallet);\n          return;\n        }\n      }\n      // If we couldn't find the personal wallet, just switch the smart wallet\n      await wallet.switchChain(chain);\n      handleSetActiveWallet(wallet);\n    } else {\n      await wallet.switchChain(chain);\n    }\n\n    // for wallets that dont implement events, just set it manually\n    activeWalletChainStore.setValue(wallet.getChain());\n  };\n\n  function defineChains(chains: Chain[]) {\n    const currentMapVal = definedChainsStore.getValue();\n\n    // if all chains to be defined are already defined, no need to update the definedChains map\n    const allChainsSame = chains.every((c) => {\n      const definedChain = currentMapVal.get(c.id);\n      // basically a deep equal check\n      return stringify(definedChain) === stringify(c);\n    });\n\n    if (allChainsSame) {\n      return;\n    }\n\n    const newMapVal = new Map(currentMapVal);\n    for (const c of chains) {\n      newMapVal.set(c.id, c);\n    }\n    definedChainsStore.setValue(newMapVal);\n  }\n\n  return {\n    activeAccountStore,\n    activeWalletChainStore,\n    activeWalletConnectionStatusStore,\n    activeWalletStore,\n    addConnectedWallet,\n    connect,\n    connectedWallets,\n    defineChains,\n    disconnectWallet,\n    handleConnection,\n    isAutoConnecting,\n    removeConnectedWallet,\n    setActiveWallet,\n    switchActiveWalletChain,\n  };\n}\n\n/**\n *\n * @internal\n */\nexport async function getStoredConnectedWalletIds(\n  storage: AsyncStorage,\n): Promise<string[] | null> {\n  try {\n    const value = await storage.getItem(CONNECTED_WALLET_IDS);\n    if (value) {\n      return JSON.parse(value) as string[];\n    }\n    return [];\n  } catch {\n    return [];\n  }\n}\n\n/**\n * @internal\n */\nexport async function getStoredActiveWalletId(\n  storage: AsyncStorage,\n): Promise<WalletId | null> {\n  try {\n    const value = await storage.getItem(LAST_ACTIVE_EOA_ID);\n    if (value) {\n      return value as WalletId;\n    }\n  } catch {}\n\n  return null;\n}\n\n/**\n * @internal\n */\nexport async function getLastConnectedChain(\n  storage: AsyncStorage,\n): Promise<Chain | null> {\n  try {\n    const value = await storage.getItem(LAST_ACTIVE_CHAIN);\n    if (value) {\n      return JSON.parse(value) as Chain;\n    }\n  } catch {}\n\n  return null;\n}\n\n/**\n * @internal\n */\nexport const handleSmartWalletConnection = async (\n  eoaWallet: Wallet,\n  client: ThirdwebClient,\n  options: SmartWalletOptions,\n  onWalletDisconnect: (wallet: Wallet) => void,\n) => {\n  const signer = eoaWallet.getAccount();\n  if (!signer) {\n    throw new Error(\"Cannot set a wallet without an account as active\");\n  }\n\n  const wallet = smartWallet(options);\n\n  await wallet.connect({\n    chain: options.chain,\n    client: client,\n    personalAccount: signer,\n  });\n\n  // Disconnect the active wallet when the EOA disconnects if it the active wallet is a smart wallet\n  const disconnectUnsub = eoaWallet.subscribe(\"disconnect\", () => {\n    handleDisconnect();\n  });\n  const handleDisconnect = () => {\n    disconnectUnsub();\n    onWalletDisconnect(wallet);\n  };\n\n  return wallet;\n};\n"],"mappings":"AACA,SAASA,WAAW,QAAQ,uBAAuB;AAEnD,SAASC,aAAa,QAAQ,iCAAiC;AAC/D,SAASC,MAAM,QAAQ,0BAA0B;AACjD,SAASC,WAAW,QAAQ,yBAAyB;AACrD,SAASC,SAAS,QAAQ,qBAAqB;AAE/C,SAASC,8BAA8B,QAAQ,sCAAsC;AAErF,SAASC,aAAa,QAAQ,mBAAmB;AACjD,SAASC,WAAW,QAAQ,0BAA0B;AAWtD,MAAMC,oBAAoB,GAAG,+BAA+B;AAC5D,MAAMC,kBAAkB,GAAG,2BAA2B;AACtD,MAAMC,iBAAiB,GAAG,uBAAuB;AAUjD;;;;;;;;;;AAUA,OAAM,SAAUC,uBAAuBA,CAACC,OAAqB;EAC3D;EAEA;EACA,MAAMC,iBAAiB,GAAGV,WAAW,CAAqBW,SAAS,CAAC;EACpE,MAAMC,kBAAkB,GAAGZ,WAAW,CAAsBW,SAAS,CAAC;EACtE,MAAME,sBAAsB,GAAGb,WAAW,CAAoBW,SAAS,CAAC;EACxE,MAAMG,iCAAiC,GACrCd,WAAW,CAAmB,SAAS,CAAC;EAE1C,MAAMe,kBAAkB,GAAGf,WAAW,CAAqB,IAAIgB,GAAG,EAAE,CAAC;EAErE;EACAjB,MAAM,CAAC,MAAK;IACVF,WAAW,CAAC,CAAC,GAAGkB,kBAAkB,CAACE,QAAQ,EAAE,CAACC,MAAM,EAAE,CAAC,CAAC;EAC1D,CAAC,EAAE,CAACH,kBAAkB,CAAC,CAAC;EAExB;EACAhB,MAAM,CAAC,MAAK;IACV,MAAMoB,QAAQ,GAAGN,sBAAsB,CAACI,QAAQ,EAAE;IAClD,IAAI,CAACE,QAAQ,EAAE;MACb;IACF;IAEA,MAAMC,YAAY,GAAGL,kBAAkB,CAACE,QAAQ,EAAE,CAACI,GAAG,CAACF,QAAQ,CAACG,EAAE,CAAC;IAEnE,IAAI,CAACF,YAAY,IAAIA,YAAY,KAAKD,QAAQ,EAAE;MAC9C;IACF;IAEA;IACAN,sBAAsB,CAACU,QAAQ,CAACH,YAAY,CAAC;EAC/C,CAAC,EAAE,CAACL,kBAAkB,EAAEF,sBAAsB,CAAC,CAAC;EAEhD;EACA,MAAMW,4BAA4B,GAChCxB,WAAW,CAA+B,IAAIgB,GAAG,EAAE,CAAC;EAEtD,MAAMS,gBAAgB,GAAGzB,WAAW,CAAC,KAAK,CAAC;EAE3C,MAAM0B,gBAAgB,GAAG5B,aAAa,CAAC,MAAK;IAC1C,OAAO6B,KAAK,CAACC,IAAI,CAACJ,4BAA4B,CAACP,QAAQ,EAAE,CAACC,MAAM,EAAE,CAAC;EACrE,CAAC,EAAE,CAACM,4BAA4B,CAAC,CAAC;EAElC;EACA,MAAMK,kBAAkB,GAAIC,MAAc,IAAI;IAC5C,MAAMC,QAAQ,GAAGP,4BAA4B,CAACP,QAAQ,EAAE;IACxD,IAAIc,QAAQ,CAACC,GAAG,CAACF,MAAM,CAACR,EAAE,CAAC,EAAE;MAC3B;IACF;IACA,MAAMW,QAAQ,GAAG,IAAIjB,GAAG,CAACe,QAAQ,CAAC;IAClCE,QAAQ,CAACC,GAAG,CAACJ,MAAM,CAACR,EAAE,EAAEQ,MAAM,CAAC;IAC/BN,4BAA4B,CAACD,QAAQ,CAACU,QAAQ,CAAC;EACjD,CAAC;EAED,MAAME,qBAAqB,GAAIL,MAAc,IAAI;IAC/C,MAAMC,QAAQ,GAAGP,4BAA4B,CAACP,QAAQ,EAAE;IACxD,MAAMgB,QAAQ,GAAG,IAAIjB,GAAG,CAACe,QAAQ,CAAC;IAClCE,QAAQ,CAACG,MAAM,CAACN,MAAM,CAACR,EAAE,CAAC;IAC1BE,4BAA4B,CAACD,QAAQ,CAACU,QAAQ,CAAC;EACjD,CAAC;EAED,MAAMI,kBAAkB,GAAIP,MAAc,IAAI;IAC5C5B,8BAA8B,CAACO,OAAO,EAAEqB,MAAM,CAACR,EAAE,CAAC;IAClDa,qBAAqB,CAACL,MAAM,CAAC;IAE7B;IACA,IAAIpB,iBAAiB,CAACO,QAAQ,EAAE,KAAKa,MAAM,EAAE;MAC3CrB,OAAO,CAAC6B,UAAU,CAAChC,kBAAkB,CAAC;MACtCM,kBAAkB,CAACW,QAAQ,CAACZ,SAAS,CAAC;MACtCE,sBAAsB,CAACU,QAAQ,CAACZ,SAAS,CAAC;MAC1CD,iBAAiB,CAACa,QAAQ,CAACZ,SAAS,CAAC;MACrCG,iCAAiC,CAACS,QAAQ,CAAC,cAAc,CAAC;IAC5D;EACF,CAAC;EAED,MAAMgB,gBAAgB,GAAIT,MAAc,IAAI;IAC1CO,kBAAkB,CAACP,MAAM,CAAC;IAC1BA,MAAM,CAACU,UAAU,EAAE;EACrB,CAAC;EAED;EACA,MAAMC,gBAAgB,GAAG,MAAAA,CACvBX,MAAc,EACdY,OAA+B,KAC7B;IACF,MAAMC,OAAO,GAAGb,MAAM,CAACc,UAAU,EAAE;IACnC,IAAI,CAACD,OAAO,EAAE;MACZ,MAAM,IAAIE,KAAK,CAAC,kDAAkD,CAAC;IACrE;IAEA,MAAMC,YAAY,GAAG,MAAM,CAAC,YAAW;MACrC,IAAIJ,OAAO,aAAPA,OAAO,eAAPA,OAAO,CAAEK,kBAAkB,IAAI,CAAC5C,aAAa,CAAC2B,MAAM,CAAC,EAAE;QACzD,OAAO,MAAMkB,2BAA2B,CACtClB,MAAM,EACNY,OAAO,CAACO,MAAM,EACdP,OAAO,CAACK,kBAAkB,EAC1BV,kBAAkB,CACnB;MACH,CAAC,MAAM;QACL,OAAOP,MAAM;MACf;IACF,CAAC,EAAC,CAAE;IAEJ,MAAMrB,OAAO,CAACyC,OAAO,CAAC5C,kBAAkB,EAAEwB,MAAM,CAACR,EAAE,CAAC;IAEpD;IACAO,kBAAkB,CAACC,MAAM,CAAC;IAE1B,IAAI,CAAAY,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAES,iBAAiB,MAAK,KAAK,EAAE;MACxCC,qBAAqB,CAACN,YAAY,CAAC;IACrC;IAEAhB,MAAM,CAACuB,SAAS,CAAC,gBAAgB,EAAE,YAAW;MAAA,IAAAC,kBAAA;MAC5C;MACA,MAAMC,SAAS,GAAG,MAAMd,gBAAgB,CAACX,MAAM,EAAEY,OAAO,CAAC;MACzDA,OAAO,aAAPA,OAAO,gBAAAY,kBAAA,GAAPZ,OAAO,CAAEc,SAAS,cAAAF,kBAAA,eAAlBA,kBAAA,CAAAG,IAAA,CAAAf,OAAO,EAAca,SAAS,CAAC;IACjC,CAAC,CAAC;IAEF,OAAOT,YAAY;EACrB,CAAC;EAED,MAAMY,OAAO,GAAG,MAAAA,CAAO5B,MAAc,EAAEY,OAA+B,KAAI;IAAA,IAAAiB,mBAAA;IACxE;IACA,MAAMC,eAAe,GAAG,MAAMnB,gBAAgB,CAACX,MAAM,EAAEY,OAAO,CAAC;IAC/DA,OAAO,aAAPA,OAAO,gBAAAiB,mBAAA,GAAPjB,OAAO,CAAEc,SAAS,cAAAG,mBAAA,eAAlBA,mBAAA,CAAAF,IAAA,CAAAf,OAAO,EAAckB,eAAe,CAAC;IACrC,OAAOA,eAAe;EACxB,CAAC;EAED,MAAMR,qBAAqB,GAAIN,YAAoB,IAAI;IACrD,MAAMH,OAAO,GAAGG,YAAY,CAACF,UAAU,EAAE;IACzC,IAAI,CAACD,OAAO,EAAE;MACZ,MAAM,IAAIE,KAAK,CAAC,kDAAkD,CAAC;IACrE;IAEA;IACAhB,kBAAkB,CAACiB,YAAY,CAAC;IAEhC;IACApC,iBAAiB,CAACa,QAAQ,CAACuB,YAAY,CAAC;IACxClC,kBAAkB,CAACW,QAAQ,CAACoB,OAAO,CAAC;IACpC9B,sBAAsB,CAACU,QAAQ,CAACuB,YAAY,CAACe,QAAQ,EAAE,CAAC;IACxD/C,iCAAiC,CAACS,QAAQ,CAAC,WAAW,CAAC;IAEvD;IAEA,MAAMuC,iBAAiB,GAAIC,UAAmB,IAAI;MAChDnD,kBAAkB,CAACW,QAAQ,CAACwC,UAAU,CAAC;IACzC,CAAC;IAED,MAAMC,aAAa,GAAGlB,YAAY,CAACO,SAAS,CAC1C,gBAAgB,EAChBS,iBAAiB,CAClB;IAED,MAAMG,iBAAiB,GAAGnB,YAAY,CAACO,SAAS,CAAC,cAAc,EAAGa,KAAK,IACrErD,sBAAsB,CAACU,QAAQ,CAAC2C,KAAK,CAAC,CACvC;IACD,MAAMC,eAAe,GAAGrB,YAAY,CAACO,SAAS,CAAC,YAAY,EAAE,MAAK;MAChEe,gBAAgB,EAAE;IACpB,CAAC,CAAC;IAEF,MAAMA,gBAAgB,GAAGA,CAAA,KAAK;MAC5B/B,kBAAkB,CAACS,YAAY,CAAC;MAChCkB,aAAa,EAAE;MACfC,iBAAiB,EAAE;MACnBE,eAAe,EAAE;IACnB,CAAC;EACH,CAAC;EAED,MAAME,eAAe,GAAG,MAAOvB,YAAoB,IAAI;IACrDM,qBAAqB,CAACN,YAAY,CAAC;IACnC;IACA,IAAIA,YAAY,CAACxB,EAAE,KAAK,OAAO,EAAE;MAC/B,MAAMb,OAAO,CAACyC,OAAO,CAAC5C,kBAAkB,EAAEwC,YAAY,CAACxB,EAAE,CAAC;IAC5D;EACF,CAAC;EAED;EAEAvB,MAAM,CACJ,MAAK;IACH,MAAMuE,MAAM,GAAGzD,sBAAsB,CAACI,QAAQ,EAAE;IAChD,IAAIqD,MAAM,EAAE;MACV7D,OAAO,CAACyC,OAAO,CAAC3C,iBAAiB,EAAEN,SAAS,CAACqE,MAAM,CAAC,CAAC;IACvD,CAAC,MAAM;MACL7D,OAAO,CAAC6B,UAAU,CAAC/B,iBAAiB,CAAC;IACvC;EACF,CAAC,EACD,CAACM,sBAAsB,CAAC,EACxB,KAAK,CACN;EAED;EACAd,MAAM,CACJ,YAAW;IACT,MAAMwE,QAAQ,GAAG7C,gBAAgB,CAACT,QAAQ,EAAE;IAC5C,MAAMuD,GAAG,GAAGD,QAAQ,CAACE,GAAG,CAAEC,GAAG,IAAKA,GAAG,aAAHA,GAAG,uBAAHA,GAAG,CAAEpD,EAAE,CAAC,CAACqD,MAAM,CAAEC,CAAC,IAAK,CAAC,CAACA,CAAC,CAAa;IAEzEnE,OAAO,CAACyC,OAAO,CACb7C,oBAAoB,EACpBJ,SAAS,CAAC0B,KAAK,CAACC,IAAI,CAAC,IAAIiD,GAAG,CAAC,CAAC,GAAGL,GAAG,CAAC,CAAC,CAAC,CAAC,CACzC;EACH,CAAC,EACD,CAAC9C,gBAAgB,CAAC,EAClB,KAAK,CACN;EAED,MAAMoD,uBAAuB,GAAG,MAAOZ,KAAY,IAAI;IACrD,MAAMpC,MAAM,GAAGpB,iBAAiB,CAACO,QAAQ,EAAE;IAC3C,IAAI,CAACa,MAAM,EAAE;MACX,MAAM,IAAIe,KAAK,CAAC,wBAAwB,CAAC;IAC3C;IAEA,IAAI,CAACf,MAAM,CAACiD,WAAW,EAAE;MACvB,MAAM,IAAIlC,KAAK,CAAC,0CAA0C,CAAC;IAC7D;IAEA,IAAI1C,aAAa,CAAC2B,MAAM,CAAC,EAAE;MACzB;MACA,MAAMkD,gBAAgB,GAAG,MAAMC,uBAAuB,CAACxE,OAAO,CAAC;MAC/D,IAAIuE,gBAAgB,EAAE;QACpB,MAAME,cAAc,GAAGxD,gBAAgB,CACpCT,QAAQ,EAAE,CACVkE,IAAI,CAAEC,CAAC,IAAKA,CAAC,CAAC9D,EAAE,KAAK0D,gBAAgB,CAAC;QACzC,IAAIE,cAAc,EAAE;UAClB,MAAMA,cAAc,CAACH,WAAW,CAACb,KAAK,CAAC;UACvC,MAAMpC,MAAM,CAACiD,WAAW,CAACb,KAAK,CAAC;UAC/B;UACAd,qBAAqB,CAACtB,MAAM,CAAC;UAC7B;QACF;MACF;MACA;MACA,MAAMA,MAAM,CAACiD,WAAW,CAACb,KAAK,CAAC;MAC/Bd,qBAAqB,CAACtB,MAAM,CAAC;IAC/B,CAAC,MAAM;MACL,MAAMA,MAAM,CAACiD,WAAW,CAACb,KAAK,CAAC;IACjC;IAEA;IACArD,sBAAsB,CAACU,QAAQ,CAACO,MAAM,CAAC+B,QAAQ,EAAE,CAAC;EACpD,CAAC;EAED,SAASwB,YAAYA,CAACC,MAAe;IACnC,MAAMC,aAAa,GAAGxE,kBAAkB,CAACE,QAAQ,EAAE;IAEnD;IACA,MAAMuE,aAAa,GAAGF,MAAM,CAACG,KAAK,CAAEb,CAAC,IAAI;MACvC,MAAMxD,YAAY,GAAGmE,aAAa,CAAClE,GAAG,CAACuD,CAAC,CAACtD,EAAE,CAAC;MAC5C;MACA,OAAOrB,SAAS,CAACmB,YAAY,CAAC,KAAKnB,SAAS,CAAC2E,CAAC,CAAC;IACjD,CAAC,CAAC;IAEF,IAAIY,aAAa,EAAE;MACjB;IACF;IAEA,MAAME,SAAS,GAAG,IAAI1E,GAAG,CAACuE,aAAa,CAAC;IACxC,KAAK,MAAMX,CAAC,IAAIU,MAAM,EAAE;MACtBI,SAAS,CAACxD,GAAG,CAAC0C,CAAC,CAACtD,EAAE,EAAEsD,CAAC,CAAC;IACxB;IACA7D,kBAAkB,CAACQ,QAAQ,CAACmE,SAAS,CAAC;EACxC;EAEA,OAAO;IACL9E,kBAAkB;IAClBC,sBAAsB;IACtBC,iCAAiC;IACjCJ,iBAAiB;IACjBmB,kBAAkB;IAClB6B,OAAO;IACPhC,gBAAgB;IAChB2D,YAAY;IACZ9C,gBAAgB;IAChBE,gBAAgB;IAChBhB,gBAAgB;IAChBU,qBAAqB;IACrBkC,eAAe;IACfS;GACD;AACH;AAEA;;;;AAIA,OAAO,eAAea,2BAA2BA,CAC/ClF,OAAqB;EAErB,IAAI;IACF,MAAMmF,KAAK,GAAG,MAAMnF,OAAO,CAACoF,OAAO,CAACxF,oBAAoB,CAAC;IACzD,IAAIuF,KAAK,EAAE;MACT,OAAOE,IAAI,CAACC,KAAK,CAACH,KAAK,CAAa;IACtC;IACA,OAAO,EAAE;EACX,CAAC,CAAC,OAAAI,OAAA,EAAM;IACN,OAAO,EAAE;EACX;AACF;AAEA;;;AAGA,OAAO,eAAef,uBAAuBA,CAC3CxE,OAAqB;EAErB,IAAI;IACF,MAAMmF,KAAK,GAAG,MAAMnF,OAAO,CAACoF,OAAO,CAACvF,kBAAkB,CAAC;IACvD,IAAIsF,KAAK,EAAE;MACT,OAAOA,KAAiB;IAC1B;EACF,CAAC,CAAC,OAAAK,QAAA,EAAM,CAAC;EAET,OAAO,IAAI;AACb;AAEA;;;AAGA,OAAO,eAAeC,qBAAqBA,CACzCzF,OAAqB;EAErB,IAAI;IACF,MAAMmF,KAAK,GAAG,MAAMnF,OAAO,CAACoF,OAAO,CAACtF,iBAAiB,CAAC;IACtD,IAAIqF,KAAK,EAAE;MACT,OAAOE,IAAI,CAACC,KAAK,CAACH,KAAK,CAAU;IACnC;EACF,CAAC,CAAC,OAAAO,QAAA,EAAM,CAAC;EAET,OAAO,IAAI;AACb;AAEA;;;AAGA,OAAO,MAAMnD,2BAA2B,GAAG,MAAAA,CACzCoD,SAAiB,EACjBnD,MAAsB,EACtBP,OAA2B,EAC3BL,kBAA4C,KAC1C;EACF,MAAMgE,MAAM,GAAGD,SAAS,CAACxD,UAAU,EAAE;EACrC,IAAI,CAACyD,MAAM,EAAE;IACX,MAAM,IAAIxD,KAAK,CAAC,kDAAkD,CAAC;EACrE;EAEA,MAAMf,MAAM,GAAG1B,WAAW,CAACsC,OAAO,CAAC;EAEnC,MAAMZ,MAAM,CAAC4B,OAAO,CAAC;IACnBQ,KAAK,EAAExB,OAAO,CAACwB,KAAK;IACpBjB,MAAM,EAAEA,MAAM;IACdqD,eAAe,EAAED;GAClB,CAAC;EAEF;EACA,MAAME,eAAe,GAAGH,SAAS,CAAC/C,SAAS,CAAC,YAAY,EAAE,MAAK;IAC7De,gBAAgB,EAAE;EACpB,CAAC,CAAC;EACF,MAAMA,gBAAgB,GAAGA,CAAA,KAAK;IAC5BmC,eAAe,EAAE;IACjBlE,kBAAkB,CAACP,MAAM,CAAC;EAC5B,CAAC;EAED,OAAOA,MAAM;AACf,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}