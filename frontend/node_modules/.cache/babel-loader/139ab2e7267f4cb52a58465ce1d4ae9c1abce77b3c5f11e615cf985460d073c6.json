{"ast":null,"code":"import { getContract } from \"../../../contract/contract.js\";\nimport { getAddress } from \"../../../utils/address.js\";\nimport { resolvePromisedValue } from \"../../../utils/promise/resolve-promised-value.js\";\nimport { allowance } from \"../__generated__/IERC20/read/allowance.js\";\nimport { approve } from \"../__generated__/IERC20/write/approve.js\";\n/**\n * When dealing with transactions that involve ERC20 tokens (Airdropping ERC20, buy NFTs with ERC20, etc.)\n * you often have to do a pre-check to see if the targeted contract has the sufficient allowance to \"take\" the ERC20 tokens from the caller's wallet.\n *\n * This extension is a handy method that checks for the allowance and requests to approve for more if current allowance is insufficient\n *\n * @param options GetApprovalForTransactionParams\n * @returns a PreparedTransaction\n *\n * @example\n * ```ts\n * import { getApprovalForTransaction } from \"thirdweb/extensions/erc20\";\n * import { sendAndConfirmTransaction } from \"thirdweb\";\n *\n * async function buyNFT() {\n *   const buyTransaction = ... // could be a marketplacev3's buyFromListing\n *\n *   // Check if you need to approve spending for the involved ERC20 contract\n *   const approveTx = await getApprovalForTransaction({\n *     transaction: buyTransaction,\n *     account, // the connected account\n *   });\n *   if (approveTx) {\n *     await sendAndConfirmTransaction({\n *       transaction: approveTx,\n *       account,\n *     })\n *   }\n *   // Once approved, you can finally perform the buy transaction\n *   await sendAndConfirmTransaction({\n *     transaction: buyTransaction,\n *     account,\n *   });\n * }\n * ```\n *\n * @transaction\n */\nexport async function getApprovalForTransaction(options) {\n  const {\n    transaction,\n    account\n  } = options;\n  if (!account) {\n    return null;\n  }\n  const erc20Value = await resolvePromisedValue(transaction.erc20Value);\n  if (erc20Value) {\n    const target = await resolvePromisedValue(transaction.to);\n    if (!target || !erc20Value.tokenAddress || getAddress(target) === getAddress(erc20Value.tokenAddress)) {\n      return null;\n    }\n    const contract = getContract({\n      address: erc20Value.tokenAddress,\n      chain: transaction.chain,\n      client: transaction.client\n    });\n    const approvedValue = await allowance({\n      contract,\n      owner: account.address,\n      spender: target\n    });\n    if (approvedValue > erc20Value.amountWei) {\n      return null;\n    }\n    return approve({\n      contract,\n      spender: target,\n      value: erc20Value.amountWei\n    });\n  }\n  return null;\n}","map":{"version":3,"names":["getContract","getAddress","resolvePromisedValue","allowance","approve","getApprovalForTransaction","options","transaction","account","erc20Value","target","to","tokenAddress","contract","address","chain","client","approvedValue","owner","spender","amountWei","value"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/extensions/erc20/write/getApprovalForTransaction.ts"],"sourcesContent":["import { getContract } from \"../../../contract/contract.js\";\nimport type { PreparedTransaction } from \"../../../transaction/prepare-transaction.js\";\nimport { getAddress } from \"../../../utils/address.js\";\nimport { resolvePromisedValue } from \"../../../utils/promise/resolve-promised-value.js\";\nimport type { Account } from \"../../../wallets/interfaces/wallet.js\";\nimport { allowance } from \"../__generated__/IERC20/read/allowance.js\";\nimport { approve } from \"../__generated__/IERC20/write/approve.js\";\n\nexport type GetApprovalForTransactionParams = {\n  /**\n   * The transaction that involves the ERC20 token\n   */\n  transaction: PreparedTransaction;\n  /**\n   * The caller's account\n   */\n  account: Account;\n};\n\n/**\n * When dealing with transactions that involve ERC20 tokens (Airdropping ERC20, buy NFTs with ERC20, etc.)\n * you often have to do a pre-check to see if the targeted contract has the sufficient allowance to \"take\" the ERC20 tokens from the caller's wallet.\n *\n * This extension is a handy method that checks for the allowance and requests to approve for more if current allowance is insufficient\n *\n * @param options GetApprovalForTransactionParams\n * @returns a PreparedTransaction\n *\n * @example\n * ```ts\n * import { getApprovalForTransaction } from \"thirdweb/extensions/erc20\";\n * import { sendAndConfirmTransaction } from \"thirdweb\";\n *\n * async function buyNFT() {\n *   const buyTransaction = ... // could be a marketplacev3's buyFromListing\n *\n *   // Check if you need to approve spending for the involved ERC20 contract\n *   const approveTx = await getApprovalForTransaction({\n *     transaction: buyTransaction,\n *     account, // the connected account\n *   });\n *   if (approveTx) {\n *     await sendAndConfirmTransaction({\n *       transaction: approveTx,\n *       account,\n *     })\n *   }\n *   // Once approved, you can finally perform the buy transaction\n *   await sendAndConfirmTransaction({\n *     transaction: buyTransaction,\n *     account,\n *   });\n * }\n * ```\n *\n * @transaction\n */\nexport async function getApprovalForTransaction(\n  options: GetApprovalForTransactionParams,\n): Promise<PreparedTransaction | null> {\n  const { transaction, account } = options;\n  if (!account) {\n    return null;\n  }\n\n  const erc20Value = await resolvePromisedValue(transaction.erc20Value);\n  if (erc20Value) {\n    const target = await resolvePromisedValue(transaction.to);\n\n    if (\n      !target ||\n      !erc20Value.tokenAddress ||\n      getAddress(target) === getAddress(erc20Value.tokenAddress)\n    ) {\n      return null;\n    }\n\n    const contract = getContract({\n      address: erc20Value.tokenAddress,\n      chain: transaction.chain,\n      client: transaction.client,\n    });\n\n    const approvedValue = await allowance({\n      contract,\n      owner: account.address,\n      spender: target,\n    });\n\n    if (approvedValue > erc20Value.amountWei) {\n      return null;\n    }\n\n    return approve({\n      contract,\n      spender: target,\n      value: erc20Value.amountWei,\n    });\n  }\n\n  return null;\n}\n"],"mappings":"AAAA,SAASA,WAAW,QAAQ,+BAA+B;AAE3D,SAASC,UAAU,QAAQ,2BAA2B;AACtD,SAASC,oBAAoB,QAAQ,kDAAkD;AAEvF,SAASC,SAAS,QAAQ,2CAA2C;AACrE,SAASC,OAAO,QAAQ,0CAA0C;AAalE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCA,OAAO,eAAeC,yBAAyBA,CAC7CC,OAAwC;EAExC,MAAM;IAAEC,WAAW;IAAEC;EAAO,CAAE,GAAGF,OAAO;EACxC,IAAI,CAACE,OAAO,EAAE;IACZ,OAAO,IAAI;EACb;EAEA,MAAMC,UAAU,GAAG,MAAMP,oBAAoB,CAACK,WAAW,CAACE,UAAU,CAAC;EACrE,IAAIA,UAAU,EAAE;IACd,MAAMC,MAAM,GAAG,MAAMR,oBAAoB,CAACK,WAAW,CAACI,EAAE,CAAC;IAEzD,IACE,CAACD,MAAM,IACP,CAACD,UAAU,CAACG,YAAY,IACxBX,UAAU,CAACS,MAAM,CAAC,KAAKT,UAAU,CAACQ,UAAU,CAACG,YAAY,CAAC,EAC1D;MACA,OAAO,IAAI;IACb;IAEA,MAAMC,QAAQ,GAAGb,WAAW,CAAC;MAC3Bc,OAAO,EAAEL,UAAU,CAACG,YAAY;MAChCG,KAAK,EAAER,WAAW,CAACQ,KAAK;MACxBC,MAAM,EAAET,WAAW,CAACS;KACrB,CAAC;IAEF,MAAMC,aAAa,GAAG,MAAMd,SAAS,CAAC;MACpCU,QAAQ;MACRK,KAAK,EAAEV,OAAO,CAACM,OAAO;MACtBK,OAAO,EAAET;KACV,CAAC;IAEF,IAAIO,aAAa,GAAGR,UAAU,CAACW,SAAS,EAAE;MACxC,OAAO,IAAI;IACb;IAEA,OAAOhB,OAAO,CAAC;MACbS,QAAQ;MACRM,OAAO,EAAET,MAAM;MACfW,KAAK,EAAEZ,UAAU,CAACW;KACnB,CAAC;EACJ;EAEA,OAAO,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}