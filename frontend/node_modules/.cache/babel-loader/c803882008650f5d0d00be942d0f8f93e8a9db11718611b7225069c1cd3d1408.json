{"ast":null,"code":"import { decodeAbiParameters, formatTransactionRequest } from \"viem\";\nimport { eth_call } from \"../../rpc/actions/eth_call.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport { extractError } from \"../extract-error.js\";\nimport { encode } from \"./encode.js\";\n/**\n * Simulates the execution of a transaction.\n * @param options - The options for simulating the transaction.\n * @returns A promise that resolves to the result of the simulation.\n * @transaction\n * @example\n * ```ts\n * import { simulateTransaction } from \"thirdweb\";\n * const result = await simulateTransaction({\n *  transaction,\n * });\n * ```\n */\nexport async function simulateTransaction(options) {\n  var _ref, _options$from, _options$account;\n  const [data, to, accessList, value] = await Promise.all([encode(options.transaction), resolvePromisedValue(options.transaction.to), resolvePromisedValue(options.transaction.accessList), resolvePromisedValue(options.transaction.value)]);\n  // from is:\n  // 1. the user specified from address\n  // 2. the passed in account address\n  // 3. the passed in wallet's account address\n  const from = (_ref = (_options$from = options.from) !== null && _options$from !== void 0 ? _options$from : (_options$account = options.account) === null || _options$account === void 0 ? void 0 : _options$account.address) !== null && _ref !== void 0 ? _ref : undefined;\n  const serializedTx = formatTransactionRequest({\n    accessList,\n    data,\n    from: from ? getAddress(from) : undefined,\n    to: to ? getAddress(to) : undefined,\n    value\n  });\n  const rpcRequest = getRpcClient(options.transaction);\n  try {\n    const result = await eth_call(rpcRequest, serializedTx);\n    if (!options.transaction.__preparedMethod) {\n      return result;\n    }\n    const prepared = await options.transaction.__preparedMethod();\n    const decoded = decodeAbiParameters(prepared[2], result);\n    if (Array.isArray(decoded) && decoded.length === 1) {\n      return decoded[0];\n    }\n    return decoded;\n  } catch (error) {\n    throw await extractError({\n      contract: options.transaction.__contract,\n      error,\n      fromAddress: from\n    });\n  }\n}","map":{"version":3,"names":["decodeAbiParameters","formatTransactionRequest","eth_call","getRpcClient","getAddress","resolvePromisedValue","extractError","encode","simulateTransaction","options","_ref","_options$from","_options$account","data","to","accessList","value","Promise","all","transaction","from","account","address","undefined","serializedTx","rpcRequest","result","__preparedMethod","prepared","decoded","Array","isArray","length","error","contract","__contract","fromAddress"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/transaction/actions/simulate.ts"],"sourcesContent":["import type { Abi, AbiFunction } from \"abitype\";\nimport { decodeAbiParameters, formatTransactionRequest } from \"viem\";\nimport { eth_call } from \"../../rpc/actions/eth_call.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport type { PreparedMethod } from \"../../utils/abi/prepare-method.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport type { Prettify } from \"../../utils/type-utils.js\";\nimport type { Account } from \"../../wallets/interfaces/wallet.js\";\nimport { extractError } from \"../extract-error.js\";\nimport type { PreparedTransaction } from \"../prepare-transaction.js\";\nimport type { ReadContractResult } from \"../read-contract.js\";\nimport { encode } from \"./encode.js\";\n\nexport type SimulateOptions<\n  abi extends Abi,\n  abiFn extends AbiFunction,\n> = Prettify<\n  {\n    transaction: PreparedTransaction<abi, abiFn>;\n  } & (\n    | {\n        account: Account;\n        from?: never;\n      }\n    | {\n        account?: never;\n        from?: string;\n      }\n  )\n>;\n\n/**\n * Simulates the execution of a transaction.\n * @param options - The options for simulating the transaction.\n * @returns A promise that resolves to the result of the simulation.\n * @transaction\n * @example\n * ```ts\n * import { simulateTransaction } from \"thirdweb\";\n * const result = await simulateTransaction({\n *  transaction,\n * });\n * ```\n */\nexport async function simulateTransaction<\n  const abi extends Abi,\n  const abiFn extends AbiFunction,\n>(options: SimulateOptions<abi, abiFn>) {\n  const [data, to, accessList, value] = await Promise.all([\n    encode(options.transaction),\n    resolvePromisedValue(options.transaction.to),\n    resolvePromisedValue(options.transaction.accessList),\n    resolvePromisedValue(options.transaction.value),\n  ]);\n\n  // from is:\n  // 1. the user specified from address\n  // 2. the passed in account address\n  // 3. the passed in wallet's account address\n  const from = options.from ?? options.account?.address ?? undefined;\n\n  const serializedTx = formatTransactionRequest({\n    accessList,\n    data,\n    from: from ? getAddress(from) : undefined,\n    to: to ? getAddress(to) : undefined,\n    value,\n  });\n\n  const rpcRequest = getRpcClient(options.transaction);\n  try {\n    const result = await eth_call(rpcRequest, serializedTx);\n\n    if (!options.transaction.__preparedMethod) {\n      return result;\n    }\n\n    const prepared = await options.transaction.__preparedMethod();\n\n    const decoded = decodeAbiParameters(prepared[2], result);\n\n    if (Array.isArray(decoded) && decoded.length === 1) {\n      return decoded[0];\n    }\n\n    return decoded as ReadContractResult<PreparedMethod<abiFn>[2]>;\n  } catch (error) {\n    throw await extractError({\n      contract: options.transaction.__contract,\n      error,\n      fromAddress: from,\n    });\n  }\n}\n"],"mappings":"AACA,SAASA,mBAAmB,EAAEC,wBAAwB,QAAQ,MAAM;AACpE,SAASC,QAAQ,QAAQ,+BAA+B;AACxD,SAASC,YAAY,QAAQ,kBAAkB;AAE/C,SAASC,UAAU,QAAQ,wBAAwB;AACnD,SAASC,oBAAoB,QAAQ,+CAA+C;AAGpF,SAASC,YAAY,QAAQ,qBAAqB;AAGlD,SAASC,MAAM,QAAQ,aAAa;AAoBpC;;;;;;;;;;;;;AAaA,OAAO,eAAeC,mBAAmBA,CAGvCC,OAAoC;EAAA,IAAAC,IAAA,EAAAC,aAAA,EAAAC,gBAAA;EACpC,MAAM,CAACC,IAAI,EAAEC,EAAE,EAAEC,UAAU,EAAEC,KAAK,CAAC,GAAG,MAAMC,OAAO,CAACC,GAAG,CAAC,CACtDX,MAAM,CAACE,OAAO,CAACU,WAAW,CAAC,EAC3Bd,oBAAoB,CAACI,OAAO,CAACU,WAAW,CAACL,EAAE,CAAC,EAC5CT,oBAAoB,CAACI,OAAO,CAACU,WAAW,CAACJ,UAAU,CAAC,EACpDV,oBAAoB,CAACI,OAAO,CAACU,WAAW,CAACH,KAAK,CAAC,CAChD,CAAC;EAEF;EACA;EACA;EACA;EACA,MAAMI,IAAI,IAAAV,IAAA,IAAAC,aAAA,GAAGF,OAAO,CAACW,IAAI,cAAAT,aAAA,cAAAA,aAAA,IAAAC,gBAAA,GAAIH,OAAO,CAACY,OAAO,cAAAT,gBAAA,uBAAfA,gBAAA,CAAiBU,OAAO,cAAAZ,IAAA,cAAAA,IAAA,GAAIa,SAAS;EAElE,MAAMC,YAAY,GAAGvB,wBAAwB,CAAC;IAC5Cc,UAAU;IACVF,IAAI;IACJO,IAAI,EAAEA,IAAI,GAAGhB,UAAU,CAACgB,IAAI,CAAC,GAAGG,SAAS;IACzCT,EAAE,EAAEA,EAAE,GAAGV,UAAU,CAACU,EAAE,CAAC,GAAGS,SAAS;IACnCP;GACD,CAAC;EAEF,MAAMS,UAAU,GAAGtB,YAAY,CAACM,OAAO,CAACU,WAAW,CAAC;EACpD,IAAI;IACF,MAAMO,MAAM,GAAG,MAAMxB,QAAQ,CAACuB,UAAU,EAAED,YAAY,CAAC;IAEvD,IAAI,CAACf,OAAO,CAACU,WAAW,CAACQ,gBAAgB,EAAE;MACzC,OAAOD,MAAM;IACf;IAEA,MAAME,QAAQ,GAAG,MAAMnB,OAAO,CAACU,WAAW,CAACQ,gBAAgB,EAAE;IAE7D,MAAME,OAAO,GAAG7B,mBAAmB,CAAC4B,QAAQ,CAAC,CAAC,CAAC,EAAEF,MAAM,CAAC;IAExD,IAAII,KAAK,CAACC,OAAO,CAACF,OAAO,CAAC,IAAIA,OAAO,CAACG,MAAM,KAAK,CAAC,EAAE;MAClD,OAAOH,OAAO,CAAC,CAAC,CAAC;IACnB;IAEA,OAAOA,OAAuD;EAChE,CAAC,CAAC,OAAOI,KAAK,EAAE;IACd,MAAM,MAAM3B,YAAY,CAAC;MACvB4B,QAAQ,EAAEzB,OAAO,CAACU,WAAW,CAACgB,UAAU;MACxCF,KAAK;MACLG,WAAW,EAAEhB;KACd,CAAC;EACJ;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}