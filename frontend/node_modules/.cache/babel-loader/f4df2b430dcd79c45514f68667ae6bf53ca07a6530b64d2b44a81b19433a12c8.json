{"ast":null,"code":"import { getRpcUrlForChain } from \"../chains/utils.js\";\nimport { stringify } from \"../utils/json.js\";\nimport { fetchRpc, fetchSingleRpc } from \"./fetch-rpc.js\";\nconst RPC_CLIENT_MAP = new WeakMap();\n/**\n * @internal\n */\nfunction getRpcClientMap(client) {\n  if (RPC_CLIENT_MAP.has(client)) {\n    return RPC_CLIENT_MAP.get(client);\n  }\n  const rpcClientMap = new Map();\n  RPC_CLIENT_MAP.set(client, rpcClientMap);\n  return rpcClientMap;\n}\n/**\n * @internal\n */\nfunction rpcRequestKey(request) {\n  return \"\".concat(request.method, \":\").concat(stringify(request.params));\n}\nconst DEFAULT_MAX_BATCH_SIZE = 100;\n// default to no timeout (next tick)\nconst DEFAULT_BATCH_TIMEOUT_MS = 0;\n/**\n * Returns an RPC request that can be used to make JSON-RPC requests.\n * @param options - The RPC options.\n * @returns The RPC request function.\n * @rpc\n * @example\n * ```ts\n * import { createThirdwebClient } from \"thirdweb\";\n * import { getRpcClient } from \"thirdweb/rpc\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const rpcRequest = getRpcClient({ client, chain: ethereum, });\n * const blockNumber = await rpcRequest({\n *  method: \"eth_blockNumber\",\n * });\n * ```\n */\nexport function getRpcClient(options) {\n  const rpcClientMap = getRpcClientMap(options.client);\n  const rpcUrl = options.chain.rpc;\n  if (rpcClientMap.has(rpcUrl)) {\n    return rpcClientMap.get(rpcUrl);\n  }\n  const rpcClient = ((_ref, _options$config$maxBa, _options$config, _options$client$confi, _ref2, _options$config$batch, _options$config2, _options$client$confi2) => {\n    // we can do this upfront because it cannot change later\n    const rpcUrl = getRpcUrlForChain({\n      chain: options.chain,\n      client: options.client\n    });\n    const batchSize = // look at the direct options passed\n    (_ref = (_options$config$maxBa = (_options$config = options.config) === null || _options$config === void 0 ? void 0 : _options$config.maxBatchSize) !== null && _options$config$maxBa !== void 0 ? _options$config$maxBa : // look at the client options\n    (_options$client$confi = options.client.config) === null || _options$client$confi === void 0 || (_options$client$confi = _options$client$confi.rpc) === null || _options$client$confi === void 0 ? void 0 : _options$client$confi.maxBatchSize) !== null && _ref !== void 0 ? _ref :\n    // use defaults\n    DEFAULT_MAX_BATCH_SIZE;\n    const batchTimeoutMs = // look at the direct options passed\n    (_ref2 = (_options$config$batch = (_options$config2 = options.config) === null || _options$config2 === void 0 ? void 0 : _options$config2.batchTimeoutMs) !== null && _options$config$batch !== void 0 ? _options$config$batch : // look at the client options\n    (_options$client$confi2 = options.client.config) === null || _options$client$confi2 === void 0 || (_options$client$confi2 = _options$client$confi2.rpc) === null || _options$client$confi2 === void 0 ? void 0 : _options$client$confi2.batchTimeoutMs) !== null && _ref2 !== void 0 ? _ref2 : DEFAULT_BATCH_TIMEOUT_MS;\n    // inflight requests\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n    const inflightRequests = new Map();\n    let pendingBatch = [];\n    let pendingBatchTimeout = null;\n    /**\n     * Sends the pending batch of requests.\n     * @internal\n     */\n    function sendPendingBatch() {\n      var _options$config3;\n      // clear the timeout if any\n      if (pendingBatchTimeout) {\n        clearTimeout(pendingBatchTimeout);\n        pendingBatchTimeout = null;\n      }\n      // prepare the requests array (we know the size)\n      const requests = new Array(pendingBatch.length);\n      const activeBatch = pendingBatch.slice().map((inflight, index) => {\n        // assign the id to the request\n        inflight.request.id = index;\n        // also assign the jsonrpc version\n        inflight.request.jsonrpc = \"2.0\";\n        // assign the request to the requests array (so we don't have to map it again later)\n        requests[index] = inflight.request;\n        return inflight;\n      });\n      // reset pendingBatch to empty\n      pendingBatch = [];\n      fetchRpc(rpcUrl, options.client, {\n        requests,\n        requestTimeoutMs: (_options$config3 = options.config) === null || _options$config3 === void 0 ? void 0 : _options$config3.requestTimeoutMs\n      }).then(responses => {\n        activeBatch.forEach((inflight, index) => {\n          // Handle the inflight request promise for each response.\n          const response = responses[index];\n          // No response.\n          if (!response) {\n            inflight.reject(new Error(\"RPC Error from \".concat(rpcUrl, \":\\nrequests: \").concat(stringify(requests), \"\\nresponses: \").concat(stringify(responses))));\n          }\n          // Response is an error or error string.\n          else if (response instanceof Error) {\n            inflight.reject(response);\n          } else if (\"error\" in response) {\n            inflight.reject(response.error);\n          } else if (typeof response === \"string\") {\n            inflight.reject(new Error(response));\n          }\n          // eth_subscription is not supported yet.\n          else if (response.method === \"eth_subscription\") {\n            inflight.reject(\"Subscriptions not supported yet\");\n          }\n          // Else return the successful response for the inflight request.\n          else {\n            inflight.resolve(response.result);\n          }\n        });\n      }).catch(err => {\n        // http call failed, reject all inflight requests\n        for (const inflight of activeBatch) {\n          inflight.reject(err);\n        }\n      }).finally(() => {\n        // Clear the inflight requests map so any new requests are re-fetched.\n        inflightRequests.clear();\n      });\n    }\n    // shortcut everything if we do not need to batch\n    if (batchSize === 1) {\n      return async request => {\n        var _options$config4;\n        // we can hard-code the id and jsonrpc version\n        // we also mutate the request object here to avoid copying it\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n        request.id = 1;\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n        request.jsonrpc = \"2.0\";\n        const rpcResponse = await fetchSingleRpc(rpcUrl, options.client, {\n          request: request,\n          requestTimeoutMs: (_options$config4 = options.config) === null || _options$config4 === void 0 ? void 0 : _options$config4.requestTimeoutMs\n        });\n        if (!rpcResponse) {\n          throw new Error(\"No response\");\n        }\n        if (\"error\" in rpcResponse) {\n          throw rpcResponse.error;\n        }\n        return rpcResponse.result;\n      };\n    }\n    return async request => {\n      const requestKey = rpcRequestKey(request);\n      // if the request for this key is already inflight, return the promise directly\n      if (inflightRequests.has(requestKey)) {\n        // biome-ignore lint/style/noNonNullAssertion: the `has` check ensures this is defined\n        return inflightRequests.get(requestKey);\n      }\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      let resolve;\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      let reject;\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      const promise = new Promise((resolve_, reject_) => {\n        resolve = resolve_;\n        reject = reject_;\n      });\n      inflightRequests.set(requestKey, promise);\n      // @ts-expect-error - they *are* definitely assigned within the promise constructor\n      pendingBatch.push({\n        reject,\n        request,\n        requestKey,\n        resolve\n      });\n      if (batchSize > 1) {\n        // if there is no timeout, set one\n        if (!pendingBatchTimeout) {\n          pendingBatchTimeout = setTimeout(sendPendingBatch, batchTimeoutMs);\n        }\n        // if the batch is full, send it\n        if (pendingBatch.length >= batchSize) {\n          sendPendingBatch();\n        }\n      } else {\n        sendPendingBatch();\n      }\n      return promise;\n    };\n  })();\n  rpcClientMap.set(rpcUrl, rpcClient);\n  return rpcClient;\n}","map":{"version":3,"names":["getRpcUrlForChain","stringify","fetchRpc","fetchSingleRpc","RPC_CLIENT_MAP","WeakMap","getRpcClientMap","client","has","get","rpcClientMap","Map","set","rpcRequestKey","request","concat","method","params","DEFAULT_MAX_BATCH_SIZE","DEFAULT_BATCH_TIMEOUT_MS","getRpcClient","options","rpcUrl","chain","rpc","rpcClient","_ref","_options$config$maxBa","_options$config","_options$client$confi","_ref2","_options$config$batch","_options$config2","_options$client$confi2","batchSize","config","maxBatchSize","batchTimeoutMs","inflightRequests","pendingBatch","pendingBatchTimeout","sendPendingBatch","_options$config3","clearTimeout","requests","Array","length","activeBatch","slice","map","inflight","index","id","jsonrpc","requestTimeoutMs","then","responses","forEach","response","reject","Error","error","resolve","result","catch","err","finally","clear","_options$config4","rpcResponse","requestKey","promise","Promise","resolve_","reject_","push","setTimeout"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/rpc/rpc.ts"],"sourcesContent":["import type { EIP1193RequestFn, EIP1474Methods } from \"viem\";\nimport type { Chain } from \"../chains/types.js\";\nimport { getRpcUrlForChain } from \"../chains/utils.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { stringify } from \"../utils/json.js\";\nimport { fetchRpc, fetchSingleRpc, type RpcRequest } from \"./fetch-rpc.js\";\n\nconst RPC_CLIENT_MAP = new WeakMap();\n\n/**\n * @internal\n */\nfunction getRpcClientMap(client: ThirdwebClient) {\n  if (RPC_CLIENT_MAP.has(client)) {\n    return RPC_CLIENT_MAP.get(client);\n  }\n  const rpcClientMap = new Map();\n  RPC_CLIENT_MAP.set(client, rpcClientMap);\n  return rpcClientMap;\n}\n\n/**\n * @internal\n */\nfunction rpcRequestKey(request: RpcRequest): string {\n  return `${request.method}:${stringify(request.params)}`;\n}\n\nconst DEFAULT_MAX_BATCH_SIZE = 100;\n// default to no timeout (next tick)\nconst DEFAULT_BATCH_TIMEOUT_MS = 0;\n\ntype RPCOptions = Readonly<{\n  client: ThirdwebClient;\n  chain: Chain;\n  config?: {\n    maxBatchSize?: number;\n    batchTimeoutMs?: number;\n    requestTimeoutMs?: number;\n  };\n}>;\n\n/**\n * Returns an RPC request that can be used to make JSON-RPC requests.\n * @param options - The RPC options.\n * @returns The RPC request function.\n * @rpc\n * @example\n * ```ts\n * import { createThirdwebClient } from \"thirdweb\";\n * import { getRpcClient } from \"thirdweb/rpc\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const rpcRequest = getRpcClient({ client, chain: ethereum, });\n * const blockNumber = await rpcRequest({\n *  method: \"eth_blockNumber\",\n * });\n * ```\n */\nexport function getRpcClient(\n  options: RPCOptions,\n): EIP1193RequestFn<EIP1474Methods> {\n  const rpcClientMap = getRpcClientMap(options.client);\n  const rpcUrl = options.chain.rpc;\n\n  if (rpcClientMap.has(rpcUrl)) {\n    return rpcClientMap.get(rpcUrl) as EIP1193RequestFn<EIP1474Methods>;\n  }\n\n  const rpcClient: EIP1193RequestFn<EIP1474Methods> = (() => {\n    // we can do this upfront because it cannot change later\n    const rpcUrl = getRpcUrlForChain({\n      chain: options.chain,\n      client: options.client,\n    });\n\n    const batchSize =\n      // look at the direct options passed\n      options.config?.maxBatchSize ??\n      // look at the client options\n      options.client.config?.rpc?.maxBatchSize ??\n      // use defaults\n      DEFAULT_MAX_BATCH_SIZE;\n    const batchTimeoutMs =\n      // look at the direct options passed\n      options.config?.batchTimeoutMs ??\n      // look at the client options\n      options.client.config?.rpc?.batchTimeoutMs ??\n      DEFAULT_BATCH_TIMEOUT_MS;\n\n    // inflight requests\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n    const inflightRequests = new Map<string, Promise<any>>();\n\n    let pendingBatch: Array<{\n      request: {\n        method: string;\n        params: unknown[];\n        id: number;\n        jsonrpc: \"2.0\";\n      };\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      resolve: (value: any) => void;\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      reject: (reason?: any) => void;\n      requestKey: string;\n    }> = [];\n    let pendingBatchTimeout: ReturnType<typeof setTimeout> | null = null;\n\n    /**\n     * Sends the pending batch of requests.\n     * @internal\n     */\n    function sendPendingBatch() {\n      // clear the timeout if any\n      if (pendingBatchTimeout) {\n        clearTimeout(pendingBatchTimeout);\n        pendingBatchTimeout = null;\n      }\n\n      // prepare the requests array (we know the size)\n      const requests = new Array(pendingBatch.length);\n      const activeBatch = pendingBatch.slice().map((inflight, index) => {\n        // assign the id to the request\n        inflight.request.id = index;\n        // also assign the jsonrpc version\n        inflight.request.jsonrpc = \"2.0\";\n        // assign the request to the requests array (so we don't have to map it again later)\n        requests[index] = inflight.request;\n        return inflight;\n      });\n      // reset pendingBatch to empty\n      pendingBatch = [];\n\n      fetchRpc(rpcUrl, options.client, {\n        requests,\n        requestTimeoutMs: options.config?.requestTimeoutMs,\n      })\n        .then((responses) => {\n          activeBatch.forEach((inflight, index) => {\n            // Handle the inflight request promise for each response.\n            const response = responses[index];\n\n            // No response.\n            if (!response) {\n              inflight.reject(\n                new Error(\n                  `RPC Error from ${rpcUrl}:\\nrequests: ${stringify(requests)}\\nresponses: ${stringify(responses)}`,\n                ),\n              );\n            }\n            // Response is an error or error string.\n            else if (response instanceof Error) {\n              inflight.reject(response);\n            } else if (\"error\" in response) {\n              inflight.reject(response.error);\n            } else if (typeof response === \"string\") {\n              inflight.reject(new Error(response));\n            }\n            // eth_subscription is not supported yet.\n            else if (response.method === \"eth_subscription\") {\n              inflight.reject(\"Subscriptions not supported yet\");\n            }\n            // Else return the successful response for the inflight request.\n            else {\n              inflight.resolve(response.result);\n            }\n          });\n        })\n        .catch((err) => {\n          // http call failed, reject all inflight requests\n          for (const inflight of activeBatch) {\n            inflight.reject(err);\n          }\n        })\n        .finally(() => {\n          // Clear the inflight requests map so any new requests are re-fetched.\n          inflightRequests.clear();\n        });\n    }\n\n    // shortcut everything if we do not need to batch\n    if (batchSize === 1) {\n      return async (request) => {\n        // we can hard-code the id and jsonrpc version\n        // we also mutate the request object here to avoid copying it\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n        (request as any).id = 1;\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n        (request as any).jsonrpc = \"2.0\";\n        const rpcResponse = await fetchSingleRpc(rpcUrl, options.client, {\n          request: request,\n          requestTimeoutMs: options.config?.requestTimeoutMs,\n        });\n\n        if (!rpcResponse) {\n          throw new Error(\"No response\");\n        }\n        if (\"error\" in rpcResponse) {\n          throw rpcResponse.error;\n        }\n        return rpcResponse.result;\n      };\n    }\n\n    return async (request) => {\n      const requestKey = rpcRequestKey(request);\n\n      // if the request for this key is already inflight, return the promise directly\n      if (inflightRequests.has(requestKey)) {\n        // biome-ignore lint/style/noNonNullAssertion: the `has` check ensures this is defined\n        return inflightRequests.get(requestKey)!;\n      }\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      let resolve: (value: any) => void;\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      let reject: (reason?: any) => void;\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      const promise = new Promise<any>((resolve_, reject_) => {\n        resolve = resolve_;\n        reject = reject_;\n      });\n      inflightRequests.set(requestKey, promise);\n      // @ts-expect-error - they *are* definitely assigned within the promise constructor\n      pendingBatch.push({ reject, request, requestKey, resolve });\n      if (batchSize > 1) {\n        // if there is no timeout, set one\n        if (!pendingBatchTimeout) {\n          pendingBatchTimeout = setTimeout(sendPendingBatch, batchTimeoutMs);\n        }\n        // if the batch is full, send it\n        if (pendingBatch.length >= batchSize) {\n          sendPendingBatch();\n        }\n      } else {\n        sendPendingBatch();\n      }\n      return promise;\n    };\n  })();\n\n  rpcClientMap.set(rpcUrl, rpcClient);\n  return rpcClient as EIP1193RequestFn<EIP1474Methods>;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}