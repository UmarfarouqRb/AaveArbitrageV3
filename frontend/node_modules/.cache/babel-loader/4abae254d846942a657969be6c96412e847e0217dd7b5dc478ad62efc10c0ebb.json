{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { maxUint96 } from \"ox/Solidity\";\nimport { concat } from \"viem\";\nimport { getContract } from \"../../../contract/contract.js\";\nimport { getNonce } from \"../../../extensions/erc4337/__generated__/IEntryPoint/read/getNonce.js\";\nimport { getUserOpHash as getUserOpHashV06 } from \"../../../extensions/erc4337/__generated__/IEntryPoint/read/getUserOpHash.js\";\nimport { getUserOpHash as getUserOpHashV07 } from \"../../../extensions/erc4337/__generated__/IEntryPoint_v07/read/getUserOpHash.js\";\nimport { getDefaultGasOverrides } from \"../../../gas/fee-data.js\";\nimport { encode } from \"../../../transaction/actions/encode.js\";\nimport { toSerializableTransaction } from \"../../../transaction/actions/to-serializable-transaction.js\";\nimport { encodeAbiParameters } from \"../../../utils/abi/encodeAbiParameters.js\";\nimport { isContractDeployed } from \"../../../utils/bytecode/is-contract-deployed.js\";\nimport { toHex } from \"../../../utils/encoding/hex.js\";\nimport { hexToBytes } from \"../../../utils/encoding/to-bytes.js\";\nimport { isThirdwebUrl } from \"../../../utils/fetch.js\";\nimport { keccak256 } from \"../../../utils/hashing/keccak256.js\";\nimport { stringify } from \"../../../utils/json.js\";\nimport { resolvePromisedValue } from \"../../../utils/promise/resolve-promised-value.js\";\nimport { getEntrypointFromFactory } from \"../index.js\";\nimport { estimateUserOpGas, getUserOpGasFees, getUserOpReceipt } from \"./bundler.js\";\nimport { predictAddress, prepareBatchExecute, prepareCreateAccount, prepareExecute } from \"./calls.js\";\nimport { DUMMY_SIGNATURE, ENTRYPOINT_ADDRESS_v0_6, ENTRYPOINT_ADDRESS_v0_7, getDefaultAccountFactory, getDefaultBundlerUrl, getEntryPointVersion } from \"./constants.js\";\nimport { getPackedUserOperation } from \"./packUserOp.js\";\nimport { getPaymasterAndData } from \"./paymaster.js\";\nimport { generateRandomUint192 } from \"./utils.js\";\nconst isDeployingSet = new Set();\nconst getKey = accountContract => {\n  return \"\".concat(accountContract.chain.id, \":\").concat(accountContract.address);\n};\nconst markAccountDeploying = accountContract => {\n  isDeployingSet.add(getKey(accountContract));\n};\nexport const clearAccountDeploying = accountContract => {\n  isDeployingSet.delete(getKey(accountContract));\n};\nconst isAccountDeploying = accountContract => {\n  return isDeployingSet.has(getKey(accountContract));\n};\n/**\n * Wait for the user operation to be mined.\n * @param args - The options and user operation hash\n * @returns - The transaction receipt\n *\n * @example\n * ```ts\n * import { waitForUserOpReceipt } from \"thirdweb/wallets/smart\";\n *\n * const receipt = await waitForUserOpReceipt({\n *  chain,\n *  client,\n *  userOpHash,\n * });\n * ```\n * @walletUtils\n */\nexport async function waitForUserOpReceipt(args) {\n  const timeout = args.timeoutMs || 120000; // 2mins\n  const interval = args.intervalMs || 1000; // 1s\n  const endtime = Date.now() + timeout;\n  while (Date.now() < endtime) {\n    const userOpReceipt = await getUserOpReceipt(args);\n    if (userOpReceipt) {\n      return userOpReceipt;\n    }\n    await new Promise(resolve => setTimeout(resolve, interval));\n  }\n  throw new Error(\"Timeout waiting for userOp to be mined on chain \".concat(args.chain.id, \" with UserOp hash: \").concat(args.userOpHash));\n}\n/**\n * Creates an unsigned user operation from a prepared transaction.\n * @param args - The prepared transaction and options\n * @returns - The unsigned user operation\n * @example\n * ```ts\n * import { createUnsignedUserOp } from \"thirdweb/wallets/smart\";\n *\n * const transaction = prepareContractCall(...);\n *\n * const userOp = await createUnsignedUserOp({\n *  transaction,\n *  factoryContract,\n *  accountContract,\n *  adminAddress,\n *  sponsorGas,\n *  overrides,\n * });\n * ```\n * @walletUtils\n */\nexport async function createUnsignedUserOp(args) {\n  var _args$overrides;\n  const {\n    transaction: executeTx,\n    accountContract,\n    factoryContract,\n    adminAddress,\n    overrides,\n    sponsorGas,\n    waitForDeployment = true,\n    isDeployedOverride\n  } = args;\n  const chain = executeTx.chain;\n  const client = executeTx.client;\n  const bundlerOptions = {\n    bundlerUrl: overrides === null || overrides === void 0 ? void 0 : overrides.bundlerUrl,\n    chain,\n    client,\n    entrypointAddress: overrides === null || overrides === void 0 ? void 0 : overrides.entrypointAddress\n  };\n  const entrypointVersion = getEntryPointVersion(((_args$overrides = args.overrides) === null || _args$overrides === void 0 ? void 0 : _args$overrides.entrypointAddress) || ENTRYPOINT_ADDRESS_v0_6);\n  const [isDeployed, callData, callGasLimit, gasFees, nonce] = await Promise.all([typeof isDeployedOverride === \"boolean\" ? isDeployedOverride : isContractDeployed(accountContract).then(isDeployed => isDeployed || isAccountDeploying(accountContract)), encode(executeTx), resolvePromisedValue(executeTx.gas), getGasFees({\n    bundlerOptions,\n    chain,\n    client,\n    executeTx\n  }), getAccountNonce({\n    accountContract,\n    chain,\n    client,\n    entrypointAddress: overrides === null || overrides === void 0 ? void 0 : overrides.entrypointAddress,\n    getNonceOverride: overrides === null || overrides === void 0 ? void 0 : overrides.getAccountNonce\n  })]);\n  const {\n    maxFeePerGas,\n    maxPriorityFeePerGas\n  } = gasFees;\n  if (entrypointVersion === \"v0.7\") {\n    return populateUserOp_v0_7({\n      accountContract,\n      adminAddress,\n      bundlerOptions,\n      callData,\n      callGasLimit,\n      factoryContract,\n      isDeployed,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      overrides,\n      sponsorGas,\n      waitForDeployment\n    });\n  }\n  // default to v0.6\n  return populateUserOp_v0_6({\n    accountContract,\n    adminAddress,\n    bundlerOptions,\n    callData,\n    callGasLimit,\n    factoryContract,\n    isDeployed,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    overrides,\n    sponsorGas,\n    waitForDeployment\n  });\n}\nasync function getGasFees(args) {\n  var _bundlerOptions$bundl;\n  const {\n    executeTx,\n    bundlerOptions,\n    chain,\n    client\n  } = args;\n  let {\n    maxFeePerGas,\n    maxPriorityFeePerGas\n  } = executeTx;\n  const bundlerUrl = (_bundlerOptions$bundl = bundlerOptions === null || bundlerOptions === void 0 ? void 0 : bundlerOptions.bundlerUrl) !== null && _bundlerOptions$bundl !== void 0 ? _bundlerOptions$bundl : getDefaultBundlerUrl(chain);\n  if (isThirdwebUrl(bundlerUrl)) {\n    // get gas prices from bundler\n    const bundlerGasPrice = await getUserOpGasFees({\n      options: bundlerOptions\n    });\n    maxFeePerGas = bundlerGasPrice.maxFeePerGas;\n    maxPriorityFeePerGas = bundlerGasPrice.maxPriorityFeePerGas;\n  } else {\n    // Check for explicity values\n    const [resolvedMaxFeePerGas, resolvedMaxPriorityFeePerGas] = await Promise.all([resolvePromisedValue(maxFeePerGas), resolvePromisedValue(maxPriorityFeePerGas)]);\n    if (resolvedMaxFeePerGas && resolvedMaxPriorityFeePerGas) {\n      // Save a network call if the values are provided\n      maxFeePerGas = resolvedMaxFeePerGas;\n      maxPriorityFeePerGas = resolvedMaxPriorityFeePerGas;\n    } else {\n      var _ref, _ref2;\n      // Fallback to RPC gas prices if no explicit values provided\n      const feeData = await getDefaultGasOverrides(client, chain);\n      // Still check for explicit values in case one is provided and not the other\n      maxPriorityFeePerGas = (_ref = resolvedMaxPriorityFeePerGas !== null && resolvedMaxPriorityFeePerGas !== void 0 ? resolvedMaxPriorityFeePerGas : feeData.maxPriorityFeePerGas) !== null && _ref !== void 0 ? _ref : 0n;\n      maxFeePerGas = (_ref2 = resolvedMaxFeePerGas !== null && resolvedMaxFeePerGas !== void 0 ? resolvedMaxFeePerGas : feeData.maxFeePerGas) !== null && _ref2 !== void 0 ? _ref2 : 0n;\n    }\n  }\n  return {\n    maxFeePerGas,\n    maxPriorityFeePerGas\n  };\n}\nasync function populateUserOp_v0_7(args) {\n  const {\n    bundlerOptions,\n    isDeployed,\n    factoryContract,\n    accountContract,\n    adminAddress,\n    sponsorGas,\n    overrides,\n    nonce,\n    callData,\n    callGasLimit,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    waitForDeployment\n  } = args;\n  const {\n    chain,\n    client\n  } = bundlerOptions;\n  let factory;\n  let factoryData;\n  if (isDeployed) {\n    factoryData = \"0x\";\n    if (waitForDeployment) {\n      // lock until account is deployed if needed to avoid 'sender already created' errors when sending multiple transactions in parallel\n      await waitForAccountDeployed(accountContract);\n    }\n  } else {\n    factory = factoryContract.address;\n    factoryData = await encode(prepareCreateAccount({\n      accountSalt: overrides === null || overrides === void 0 ? void 0 : overrides.accountSalt,\n      adminAddress,\n      createAccountOverride: overrides === null || overrides === void 0 ? void 0 : overrides.createAccount,\n      factoryContract: factoryContract\n    }));\n    if (waitForDeployment) {\n      markAccountDeploying(accountContract);\n    }\n  }\n  const partialOp = {\n    callData,\n    callGasLimit: callGasLimit !== null && callGasLimit !== void 0 ? callGasLimit : 0n,\n    factory,\n    factoryData,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    paymaster: undefined,\n    paymasterData: \"0x\",\n    paymasterPostOpGasLimit: 0n,\n    paymasterVerificationGasLimit: 0n,\n    preVerificationGas: 0n,\n    sender: accountContract.address,\n    signature: DUMMY_SIGNATURE,\n    verificationGasLimit: 0n\n  };\n  if (sponsorGas) {\n    const paymasterResult = await getPaymasterAndData({\n      chain,\n      client,\n      entrypointAddress: overrides === null || overrides === void 0 ? void 0 : overrides.entrypointAddress,\n      paymasterOverride: overrides === null || overrides === void 0 ? void 0 : overrides.paymaster,\n      userOp: partialOp\n    });\n    if (paymasterResult.paymaster && paymasterResult.paymasterData) {\n      partialOp.paymaster = paymasterResult.paymaster;\n      partialOp.paymasterData = paymasterResult.paymasterData;\n    }\n    // paymaster can have the gas limits in the response\n    if (paymasterResult.callGasLimit && paymasterResult.verificationGasLimit && paymasterResult.preVerificationGas && paymasterResult.paymasterPostOpGasLimit && paymasterResult.paymasterVerificationGasLimit) {\n      partialOp.callGasLimit = paymasterResult.callGasLimit;\n      partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;\n      partialOp.preVerificationGas = paymasterResult.preVerificationGas;\n      partialOp.paymasterPostOpGasLimit = paymasterResult.paymasterPostOpGasLimit;\n      partialOp.paymasterVerificationGasLimit = paymasterResult.paymasterVerificationGasLimit;\n    } else {\n      // otherwise fallback to bundler for gas limits\n      const stateOverrides = overrides !== null && overrides !== void 0 && overrides.tokenPaymaster ? {\n        [overrides.tokenPaymaster.tokenAddress]: {\n          stateDiff: {\n            [keccak256(encodeAbiParameters([{\n              type: \"address\"\n            }, {\n              type: \"uint256\"\n            }], [accountContract.address, overrides.tokenPaymaster.balanceStorageSlot]))]: toHex(maxUint96, {\n              size: 32\n            })\n          }\n        }\n      } : undefined;\n      const estimates = await estimateUserOpGas({\n        options: bundlerOptions,\n        userOp: partialOp\n      }, stateOverrides);\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n      partialOp.paymasterPostOpGasLimit = overrides !== null && overrides !== void 0 && overrides.tokenPaymaster ? 500000n // TODO: estimate this better, needed if there's an extra swap needed in the paymaster\n      : estimates.paymasterPostOpGasLimit || 0n;\n      partialOp.paymasterVerificationGasLimit = estimates.paymasterVerificationGasLimit || 0n;\n      // need paymaster to re-sign after estimates\n      const paymasterResult2 = await getPaymasterAndData({\n        chain,\n        client,\n        entrypointAddress: overrides === null || overrides === void 0 ? void 0 : overrides.entrypointAddress,\n        paymasterOverride: overrides === null || overrides === void 0 ? void 0 : overrides.paymaster,\n        userOp: partialOp\n      });\n      if (paymasterResult2.paymaster && paymasterResult2.paymasterData) {\n        partialOp.paymaster = paymasterResult2.paymaster;\n        partialOp.paymasterData = paymasterResult2.paymasterData;\n      }\n    }\n  } else {\n    // not gasless, so we just need to estimate gas limits\n    const estimates = await estimateUserOpGas({\n      options: bundlerOptions,\n      userOp: partialOp\n    });\n    partialOp.callGasLimit = estimates.callGasLimit;\n    partialOp.verificationGasLimit = estimates.verificationGasLimit;\n    partialOp.preVerificationGas = estimates.preVerificationGas;\n    partialOp.paymasterPostOpGasLimit = estimates.paymasterPostOpGasLimit || 0n;\n    partialOp.paymasterVerificationGasLimit = estimates.paymasterVerificationGasLimit || 0n;\n  }\n  return _objectSpread(_objectSpread({}, partialOp), {}, {\n    signature: \"0x\"\n  });\n}\nasync function populateUserOp_v0_6(args) {\n  const {\n    bundlerOptions,\n    isDeployed,\n    factoryContract,\n    accountContract,\n    adminAddress,\n    sponsorGas,\n    overrides,\n    nonce,\n    callData,\n    callGasLimit,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    waitForDeployment\n  } = args;\n  const {\n    chain,\n    client\n  } = bundlerOptions;\n  let initCode;\n  if (isDeployed) {\n    initCode = \"0x\";\n    if (waitForDeployment) {\n      // lock until account is deployed if needed to avoid 'sender already created' errors when sending multiple transactions in parallel\n      await waitForAccountDeployed(accountContract);\n    }\n  } else {\n    initCode = await getAccountInitCode({\n      accountSalt: overrides === null || overrides === void 0 ? void 0 : overrides.accountSalt,\n      adminAddress,\n      createAccountOverride: overrides === null || overrides === void 0 ? void 0 : overrides.createAccount,\n      factoryContract: factoryContract\n    });\n    if (waitForDeployment) {\n      markAccountDeploying(accountContract);\n    }\n  }\n  const partialOp = {\n    callData,\n    callGasLimit: callGasLimit !== null && callGasLimit !== void 0 ? callGasLimit : 0n,\n    initCode,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    paymasterAndData: \"0x\",\n    preVerificationGas: 0n,\n    sender: accountContract.address,\n    signature: DUMMY_SIGNATURE,\n    verificationGasLimit: 0n\n  };\n  if (sponsorGas) {\n    const paymasterResult = await getPaymasterAndData({\n      chain,\n      client,\n      entrypointAddress: overrides === null || overrides === void 0 ? void 0 : overrides.entrypointAddress,\n      paymasterOverride: overrides === null || overrides === void 0 ? void 0 : overrides.paymaster,\n      userOp: partialOp\n    });\n    const paymasterAndData = \"paymasterAndData\" in paymasterResult ? paymasterResult.paymasterAndData : \"0x\";\n    if (paymasterAndData && paymasterAndData !== \"0x\") {\n      partialOp.paymasterAndData = paymasterAndData;\n    }\n    // paymaster can have the gas limits in the response\n    if (paymasterResult.callGasLimit && paymasterResult.verificationGasLimit && paymasterResult.preVerificationGas) {\n      partialOp.callGasLimit = paymasterResult.callGasLimit;\n      partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;\n      partialOp.preVerificationGas = paymasterResult.preVerificationGas;\n    } else {\n      // otherwise fallback to bundler for gas limits\n      const estimates = await estimateUserOpGas({\n        options: bundlerOptions,\n        userOp: partialOp\n      });\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n      // need paymaster to re-sign after estimates\n      if (paymasterAndData && paymasterAndData !== \"0x\") {\n        const paymasterResult2 = await getPaymasterAndData({\n          chain,\n          client,\n          entrypointAddress: overrides === null || overrides === void 0 ? void 0 : overrides.entrypointAddress,\n          paymasterOverride: overrides === null || overrides === void 0 ? void 0 : overrides.paymaster,\n          userOp: partialOp\n        });\n        const paymasterAndData2 = \"paymasterAndData\" in paymasterResult2 ? paymasterResult2.paymasterAndData : \"0x\";\n        if (paymasterAndData2 && paymasterAndData2 !== \"0x\") {\n          partialOp.paymasterAndData = paymasterAndData2;\n        }\n      }\n    }\n  } else {\n    // not gasless, so we just need to estimate gas limits\n    const estimates = await estimateUserOpGas({\n      options: bundlerOptions,\n      userOp: partialOp\n    });\n    partialOp.callGasLimit = estimates.callGasLimit;\n    partialOp.verificationGasLimit = estimates.verificationGasLimit;\n    partialOp.preVerificationGas = estimates.preVerificationGas;\n  }\n  return _objectSpread(_objectSpread({}, partialOp), {}, {\n    signature: \"0x\"\n  });\n}\n/**\n * Sign a user operation.\n * @param userOp - The UserOperation to sign (with signature field ignored)\n * @returns - The user operation with the signature field populated\n * @example\n * ```ts\n * import { signUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOp = await createUnsignedUserOp(...);\n *\n * const signedUserOp = await signUserOp({\n *  client,\n *  userOp,\n *  chain,\n *  adminAccount,\n * });\n * ```\n * @walletUtils\n */\nexport async function signUserOp(args) {\n  const {\n    userOp,\n    chain,\n    entrypointAddress,\n    adminAccount\n  } = args;\n  const userOpHash = await getUserOpHash({\n    chain,\n    client: args.client,\n    entrypointAddress,\n    userOp\n  });\n  if (adminAccount.signMessage) {\n    const signature = await adminAccount.signMessage({\n      chainId: chain.id,\n      message: {\n        raw: hexToBytes(userOpHash)\n      },\n      originalMessage: stringify(userOp)\n    });\n    return _objectSpread(_objectSpread({}, userOp), {}, {\n      signature\n    });\n  }\n  throw new Error(\"signMessage not implemented in signingAccount\");\n}\n/**\n * Get the hash of a user operation.\n * @param args - The options for getting the user operation hash\n * @returns - The user operation hash\n * @example\n * ```ts\n * import { getUserOpHash } from \"thirdweb/wallets/smart\";\n *\n * const userOp = await createUnsignedUserOp(...);\n * const userOpHash = await getUserOpHash({\n *  client,\n *  userOp,\n *  chain,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpHash(args) {\n  const {\n    userOp,\n    chain,\n    entrypointAddress\n  } = args;\n  const entrypointVersion = getEntryPointVersion(entrypointAddress || ENTRYPOINT_ADDRESS_v0_6);\n  let userOpHash;\n  if (entrypointVersion === \"v0.7\") {\n    const packedUserOp = getPackedUserOperation(userOp);\n    userOpHash = await getUserOpHashV07({\n      contract: getContract({\n        address: entrypointAddress || ENTRYPOINT_ADDRESS_v0_7,\n        chain,\n        client: args.client\n      }),\n      userOp: packedUserOp\n    });\n  } else {\n    userOpHash = await getUserOpHashV06({\n      contract: getContract({\n        address: entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n        chain,\n        client: args.client\n      }),\n      userOp: userOp\n    });\n  }\n  return userOpHash;\n}\nasync function getAccountInitCode(options) {\n  const {\n    factoryContract,\n    adminAddress,\n    accountSalt,\n    createAccountOverride\n  } = options;\n  const deployTx = prepareCreateAccount({\n    accountSalt,\n    adminAddress,\n    createAccountOverride,\n    factoryContract\n  });\n  return concat([factoryContract.address, await encode(deployTx)]);\n}\nasync function getAccountNonce(options) {\n  const {\n    accountContract,\n    chain,\n    client,\n    entrypointAddress,\n    getNonceOverride\n  } = options;\n  if (getNonceOverride) {\n    return getNonceOverride(accountContract);\n  }\n  return await getNonce({\n    contract: getContract({\n      address: entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n      chain,\n      client\n    }),\n    key: generateRandomUint192(),\n    sender: accountContract.address\n  });\n}\n/**\n * Create and sign a user operation.\n * @param options - The options for creating and signing the user operation\n * @returns - The signed user operation\n * @example\n * ```ts\n * import { createAndSignUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOp = await createAndSignUserOp({\n *  client,\n *  adminAccount,\n *  smartWalletOptions,\n *  transactions,\n * });\n * ```\n * @walletUtils\n */\nexport async function createAndSignUserOp(options) {\n  var _options$smartWalletO, _options$smartWalletO2;\n  // if factory is passed, but no entrypoint, try to resolve entrypoint from factory\n  if (options.smartWalletOptions.factoryAddress && !((_options$smartWalletO = options.smartWalletOptions.overrides) !== null && _options$smartWalletO !== void 0 && _options$smartWalletO.entrypointAddress)) {\n    const entrypointAddress = await getEntrypointFromFactory(options.smartWalletOptions.factoryAddress, options.client, options.smartWalletOptions.chain);\n    if (entrypointAddress) {\n      options.smartWalletOptions.overrides = _objectSpread(_objectSpread({}, options.smartWalletOptions.overrides), {}, {\n        entrypointAddress\n      });\n    }\n  }\n  const unsignedUserOp = await prepareUserOp({\n    adminAccount: options.adminAccount,\n    client: options.client,\n    isDeployedOverride: options.isDeployedOverride,\n    smartWalletOptions: options.smartWalletOptions,\n    transactions: options.transactions,\n    waitForDeployment: options.waitForDeployment\n  });\n  const signedUserOp = await signUserOp({\n    adminAccount: options.adminAccount,\n    chain: options.smartWalletOptions.chain,\n    client: options.client,\n    entrypointAddress: (_options$smartWalletO2 = options.smartWalletOptions.overrides) === null || _options$smartWalletO2 === void 0 ? void 0 : _options$smartWalletO2.entrypointAddress,\n    userOp: unsignedUserOp\n  });\n  return signedUserOp;\n}\n/**\n * Prepare a user operation for signing.\n * @param options - The options for preparing the user operation\n * @returns - The prepared user operation\n * @example\n * ```ts\n * import { prepareUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOp = await prepareUserOp({\n *  transactions,\n *  adminAccount,\n *  client,\n *  smartWalletOptions,\n * });\n * ```\n *\n * You can then sign the user operation with signUserOp(). and send it to the bundler with bundlerUserOp().\n * @walletUtils\n */\nexport async function prepareUserOp(options) {\n  var _config$overrides, _config$overrides2, _config$overrides3, _config$overrides4;\n  const config = options.smartWalletOptions;\n  const factoryContract = getContract({\n    address: config.factoryAddress || getDefaultAccountFactory((_config$overrides = config.overrides) === null || _config$overrides === void 0 ? void 0 : _config$overrides.entrypointAddress),\n    chain: config.chain,\n    client: options.client\n  });\n  const accountAddress = await predictAddress({\n    accountAddress: (_config$overrides2 = config.overrides) === null || _config$overrides2 === void 0 ? void 0 : _config$overrides2.accountAddress,\n    accountSalt: (_config$overrides3 = config.overrides) === null || _config$overrides3 === void 0 ? void 0 : _config$overrides3.accountSalt,\n    adminAddress: options.adminAccount.address,\n    factoryContract,\n    predictAddressOverride: (_config$overrides4 = config.overrides) === null || _config$overrides4 === void 0 ? void 0 : _config$overrides4.predictAddress\n  });\n  const accountContract = getContract({\n    address: accountAddress,\n    chain: config.chain,\n    client: options.client\n  });\n  let executeTx;\n  if (options.transactions.length === 1) {\n    var _config$overrides5;\n    const tx = options.transactions[0];\n    // for single tx, simulate fully\n    const serializedTx = await toSerializableTransaction({\n      from: accountAddress,\n      transaction: tx\n    });\n    executeTx = prepareExecute({\n      accountContract,\n      executeOverride: (_config$overrides5 = config.overrides) === null || _config$overrides5 === void 0 ? void 0 : _config$overrides5.execute,\n      transaction: serializedTx\n    });\n  } else {\n    var _config$overrides6;\n    // for multiple txs, we can't simulate, just encode\n    const serializedTxs = await Promise.all(options.transactions.map(async tx => {\n      const [data, to, value] = await Promise.all([encode(tx), resolvePromisedValue(tx.to), resolvePromisedValue(tx.value)]);\n      return {\n        chainId: tx.chain.id,\n        data,\n        to,\n        value\n      };\n    }));\n    executeTx = prepareBatchExecute({\n      accountContract,\n      executeBatchOverride: (_config$overrides6 = config.overrides) === null || _config$overrides6 === void 0 ? void 0 : _config$overrides6.executeBatch,\n      transactions: serializedTxs\n    });\n  }\n  return createUnsignedUserOp({\n    accountContract,\n    adminAddress: options.adminAccount.address,\n    factoryContract,\n    isDeployedOverride: options.isDeployedOverride,\n    overrides: config.overrides,\n    sponsorGas: \"sponsorGas\" in config ? config.sponsorGas : config.gasless,\n    transaction: executeTx,\n    waitForDeployment: options.waitForDeployment\n  });\n}\nasync function waitForAccountDeployed(accountContract) {\n  const startTime = Date.now();\n  while (isAccountDeploying(accountContract)) {\n    if (Date.now() - startTime > 60000) {\n      clearAccountDeploying(accountContract); // clear the flag so it doesnt stay stuck in this state\n      throw new Error(\"Account deployment is taking too long (over 1 minute). Please try again.\");\n    }\n    await new Promise(resolve => setTimeout(resolve, 500));\n  }\n}","map":{"version":3,"names":["maxUint96","concat","getContract","getNonce","getUserOpHash","getUserOpHashV06","getUserOpHashV07","getDefaultGasOverrides","encode","toSerializableTransaction","encodeAbiParameters","isContractDeployed","toHex","hexToBytes","isThirdwebUrl","keccak256","stringify","resolvePromisedValue","getEntrypointFromFactory","estimateUserOpGas","getUserOpGasFees","getUserOpReceipt","predictAddress","prepareBatchExecute","prepareCreateAccount","prepareExecute","DUMMY_SIGNATURE","ENTRYPOINT_ADDRESS_v0_6","ENTRYPOINT_ADDRESS_v0_7","getDefaultAccountFactory","getDefaultBundlerUrl","getEntryPointVersion","getPackedUserOperation","getPaymasterAndData","generateRandomUint192","isDeployingSet","Set","getKey","accountContract","chain","id","address","markAccountDeploying","add","clearAccountDeploying","delete","isAccountDeploying","has","waitForUserOpReceipt","args","timeout","timeoutMs","interval","intervalMs","endtime","Date","now","userOpReceipt","Promise","resolve","setTimeout","Error","userOpHash","createUnsignedUserOp","_args$overrides","transaction","executeTx","factoryContract","adminAddress","overrides","sponsorGas","waitForDeployment","isDeployedOverride","client","bundlerOptions","bundlerUrl","entrypointAddress","entrypointVersion","isDeployed","callData","callGasLimit","gasFees","nonce","all","then","gas","getGasFees","getAccountNonce","getNonceOverride","maxFeePerGas","maxPriorityFeePerGas","populateUserOp_v0_7","populateUserOp_v0_6","_bundlerOptions$bundl","bundlerGasPrice","options","resolvedMaxFeePerGas","resolvedMaxPriorityFeePerGas","_ref","_ref2","feeData","factory","factoryData","waitForAccountDeployed","accountSalt","createAccountOverride","createAccount","partialOp","paymaster","undefined","paymasterData","paymasterPostOpGasLimit","paymasterVerificationGasLimit","preVerificationGas","sender","signature","verificationGasLimit","paymasterResult","paymasterOverride","userOp","stateOverrides","tokenPaymaster","tokenAddress","stateDiff","type","balanceStorageSlot","size","estimates","paymasterResult2","_objectSpread","initCode","getAccountInitCode","paymasterAndData","paymasterAndData2","signUserOp","adminAccount","signMessage","chainId","message","raw","originalMessage","packedUserOp","contract","deployTx","key","createAndSignUserOp","_options$smartWalletO","_options$smartWalletO2","smartWalletOptions","factoryAddress","unsignedUserOp","prepareUserOp","transactions","signedUserOp","_config$overrides","_config$overrides2","_config$overrides3","_config$overrides4","config","accountAddress","predictAddressOverride","length","_config$overrides5","tx","serializedTx","from","executeOverride","execute","_config$overrides6","serializedTxs","map","data","to","value","executeBatchOverride","executeBatch","gasless","startTime"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/wallets/smart/lib/userop.ts"],"sourcesContent":["import { maxUint96 } from \"ox/Solidity\";\nimport { concat } from \"viem\";\nimport type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport {\n  getContract,\n  type ThirdwebContract,\n} from \"../../../contract/contract.js\";\nimport { getNonce } from \"../../../extensions/erc4337/__generated__/IEntryPoint/read/getNonce.js\";\nimport { getUserOpHash as getUserOpHashV06 } from \"../../../extensions/erc4337/__generated__/IEntryPoint/read/getUserOpHash.js\";\nimport { getUserOpHash as getUserOpHashV07 } from \"../../../extensions/erc4337/__generated__/IEntryPoint_v07/read/getUserOpHash.js\";\nimport { getDefaultGasOverrides } from \"../../../gas/fee-data.js\";\nimport { encode } from \"../../../transaction/actions/encode.js\";\nimport { toSerializableTransaction } from \"../../../transaction/actions/to-serializable-transaction.js\";\nimport type { PreparedTransaction } from \"../../../transaction/prepare-transaction.js\";\nimport type { TransactionReceipt } from \"../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../utils/abi/encodeAbiParameters.js\";\nimport { isContractDeployed } from \"../../../utils/bytecode/is-contract-deployed.js\";\nimport { type Hex, toHex } from \"../../../utils/encoding/hex.js\";\nimport { hexToBytes } from \"../../../utils/encoding/to-bytes.js\";\nimport { isThirdwebUrl } from \"../../../utils/fetch.js\";\nimport { keccak256 } from \"../../../utils/hashing/keccak256.js\";\nimport { stringify } from \"../../../utils/json.js\";\nimport { resolvePromisedValue } from \"../../../utils/promise/resolve-promised-value.js\";\nimport type { Account } from \"../../interfaces/wallet.js\";\nimport { getEntrypointFromFactory } from \"../index.js\";\nimport type {\n  BundlerOptions,\n  PaymasterResult,\n  SmartWalletOptions,\n  UserOperationV06,\n  UserOperationV07,\n} from \"../types.js\";\nimport {\n  estimateUserOpGas,\n  getUserOpGasFees,\n  getUserOpReceipt,\n} from \"./bundler.js\";\nimport {\n  predictAddress,\n  prepareBatchExecute,\n  prepareCreateAccount,\n  prepareExecute,\n} from \"./calls.js\";\nimport {\n  DUMMY_SIGNATURE,\n  ENTRYPOINT_ADDRESS_v0_6,\n  ENTRYPOINT_ADDRESS_v0_7,\n  getDefaultAccountFactory,\n  getDefaultBundlerUrl,\n  getEntryPointVersion,\n} from \"./constants.js\";\nimport { getPackedUserOperation } from \"./packUserOp.js\";\nimport { getPaymasterAndData } from \"./paymaster.js\";\nimport { generateRandomUint192 } from \"./utils.js\";\n\nconst isDeployingSet: Set<string> = new Set();\n\nconst getKey = (accountContract: ThirdwebContract) => {\n  return `${accountContract.chain.id}:${accountContract.address}`;\n};\n\nconst markAccountDeploying = (accountContract: ThirdwebContract) => {\n  isDeployingSet.add(getKey(accountContract));\n};\n\nexport const clearAccountDeploying = (accountContract: ThirdwebContract) => {\n  isDeployingSet.delete(getKey(accountContract));\n};\n\nconst isAccountDeploying = (accountContract: ThirdwebContract) => {\n  return isDeployingSet.has(getKey(accountContract));\n};\n\n/**\n * Wait for the user operation to be mined.\n * @param args - The options and user operation hash\n * @returns - The transaction receipt\n *\n * @example\n * ```ts\n * import { waitForUserOpReceipt } from \"thirdweb/wallets/smart\";\n *\n * const receipt = await waitForUserOpReceipt({\n *  chain,\n *  client,\n *  userOpHash,\n * });\n * ```\n * @walletUtils\n */\nexport async function waitForUserOpReceipt(\n  args: BundlerOptions & {\n    userOpHash: Hex;\n    timeoutMs?: number;\n    intervalMs?: number;\n  },\n): Promise<TransactionReceipt> {\n  const timeout = args.timeoutMs || 120000; // 2mins\n  const interval = args.intervalMs || 1000; // 1s\n  const endtime = Date.now() + timeout;\n  while (Date.now() < endtime) {\n    const userOpReceipt = await getUserOpReceipt(args);\n    if (userOpReceipt) {\n      return userOpReceipt;\n    }\n    await new Promise((resolve) => setTimeout(resolve, interval));\n  }\n  throw new Error(\n    `Timeout waiting for userOp to be mined on chain ${args.chain.id} with UserOp hash: ${args.userOpHash}`,\n  );\n}\n\n/**\n * Creates an unsigned user operation from a prepared transaction.\n * @param args - The prepared transaction and options\n * @returns - The unsigned user operation\n * @example\n * ```ts\n * import { createUnsignedUserOp } from \"thirdweb/wallets/smart\";\n *\n * const transaction = prepareContractCall(...);\n *\n * const userOp = await createUnsignedUserOp({\n *  transaction,\n *  factoryContract,\n *  accountContract,\n *  adminAddress,\n *  sponsorGas,\n *  overrides,\n * });\n * ```\n * @walletUtils\n */\nexport async function createUnsignedUserOp(args: {\n  transaction: PreparedTransaction;\n  factoryContract: ThirdwebContract;\n  accountContract: ThirdwebContract;\n  adminAddress: string;\n  sponsorGas: boolean;\n  waitForDeployment?: boolean;\n  isDeployedOverride?: boolean;\n  overrides?: SmartWalletOptions[\"overrides\"];\n}): Promise<UserOperationV06 | UserOperationV07> {\n  const {\n    transaction: executeTx,\n    accountContract,\n    factoryContract,\n    adminAddress,\n    overrides,\n    sponsorGas,\n    waitForDeployment = true,\n    isDeployedOverride,\n  } = args;\n  const chain = executeTx.chain;\n  const client = executeTx.client;\n\n  const bundlerOptions = {\n    bundlerUrl: overrides?.bundlerUrl,\n    chain,\n    client,\n    entrypointAddress: overrides?.entrypointAddress,\n  };\n\n  const entrypointVersion = getEntryPointVersion(\n    args.overrides?.entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n  );\n\n  const [isDeployed, callData, callGasLimit, gasFees, nonce] =\n    await Promise.all([\n      typeof isDeployedOverride === \"boolean\"\n        ? isDeployedOverride\n        : isContractDeployed(accountContract).then(\n            (isDeployed) => isDeployed || isAccountDeploying(accountContract),\n          ),\n      encode(executeTx),\n      resolvePromisedValue(executeTx.gas),\n      getGasFees({\n        bundlerOptions,\n        chain,\n        client,\n        executeTx,\n      }),\n      getAccountNonce({\n        accountContract,\n        chain,\n        client,\n        entrypointAddress: overrides?.entrypointAddress,\n        getNonceOverride: overrides?.getAccountNonce,\n      }),\n    ]);\n\n  const { maxFeePerGas, maxPriorityFeePerGas } = gasFees;\n\n  if (entrypointVersion === \"v0.7\") {\n    return populateUserOp_v0_7({\n      accountContract,\n      adminAddress,\n      bundlerOptions,\n      callData,\n      callGasLimit,\n      factoryContract,\n      isDeployed,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      overrides,\n      sponsorGas,\n      waitForDeployment,\n    });\n  }\n\n  // default to v0.6\n  return populateUserOp_v0_6({\n    accountContract,\n    adminAddress,\n    bundlerOptions,\n    callData,\n    callGasLimit,\n    factoryContract,\n    isDeployed,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    overrides,\n    sponsorGas,\n    waitForDeployment,\n  });\n}\n\nasync function getGasFees(args: {\n  executeTx: PreparedTransaction;\n  bundlerOptions: BundlerOptions;\n  chain: Chain;\n  client: ThirdwebClient;\n}): Promise<{\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n}> {\n  const { executeTx, bundlerOptions, chain, client } = args;\n  let { maxFeePerGas, maxPriorityFeePerGas } = executeTx;\n\n  const bundlerUrl = bundlerOptions?.bundlerUrl ?? getDefaultBundlerUrl(chain);\n\n  if (isThirdwebUrl(bundlerUrl)) {\n    // get gas prices from bundler\n    const bundlerGasPrice = await getUserOpGasFees({\n      options: bundlerOptions,\n    });\n    maxFeePerGas = bundlerGasPrice.maxFeePerGas;\n    maxPriorityFeePerGas = bundlerGasPrice.maxPriorityFeePerGas;\n  } else {\n    // Check for explicity values\n    const [resolvedMaxFeePerGas, resolvedMaxPriorityFeePerGas] =\n      await Promise.all([\n        resolvePromisedValue(maxFeePerGas),\n        resolvePromisedValue(maxPriorityFeePerGas),\n      ]);\n\n    if (resolvedMaxFeePerGas && resolvedMaxPriorityFeePerGas) {\n      // Save a network call if the values are provided\n      maxFeePerGas = resolvedMaxFeePerGas;\n      maxPriorityFeePerGas = resolvedMaxPriorityFeePerGas;\n    } else {\n      // Fallback to RPC gas prices if no explicit values provided\n      const feeData = await getDefaultGasOverrides(client, chain);\n\n      // Still check for explicit values in case one is provided and not the other\n      maxPriorityFeePerGas =\n        resolvedMaxPriorityFeePerGas ?? feeData.maxPriorityFeePerGas ?? 0n;\n      maxFeePerGas = resolvedMaxFeePerGas ?? feeData.maxFeePerGas ?? 0n;\n    }\n  }\n  return { maxFeePerGas, maxPriorityFeePerGas };\n}\n\nasync function populateUserOp_v0_7(args: {\n  bundlerOptions: BundlerOptions;\n  factoryContract: ThirdwebContract;\n  accountContract: ThirdwebContract;\n  adminAddress: string;\n  sponsorGas: boolean;\n  overrides?: SmartWalletOptions[\"overrides\"];\n  isDeployed: boolean;\n  nonce: bigint;\n  callData: Hex;\n  callGasLimit?: bigint;\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n  waitForDeployment: boolean;\n}): Promise<UserOperationV07> {\n  const {\n    bundlerOptions,\n    isDeployed,\n    factoryContract,\n    accountContract,\n    adminAddress,\n    sponsorGas,\n    overrides,\n    nonce,\n    callData,\n    callGasLimit,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    waitForDeployment,\n  } = args;\n  const { chain, client } = bundlerOptions;\n\n  let factory: string | undefined;\n  let factoryData: Hex;\n  if (isDeployed) {\n    factoryData = \"0x\";\n    if (waitForDeployment) {\n      // lock until account is deployed if needed to avoid 'sender already created' errors when sending multiple transactions in parallel\n      await waitForAccountDeployed(accountContract);\n    }\n  } else {\n    factory = factoryContract.address;\n    factoryData = await encode(\n      prepareCreateAccount({\n        accountSalt: overrides?.accountSalt,\n        adminAddress,\n        createAccountOverride: overrides?.createAccount,\n        factoryContract: factoryContract,\n      }),\n    );\n    if (waitForDeployment) {\n      markAccountDeploying(accountContract);\n    }\n  }\n\n  const partialOp: UserOperationV07 = {\n    callData,\n    callGasLimit: callGasLimit ?? 0n,\n    factory,\n    factoryData,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    paymaster: undefined,\n    paymasterData: \"0x\",\n    paymasterPostOpGasLimit: 0n,\n    paymasterVerificationGasLimit: 0n,\n    preVerificationGas: 0n,\n    sender: accountContract.address,\n    signature: DUMMY_SIGNATURE,\n    verificationGasLimit: 0n,\n  };\n\n  if (sponsorGas) {\n    const paymasterResult = (await getPaymasterAndData({\n      chain,\n      client,\n      entrypointAddress: overrides?.entrypointAddress,\n      paymasterOverride: overrides?.paymaster,\n      userOp: partialOp,\n    })) as Extract<PaymasterResult, { paymaster: string }>;\n    if (paymasterResult.paymaster && paymasterResult.paymasterData) {\n      partialOp.paymaster = paymasterResult.paymaster;\n      partialOp.paymasterData = paymasterResult.paymasterData as Hex;\n    }\n    // paymaster can have the gas limits in the response\n    if (\n      paymasterResult.callGasLimit &&\n      paymasterResult.verificationGasLimit &&\n      paymasterResult.preVerificationGas &&\n      paymasterResult.paymasterPostOpGasLimit &&\n      paymasterResult.paymasterVerificationGasLimit\n    ) {\n      partialOp.callGasLimit = paymasterResult.callGasLimit;\n      partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;\n      partialOp.preVerificationGas = paymasterResult.preVerificationGas;\n      partialOp.paymasterPostOpGasLimit =\n        paymasterResult.paymasterPostOpGasLimit;\n      partialOp.paymasterVerificationGasLimit =\n        paymasterResult.paymasterVerificationGasLimit;\n    } else {\n      // otherwise fallback to bundler for gas limits\n      const stateOverrides = overrides?.tokenPaymaster\n        ? {\n            [overrides.tokenPaymaster.tokenAddress]: {\n              stateDiff: {\n                [keccak256(\n                  encodeAbiParameters(\n                    [{ type: \"address\" }, { type: \"uint256\" }],\n                    [\n                      accountContract.address,\n                      overrides.tokenPaymaster.balanceStorageSlot,\n                    ],\n                  ),\n                )]: toHex(maxUint96, { size: 32 }),\n              },\n            },\n          }\n        : undefined;\n      const estimates = await estimateUserOpGas(\n        {\n          options: bundlerOptions,\n          userOp: partialOp,\n        },\n        stateOverrides,\n      );\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n      partialOp.paymasterPostOpGasLimit = overrides?.tokenPaymaster\n        ? 500000n // TODO: estimate this better, needed if there's an extra swap needed in the paymaster\n        : estimates.paymasterPostOpGasLimit || 0n;\n      partialOp.paymasterVerificationGasLimit =\n        estimates.paymasterVerificationGasLimit || 0n;\n      // need paymaster to re-sign after estimates\n      const paymasterResult2 = (await getPaymasterAndData({\n        chain,\n        client,\n        entrypointAddress: overrides?.entrypointAddress,\n        paymasterOverride: overrides?.paymaster,\n        userOp: partialOp,\n      })) as Extract<PaymasterResult, { paymaster: string }>;\n      if (paymasterResult2.paymaster && paymasterResult2.paymasterData) {\n        partialOp.paymaster = paymasterResult2.paymaster;\n        partialOp.paymasterData = paymasterResult2.paymasterData as Hex;\n      }\n    }\n  } else {\n    // not gasless, so we just need to estimate gas limits\n    const estimates = await estimateUserOpGas({\n      options: bundlerOptions,\n      userOp: partialOp,\n    });\n    partialOp.callGasLimit = estimates.callGasLimit;\n    partialOp.verificationGasLimit = estimates.verificationGasLimit;\n    partialOp.preVerificationGas = estimates.preVerificationGas;\n    partialOp.paymasterPostOpGasLimit = estimates.paymasterPostOpGasLimit || 0n;\n    partialOp.paymasterVerificationGasLimit =\n      estimates.paymasterVerificationGasLimit || 0n;\n  }\n  return {\n    ...partialOp,\n    signature: \"0x\" as Hex,\n  };\n}\n\nasync function populateUserOp_v0_6(args: {\n  bundlerOptions: BundlerOptions;\n  factoryContract: ThirdwebContract;\n  accountContract: ThirdwebContract;\n  adminAddress: string;\n  sponsorGas: boolean;\n  overrides?: SmartWalletOptions[\"overrides\"];\n  isDeployed: boolean;\n  nonce: bigint;\n  callData: Hex;\n  callGasLimit?: bigint;\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n  waitForDeployment: boolean;\n}): Promise<UserOperationV06> {\n  const {\n    bundlerOptions,\n    isDeployed,\n    factoryContract,\n    accountContract,\n    adminAddress,\n    sponsorGas,\n    overrides,\n    nonce,\n    callData,\n    callGasLimit,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    waitForDeployment,\n  } = args;\n  const { chain, client } = bundlerOptions;\n  let initCode: Hex;\n\n  if (isDeployed) {\n    initCode = \"0x\";\n    if (waitForDeployment) {\n      // lock until account is deployed if needed to avoid 'sender already created' errors when sending multiple transactions in parallel\n      await waitForAccountDeployed(accountContract);\n    }\n  } else {\n    initCode = await getAccountInitCode({\n      accountSalt: overrides?.accountSalt,\n      adminAddress,\n      createAccountOverride: overrides?.createAccount,\n      factoryContract: factoryContract,\n    });\n    if (waitForDeployment) {\n      markAccountDeploying(accountContract);\n    }\n  }\n\n  const partialOp: UserOperationV06 = {\n    callData,\n    callGasLimit: callGasLimit ?? 0n,\n    initCode,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    paymasterAndData: \"0x\",\n    preVerificationGas: 0n,\n    sender: accountContract.address,\n    signature: DUMMY_SIGNATURE,\n    verificationGasLimit: 0n,\n  };\n\n  if (sponsorGas) {\n    const paymasterResult = await getPaymasterAndData({\n      chain,\n      client,\n      entrypointAddress: overrides?.entrypointAddress,\n      paymasterOverride: overrides?.paymaster,\n      userOp: partialOp,\n    });\n    const paymasterAndData =\n      \"paymasterAndData\" in paymasterResult\n        ? paymasterResult.paymasterAndData\n        : \"0x\";\n    if (paymasterAndData && paymasterAndData !== \"0x\") {\n      partialOp.paymasterAndData = paymasterAndData as Hex;\n    }\n    // paymaster can have the gas limits in the response\n    if (\n      paymasterResult.callGasLimit &&\n      paymasterResult.verificationGasLimit &&\n      paymasterResult.preVerificationGas\n    ) {\n      partialOp.callGasLimit = paymasterResult.callGasLimit;\n      partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;\n      partialOp.preVerificationGas = paymasterResult.preVerificationGas;\n    } else {\n      // otherwise fallback to bundler for gas limits\n      const estimates = await estimateUserOpGas({\n        options: bundlerOptions,\n        userOp: partialOp,\n      });\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n      // need paymaster to re-sign after estimates\n      if (paymasterAndData && paymasterAndData !== \"0x\") {\n        const paymasterResult2 = await getPaymasterAndData({\n          chain,\n          client,\n          entrypointAddress: overrides?.entrypointAddress,\n          paymasterOverride: overrides?.paymaster,\n          userOp: partialOp,\n        });\n        const paymasterAndData2 =\n          \"paymasterAndData\" in paymasterResult2\n            ? paymasterResult2.paymasterAndData\n            : \"0x\";\n        if (paymasterAndData2 && paymasterAndData2 !== \"0x\") {\n          partialOp.paymasterAndData = paymasterAndData2 as Hex;\n        }\n      }\n    }\n  } else {\n    // not gasless, so we just need to estimate gas limits\n    const estimates = await estimateUserOpGas({\n      options: bundlerOptions,\n      userOp: partialOp,\n    });\n    partialOp.callGasLimit = estimates.callGasLimit;\n    partialOp.verificationGasLimit = estimates.verificationGasLimit;\n    partialOp.preVerificationGas = estimates.preVerificationGas;\n  }\n  return {\n    ...partialOp,\n    signature: \"0x\" as Hex,\n  };\n}\n\n/**\n * Sign a user operation.\n * @param userOp - The UserOperation to sign (with signature field ignored)\n * @returns - The user operation with the signature field populated\n * @example\n * ```ts\n * import { signUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOp = await createUnsignedUserOp(...);\n *\n * const signedUserOp = await signUserOp({\n *  client,\n *  userOp,\n *  chain,\n *  adminAccount,\n * });\n * ```\n * @walletUtils\n */\nexport async function signUserOp(args: {\n  client: ThirdwebClient;\n  userOp: UserOperationV06 | UserOperationV07;\n  chain: Chain;\n  entrypointAddress?: string;\n  adminAccount: Account;\n}): Promise<UserOperationV06 | UserOperationV07> {\n  const { userOp, chain, entrypointAddress, adminAccount } = args;\n\n  const userOpHash = await getUserOpHash({\n    chain,\n    client: args.client,\n    entrypointAddress,\n    userOp,\n  });\n\n  if (adminAccount.signMessage) {\n    const signature = await adminAccount.signMessage({\n      chainId: chain.id,\n      message: {\n        raw: hexToBytes(userOpHash),\n      },\n      originalMessage: stringify(userOp),\n    });\n    return {\n      ...userOp,\n      signature,\n    };\n  }\n  throw new Error(\"signMessage not implemented in signingAccount\");\n}\n\n/**\n * Get the hash of a user operation.\n * @param args - The options for getting the user operation hash\n * @returns - The user operation hash\n * @example\n * ```ts\n * import { getUserOpHash } from \"thirdweb/wallets/smart\";\n *\n * const userOp = await createUnsignedUserOp(...);\n * const userOpHash = await getUserOpHash({\n *  client,\n *  userOp,\n *  chain,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpHash(args: {\n  client: ThirdwebClient;\n  userOp: UserOperationV06 | UserOperationV07;\n  chain: Chain;\n  entrypointAddress?: string;\n}): Promise<Hex> {\n  const { userOp, chain, entrypointAddress } = args;\n\n  const entrypointVersion = getEntryPointVersion(\n    entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n  );\n\n  let userOpHash: Hex;\n\n  if (entrypointVersion === \"v0.7\") {\n    const packedUserOp = getPackedUserOperation(userOp as UserOperationV07);\n    userOpHash = await getUserOpHashV07({\n      contract: getContract({\n        address: entrypointAddress || ENTRYPOINT_ADDRESS_v0_7,\n        chain,\n        client: args.client,\n      }),\n      userOp: packedUserOp,\n    });\n  } else {\n    userOpHash = await getUserOpHashV06({\n      contract: getContract({\n        address: entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n        chain,\n        client: args.client,\n      }),\n      userOp: userOp as UserOperationV06,\n    });\n  }\n  return userOpHash;\n}\n\nasync function getAccountInitCode(options: {\n  factoryContract: ThirdwebContract;\n  adminAddress: string;\n  accountSalt?: string;\n  createAccountOverride?: (\n    factoryContract: ThirdwebContract,\n    adminAddress: string,\n  ) => PreparedTransaction;\n}): Promise<Hex> {\n  const { factoryContract, adminAddress, accountSalt, createAccountOverride } =\n    options;\n  const deployTx = prepareCreateAccount({\n    accountSalt,\n    adminAddress,\n    createAccountOverride,\n    factoryContract,\n  });\n  return concat([factoryContract.address as Hex, await encode(deployTx)]);\n}\n\nasync function getAccountNonce(options: {\n  accountContract: ThirdwebContract;\n  chain: Chain;\n  client: ThirdwebClient;\n  entrypointAddress?: string;\n  getNonceOverride?: (accountContract: ThirdwebContract) => Promise<bigint>;\n}): Promise<bigint> {\n  const {\n    accountContract,\n    chain,\n    client,\n    entrypointAddress,\n    getNonceOverride,\n  } = options;\n  if (getNonceOverride) {\n    return getNonceOverride(accountContract);\n  }\n  return await getNonce({\n    contract: getContract({\n      address: entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n      chain,\n      client,\n    }),\n    key: generateRandomUint192(),\n    sender: accountContract.address,\n  });\n}\n\n/**\n * Create and sign a user operation.\n * @param options - The options for creating and signing the user operation\n * @returns - The signed user operation\n * @example\n * ```ts\n * import { createAndSignUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOp = await createAndSignUserOp({\n *  client,\n *  adminAccount,\n *  smartWalletOptions,\n *  transactions,\n * });\n * ```\n * @walletUtils\n */\nexport async function createAndSignUserOp(options: {\n  transactions: PreparedTransaction[];\n  adminAccount: Account;\n  client: ThirdwebClient;\n  smartWalletOptions: SmartWalletOptions;\n  waitForDeployment?: boolean;\n  isDeployedOverride?: boolean;\n}) {\n  // if factory is passed, but no entrypoint, try to resolve entrypoint from factory\n  if (\n    options.smartWalletOptions.factoryAddress &&\n    !options.smartWalletOptions.overrides?.entrypointAddress\n  ) {\n    const entrypointAddress = await getEntrypointFromFactory(\n      options.smartWalletOptions.factoryAddress,\n      options.client,\n      options.smartWalletOptions.chain,\n    );\n    if (entrypointAddress) {\n      options.smartWalletOptions.overrides = {\n        ...options.smartWalletOptions.overrides,\n        entrypointAddress,\n      };\n    }\n  }\n  const unsignedUserOp = await prepareUserOp({\n    adminAccount: options.adminAccount,\n    client: options.client,\n    isDeployedOverride: options.isDeployedOverride,\n    smartWalletOptions: options.smartWalletOptions,\n    transactions: options.transactions,\n    waitForDeployment: options.waitForDeployment,\n  });\n  const signedUserOp = await signUserOp({\n    adminAccount: options.adminAccount,\n    chain: options.smartWalletOptions.chain,\n    client: options.client,\n    entrypointAddress: options.smartWalletOptions.overrides?.entrypointAddress,\n    userOp: unsignedUserOp,\n  });\n  return signedUserOp;\n}\n\n/**\n * Prepare a user operation for signing.\n * @param options - The options for preparing the user operation\n * @returns - The prepared user operation\n * @example\n * ```ts\n * import { prepareUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOp = await prepareUserOp({\n *  transactions,\n *  adminAccount,\n *  client,\n *  smartWalletOptions,\n * });\n * ```\n *\n * You can then sign the user operation with signUserOp(). and send it to the bundler with bundlerUserOp().\n * @walletUtils\n */\nexport async function prepareUserOp(options: {\n  transactions: PreparedTransaction[];\n  adminAccount: Account;\n  client: ThirdwebClient;\n  smartWalletOptions: SmartWalletOptions;\n  waitForDeployment?: boolean;\n  isDeployedOverride?: boolean;\n}) {\n  const config = options.smartWalletOptions;\n  const factoryContract = getContract({\n    address:\n      config.factoryAddress ||\n      getDefaultAccountFactory(config.overrides?.entrypointAddress),\n    chain: config.chain,\n    client: options.client,\n  });\n  const accountAddress = await predictAddress({\n    accountAddress: config.overrides?.accountAddress,\n    accountSalt: config.overrides?.accountSalt,\n    adminAddress: options.adminAccount.address,\n    factoryContract,\n    predictAddressOverride: config.overrides?.predictAddress,\n  });\n  const accountContract = getContract({\n    address: accountAddress,\n    chain: config.chain,\n    client: options.client,\n  });\n\n  let executeTx: PreparedTransaction;\n  if (options.transactions.length === 1) {\n    const tx = options.transactions[0] as PreparedTransaction;\n    // for single tx, simulate fully\n    const serializedTx = await toSerializableTransaction({\n      from: accountAddress,\n      transaction: tx,\n    });\n    executeTx = prepareExecute({\n      accountContract,\n      executeOverride: config.overrides?.execute,\n      transaction: serializedTx,\n    });\n  } else {\n    // for multiple txs, we can't simulate, just encode\n    const serializedTxs = await Promise.all(\n      options.transactions.map(async (tx) => {\n        const [data, to, value] = await Promise.all([\n          encode(tx),\n          resolvePromisedValue(tx.to),\n          resolvePromisedValue(tx.value),\n        ]);\n        return {\n          chainId: tx.chain.id,\n          data,\n          to,\n          value,\n        };\n      }),\n    );\n    executeTx = prepareBatchExecute({\n      accountContract,\n      executeBatchOverride: config.overrides?.executeBatch,\n      transactions: serializedTxs,\n    });\n  }\n\n  return createUnsignedUserOp({\n    accountContract,\n    adminAddress: options.adminAccount.address,\n    factoryContract,\n    isDeployedOverride: options.isDeployedOverride,\n    overrides: config.overrides,\n    sponsorGas: \"sponsorGas\" in config ? config.sponsorGas : config.gasless,\n    transaction: executeTx,\n    waitForDeployment: options.waitForDeployment,\n  });\n}\n\nasync function waitForAccountDeployed(accountContract: ThirdwebContract) {\n  const startTime = Date.now();\n  while (isAccountDeploying(accountContract)) {\n    if (Date.now() - startTime > 60000) {\n      clearAccountDeploying(accountContract); // clear the flag so it doesnt stay stuck in this state\n      throw new Error(\n        \"Account deployment is taking too long (over 1 minute). Please try again.\",\n      );\n    }\n    await new Promise((resolve) => setTimeout(resolve, 500));\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}