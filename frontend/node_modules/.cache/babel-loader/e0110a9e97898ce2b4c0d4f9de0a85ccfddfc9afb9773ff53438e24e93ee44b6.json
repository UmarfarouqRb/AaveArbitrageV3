{"ast":null,"code":"import { getThirdwebBaseUrl } from \"../utils/domains.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { ApiError } from \"./types/Errors.js\";\n/**\n * Retrieves a Bridge quote for the provided sell intent. The quote will specify the expected `destinationAmount` that will be received in exchange for the specified `originAmount`, which is specified with the `sellAmountWei` option.\n *\n * The returned status will include both the origin and destination transactions and any finalized amounts for the route.\n *\n * @example\n * ```typescript\n * import { Bridge } from \"thirdweb\";\n *\n * const status = await Bridge.status({\n *   transactionHash: \"0xe199ef82a0b6215221536e18ec512813c1aa10b4f5ed0d4dfdfcd703578da56d\",\n *   chainId: 8453,\n *   client: thirdwebClient,\n * });\n * ```\n *\n * If the transaction is complete, a response might look like:\n * ```typescript\n * {\n *   status: 'COMPLETED',\n *   originAmount: 200000000000000n,\n *   destinationAmount: 188625148000000n,\n *   originChainId: 8453,\n *   destinationChainId: 2741,\n *   originTokenAddress: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE',\n *   destinationTokenAddress: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE',\n *   transactions: [\n *     {\n *       chainId: 8453,\n *       transactionHash: '0xe199ef82a0b6215221536e18ec512813c1aa10b4f5ed0d4dfdfcd703578da56d'\n *     },\n *     {\n *       chainId: 2741,\n *       transactionHash: '0xa70a82f42330f54be95a542e1fcfe6ed2dd9f07fb8c82ae67afb4342319f7433'\n *     }\n *   ],\n *   purchaseData: {\n *     foo: \"bar\"\n *   }\n * }\n * ```\n *\n * If the origin transaction hasn't been mined yet, a response might look like:\n * ```typescript\n * {\n *   status: \"NOT_FOUND\",\n * }\n * ```\n * This is to allow you to poll for the status without catching an error. Be sure your transaction hash and chain are correct though, as this could also represent a legitimate 404 if the transaction doesn't exist.\n *\n * If the transaction is still pending, a response might look like:\n * ```typescript\n * {\n *   status: \"PENDING\",\n *   originAmount: 1000000000000000000n,\n *   originChainId: 466,\n *   destinationChainId: 1,\n *   originTokenAddress: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *   destinationTokenAddress: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *   transactions: [\n *     {\n *       transactionHash: \"0xe199ef82a0b6215221536e18ec512813c1aa10b4f5ed0d4dfdfcd703578da56d\",\n *       chainId: 466,\n *     }\n *   ]\n * }\n * ```\n *\n * If the transaction failed, a response might look like:\n * ```typescript\n * {\n *   status: \"FAILED\",\n *   transactions: [\n *     {\n *       transactionHash: \"0xe199ef82a0b6215221536e18ec512813c1aa10b4f5ed0d4dfdfcd703578da56d\",\n *       chainId: 466,\n *     }\n *   ]\n * }\n * ```\n *\n * This status is for a **single origin transaction only**. If your route involves multiple transactions, you'll need to get the status for each of them individually.\n *\n * If sending multiple dependent sequential transactions, wait until `status` returns `COMPLETED` before sending the next transaction.\n *\n * You can access this function's input and output types with `status.Options` and `status.Result`, respectively.\n *\n * @param options - The options for the quote.\n * @param options.transactionHash - The hash of the origin transaction to get the bridge status for.\n * @param options.chainId - The chain ID of the origin token.\n * @param options.transactionId - The transaction ID received from the `prepare` request.\n * @param options.client - Your thirdweb client.\n *\n * @returns A promise that resolves to a status object for the transaction.\n *\n * @throws Will throw an error if there is an issue fetching the status.\n * @bridge\n * @beta\n */\nexport async function status(options) {\n  const {\n    transactionHash,\n    client,\n    transactionId\n  } = options;\n  const chainId = \"chainId\" in options ? options.chainId : options.chain.id;\n  const clientFetch = getClientFetch(client);\n  const url = new URL(\"\".concat(getThirdwebBaseUrl(\"bridge\"), \"/v1/status\"));\n  url.searchParams.set(\"transactionHash\", transactionHash);\n  url.searchParams.set(\"chainId\", chainId.toString());\n  if (transactionId) {\n    url.searchParams.set(\"transactionId\", transactionId);\n  }\n  const response = await clientFetch(url.toString());\n  if (!response.ok) {\n    const errorJson = await response.json();\n    throw new ApiError({\n      code: errorJson.code || \"UNKNOWN_ERROR\",\n      correlationId: errorJson.correlationId || undefined,\n      message: errorJson.message || response.statusText,\n      statusCode: response.status\n    });\n  }\n  const {\n    data\n  } = await response.json();\n  if (data.status === \"FAILED\") {\n    return {\n      paymentId: data.paymentId,\n      status: \"FAILED\",\n      transactions: data.transactions\n    };\n  }\n  if (data.status === \"PENDING\") {\n    return {\n      destinationChainId: data.destinationChainId,\n      destinationToken: data.destinationToken,\n      destinationTokenAddress: data.destinationTokenAddress,\n      originAmount: BigInt(data.originAmount),\n      originChainId: data.originChainId,\n      originToken: data.originToken,\n      originTokenAddress: data.originTokenAddress,\n      paymentId: data.paymentId,\n      purchaseData: data.purchaseData,\n      receiver: data.receiver,\n      sender: data.sender,\n      status: \"PENDING\",\n      transactions: data.transactions\n    };\n  }\n  if (data.status === \"NOT_FOUND\") {\n    return {\n      paymentId: data.paymentId,\n      status: \"NOT_FOUND\",\n      transactions: []\n    };\n  }\n  return {\n    destinationAmount: BigInt(data.destinationAmount),\n    destinationChainId: data.destinationChainId,\n    destinationToken: data.destinationToken,\n    destinationTokenAddress: data.destinationTokenAddress,\n    originAmount: BigInt(data.originAmount),\n    originChainId: data.originChainId,\n    originToken: data.originToken,\n    originTokenAddress: data.originTokenAddress,\n    paymentId: data.paymentId,\n    purchaseData: data.purchaseData,\n    receiver: data.receiver,\n    sender: data.sender,\n    status: \"COMPLETED\",\n    transactions: data.transactions\n  };\n}","map":{"version":3,"names":["getThirdwebBaseUrl","getClientFetch","ApiError","status","options","transactionHash","client","transactionId","chainId","chain","id","clientFetch","url","URL","concat","searchParams","set","toString","response","ok","errorJson","json","code","correlationId","undefined","message","statusText","statusCode","data","paymentId","transactions","destinationChainId","destinationToken","destinationTokenAddress","originAmount","BigInt","originChainId","originToken","originTokenAddress","purchaseData","receiver","sender","destinationAmount"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/bridge/Status.ts"],"sourcesContent":["import type { Hex as ox__Hex } from \"ox\";\nimport type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../utils/domains.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { ApiError } from \"./types/Errors.js\";\nimport type { Status } from \"./types/Status.js\";\n\n/**\n * Retrieves a Bridge quote for the provided sell intent. The quote will specify the expected `destinationAmount` that will be received in exchange for the specified `originAmount`, which is specified with the `sellAmountWei` option.\n *\n * The returned status will include both the origin and destination transactions and any finalized amounts for the route.\n *\n * @example\n * ```typescript\n * import { Bridge } from \"thirdweb\";\n *\n * const status = await Bridge.status({\n *   transactionHash: \"0xe199ef82a0b6215221536e18ec512813c1aa10b4f5ed0d4dfdfcd703578da56d\",\n *   chainId: 8453,\n *   client: thirdwebClient,\n * });\n * ```\n *\n * If the transaction is complete, a response might look like:\n * ```typescript\n * {\n *   status: 'COMPLETED',\n *   originAmount: 200000000000000n,\n *   destinationAmount: 188625148000000n,\n *   originChainId: 8453,\n *   destinationChainId: 2741,\n *   originTokenAddress: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE',\n *   destinationTokenAddress: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE',\n *   transactions: [\n *     {\n *       chainId: 8453,\n *       transactionHash: '0xe199ef82a0b6215221536e18ec512813c1aa10b4f5ed0d4dfdfcd703578da56d'\n *     },\n *     {\n *       chainId: 2741,\n *       transactionHash: '0xa70a82f42330f54be95a542e1fcfe6ed2dd9f07fb8c82ae67afb4342319f7433'\n *     }\n *   ],\n *   purchaseData: {\n *     foo: \"bar\"\n *   }\n * }\n * ```\n *\n * If the origin transaction hasn't been mined yet, a response might look like:\n * ```typescript\n * {\n *   status: \"NOT_FOUND\",\n * }\n * ```\n * This is to allow you to poll for the status without catching an error. Be sure your transaction hash and chain are correct though, as this could also represent a legitimate 404 if the transaction doesn't exist.\n *\n * If the transaction is still pending, a response might look like:\n * ```typescript\n * {\n *   status: \"PENDING\",\n *   originAmount: 1000000000000000000n,\n *   originChainId: 466,\n *   destinationChainId: 1,\n *   originTokenAddress: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *   destinationTokenAddress: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *   transactions: [\n *     {\n *       transactionHash: \"0xe199ef82a0b6215221536e18ec512813c1aa10b4f5ed0d4dfdfcd703578da56d\",\n *       chainId: 466,\n *     }\n *   ]\n * }\n * ```\n *\n * If the transaction failed, a response might look like:\n * ```typescript\n * {\n *   status: \"FAILED\",\n *   transactions: [\n *     {\n *       transactionHash: \"0xe199ef82a0b6215221536e18ec512813c1aa10b4f5ed0d4dfdfcd703578da56d\",\n *       chainId: 466,\n *     }\n *   ]\n * }\n * ```\n *\n * This status is for a **single origin transaction only**. If your route involves multiple transactions, you'll need to get the status for each of them individually.\n *\n * If sending multiple dependent sequential transactions, wait until `status` returns `COMPLETED` before sending the next transaction.\n *\n * You can access this function's input and output types with `status.Options` and `status.Result`, respectively.\n *\n * @param options - The options for the quote.\n * @param options.transactionHash - The hash of the origin transaction to get the bridge status for.\n * @param options.chainId - The chain ID of the origin token.\n * @param options.transactionId - The transaction ID received from the `prepare` request.\n * @param options.client - Your thirdweb client.\n *\n * @returns A promise that resolves to a status object for the transaction.\n *\n * @throws Will throw an error if there is an issue fetching the status.\n * @bridge\n * @beta\n */\nexport async function status(options: status.Options): Promise<status.Result> {\n  const { transactionHash, client, transactionId } = options;\n  const chainId = \"chainId\" in options ? options.chainId : options.chain.id;\n\n  const clientFetch = getClientFetch(client);\n  const url = new URL(`${getThirdwebBaseUrl(\"bridge\")}/v1/status`);\n  url.searchParams.set(\"transactionHash\", transactionHash);\n  url.searchParams.set(\"chainId\", chainId.toString());\n  if (transactionId) {\n    url.searchParams.set(\"transactionId\", transactionId);\n  }\n\n  const response = await clientFetch(url.toString());\n  if (!response.ok) {\n    const errorJson = await response.json();\n    throw new ApiError({\n      code: errorJson.code || \"UNKNOWN_ERROR\",\n      correlationId: errorJson.correlationId || undefined,\n      message: errorJson.message || response.statusText,\n      statusCode: response.status,\n    });\n  }\n\n  const { data }: { data: Status } = await response.json();\n  if (data.status === \"FAILED\") {\n    return {\n      paymentId: data.paymentId,\n      status: \"FAILED\",\n      transactions: data.transactions,\n    };\n  }\n\n  if (data.status === \"PENDING\") {\n    return {\n      destinationChainId: data.destinationChainId,\n      destinationToken: data.destinationToken,\n      destinationTokenAddress: data.destinationTokenAddress,\n      originAmount: BigInt(data.originAmount),\n      originChainId: data.originChainId,\n      originToken: data.originToken,\n      originTokenAddress: data.originTokenAddress,\n      paymentId: data.paymentId,\n      purchaseData: data.purchaseData,\n      receiver: data.receiver,\n      sender: data.sender,\n      status: \"PENDING\",\n      transactions: data.transactions,\n    };\n  }\n\n  if (data.status === \"NOT_FOUND\") {\n    return {\n      paymentId: data.paymentId,\n      status: \"NOT_FOUND\",\n      transactions: [],\n    };\n  }\n\n  return {\n    destinationAmount: BigInt(data.destinationAmount),\n    destinationChainId: data.destinationChainId,\n    destinationToken: data.destinationToken,\n    destinationTokenAddress: data.destinationTokenAddress,\n    originAmount: BigInt(data.originAmount),\n    originChainId: data.originChainId,\n    originToken: data.originToken,\n    originTokenAddress: data.originTokenAddress,\n    paymentId: data.paymentId,\n    purchaseData: data.purchaseData,\n    receiver: data.receiver,\n    sender: data.sender,\n    status: \"COMPLETED\",\n    transactions: data.transactions,\n  };\n}\n\n/**\n * Namespace containing types for the status function.\n * @namespace status\n * @bridge\n */\nexport declare namespace status {\n  /**\n   * Options for checking transaction status.\n   * Can specify either chainId or chain object.\n   * @interface Options\n   * @bridge\n   */\n  type Options =\n    | {\n        /** The transaction hash to check status for */\n        transactionHash: ox__Hex.Hex;\n        /** The chain ID where the transaction occurred */\n        chainId: number;\n        /** The transaction ID received from the `prepare` request */\n        transactionId?: string;\n        /** Your thirdweb client */\n        client: ThirdwebClient;\n      }\n    | {\n        /** The transaction hash to check status for */\n        transactionHash: ox__Hex.Hex;\n        /** The chain object where the transaction occurred */\n        chain: Chain;\n        /** The transaction ID received from the `prepare` request */\n        transactionId?: string;\n        /** Your thirdweb client */\n        client: ThirdwebClient;\n      };\n\n  /**\n   * Result returned from checking transaction status.\n   * Contains the current status and transaction details.\n   * @interface Result\n   * @bridge\n   */\n  type Result = Status;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}