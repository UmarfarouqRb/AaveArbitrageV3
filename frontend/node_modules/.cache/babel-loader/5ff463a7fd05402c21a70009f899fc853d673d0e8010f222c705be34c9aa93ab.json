{"ast":null,"code":"/* biome-ignore-all lint: IGNORED */\n// source code of yocto-queue + modified to add types\n// https://github.com/sindresorhus/yocto-queue\nclass Node {\n  constructor(value) {\n    Object.defineProperty(this, \"value\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"next\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.value = value;\n  }\n}\n/**\n * @internal\n */\nexport class Queue {\n  constructor() {\n    Object.defineProperty(this, \"head\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"tail\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"size\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.clear();\n    this.size = 0;\n  }\n  enqueue(value) {\n    const node = new Node(value);\n    if (this.head) {\n      if (this.tail) {\n        this.tail.next = node;\n      }\n      this.tail = node;\n    } else {\n      this.head = node;\n      this.tail = node;\n    }\n    this.size++;\n  }\n  dequeue() {\n    var _this$head;\n    const current = this.head;\n    if (!current) {\n      return;\n    }\n    this.head = (_this$head = this.head) === null || _this$head === void 0 ? void 0 : _this$head.next;\n    this.size--;\n    return current.value;\n  }\n  clear() {\n    this.head = undefined;\n    this.tail = undefined;\n    this.size = 0;\n  }\n  *[Symbol.iterator]() {\n    let current = this.head;\n    while (current) {\n      yield current.value;\n      current = current.next;\n    }\n  }\n}\n// source code of p-limit - https://github.com/sindresorhus/p-limit/ + modified to add types\nconst AsyncResource = {\n  bind(fn, _type, thisArg) {\n    return fn.bind(thisArg);\n  }\n};\n/**\n * Run multiple promise-returning & async functions with limited concurrency.\n * @param concurrency\n * @internal\n */\nexport function pLimit(concurrency) {\n  if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {\n    throw new TypeError(\"Expected `concurrency` to be a number from 1 and up\");\n  }\n  const queue = new Queue();\n  let activeCount = 0;\n  const next = () => {\n    activeCount--;\n    if (queue.size > 0) {\n      const fn = queue.dequeue();\n      if (fn) {\n        fn();\n      }\n    }\n  };\n  const run = async (function_, resolve, arguments_) => {\n    activeCount++;\n    // @ts-ignore\n    const result = (async () => function_(...arguments_))();\n    resolve(result);\n    try {\n      await result;\n    } catch (_unused) {}\n    next();\n  };\n  const enqueue = (function_, resolve, arguments_) => {\n    queue.enqueue(AsyncResource.bind(run.bind(undefined, function_, resolve, arguments_)));\n    (async () => {\n      // This function needs to wait until the next microtask before comparing\n      // `activeCount` to `concurrency`, because `activeCount` is updated asynchronously\n      // when the run function is dequeued and called. The comparison in the if-statement\n      // needs to happen asynchronously as well to get an up-to-date value for `activeCount`.\n      await Promise.resolve();\n      if (activeCount < concurrency && queue.size > 0) {\n        const fn = queue.dequeue();\n        if (fn) {\n          fn();\n        }\n      }\n    })();\n  };\n  const generator = function (function_) {\n    for (var _len = arguments.length, arguments_ = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      arguments_[_key - 1] = arguments[_key];\n    }\n    return new Promise(resolve => {\n      enqueue(function_, resolve, arguments_);\n    });\n  };\n  Object.defineProperties(generator, {\n    activeCount: {\n      get: () => activeCount\n    },\n    clearQueue: {\n      value() {\n        queue.clear();\n      }\n    },\n    pendingCount: {\n      get: () => queue.size\n    }\n  });\n  return generator;\n}","map":{"version":3,"names":["Node","constructor","value","Object","defineProperty","Queue","clear","size","enqueue","node","head","tail","next","dequeue","_this$head","current","undefined","Symbol","iterator","AsyncResource","bind","fn","_type","thisArg","pLimit","concurrency","Number","isInteger","POSITIVE_INFINITY","TypeError","queue","activeCount","run","function_","resolve","arguments_","result","_unused","Promise","generator","_len","arguments","length","Array","_key","defineProperties","get","clearQueue","pendingCount"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/utils/promise/p-limit.ts"],"sourcesContent":["/* biome-ignore-all lint: IGNORED */\n\n// source code of yocto-queue + modified to add types\n// https://github.com/sindresorhus/yocto-queue\nclass Node<T> {\n  value: T;\n  next: Node<T> | undefined;\n\n  constructor(value: T) {\n    this.value = value;\n  }\n}\n\n/**\n * @internal\n */\nexport class Queue<T> {\n  private head: Node<T> | undefined;\n  private tail: Node<T> | undefined;\n  size: number;\n\n  constructor() {\n    this.clear();\n    this.size = 0;\n  }\n\n  enqueue(value: T) {\n    const node = new Node(value);\n\n    if (this.head) {\n      if (this.tail) {\n        this.tail.next = node;\n      }\n      this.tail = node;\n    } else {\n      this.head = node;\n      this.tail = node;\n    }\n\n    this.size++;\n  }\n\n  dequeue() {\n    const current = this.head;\n    if (!current) {\n      return;\n    }\n\n    this.head = this.head?.next;\n    this.size--;\n    return current.value;\n  }\n\n  clear() {\n    this.head = undefined;\n    this.tail = undefined;\n    this.size = 0;\n  }\n\n  *[Symbol.iterator]() {\n    let current = this.head;\n\n    while (current) {\n      yield current.value;\n      current = current.next;\n    }\n  }\n}\n\n// source code of p-limit - https://github.com/sindresorhus/p-limit/ + modified to add types\nconst AsyncResource = {\n  bind(fn: () => void, _type?: any, thisArg?: any) {\n    return fn.bind(thisArg);\n  },\n};\n\ntype LimitFunctionCallSignature = {\n  /**\n   * @param fn - Promise-returning/async function.\n   * @param arguments - Any arguments to pass through to `fn`. Support for passing arguments on to the `fn` is provided in order to be able to avoid creating unnecessary closures. You probably don't need this optimization unless you're pushing a lot of functions.\n   * @returns The promise returned by calling `fn(...arguments)`.\n   */\n  <Arguments extends unknown[], ReturnType>(\n    fn: (...arguments_: Arguments) => PromiseLike<ReturnType> | ReturnType,\n    ...arguments_: Arguments\n  ): Promise<ReturnType>;\n};\n\ntype LimitFunction = {\n  /**\n   * The number of promises that are currently running.\n   */\n  readonly activeCount: number;\n\n  /**\n   * The number of promises that are waiting to run (i.e. their internal `fn` was not called yet).\n   */\n  readonly pendingCount: number;\n\n  /**\n   * Discard pending promises that are waiting to run.\n   *\n   * This might be useful if you want to teardown the queue at the end of your program's lifecycle or discard any function calls referencing an intermediary state of your app.\n   *\n   * Note: This does not cancel promises that are already running.\n   */\n  clearQueue: () => void;\n} & LimitFunctionCallSignature;\n\ntype Fn = () => void;\n\n/**\n * Run multiple promise-returning & async functions with limited concurrency.\n * @param concurrency\n * @internal\n */\nexport function pLimit(concurrency: number): LimitFunction {\n  if (\n    !(\n      (Number.isInteger(concurrency) ||\n        concurrency === Number.POSITIVE_INFINITY) &&\n      concurrency > 0\n    )\n  ) {\n    throw new TypeError(\"Expected `concurrency` to be a number from 1 and up\");\n  }\n\n  const queue = new Queue<Fn>();\n  let activeCount = 0;\n\n  const next = () => {\n    activeCount--;\n\n    if (queue.size > 0) {\n      const fn = queue.dequeue();\n      if (fn) {\n        fn();\n      }\n    }\n  };\n\n  const run = async (function_: Fn, resolve: any, arguments_: any[]) => {\n    activeCount++;\n\n    // @ts-ignore\n    const result = (async () => function_(...arguments_))();\n\n    resolve(result);\n\n    try {\n      await result;\n    } catch {}\n\n    next();\n  };\n\n  const enqueue = (function_: Fn, resolve: any, arguments_: any[]) => {\n    queue.enqueue(\n      AsyncResource.bind(run.bind(undefined, function_, resolve, arguments_)),\n    );\n\n    (async () => {\n      // This function needs to wait until the next microtask before comparing\n      // `activeCount` to `concurrency`, because `activeCount` is updated asynchronously\n      // when the run function is dequeued and called. The comparison in the if-statement\n      // needs to happen asynchronously as well to get an up-to-date value for `activeCount`.\n      await Promise.resolve();\n\n      if (activeCount < concurrency && queue.size > 0) {\n        const fn = queue.dequeue();\n        if (fn) {\n          fn();\n        }\n      }\n    })();\n  };\n\n  const generator: LimitFunctionCallSignature = (function_, ...arguments_) =>\n    new Promise((resolve) => {\n      enqueue(function_, resolve, arguments_);\n    });\n\n  Object.defineProperties(generator, {\n    activeCount: {\n      get: () => activeCount,\n    },\n    clearQueue: {\n      value() {\n        queue.clear();\n      },\n    },\n    pendingCount: {\n      get: () => queue.size,\n    },\n  });\n\n  return generator as LimitFunction;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}