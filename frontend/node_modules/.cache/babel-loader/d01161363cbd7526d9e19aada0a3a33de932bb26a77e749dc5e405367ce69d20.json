{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport * as ox__Hex from \"ox/Hex\";\nimport { isAddress } from \"../address.js\";\nimport { byteSize } from \"../encoding/helpers/byte-size.js\";\nimport { boolToHex, numberToHex, padHex, stringToHex } from \"../encoding/hex.js\";\n/**\n * Encodes the given ABI parameters and values into a hexadecimal string.\n * @template TParams - The type of the ABI parameters.\n * @param params - The ABI parameters.\n * @param values - The corresponding values for the ABI parameters.\n * @returns - The encoded ABI parameters as a hexadecimal string.\n * @throws {Error} - If the number of parameters and values do not match.\n * @example\n * ```ts\n * import { encodeAbiParameters } from \"thirdweb/utils\";\n *\n * const params = [\n *  { name: \"param1\", type: \"uint256\" },\n *  { name: \"param2\", type: \"string\" },\n * ];\n * const values = [123, \"hello\"];\n *\n * const data = encodeAbiParameters(params, values);\n * console.log(data);\n * ```\n * @utils\n */\nexport function encodeAbiParameters(params, values) {\n  if (params.length !== values.length) {\n    throw new Error(\"The number of parameters and values must match.\");\n  }\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params,\n    values\n  });\n  const data = encodeParams(preparedParams);\n  if (data.length === 0) {\n    return \"0x\";\n  }\n  return data;\n}\nfunction prepareParams(_ref) {\n  let {\n    params,\n    values\n  } = _ref;\n  const preparedParams = [];\n  for (let i = 0; i < params.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    preparedParams.push(prepareParam({\n      param: params[i],\n      value: values[i]\n    }));\n  }\n  return preparedParams;\n}\n/**\n * @internal Export for unit test\n */\nexport function prepareParam(_ref2) {\n  let {\n    param,\n    value\n  } = _ref2;\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return encodeArray(value, {\n      length,\n      param: _objectSpread(_objectSpread({}, param), {}, {\n        type\n      })\n    });\n  }\n  if (param.type === \"tuple\") {\n    return encodeTuple(value, {\n      param: param\n    });\n  }\n  if (param.type === \"address\") {\n    return encodeAddress(value);\n  }\n  if (param.type === \"bool\") {\n    return encodeBool(value);\n  }\n  if (param.type.startsWith(\"uint\") || param.type.startsWith(\"int\")) {\n    const signed = param.type.startsWith(\"int\");\n    return encodeNumber(value, {\n      signed\n    });\n  }\n  if (param.type.startsWith(\"bytes\")) {\n    return encodeBytes(value, {\n      param\n    });\n  }\n  if (param.type === \"string\") {\n    return encodeString(value);\n  }\n  throw new Error(\"Unsupported parameter type: \".concat(param.type));\n}\nfunction encodeParams(preparedParams) {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0;\n  for (let i = 0; i < preparedParams.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const {\n      dynamic,\n      encoded\n    } = preparedParams[i];\n    if (dynamic) {\n      staticSize += 32;\n    } else {\n      staticSize += byteSize(encoded);\n    }\n  }\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParams = [];\n  const dynamicParams = [];\n  let dynamicSize = 0;\n  for (let i = 0; i < preparedParams.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const {\n      dynamic,\n      encoded\n    } = preparedParams[i];\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, {\n        size: 32\n      }));\n      dynamicParams.push(encoded);\n      dynamicSize += byteSize(encoded);\n    } else {\n      staticParams.push(encoded);\n    }\n  }\n  // 3. Concatenate static and dynamic parts.\n  return ox__Hex.concat(...[...staticParams, ...dynamicParams]);\n}\n/////////////////////////////////////////////////////////////////\n/**\n * @internal Export for unit test\n */\nexport function encodeAddress(value) {\n  // We allow empty strings for deployment transactions where there is no to address\n  if (value !== \"\" && value !== undefined && !isAddress(value)) {\n    throw new Error(\"Invalid address: \".concat(value));\n  }\n  return {\n    dynamic: false,\n    encoded: padHex(value.toLowerCase())\n  };\n}\nfunction encodeArray(value, _ref3) {\n  let {\n    length,\n    param\n  } = _ref3;\n  const dynamic = length === null;\n  if (!Array.isArray(value)) {\n    throw new Error(\"Invalid array value.\");\n  }\n  if (!dynamic && value.length !== length) {\n    throw new Error(\"Invalid array length.\");\n  }\n  let dynamicChild = false;\n  const preparedParams = [];\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({\n      param,\n      value: value[i]\n    });\n    if (preparedParam.dynamic) {\n      dynamicChild = true;\n    }\n    preparedParams.push(preparedParam);\n  }\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams);\n    if (dynamic) {\n      const length_ = numberToHex(preparedParams.length, {\n        size: 32\n      });\n      return {\n        dynamic: true,\n        encoded: preparedParams.length > 0 ? ox__Hex.concat(...[length_, data]) : length_\n      };\n    }\n    if (dynamicChild) {\n      return {\n        dynamic: true,\n        encoded: data\n      };\n    }\n  }\n  return {\n    dynamic: false,\n    encoded: ox__Hex.concat(...preparedParams.map(_ref4 => {\n      let {\n        encoded\n      } = _ref4;\n      return encoded;\n    }))\n  };\n}\nfunction encodeBytes(value, _ref5) {\n  let {\n    param\n  } = _ref5;\n  const [, paramSize] = param.type.split(\"bytes\");\n  const bytesSize = byteSize(value);\n  if (!paramSize) {\n    let value_ = value;\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0) {\n      value_ = padHex(value_, {\n        dir: \"right\",\n        size: Math.ceil((value.length - 2) / 2 / 32) * 32\n      });\n    }\n    return {\n      dynamic: true,\n      encoded: ox__Hex.concat(...[padHex(numberToHex(bytesSize, {\n        size: 32\n      })), value_])\n    };\n  }\n  if (bytesSize !== Number.parseInt(paramSize)) {\n    throw new Error(\"Invalid bytes\".concat(paramSize, \" size: \").concat(bytesSize));\n  }\n  return {\n    dynamic: false,\n    encoded: padHex(value, {\n      dir: \"right\"\n    })\n  };\n}\nfunction encodeBool(value) {\n  return {\n    dynamic: false,\n    encoded: padHex(boolToHex(value))\n  };\n}\nfunction encodeNumber(value, _ref6) {\n  let {\n    signed\n  } = _ref6;\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      signed,\n      size: 32\n    })\n  };\n}\nfunction encodeString(value) {\n  const hexValue = stringToHex(value);\n  const partsLength = Math.ceil(byteSize(hexValue) / 32);\n  const parts = [];\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(padHex(ox__Hex.slice(hexValue, i * 32, (i + 1) * 32), {\n      dir: \"right\"\n    }));\n  }\n  return {\n    dynamic: true,\n    encoded: ox__Hex.concat(...[padHex(numberToHex(byteSize(hexValue), {\n      size: 32\n    })), ...parts])\n  };\n}\nfunction encodeTuple(value, _ref7) {\n  let {\n    param\n  } = _ref7;\n  let dynamic = false;\n  const preparedParams = [];\n  for (let i = 0; i < param.components.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const param_ = param.components[i];\n    const index = Array.isArray(value) ? i : param_.name;\n    const preparedParam = prepareParam({\n      param: param_,\n      // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      value: value[index]\n    });\n    preparedParams.push(preparedParam);\n    if (preparedParam.dynamic) {\n      dynamic = true;\n    }\n  }\n  return {\n    dynamic,\n    encoded: dynamic ? encodeParams(preparedParams) : ox__Hex.concat(...preparedParams.map(_ref8 => {\n      let {\n        encoded\n      } = _ref8;\n      return encoded;\n    }))\n  };\n}\nfunction getArrayComponents(type) {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n  return matches ?\n  // Return `null` if the array is dynamic.\n  // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n  [matches[2] ? Number(matches[2]) : null, matches[1]] : undefined;\n}","map":{"version":3,"names":["ox__Hex","isAddress","byteSize","boolToHex","numberToHex","padHex","stringToHex","encodeAbiParameters","params","values","length","Error","preparedParams","prepareParams","data","encodeParams","_ref","i","push","prepareParam","param","value","_ref2","arrayComponents","getArrayComponents","type","encodeArray","_objectSpread","encodeTuple","encodeAddress","encodeBool","startsWith","signed","encodeNumber","encodeBytes","encodeString","concat","staticSize","dynamic","encoded","staticParams","dynamicParams","dynamicSize","size","undefined","toLowerCase","_ref3","Array","isArray","dynamicChild","preparedParam","length_","map","_ref4","_ref5","paramSize","split","bytesSize","value_","dir","Math","ceil","Number","parseInt","_ref6","hexValue","partsLength","parts","slice","_ref7","components","param_","index","name","_ref8","matches","match"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/utils/abi/encodeAbiParameters.ts"],"sourcesContent":["import type {\n  AbiParameter,\n  AbiParametersToPrimitiveTypes,\n  AbiParameterToPrimitiveType,\n} from \"abitype\";\nimport * as ox__Hex from \"ox/Hex\";\nimport { isAddress } from \"../address.js\";\nimport { byteSize } from \"../encoding/helpers/byte-size.js\";\nimport {\n  boolToHex,\n  type Hex,\n  numberToHex,\n  padHex,\n  stringToHex,\n} from \"../encoding/hex.js\";\n\n/**\n * Encodes the given ABI parameters and values into a hexadecimal string.\n * @template TParams - The type of the ABI parameters.\n * @param params - The ABI parameters.\n * @param values - The corresponding values for the ABI parameters.\n * @returns - The encoded ABI parameters as a hexadecimal string.\n * @throws {Error} - If the number of parameters and values do not match.\n * @example\n * ```ts\n * import { encodeAbiParameters } from \"thirdweb/utils\";\n *\n * const params = [\n *  { name: \"param1\", type: \"uint256\" },\n *  { name: \"param2\", type: \"string\" },\n * ];\n * const values = [123, \"hello\"];\n *\n * const data = encodeAbiParameters(params, values);\n * console.log(data);\n * ```\n * @utils\n */\nexport function encodeAbiParameters<\n  const TParams extends readonly AbiParameter[] | readonly unknown[],\n>(\n  params: TParams,\n  values: TParams extends readonly AbiParameter[]\n    ? AbiParametersToPrimitiveTypes<TParams>\n    : never,\n): Hex {\n  if (params.length !== values.length) {\n    throw new Error(\"The number of parameters and values must match.\");\n  }\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params as readonly AbiParameter[],\n    values,\n  });\n  const data = encodeParams(preparedParams);\n  if (data.length === 0) {\n    return \"0x\";\n  }\n  return data;\n}\n\n//UTILS\n\ntype PreparedParam = { dynamic: boolean; encoded: Hex };\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] };\ntype Tuple = AbiParameterToPrimitiveType<TupleAbiParameter>;\n\nfunction prepareParams<const TParams extends readonly AbiParameter[]>({\n  params,\n  values,\n}: {\n  params: TParams;\n  values: AbiParametersToPrimitiveTypes<TParams>;\n}) {\n  const preparedParams: PreparedParam[] = [];\n  for (let i = 0; i < params.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    preparedParams.push(prepareParam({ param: params[i]!, value: values[i] }));\n  }\n  return preparedParams;\n}\n\n/**\n * @internal Export for unit test\n */\nexport function prepareParam<const TParam extends AbiParameter>({\n  param,\n  value,\n}: {\n  param: TParam;\n  value: AbiParameterToPrimitiveType<TParam>;\n}): PreparedParam {\n  const arrayComponents = getArrayComponents(param.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return encodeArray(value, { length, param: { ...param, type } });\n  }\n  if (param.type === \"tuple\") {\n    return encodeTuple(value as unknown as Tuple, {\n      param: param as TupleAbiParameter,\n    });\n  }\n  if (param.type === \"address\") {\n    return encodeAddress(value as unknown as Hex);\n  }\n  if (param.type === \"bool\") {\n    return encodeBool(value as unknown as boolean);\n  }\n  if (param.type.startsWith(\"uint\") || param.type.startsWith(\"int\")) {\n    const signed = param.type.startsWith(\"int\");\n    return encodeNumber(value as unknown as number, { signed });\n  }\n  if (param.type.startsWith(\"bytes\")) {\n    return encodeBytes(value as unknown as Hex, { param });\n  }\n  if (param.type === \"string\") {\n    return encodeString(value as unknown as string);\n  }\n  throw new Error(`Unsupported parameter type: ${param.type}`);\n}\n\nfunction encodeParams(preparedParams: PreparedParam[]): Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0;\n  for (let i = 0; i < preparedParams.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const { dynamic, encoded } = preparedParams[i]!;\n    if (dynamic) {\n      staticSize += 32;\n    } else {\n      staticSize += byteSize(encoded);\n    }\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParams: Hex[] = [];\n  const dynamicParams: Hex[] = [];\n  let dynamicSize = 0;\n  for (let i = 0; i < preparedParams.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const { dynamic, encoded } = preparedParams[i]!;\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));\n      dynamicParams.push(encoded);\n      dynamicSize += byteSize(encoded);\n    } else {\n      staticParams.push(encoded);\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return ox__Hex.concat(...[...staticParams, ...dynamicParams]);\n}\n\n/////////////////////////////////////////////////////////////////\n\n/**\n * @internal Export for unit test\n */\nexport function encodeAddress(value: Hex): PreparedParam {\n  // We allow empty strings for deployment transactions where there is no to address\n  if ((value as string) !== \"\" && value !== undefined && !isAddress(value)) {\n    throw new Error(`Invalid address: ${value}`);\n  }\n  return { dynamic: false, encoded: padHex(value.toLowerCase() as Hex) };\n}\n\nfunction encodeArray<const TParam extends AbiParameter>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  {\n    length,\n    param,\n  }: {\n    length: number | null;\n    param: TParam;\n  },\n): PreparedParam {\n  const dynamic = length === null;\n\n  if (!Array.isArray(value)) {\n    throw new Error(\"Invalid array value.\");\n  }\n  if (!dynamic && value.length !== length) {\n    throw new Error(\"Invalid array length.\");\n  }\n\n  let dynamicChild = false;\n  const preparedParams: PreparedParam[] = [];\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({ param, value: value[i] });\n    if (preparedParam.dynamic) {\n      dynamicChild = true;\n    }\n    preparedParams.push(preparedParam);\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams);\n    if (dynamic) {\n      const length_ = numberToHex(preparedParams.length, { size: 32 });\n      return {\n        dynamic: true,\n        encoded:\n          preparedParams.length > 0\n            ? ox__Hex.concat(...[length_, data])\n            : length_,\n      };\n    }\n    if (dynamicChild) {\n      return { dynamic: true, encoded: data };\n    }\n  }\n  return {\n    dynamic: false,\n    encoded: ox__Hex.concat(...preparedParams.map(({ encoded }) => encoded)),\n  };\n}\n\nfunction encodeBytes<const TParam extends AbiParameter>(\n  value: Hex,\n  { param }: { param: TParam },\n): PreparedParam {\n  const [, paramSize] = param.type.split(\"bytes\");\n  const bytesSize = byteSize(value);\n  if (!paramSize) {\n    let value_ = value;\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0) {\n      value_ = padHex(value_, {\n        dir: \"right\",\n        size: Math.ceil((value.length - 2) / 2 / 32) * 32,\n      });\n    }\n    return {\n      dynamic: true,\n      encoded: ox__Hex.concat(\n        ...[padHex(numberToHex(bytesSize, { size: 32 })), value_],\n      ),\n    };\n  }\n  if (bytesSize !== Number.parseInt(paramSize)) {\n    throw new Error(`Invalid bytes${paramSize} size: ${bytesSize}`);\n  }\n  return { dynamic: false, encoded: padHex(value, { dir: \"right\" }) };\n}\n\nfunction encodeBool(value: boolean): PreparedParam {\n  return { dynamic: false, encoded: padHex(boolToHex(value)) };\n}\n\nfunction encodeNumber(\n  value: number,\n  { signed }: { signed: boolean },\n): PreparedParam {\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      signed,\n      size: 32,\n    }),\n  };\n}\n\nfunction encodeString(value: string): PreparedParam {\n  const hexValue = stringToHex(value);\n  const partsLength = Math.ceil(byteSize(hexValue) / 32);\n  const parts: Hex[] = [];\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(\n      padHex(ox__Hex.slice(hexValue, i * 32, (i + 1) * 32), {\n        dir: \"right\",\n      }),\n    );\n  }\n  return {\n    dynamic: true,\n    encoded: ox__Hex.concat(\n      ...[padHex(numberToHex(byteSize(hexValue), { size: 32 })), ...parts],\n    ),\n  };\n}\n\nfunction encodeTuple<\n  const TParam extends AbiParameter & { components: readonly AbiParameter[] },\n>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  { param }: { param: TParam },\n): PreparedParam {\n  let dynamic = false;\n  const preparedParams: PreparedParam[] = [];\n  for (let i = 0; i < param.components.length; i++) {\n    // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n    const param_ = param.components[i]!;\n    const index = Array.isArray(value) ? i : param_.name;\n    const preparedParam = prepareParam({\n      param: param_,\n      // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n      value: (value as any)[index!] as readonly unknown[],\n    });\n    preparedParams.push(preparedParam);\n    if (preparedParam.dynamic) {\n      dynamic = true;\n    }\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encodeParams(preparedParams)\n      : ox__Hex.concat(...preparedParams.map(({ encoded }) => encoded)),\n  };\n}\n\nfunction getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n  return matches\n    ? // Return `null` if the array is dynamic.\n      // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.\n      [matches[2] ? Number(matches[2]) : null, matches[1]!]\n    : undefined;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}