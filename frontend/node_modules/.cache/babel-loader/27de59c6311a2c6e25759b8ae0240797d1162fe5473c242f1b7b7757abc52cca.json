{"ast":null,"code":"import { sleep } from \"../utils/sleep.js\";\nimport { eth_blockNumber } from \"./actions/eth_blockNumber.js\";\nimport { getRpcClient } from \"./rpc.js\";\nconst MAX_POLL_DELAY = 5000; // 5 seconds\nconst DEFAULT_POLL_DELAY = 1000; // 1 second\nconst MIN_POLL_DELAY = 500; // 500 milliseconds\nconst DEFAULT_OVERPOLL_RATIO = 2; // poll twice as often as the average block time by default\nconst SLIDING_WINDOW_SIZE = 10; // always keep track of the last 10 block times\n/**\n * TODO: document\n * @internal\n */\nfunction getAverageBlockTime(blockTimes) {\n  // left-pad the blocktimes Array with the DEFAULT_POLL_DELAY\n  while (blockTimes.length < SLIDING_WINDOW_SIZE) {\n    blockTimes.unshift(DEFAULT_POLL_DELAY);\n  }\n  const sum = blockTimes.reduce((acc, blockTime) => acc + blockTime, 0);\n  return sum / blockTimes.length;\n}\n/**\n * TODO: document\n * @internal\n */\nfunction createBlockNumberPoller(client, chain, overPollRatio, onError) {\n  let subscribers = [];\n  let blockTimesWindow = [];\n  let isActive = false;\n  let lastBlockNumber;\n  let lastBlockAt;\n  const rpcRequest = getRpcClient({\n    chain,\n    client\n  });\n  /**\n   * TODO: document\n   * @internal\n   */\n  async function poll() {\n    // stop polling if there are no more subscriptions\n    if (!isActive) {\n      return;\n    }\n    try {\n      const blockNumber = await eth_blockNumber(rpcRequest);\n      if (!lastBlockNumber || blockNumber > lastBlockNumber) {\n        let newBlockNumbers = [];\n        if (lastBlockNumber) {\n          for (let i = lastBlockNumber + 1n; i <= blockNumber; i++) {\n            newBlockNumbers.push(BigInt(i));\n          }\n        } else {\n          newBlockNumbers = [blockNumber];\n        }\n        lastBlockNumber = blockNumber;\n        const currentTime = Date.now();\n        if (lastBlockAt) {\n          // if we skipped a block we need to adjust the block time down to that level\n          const blockTime = (currentTime - lastBlockAt) / newBlockNumbers.length;\n          blockTimesWindow.push(blockTime);\n          blockTimesWindow = blockTimesWindow.slice(-SLIDING_WINDOW_SIZE);\n        }\n        lastBlockAt = currentTime;\n        // for all new blockNumbers...\n        for (const b of newBlockNumbers) {\n          // ... call all current subscribers\n          for (const subscriberCallback of subscribers) {\n            subscriberCallback(b);\n          }\n        }\n      }\n    } catch (err) {\n      if (onError) {\n        onError(err);\n      } else {\n        console.error(\"[watchBlockNumber]: Failed to poll for latest block number: \".concat(err));\n      }\n    }\n    const currentApproximateBlockTime = getAverageBlockTime(blockTimesWindow);\n    // make sure we never poll faster than our minimum poll delay or slower than our maximum poll delay\n    const pollDelay = Math.max(MIN_POLL_DELAY, Math.min(MAX_POLL_DELAY, Math.max(MIN_POLL_DELAY, currentApproximateBlockTime)));\n    // sleep for the pollDelay for this chain (divided by the overPollRatio, which defaults to 2)\n    await sleep(pollDelay / (overPollRatio !== null && overPollRatio !== void 0 ? overPollRatio : DEFAULT_OVERPOLL_RATIO));\n    // poll again\n    poll();\n  }\n  // return the \"subscribe\" function\n  return function subscribe(callBack, initialBlockNumber) {\n    subscribers.push(callBack);\n    // if we are currently not active -> start polling\n    if (!isActive) {\n      lastBlockNumber = initialBlockNumber;\n      isActive = true;\n      poll();\n    }\n    // return the \"unsubscribe\" function (meaning the caller can unsubscribe)\n    return function unSubscribe() {\n      // filter out the callback from the subscribers\n      subscribers = subscribers.filter(fn => fn !== callBack);\n      // if the new subscribers Array is empty (aka we were the last subscriber) -> stop polling\n      if (subscribers.length === 0) {\n        lastBlockNumber = undefined;\n        lastBlockAt = undefined;\n        isActive = false;\n      }\n    };\n  };\n}\nconst existingPollers = new Map();\n/**\n * Watches the block number for a specific chain.\n * @param opts - The options for watching the block number.\n * @returns The unwatch function.\n * @example\n * ```ts\n * import { watchBlockNumber } from \"thirdweb\";\n * const unwatch = watchBlockNumber({\n *  client,\n *  chainId,\n *  onNewBlockNumber: (blockNumber) => {\n *    // do something with the block number\n *  },\n *  onError: (err) => {\n *    // do something if getting the block number fails\n *  },\n * });\n *\n * // later stop watching\n * unwatch();\n * ```\n * @rpc\n */\nexport function watchBlockNumber(opts) {\n  const {\n    client,\n    chain,\n    onNewBlockNumber,\n    overPollRatio,\n    latestBlockNumber,\n    onError\n  } = opts;\n  const chainId = chain.id;\n  // if we already have a poller for this chainId -> use it.\n  let poller = existingPollers.get(chainId);\n  // otherwise create a new poller\n  if (!poller) {\n    poller = createBlockNumberPoller(client, chain, overPollRatio, onError);\n    // and store it for later use\n    existingPollers.set(chainId, poller);\n  }\n  // subscribe to the poller and return the unSubscribe function to the caller\n  return poller(onNewBlockNumber, latestBlockNumber);\n}","map":{"version":3,"names":["sleep","eth_blockNumber","getRpcClient","MAX_POLL_DELAY","DEFAULT_POLL_DELAY","MIN_POLL_DELAY","DEFAULT_OVERPOLL_RATIO","SLIDING_WINDOW_SIZE","getAverageBlockTime","blockTimes","length","unshift","sum","reduce","acc","blockTime","createBlockNumberPoller","client","chain","overPollRatio","onError","subscribers","blockTimesWindow","isActive","lastBlockNumber","lastBlockAt","rpcRequest","poll","blockNumber","newBlockNumbers","i","push","BigInt","currentTime","Date","now","slice","b","subscriberCallback","err","console","error","concat","currentApproximateBlockTime","pollDelay","Math","max","min","subscribe","callBack","initialBlockNumber","unSubscribe","filter","fn","undefined","existingPollers","Map","watchBlockNumber","opts","onNewBlockNumber","latestBlockNumber","chainId","id","poller","get","set"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/rpc/watchBlockNumber.ts"],"sourcesContent":["import type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { sleep } from \"../utils/sleep.js\";\nimport { eth_blockNumber } from \"./actions/eth_blockNumber.js\";\nimport { getRpcClient } from \"./rpc.js\";\n\nconst MAX_POLL_DELAY = 5000; // 5 seconds\nconst DEFAULT_POLL_DELAY = 1000; // 1 second\nconst MIN_POLL_DELAY = 500; // 500 milliseconds\nconst DEFAULT_OVERPOLL_RATIO = 2; // poll twice as often as the average block time by default\n\nconst SLIDING_WINDOW_SIZE = 10; // always keep track of the last 10 block times\n\n/**\n * TODO: document\n * @internal\n */\nfunction getAverageBlockTime(blockTimes: number[]): number {\n  // left-pad the blocktimes Array with the DEFAULT_POLL_DELAY\n  while (blockTimes.length < SLIDING_WINDOW_SIZE) {\n    blockTimes.unshift(DEFAULT_POLL_DELAY);\n  }\n\n  const sum = blockTimes.reduce((acc, blockTime) => acc + blockTime, 0);\n  return sum / blockTimes.length;\n}\n\n/**\n * TODO: document\n * @internal\n */\nfunction createBlockNumberPoller(\n  client: ThirdwebClient,\n  chain: Chain,\n  overPollRatio?: number,\n  onError?: (error: Error) => void,\n) {\n  let subscribers: Array<(blockNumber: bigint) => void> = [];\n  let blockTimesWindow: number[] = [];\n\n  let isActive = false;\n  let lastBlockNumber: bigint | undefined;\n  let lastBlockAt: number | undefined;\n\n  const rpcRequest = getRpcClient({ chain, client });\n\n  /**\n   * TODO: document\n   * @internal\n   */\n  async function poll() {\n    // stop polling if there are no more subscriptions\n    if (!isActive) {\n      return;\n    }\n\n    try {\n      const blockNumber = await eth_blockNumber(rpcRequest);\n\n      if (!lastBlockNumber || blockNumber > lastBlockNumber) {\n        let newBlockNumbers = [];\n        if (lastBlockNumber) {\n          for (let i = lastBlockNumber + 1n; i <= blockNumber; i++) {\n            newBlockNumbers.push(BigInt(i));\n          }\n        } else {\n          newBlockNumbers = [blockNumber];\n        }\n        lastBlockNumber = blockNumber;\n        const currentTime = Date.now();\n        if (lastBlockAt) {\n          // if we skipped a block we need to adjust the block time down to that level\n          const blockTime =\n            (currentTime - lastBlockAt) / newBlockNumbers.length;\n\n          blockTimesWindow.push(blockTime);\n          blockTimesWindow = blockTimesWindow.slice(-SLIDING_WINDOW_SIZE);\n        }\n        lastBlockAt = currentTime;\n        // for all new blockNumbers...\n        for (const b of newBlockNumbers) {\n          // ... call all current subscribers\n          for (const subscriberCallback of subscribers) {\n            subscriberCallback(b);\n          }\n        }\n      }\n    } catch (err: unknown) {\n      if (onError) {\n        onError(err as Error);\n      } else {\n        console.error(\n          `[watchBlockNumber]: Failed to poll for latest block number: ${err}`,\n        );\n      }\n    }\n\n    const currentApproximateBlockTime = getAverageBlockTime(blockTimesWindow);\n\n    // make sure we never poll faster than our minimum poll delay or slower than our maximum poll delay\n    const pollDelay = Math.max(\n      MIN_POLL_DELAY,\n      Math.min(\n        MAX_POLL_DELAY,\n        Math.max(MIN_POLL_DELAY, currentApproximateBlockTime),\n      ),\n    );\n\n    // sleep for the pollDelay for this chain (divided by the overPollRatio, which defaults to 2)\n    await sleep(pollDelay / (overPollRatio ?? DEFAULT_OVERPOLL_RATIO));\n    // poll again\n    poll();\n  }\n\n  // return the \"subscribe\" function\n  return function subscribe(\n    callBack: (blockNumber: bigint) => void,\n    initialBlockNumber?: bigint,\n  ) {\n    subscribers.push(callBack);\n    // if we are currently not active -> start polling\n    if (!isActive) {\n      lastBlockNumber = initialBlockNumber;\n      isActive = true;\n      poll();\n    }\n\n    // return the \"unsubscribe\" function (meaning the caller can unsubscribe)\n    return function unSubscribe() {\n      // filter out the callback from the subscribers\n      subscribers = subscribers.filter((fn) => fn !== callBack);\n      // if the new subscribers Array is empty (aka we were the last subscriber) -> stop polling\n      if (subscribers.length === 0) {\n        lastBlockNumber = undefined;\n        lastBlockAt = undefined;\n        isActive = false;\n      }\n    };\n  };\n}\n\nconst existingPollers = new Map<\n  number,\n  ReturnType<typeof createBlockNumberPoller>\n>();\n\nexport type WatchBlockNumberOptions = {\n  client: ThirdwebClient;\n  chain: Chain;\n  onNewBlockNumber: (blockNumber: bigint) => void;\n  onError?: (error: Error) => void;\n  overPollRatio?: number;\n  latestBlockNumber?: bigint;\n};\n\n/**\n * Watches the block number for a specific chain.\n * @param opts - The options for watching the block number.\n * @returns The unwatch function.\n * @example\n * ```ts\n * import { watchBlockNumber } from \"thirdweb\";\n * const unwatch = watchBlockNumber({\n *  client,\n *  chainId,\n *  onNewBlockNumber: (blockNumber) => {\n *    // do something with the block number\n *  },\n *  onError: (err) => {\n *    // do something if getting the block number fails\n *  },\n * });\n *\n * // later stop watching\n * unwatch();\n * ```\n * @rpc\n */\nexport function watchBlockNumber(opts: WatchBlockNumberOptions) {\n  const {\n    client,\n    chain,\n    onNewBlockNumber,\n    overPollRatio,\n    latestBlockNumber,\n    onError,\n  } = opts;\n  const chainId = chain.id;\n  // if we already have a poller for this chainId -> use it.\n  let poller = existingPollers.get(chainId);\n  // otherwise create a new poller\n  if (!poller) {\n    poller = createBlockNumberPoller(client, chain, overPollRatio, onError);\n    // and store it for later use\n    existingPollers.set(chainId, poller);\n  }\n  // subscribe to the poller and return the unSubscribe function to the caller\n  return poller(onNewBlockNumber, latestBlockNumber);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}