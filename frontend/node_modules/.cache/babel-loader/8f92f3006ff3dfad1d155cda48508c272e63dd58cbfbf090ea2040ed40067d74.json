{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport * as ox__Authorization from \"ox/Authorization\";\nimport * as ox__Signature from \"ox/Signature\";\nimport { getTypesForEIP712Domain, serializeTypedData, stringify, validateTypedData, withTimeout } from \"viem\";\nimport { isInsufficientFundsError } from \"../../analytics/track/helpers.js\";\nimport { trackInsufficientFundsError, trackTransaction } from \"../../analytics/track/transaction.js\";\nimport { getCachedChain, getChainMetadata } from \"../../chains/utils.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { numberToHex, stringToHex, uint8ArrayToHex } from \"../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parse-typed-data.js\";\nimport { toGetCallsStatusResponse } from \"../eip5792/get-calls-status.js\";\nimport { toGetCapabilitiesResult } from \"../eip5792/get-capabilities.js\";\nimport { toProviderCallParams } from \"../eip5792/send-calls.js\";\nimport { getValidPublicRPCUrl } from \"../utils/chains.js\";\nimport { normalizeChainId } from \"../utils/normalizeChainId.js\";\nimport { injectedProvider } from \"./mipdStore.js\";\n// TODO: save the provider in data\nexport function getInjectedProvider(walletId) {\n  const provider = injectedProvider(walletId);\n  if (!provider) {\n    throw new Error(\"No injected provider found for wallet: \\\"\".concat(walletId, \"\\\"\"));\n  }\n  return provider;\n}\n/**\n * @internal\n */\nexport async function connectEip1193Wallet(_ref) {\n  var _addresses2;\n  let {\n    id,\n    provider,\n    emitter,\n    client,\n    chain\n  } = _ref;\n  let addresses;\n  const retries = 3;\n  let attempts = 0;\n  // retry 3 times, some providers take a while to return accounts on connect\n  while (!((_addresses = addresses) !== null && _addresses !== void 0 && _addresses[0]) && attempts < retries) {\n    var _addresses;\n    try {\n      addresses = await provider.request({\n        method: \"eth_requestAccounts\"\n      });\n    } catch (e) {\n      var _extractErrorMessage;\n      console.error(e);\n      if ((_extractErrorMessage = extractErrorMessage(e)) !== null && _extractErrorMessage !== void 0 && (_extractErrorMessage = _extractErrorMessage.toLowerCase()) !== null && _extractErrorMessage !== void 0 && _extractErrorMessage.includes(\"rejected\")) {\n        throw e;\n      }\n      await new Promise(resolve => setTimeout(resolve, 500));\n    }\n    attempts++;\n  }\n  const addr = (_addresses2 = addresses) === null || _addresses2 === void 0 ? void 0 : _addresses2[0];\n  if (!addr) {\n    throw new Error(\"Failed to connect to wallet, no accounts available\");\n  }\n  // use the first account\n  const address = getAddress(addr);\n  // get the chainId the provider is on\n  const chainId = await provider.request({\n    method: \"eth_chainId\"\n  }).then(normalizeChainId).catch(e => {\n    throw new Error(\"Error reading chainId from provider\", e);\n  });\n  let connectedChain = chain && chain.id === chainId ? chain : getCachedChain(chainId);\n  try {\n    // if we want a specific chainId and it is not the same as the provider chainId, trigger switchChain\n    // we check for undefined chain ID since some chain-specific wallets like Abstract will not send a chain ID on connection\n    if (chain && typeof chain.id !== \"undefined\" && chain.id !== chainId) {\n      await switchChain(provider, chain);\n      connectedChain = chain;\n    }\n  } catch (_unused) {\n    console.warn(\"Error switching to chain \".concat(chain === null || chain === void 0 ? void 0 : chain.id, \" - defaulting to wallet chain (\").concat(chainId, \")\"));\n  }\n  return onConnect({\n    address,\n    chain: connectedChain,\n    client,\n    emitter,\n    id,\n    provider\n  });\n}\n/**\n * @internal\n */\nexport async function autoConnectEip1193Wallet(_ref2) {\n  let {\n    id,\n    provider,\n    emitter,\n    client,\n    chain\n  } = _ref2;\n  // connected accounts\n  const addresses = await provider.request({\n    method: \"eth_accounts\"\n  });\n  const addr = addresses[0];\n  if (!addr) {\n    throw new Error(\"Failed to connect to wallet, no accounts available\");\n  }\n  // use the first account\n  const address = getAddress(addr);\n  // get the chainId the provider is on\n  const chainId = await provider.request({\n    method: \"eth_chainId\"\n  }).then(normalizeChainId);\n  const connectedChain = chain && chain.id === chainId ? chain : getCachedChain(chainId);\n  return onConnect({\n    address,\n    chain: connectedChain,\n    client,\n    emitter,\n    id,\n    provider\n  });\n}\nfunction createAccount(_ref3) {\n  let {\n    provider,\n    address,\n    client,\n    id\n  } = _ref3;\n  const account = {\n    address: getAddress(address),\n    async sendTransaction(tx) {\n      const gasFees = tx.gasPrice ? {\n        gasPrice: numberToHex(tx.gasPrice)\n      } : {\n        maxFeePerGas: tx.maxFeePerGas ? numberToHex(tx.maxFeePerGas) : undefined,\n        maxPriorityFeePerGas: tx.maxPriorityFeePerGas ? numberToHex(tx.maxPriorityFeePerGas) : undefined\n      };\n      const params = [_objectSpread(_objectSpread({}, gasFees), {}, {\n        from: this.address,\n        gas: tx.gas ? numberToHex(tx.gas) : undefined,\n        nonce: tx.nonce ? numberToHex(tx.nonce) : undefined,\n        to: tx.to ? getAddress(tx.to) : undefined,\n        data: tx.data,\n        value: tx.value ? numberToHex(tx.value) : undefined,\n        authorizationList: tx.authorizationList ? ox__Authorization.toRpcList(tx.authorizationList) : undefined,\n        accessList: tx.accessList\n      }, tx.eip712)];\n      try {\n        var _tx$to;\n        const transactionHash = await provider.request({\n          method: \"eth_sendTransaction\",\n          // @ts-expect-error - overriding types here\n          params\n        });\n        trackTransaction({\n          chainId: tx.chainId,\n          client,\n          contractAddress: (_tx$to = tx.to) !== null && _tx$to !== void 0 ? _tx$to : undefined,\n          gasPrice: tx.gasPrice,\n          transactionHash,\n          walletAddress: getAddress(address),\n          walletType: id\n        });\n        return {\n          transactionHash\n        };\n      } catch (error) {\n        // Track insufficient funds errors\n        if (isInsufficientFundsError(error)) {\n          trackInsufficientFundsError({\n            chainId: tx.chainId,\n            client,\n            contractAddress: tx.to || undefined,\n            error,\n            transactionValue: tx.value,\n            walletAddress: getAddress(address)\n          });\n        }\n        throw error;\n      }\n    },\n    async signMessage(_ref4) {\n      let {\n        message\n      } = _ref4;\n      if (!account.address) {\n        throw new Error(\"Provider not setup\");\n      }\n      const messageToSign = (() => {\n        if (typeof message === \"string\") {\n          return stringToHex(message);\n        }\n        if (message.raw instanceof Uint8Array) {\n          return uint8ArrayToHex(message.raw);\n        }\n        return message.raw;\n      })();\n      return await provider.request({\n        method: \"personal_sign\",\n        params: [messageToSign, getAddress(account.address)]\n      });\n    },\n    async signAuthorization(authorization) {\n      const payload = ox__Authorization.getSignPayload(authorization);\n      let signature;\n      try {\n        signature = await provider.request({\n          method: \"eth_sign\",\n          params: [getAddress(account.address), payload]\n        });\n      } catch (_unused2) {\n        // fallback to secp256k1_sign, some providers don't support eth_sign\n        signature = await provider.request({\n          // @ts-expect-error - overriding types here\n          method: \"secp256k1_sign\",\n          params: [payload]\n        });\n      }\n      if (!signature) {\n        throw new Error(\"Failed to sign authorization\");\n      }\n      const parsedSignature = ox__Signature.fromHex(signature);\n      return _objectSpread(_objectSpread({}, authorization), parsedSignature);\n    },\n    async signTypedData(typedData) {\n      if (!provider || !account.address) {\n        throw new Error(\"Provider not setup\");\n      }\n      const parsedTypedData = parseTypedData(typedData);\n      const {\n        domain,\n        message,\n        primaryType\n      } = parsedTypedData;\n      const types = _objectSpread({\n        EIP712Domain: getTypesForEIP712Domain({\n          domain\n        })\n      }, parsedTypedData.types);\n      // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n      // as we can't statically check this with TypeScript.\n      validateTypedData({\n        domain,\n        message,\n        primaryType,\n        types\n      });\n      const stringifiedData = serializeTypedData({\n        domain: domain !== null && domain !== void 0 ? domain : {},\n        message,\n        primaryType,\n        types\n      });\n      return await provider.request({\n        method: \"eth_signTypedData_v4\",\n        params: [getAddress(account.address), stringifiedData]\n      });\n    },\n    async watchAsset(asset) {\n      const result = await provider.request({\n        method: \"wallet_watchAsset\",\n        params: asset\n      }, {\n        retryCount: 0\n      });\n      return result;\n    },\n    async sendCalls(options) {\n      try {\n        const {\n          callParams,\n          chain\n        } = await toProviderCallParams(options, account);\n        const callId = await provider.request({\n          method: \"wallet_sendCalls\",\n          params: callParams\n        });\n        if (callId && typeof callId === \"object\" && \"id\" in callId) {\n          return {\n            chain,\n            client,\n            id: callId.id\n          };\n        }\n        return {\n          chain,\n          client,\n          id: callId\n        };\n      } catch (error) {\n        if (/unsupport|not support/i.test(error.message)) {\n          throw new Error(\"\".concat(id, \" errored calling wallet_sendCalls, with error: \").concat(error instanceof Error ? error.message : stringify(error)));\n        }\n        throw error;\n      }\n    },\n    async getCallsStatus(options) {\n      try {\n        const rawResponse = await provider.request({\n          method: \"wallet_getCallsStatus\",\n          params: [options.id]\n        });\n        return toGetCallsStatusResponse(rawResponse);\n      } catch (error) {\n        if (/unsupport|not support/i.test(error.message)) {\n          throw new Error(\"\".concat(id, \" does not support wallet_getCallsStatus, reach out to them directly to request EIP-5792 support.\"));\n        }\n        throw error;\n      }\n    },\n    async getCapabilities(options) {\n      const chainId = options.chainId;\n      try {\n        const result = await provider.request({\n          method: \"wallet_getCapabilities\",\n          params: [getAddress(account.address)]\n        });\n        return toGetCapabilitiesResult(result, chainId);\n      } catch (error) {\n        if (/unsupport|not support|not available/i.test(error.message)) {\n          return {\n            message: \"\".concat(id, \" does not support wallet_getCapabilities, reach out to them directly to request EIP-5792 support.\")\n          };\n        }\n        throw error;\n      }\n    }\n  };\n  return account;\n}\n/**\n * Call this method when the wallet provider is connected or auto connected\n * @internal\n */\nasync function onConnect(_ref5) {\n  let {\n    provider,\n    address,\n    chain,\n    emitter,\n    client,\n    id\n  } = _ref5;\n  const account = createAccount({\n    address,\n    client,\n    id,\n    provider\n  });\n  async function disconnect() {\n    provider.removeListener(\"accountsChanged\", onAccountsChanged);\n    provider.removeListener(\"chainChanged\", onChainChanged);\n    provider.removeListener(\"disconnect\", onDisconnect);\n    // Experimental support for MetaMask disconnect\n    // https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-2.md\n    try {\n      // Adding timeout as not all wallets support this method and can hang\n      await withTimeout(() => provider.request({\n        method: \"wallet_revokePermissions\",\n        params: [{\n          eth_accounts: {}\n        }]\n      }), {\n        timeout: 100\n      });\n    } catch (_unused3) {}\n  }\n  async function onDisconnect() {\n    disconnect();\n    emitter.emit(\"disconnect\", undefined);\n  }\n  function onAccountsChanged(accounts) {\n    if (accounts[0]) {\n      const newAccount = createAccount({\n        address: getAddress(accounts[0]),\n        client,\n        id,\n        provider\n      });\n      emitter.emit(\"accountChanged\", newAccount);\n      emitter.emit(\"accountsChanged\", accounts);\n    } else {\n      onDisconnect();\n    }\n  }\n  function onChainChanged(newChainId) {\n    const newChain = getCachedChain(normalizeChainId(newChainId));\n    emitter.emit(\"chainChanged\", newChain);\n  }\n  if (provider.on) {\n    provider.on(\"accountsChanged\", onAccountsChanged);\n    provider.on(\"chainChanged\", onChainChanged);\n    provider.on(\"disconnect\", onDisconnect);\n  }\n  return [account, chain, onDisconnect, newChain => switchChain(provider, newChain)];\n}\n/**\n * @internal\n */\nasync function switchChain(provider, chain) {\n  const hexChainId = numberToHex(chain.id);\n  try {\n    await provider.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{\n        chainId: hexChainId\n      }]\n    });\n  } catch (_unused4) {\n    var _apiChain$explorers;\n    // if chain does not exist, add the chain\n    const apiChain = await getChainMetadata(chain);\n    await provider.request({\n      method: \"wallet_addEthereumChain\",\n      params: [{\n        blockExplorerUrls: (_apiChain$explorers = apiChain.explorers) === null || _apiChain$explorers === void 0 ? void 0 : _apiChain$explorers.map(x => x.url),\n        chainId: hexChainId,\n        chainName: apiChain.name,\n        nativeCurrency: apiChain.nativeCurrency,\n        // no client id on purpose here\n        rpcUrls: getValidPublicRPCUrl(apiChain)\n      }]\n    });\n  }\n}\nfunction extractErrorMessage(e) {\n  if (e instanceof Error) {\n    return e.message;\n  }\n  if (typeof e === \"string\") {\n    return e;\n  }\n  if (typeof e === \"object\" && e !== null) {\n    return JSON.stringify(e);\n  }\n  return String(e);\n}","map":{"version":3,"names":["ox__Authorization","ox__Signature","getTypesForEIP712Domain","serializeTypedData","stringify","validateTypedData","withTimeout","isInsufficientFundsError","trackInsufficientFundsError","trackTransaction","getCachedChain","getChainMetadata","getAddress","numberToHex","stringToHex","uint8ArrayToHex","parseTypedData","toGetCallsStatusResponse","toGetCapabilitiesResult","toProviderCallParams","getValidPublicRPCUrl","normalizeChainId","injectedProvider","getInjectedProvider","walletId","provider","Error","concat","connectEip1193Wallet","_ref","_addresses2","id","emitter","client","chain","addresses","retries","attempts","_addresses","request","method","e","_extractErrorMessage","console","error","extractErrorMessage","toLowerCase","includes","Promise","resolve","setTimeout","addr","address","chainId","then","catch","connectedChain","switchChain","_unused","warn","onConnect","autoConnectEip1193Wallet","_ref2","createAccount","_ref3","account","sendTransaction","tx","gasFees","gasPrice","maxFeePerGas","undefined","maxPriorityFeePerGas","params","_objectSpread","from","gas","nonce","to","data","value","authorizationList","toRpcList","accessList","eip712","_tx$to","transactionHash","contractAddress","walletAddress","walletType","transactionValue","signMessage","_ref4","message","messageToSign","raw","Uint8Array","signAuthorization","authorization","payload","getSignPayload","signature","_unused2","parsedSignature","fromHex","signTypedData","typedData","parsedTypedData","domain","primaryType","types","EIP712Domain","stringifiedData","watchAsset","asset","result","retryCount","sendCalls","options","callParams","callId","test","getCallsStatus","rawResponse","getCapabilities","_ref5","disconnect","removeListener","onAccountsChanged","onChainChanged","onDisconnect","eth_accounts","timeout","_unused3","emit","accounts","newAccount","newChainId","newChain","on","hexChainId","_unused4","_apiChain$explorers","apiChain","blockExplorerUrls","explorers","map","x","url","chainName","name","nativeCurrency","rpcUrls","JSON","String"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/wallets/injected/index.ts"],"sourcesContent":["import * as ox__Authorization from \"ox/Authorization\";\nimport * as ox__Signature from \"ox/Signature\";\nimport {\n  type EIP1193Provider,\n  getTypesForEIP712Domain,\n  type SignTypedDataParameters,\n  serializeTypedData,\n  stringify,\n  validateTypedData,\n  withTimeout,\n} from \"viem\";\nimport { isInsufficientFundsError } from \"../../analytics/track/helpers.js\";\nimport {\n  trackInsufficientFundsError,\n  trackTransaction,\n} from \"../../analytics/track/transaction.js\";\nimport type { Chain } from \"../../chains/types.js\";\nimport { getCachedChain, getChainMetadata } from \"../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport type { AuthorizationRequest } from \"../../transaction/actions/eip7702/authorization.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport {\n  type Hex,\n  numberToHex,\n  stringToHex,\n  uint8ArrayToHex,\n} from \"../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parse-typed-data.js\";\nimport type { InjectedSupportedWalletIds } from \"../__generated__/wallet-ids.js\";\nimport { toGetCallsStatusResponse } from \"../eip5792/get-calls-status.js\";\nimport { toGetCapabilitiesResult } from \"../eip5792/get-capabilities.js\";\nimport { toProviderCallParams } from \"../eip5792/send-calls.js\";\nimport type { GetCallsStatusRawResponse } from \"../eip5792/types.js\";\nimport type { Account, SendTransactionOption } from \"../interfaces/wallet.js\";\nimport type { DisconnectFn, SwitchChainFn } from \"../types.js\";\nimport { getValidPublicRPCUrl } from \"../utils/chains.js\";\nimport { normalizeChainId } from \"../utils/normalizeChainId.js\";\nimport type { WalletEmitter } from \"../wallet-emitter.js\";\nimport type { WalletId } from \"../wallet-types.js\";\nimport { injectedProvider } from \"./mipdStore.js\";\n\n// TODO: save the provider in data\nexport function getInjectedProvider(walletId: WalletId) {\n  const provider = injectedProvider(walletId);\n  if (!provider) {\n    throw new Error(`No injected provider found for wallet: \"${walletId}\"`);\n  }\n\n  return provider;\n}\n\n/**\n * @internal\n */\nexport async function connectEip1193Wallet({\n  id,\n  provider,\n  emitter,\n  client,\n  chain,\n}: {\n  id: InjectedSupportedWalletIds | ({} & string);\n  provider: EIP1193Provider;\n  client: ThirdwebClient;\n  chain?: Chain;\n  emitter: WalletEmitter<InjectedSupportedWalletIds>;\n}): Promise<ReturnType<typeof onConnect>> {\n  let addresses: string[] | undefined;\n  const retries = 3;\n  let attempts = 0;\n  // retry 3 times, some providers take a while to return accounts on connect\n  while (!addresses?.[0] && attempts < retries) {\n    try {\n      addresses = await provider.request({\n        method: \"eth_requestAccounts\",\n      });\n    } catch (e) {\n      console.error(e);\n      if (extractErrorMessage(e)?.toLowerCase()?.includes(\"rejected\")) {\n        throw e;\n      }\n      await new Promise((resolve) => setTimeout(resolve, 500));\n    }\n    attempts++;\n  }\n\n  const addr = addresses?.[0];\n  if (!addr) {\n    throw new Error(\"Failed to connect to wallet, no accounts available\");\n  }\n\n  // use the first account\n  const address = getAddress(addr);\n\n  // get the chainId the provider is on\n  const chainId = await provider\n    .request({ method: \"eth_chainId\" })\n    .then(normalizeChainId)\n    .catch((e) => {\n      throw new Error(\"Error reading chainId from provider\", e);\n    });\n\n  let connectedChain =\n    chain && chain.id === chainId ? chain : getCachedChain(chainId);\n\n  try {\n    // if we want a specific chainId and it is not the same as the provider chainId, trigger switchChain\n    // we check for undefined chain ID since some chain-specific wallets like Abstract will not send a chain ID on connection\n    if (chain && typeof chain.id !== \"undefined\" && chain.id !== chainId) {\n      await switchChain(provider, chain);\n      connectedChain = chain;\n    }\n  } catch {\n    console.warn(\n      `Error switching to chain ${chain?.id} - defaulting to wallet chain (${chainId})`,\n    );\n  }\n\n  return onConnect({\n    address,\n    chain: connectedChain,\n    client,\n    emitter,\n    id,\n    provider,\n  });\n}\n\n/**\n * @internal\n */\nexport async function autoConnectEip1193Wallet({\n  id,\n  provider,\n  emitter,\n  client,\n  chain,\n}: {\n  id: InjectedSupportedWalletIds | ({} & string);\n  provider: EIP1193Provider;\n  emitter: WalletEmitter<InjectedSupportedWalletIds>;\n  client: ThirdwebClient;\n  chain?: Chain;\n}): Promise<ReturnType<typeof onConnect>> {\n  // connected accounts\n  const addresses = await provider.request({\n    method: \"eth_accounts\",\n  });\n\n  const addr = addresses[0];\n  if (!addr) {\n    throw new Error(\"Failed to connect to wallet, no accounts available\");\n  }\n\n  // use the first account\n  const address = getAddress(addr);\n\n  // get the chainId the provider is on\n  const chainId = await provider\n    .request({ method: \"eth_chainId\" })\n    .then(normalizeChainId);\n\n  const connectedChain =\n    chain && chain.id === chainId ? chain : getCachedChain(chainId);\n\n  return onConnect({\n    address,\n    chain: connectedChain,\n    client,\n    emitter,\n    id,\n    provider,\n  });\n}\n\nfunction createAccount({\n  provider,\n  address,\n  client,\n  id,\n}: {\n  provider: EIP1193Provider;\n  address: string;\n  client: ThirdwebClient;\n  id: WalletId | ({} & string);\n}) {\n  const account: Account = {\n    address: getAddress(address),\n    async sendTransaction(tx: SendTransactionOption) {\n      const gasFees = tx.gasPrice\n        ? {\n            gasPrice: numberToHex(tx.gasPrice),\n          }\n        : {\n            maxFeePerGas: tx.maxFeePerGas\n              ? numberToHex(tx.maxFeePerGas)\n              : undefined,\n            maxPriorityFeePerGas: tx.maxPriorityFeePerGas\n              ? numberToHex(tx.maxPriorityFeePerGas)\n              : undefined,\n          };\n      const params = [\n        {\n          ...gasFees,\n          from: this.address,\n          gas: tx.gas ? numberToHex(tx.gas) : undefined,\n          nonce: tx.nonce ? numberToHex(tx.nonce) : undefined,\n          to: tx.to ? getAddress(tx.to) : undefined,\n          data: tx.data,\n          value: tx.value ? numberToHex(tx.value) : undefined,\n          authorizationList: tx.authorizationList\n            ? ox__Authorization.toRpcList(tx.authorizationList)\n            : undefined,\n          accessList: tx.accessList,\n          ...tx.eip712,\n        },\n      ];\n\n      try {\n        const transactionHash = (await provider.request({\n          method: \"eth_sendTransaction\",\n          // @ts-expect-error - overriding types here\n          params,\n        })) as Hex;\n\n        trackTransaction({\n          chainId: tx.chainId,\n          client,\n          contractAddress: tx.to ?? undefined,\n          gasPrice: tx.gasPrice,\n          transactionHash,\n          walletAddress: getAddress(address),\n          walletType: id,\n        });\n\n        return {\n          transactionHash,\n        };\n      } catch (error) {\n        // Track insufficient funds errors\n        if (isInsufficientFundsError(error)) {\n          trackInsufficientFundsError({\n            chainId: tx.chainId,\n            client,\n            contractAddress: tx.to || undefined,\n            error,\n            transactionValue: tx.value,\n            walletAddress: getAddress(address),\n          });\n        }\n\n        throw error;\n      }\n    },\n    async signMessage({ message }) {\n      if (!account.address) {\n        throw new Error(\"Provider not setup\");\n      }\n\n      const messageToSign = (() => {\n        if (typeof message === \"string\") {\n          return stringToHex(message);\n        }\n        if (message.raw instanceof Uint8Array) {\n          return uint8ArrayToHex(message.raw);\n        }\n        return message.raw;\n      })();\n\n      return await provider.request({\n        method: \"personal_sign\",\n        params: [messageToSign, getAddress(account.address)],\n      });\n    },\n    async signAuthorization(authorization: AuthorizationRequest) {\n      const payload = ox__Authorization.getSignPayload(authorization);\n      let signature: Hex | undefined;\n      try {\n        signature = await provider.request({\n          method: \"eth_sign\",\n          params: [getAddress(account.address), payload],\n        });\n      } catch {\n        // fallback to secp256k1_sign, some providers don't support eth_sign\n        signature = await provider.request({\n          // @ts-expect-error - overriding types here\n          method: \"secp256k1_sign\",\n          params: [payload],\n        });\n      }\n      if (!signature) {\n        throw new Error(\"Failed to sign authorization\");\n      }\n      const parsedSignature = ox__Signature.fromHex(signature as Hex);\n      return { ...authorization, ...parsedSignature };\n    },\n    async signTypedData(typedData) {\n      if (!provider || !account.address) {\n        throw new Error(\"Provider not setup\");\n      }\n      const parsedTypedData = parseTypedData(typedData);\n\n      const { domain, message, primaryType } =\n        parsedTypedData as unknown as SignTypedDataParameters;\n\n      const types = {\n        EIP712Domain: getTypesForEIP712Domain({ domain }),\n        ...parsedTypedData.types,\n      };\n\n      // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n      // as we can't statically check this with TypeScript.\n      validateTypedData({ domain, message, primaryType, types });\n\n      const stringifiedData = serializeTypedData({\n        domain: domain ?? {},\n        message,\n        primaryType,\n        types,\n      });\n\n      return await provider.request({\n        method: \"eth_signTypedData_v4\",\n        params: [getAddress(account.address), stringifiedData],\n      });\n    },\n    async watchAsset(asset) {\n      const result = await provider.request(\n        {\n          method: \"wallet_watchAsset\",\n          params: asset,\n        },\n        { retryCount: 0 },\n      );\n      return result;\n    },\n    async sendCalls(options) {\n      try {\n        const { callParams, chain } = await toProviderCallParams(\n          options,\n          account,\n        );\n        const callId = await provider.request({\n          method: \"wallet_sendCalls\",\n          params: callParams,\n        });\n        if (callId && typeof callId === \"object\" && \"id\" in callId) {\n          return { chain, client, id: callId.id };\n        }\n        return { chain, client, id: callId };\n      } catch (error) {\n        if (/unsupport|not support/i.test((error as Error).message)) {\n          throw new Error(\n            `${id} errored calling wallet_sendCalls, with error: ${error instanceof Error ? error.message : stringify(error)}`,\n          );\n        }\n        throw error;\n      }\n    },\n    async getCallsStatus(options) {\n      try {\n        const rawResponse = (await provider.request({\n          method: \"wallet_getCallsStatus\",\n          params: [options.id],\n        })) as GetCallsStatusRawResponse;\n        return toGetCallsStatusResponse(rawResponse);\n      } catch (error) {\n        if (/unsupport|not support/i.test((error as Error).message)) {\n          throw new Error(\n            `${id} does not support wallet_getCallsStatus, reach out to them directly to request EIP-5792 support.`,\n          );\n        }\n        throw error;\n      }\n    },\n    async getCapabilities(options) {\n      const chainId = options.chainId;\n      try {\n        const result = await provider.request({\n          method: \"wallet_getCapabilities\",\n          params: [getAddress(account.address)],\n        });\n        return toGetCapabilitiesResult(result, chainId);\n      } catch (error: unknown) {\n        if (\n          /unsupport|not support|not available/i.test((error as Error).message)\n        ) {\n          return {\n            message: `${id} does not support wallet_getCapabilities, reach out to them directly to request EIP-5792 support.`,\n          };\n        }\n        throw error;\n      }\n    },\n  };\n\n  return account;\n}\n\n/**\n * Call this method when the wallet provider is connected or auto connected\n * @internal\n */\nasync function onConnect({\n  provider,\n  address,\n  chain,\n  emitter,\n  client,\n  id,\n}: {\n  provider: EIP1193Provider;\n  address: string;\n  chain: Chain;\n  emitter: WalletEmitter<InjectedSupportedWalletIds>;\n  client: ThirdwebClient;\n  id: WalletId | ({} & string);\n}): Promise<[Account, Chain, DisconnectFn, SwitchChainFn]> {\n  const account = createAccount({ address, client, id, provider });\n  async function disconnect() {\n    provider.removeListener(\"accountsChanged\", onAccountsChanged);\n    provider.removeListener(\"chainChanged\", onChainChanged);\n    provider.removeListener(\"disconnect\", onDisconnect);\n\n    // Experimental support for MetaMask disconnect\n    // https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-2.md\n    try {\n      // Adding timeout as not all wallets support this method and can hang\n      await withTimeout(\n        () =>\n          provider.request({\n            method: \"wallet_revokePermissions\",\n            params: [{ eth_accounts: {} }],\n          }),\n        { timeout: 100 },\n      );\n    } catch {}\n  }\n\n  async function onDisconnect() {\n    disconnect();\n    emitter.emit(\"disconnect\", undefined);\n  }\n\n  function onAccountsChanged(accounts: string[]) {\n    if (accounts[0]) {\n      const newAccount = createAccount({\n        address: getAddress(accounts[0]),\n        client,\n        id,\n        provider,\n      });\n\n      emitter.emit(\"accountChanged\", newAccount);\n      emitter.emit(\"accountsChanged\", accounts);\n    } else {\n      onDisconnect();\n    }\n  }\n\n  function onChainChanged(newChainId: string) {\n    const newChain = getCachedChain(normalizeChainId(newChainId));\n    emitter.emit(\"chainChanged\", newChain);\n  }\n\n  if (provider.on) {\n    provider.on(\"accountsChanged\", onAccountsChanged);\n    provider.on(\"chainChanged\", onChainChanged);\n    provider.on(\"disconnect\", onDisconnect);\n  }\n\n  return [\n    account,\n    chain,\n    onDisconnect,\n    (newChain) => switchChain(provider, newChain),\n  ] as const;\n}\n\n/**\n * @internal\n */\nasync function switchChain(provider: EIP1193Provider, chain: Chain) {\n  const hexChainId = numberToHex(chain.id);\n  try {\n    await provider.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{ chainId: hexChainId }],\n    });\n  } catch {\n    // if chain does not exist, add the chain\n    const apiChain = await getChainMetadata(chain);\n    await provider.request({\n      method: \"wallet_addEthereumChain\",\n      params: [\n        {\n          blockExplorerUrls: apiChain.explorers?.map((x) => x.url),\n          chainId: hexChainId,\n          chainName: apiChain.name,\n          nativeCurrency: apiChain.nativeCurrency, // no client id on purpose here\n          rpcUrls: getValidPublicRPCUrl(apiChain),\n        },\n      ],\n    });\n  }\n}\n\nfunction extractErrorMessage(e: unknown) {\n  if (e instanceof Error) {\n    return e.message;\n  }\n  if (typeof e === \"string\") {\n    return e;\n  }\n  if (typeof e === \"object\" && e !== null) {\n    return JSON.stringify(e);\n  }\n  return String(e);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}