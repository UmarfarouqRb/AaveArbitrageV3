{"ast":null,"code":"import { getTransactionReceipt } from '../../../actions/index.js';\nimport { isAddressEqual } from '../../../utils/index.js';\nimport { l1MessengerAddress } from '../../constants/address.js';\n/** @internal */\nexport async function getWithdrawalL2ToL1Log(client, parameters) {\n  const {\n    hash,\n    index = 0\n  } = parameters;\n  const receipt = await getTransactionReceipt(client, {\n    hash\n  });\n  const messages = Array.from(receipt.l2ToL1Logs.entries()).filter(_ref => {\n    let [, log] = _ref;\n    return isAddressEqual(log.sender, l1MessengerAddress);\n  });\n  const [l2ToL1LogIndex, l2ToL1Log] = messages[index];\n  return {\n    l2ToL1LogIndex,\n    l2ToL1Log\n  };\n}","map":{"version":3,"names":["getTransactionReceipt","isAddressEqual","l1MessengerAddress","getWithdrawalL2ToL1Log","client","parameters","hash","index","receipt","messages","Array","from","l2ToL1Logs","entries","filter","_ref","log","sender","l2ToL1LogIndex","l2ToL1Log"],"sources":["/home/user/Arbitrage/frontend/node_modules/viem/zksync/utils/bridge/getWithdrawalL2ToL1Log.ts"],"sourcesContent":["import type { Address } from 'abitype'\nimport type { Account } from '../../../accounts/index.js'\nimport { getTransactionReceipt } from '../../../actions/index.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { Hash } from '../../../types/misc.js'\nimport { isAddressEqual } from '../../../utils/index.js'\nimport { l1MessengerAddress } from '../../constants/address.js'\nimport type { ZksyncL2ToL1Log } from '../../types/log.js'\nimport type { ZksyncTransactionReceipt } from '../../types/transaction.js'\n\nexport type GetWithdrawalL2ToL1LogParameters = {\n  /** Hash of the L2 transaction where the withdrawal was initiated. */\n  hash: Hash\n  /** In case there were multiple withdrawals in one transaction, you may pass an index of the\n   withdrawal you want to finalize. */\n  index?: number | undefined\n}\n\nexport type GetWithdrawalL2ToL1LogReturnType = {\n  l2ToL1LogIndex: number | null\n  l2ToL1Log: ZksyncL2ToL1Log\n}\n\n/** @internal */\nexport async function getWithdrawalL2ToL1Log<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: GetWithdrawalL2ToL1LogParameters,\n): Promise<GetWithdrawalL2ToL1LogReturnType> {\n  const { hash, index = 0 } = parameters\n  const receipt = (await getTransactionReceipt(client, {\n    hash,\n  })) as ZksyncTransactionReceipt\n  const messages = Array.from(receipt.l2ToL1Logs.entries()).filter(([, log]) =>\n    isAddressEqual(log.sender as Address, l1MessengerAddress),\n  )\n  const [l2ToL1LogIndex, l2ToL1Log] = messages[index]\n\n  return {\n    l2ToL1LogIndex,\n    l2ToL1Log,\n  }\n}\n"],"mappings":"AAEA,SAASA,qBAAqB,QAAQ,2BAA2B;AAKjE,SAASC,cAAc,QAAQ,yBAAyB;AACxD,SAASC,kBAAkB,QAAQ,4BAA4B;AAiB/D;AACA,OAAO,eAAeC,sBAAsBA,CAI1CC,MAAyC,EACzCC,UAA4C;EAE5C,MAAM;IAAEC,IAAI;IAAEC,KAAK,GAAG;EAAC,CAAE,GAAGF,UAAU;EACtC,MAAMG,OAAO,GAAI,MAAMR,qBAAqB,CAACI,MAAM,EAAE;IACnDE;GACD,CAA8B;EAC/B,MAAMG,QAAQ,GAAGC,KAAK,CAACC,IAAI,CAACH,OAAO,CAACI,UAAU,CAACC,OAAO,EAAE,CAAC,CAACC,MAAM,CAACC,IAAA;IAAA,IAAC,GAAGC,GAAG,CAAC,GAAAD,IAAA;IAAA,OACvEd,cAAc,CAACe,GAAG,CAACC,MAAiB,EAAEf,kBAAkB,CAAC;EAAA,EAC1D;EACD,MAAM,CAACgB,cAAc,EAAEC,SAAS,CAAC,GAAGV,QAAQ,CAACF,KAAK,CAAC;EAEnD,OAAO;IACLW,cAAc;IACdC;GACD;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}