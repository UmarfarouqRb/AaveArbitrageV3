{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport { ApiError } from \"../../../bridge/types/Errors.js\";\nimport { getCachedChain } from \"../../../chains/utils.js\";\nimport { waitForReceipt } from \"../../../transaction/actions/wait-for-tx-receipt.js\";\n/**\n * Flatten RouteStep[] into a linear list of transactions preserving ordering & indices.\n */\nfunction flattenRouteSteps(steps) {\n  const out = [];\n  steps.forEach((step, stepIdx) => {\n    var _step$transactions;\n    (_step$transactions = step.transactions) === null || _step$transactions === void 0 || _step$transactions.forEach((tx, _txIdx) => {\n      out.push(_objectSpread(_objectSpread({}, tx), {}, {\n        _index: out.length,\n        _stepIndex: stepIdx\n      }));\n    });\n  });\n  return out;\n}\n/**\n * Hook that sequentially executes prepared steps.\n * NOTE: initial implementation only exposes progress + basic state machine. Actual execution logic will follow in later subtasks.\n */\nexport function useStepExecutor(options) {\n  const {\n    wallet,\n    windowAdapter,\n    client,\n    autoStart = false,\n    onComplete,\n    preparedQuote\n  } = options;\n  // Flatten all transactions upfront\n  const flatTxs = useMemo(() => preparedQuote !== null && preparedQuote !== void 0 && preparedQuote.steps ? flattenRouteSteps(preparedQuote.steps) : [], [preparedQuote === null || preparedQuote === void 0 ? void 0 : preparedQuote.steps]);\n  // State management\n  const [currentTxIndex, setCurrentTxIndex] = useState(undefined);\n  const [executionState, setExecutionState] = useState(\"idle\");\n  const [error, setError] = useState(undefined);\n  const [completedTxs, setCompletedTxs] = useState(new Set());\n  const [onrampStatus, setOnrampStatus] = useState((preparedQuote === null || preparedQuote === void 0 ? void 0 : preparedQuote.type) === \"onramp\" ? \"pending\" : undefined);\n  // Cancellation tracking\n  const abortControllerRef = useRef(null);\n  // Get current step based on current tx index\n  const currentStep = useMemo(() => {\n    if (typeof (preparedQuote === null || preparedQuote === void 0 ? void 0 : preparedQuote.steps) === \"undefined\") return undefined;\n    if (currentTxIndex === undefined) {\n      return undefined;\n    }\n    const tx = flatTxs[currentTxIndex];\n    return tx ? preparedQuote.steps[tx._stepIndex] : undefined;\n  }, [currentTxIndex, flatTxs, preparedQuote === null || preparedQuote === void 0 ? void 0 : preparedQuote.steps]);\n  // Calculate progress including onramp step\n  const progress = useMemo(() => {\n    if (typeof (preparedQuote === null || preparedQuote === void 0 ? void 0 : preparedQuote.type) === \"undefined\") return 0;\n    const totalSteps = flatTxs.length + (preparedQuote.type === \"onramp\" ? 1 : 0);\n    if (totalSteps === 0) {\n      return 0;\n    }\n    const completedSteps = completedTxs.size + (onrampStatus === \"completed\" ? 1 : 0);\n    return Math.round(completedSteps / totalSteps * 100);\n  }, [completedTxs.size, flatTxs.length, preparedQuote === null || preparedQuote === void 0 ? void 0 : preparedQuote.type, onrampStatus]);\n  // Exponential backoff polling utility\n  const poller = useCallback(async (pollFn, abortSignal) => {\n    const delay = 2000; // 2 second poll interval\n    while (!abortSignal.aborted) {\n      const result = await pollFn();\n      if (result.completed) {\n        return;\n      }\n      await new Promise(resolve => {\n        const timeout = setTimeout(resolve, delay);\n        abortSignal.addEventListener(\"abort\", () => clearTimeout(timeout), {\n          once: true\n        });\n      });\n    }\n    throw new Error(\"Polling aborted\");\n  }, []);\n  // Execute a single transaction\n  const executeSingleTx = useCallback(async (tx, account, completedStatusResults, abortSignal) => {\n    if (typeof (preparedQuote === null || preparedQuote === void 0 ? void 0 : preparedQuote.type) === \"undefined\") {\n      throw new Error(\"No quote generated. This is unexpected.\");\n    }\n    const {\n      prepareTransaction\n    } = await import(\"../../../transaction/prepare-transaction.js\");\n    const {\n      sendTransaction\n    } = await import(\"../../../transaction/actions/send-transaction.js\");\n    // Prepare the transaction\n    const preparedTx = prepareTransaction({\n      chain: tx.chain,\n      client: tx.client,\n      data: tx.data,\n      to: tx.to,\n      value: tx.value\n    });\n    // Send the transaction\n    const result = await sendTransaction({\n      account,\n      transaction: preparedTx\n    });\n    const hash = result.transactionHash;\n    if (tx.action === \"approval\" || tx.action === \"fee\") {\n      // don't poll status for approval transactions, just wait for confirmation\n      await waitForReceipt(result);\n      await new Promise(resolve => setTimeout(resolve, 2000)); // Add an extra 2 second delay for RPC to catch up to new state\n      return;\n    }\n    // Poll for completion\n    const {\n      status\n    } = await import(\"../../../bridge/Status.js\");\n    await poller(async () => {\n      const statusResult = await status({\n        chainId: tx.chainId,\n        client: tx.client,\n        transactionHash: hash\n      });\n      if (statusResult.status === \"COMPLETED\") {\n        // Add type field from preparedQuote for discriminated union\n        const typedStatusResult = _objectSpread({\n          type: preparedQuote.type\n        }, statusResult);\n        completedStatusResults.push(typedStatusResult);\n        return {\n          completed: true\n        };\n      }\n      if (statusResult.status === \"FAILED\") {\n        throw new Error(\"Payment failed\");\n      }\n      return {\n        completed: false\n      };\n    }, abortSignal);\n  }, [poller, preparedQuote === null || preparedQuote === void 0 ? void 0 : preparedQuote.type]);\n  // Execute batch transactions\n  const executeBatch = useCallback(async (txs, account, completedStatusResults, abortSignal) => {\n    if (typeof (preparedQuote === null || preparedQuote === void 0 ? void 0 : preparedQuote.type) === \"undefined\") {\n      throw new Error(\"No quote generated. This is unexpected.\");\n    }\n    if (!account.sendBatchTransaction) {\n      throw new Error(\"Account does not support batch transactions\");\n    }\n    const {\n      prepareTransaction\n    } = await import(\"../../../transaction/prepare-transaction.js\");\n    const {\n      sendBatchTransaction\n    } = await import(\"../../../transaction/actions/send-batch-transaction.js\");\n    // Prepare and convert all transactions\n    const serializableTxs = await Promise.all(txs.map(async tx => {\n      const preparedTx = prepareTransaction({\n        chain: tx.chain,\n        client: tx.client,\n        data: tx.data,\n        to: tx.to,\n        value: tx.value\n      });\n      return preparedTx;\n    }));\n    // Send batch\n    const result = await sendBatchTransaction({\n      account,\n      transactions: serializableTxs\n    });\n    // Batch transactions return a single receipt, we need to handle this differently\n    // For now, we'll assume all transactions in the batch succeed together\n    // Poll for the first transaction's completion (representative of the batch)\n    if (txs.length === 0) {\n      throw new Error(\"No transactions to batch\");\n    }\n    const firstTx = txs[0];\n    if (!firstTx) {\n      throw new Error(\"Invalid batch transaction\");\n    }\n    const {\n      status\n    } = await import(\"../../../bridge/Status.js\");\n    await poller(async () => {\n      const statusResult = await status({\n        chainId: firstTx.chainId,\n        client: firstTx.client,\n        transactionHash: result.transactionHash\n      });\n      if (statusResult.status === \"COMPLETED\") {\n        // Add type field from preparedQuote for discriminated union\n        const typedStatusResult = _objectSpread({\n          type: preparedQuote.type\n        }, statusResult);\n        completedStatusResults.push(typedStatusResult);\n        return {\n          completed: true\n        };\n      }\n      if (statusResult.status === \"FAILED\") {\n        throw new Error(\"Payment failed\");\n      }\n      return {\n        completed: false\n      };\n    }, abortSignal);\n  }, [poller, preparedQuote === null || preparedQuote === void 0 ? void 0 : preparedQuote.type]);\n  // Execute onramp step\n  const executeOnramp = useCallback(async (onrampQuote, completedStatusResults, abortSignal) => {\n    setOnrampStatus(\"executing\");\n    // Open the payment URL\n    windowAdapter.open(onrampQuote.link);\n    // Poll for completion using the session ID\n    const {\n      Onramp\n    } = await import(\"../../../bridge/index.js\");\n    await poller(async () => {\n      const statusResult = await Onramp.status({\n        client: client,\n        id: onrampQuote.id\n      });\n      const status = statusResult.status;\n      if (status === \"COMPLETED\") {\n        /*\n         * The occasional race condition can happen where the onramp provider gives us completed status before the token balance has updated in our RPC.\n         * We add this pause so the simulation doesn't fail on the next step.\n         */\n        await new Promise(resolve => setTimeout(resolve, 2000));\n        setOnrampStatus(\"completed\");\n        // Add type field for discriminated union\n        const typedStatusResult = _objectSpread({\n          type: \"onramp\"\n        }, statusResult);\n        completedStatusResults.push(typedStatusResult);\n        return {\n          completed: true\n        };\n      } else if (status === \"FAILED\") {\n        setOnrampStatus(\"failed\");\n      }\n      return {\n        completed: false\n      };\n    }, abortSignal);\n  }, [poller, client, windowAdapter]);\n  // Main execution function\n  const execute = useCallback(async () => {\n    if (typeof (preparedQuote === null || preparedQuote === void 0 ? void 0 : preparedQuote.type) === \"undefined\") {\n      throw new Error(\"No quote generated. This is unexpected.\");\n    }\n    if (executionState !== \"idle\") {\n      return;\n    }\n    setExecutionState(\"executing\");\n    setError(undefined);\n    const completedStatusResults = [];\n    // Create new abort controller\n    const abortController = new AbortController();\n    abortControllerRef.current = abortController;\n    try {\n      if (flatTxs.length > 0 && !wallet) {\n        throw new ApiError({\n          code: \"INVALID_INPUT\",\n          message: \"No wallet provided to execute transactions\",\n          statusCode: 400\n        });\n      }\n      // Execute onramp first if configured and not already completed\n      if (preparedQuote.type === \"onramp\" && onrampStatus === \"pending\") {\n        await executeOnramp(preparedQuote, completedStatusResults, abortController.signal);\n      }\n      if (flatTxs.length > 0) {\n        // Then execute transactions\n        if (!wallet) {\n          throw new ApiError({\n            code: \"INVALID_INPUT\",\n            message: \"No wallet provided to execute transactions\",\n            statusCode: 400\n          });\n        }\n        const account = wallet.getAccount();\n        if (!account) {\n          throw new ApiError({\n            code: \"INVALID_INPUT\",\n            message: \"Wallet not connected\",\n            statusCode: 400\n          });\n        }\n        // Start from where we left off, or from the beginning\n        const startIndex = currentTxIndex !== null && currentTxIndex !== void 0 ? currentTxIndex : 0;\n        for (let i = startIndex; i < flatTxs.length; i++) {\n          var _wallet$getChain;\n          if (abortController.signal.aborted) {\n            break;\n          }\n          const currentTx = flatTxs[i];\n          if (!currentTx) {\n            continue; // Skip invalid index\n          }\n          setCurrentTxIndex(i);\n          const currentStepData = preparedQuote.steps[currentTx._stepIndex];\n          if (!currentStepData) {\n            throw new Error(\"Invalid step index: \".concat(currentTx._stepIndex));\n          }\n          // switch chain if needed\n          if (currentTx.chainId !== ((_wallet$getChain = wallet.getChain()) === null || _wallet$getChain === void 0 ? void 0 : _wallet$getChain.id)) {\n            await wallet.switchChain(getCachedChain(currentTx.chainId));\n          }\n          // Check if we can batch transactions\n          const canBatch = account.sendBatchTransaction !== undefined && i < flatTxs.length - 1; // Not the last transaction\n          if (canBatch) {\n            // Find consecutive transactions on the same chain\n            const batchTxs = [currentTx];\n            let j = i + 1;\n            while (j < flatTxs.length) {\n              const nextTx = flatTxs[j];\n              if (!nextTx || nextTx.chainId !== currentTx.chainId) {\n                break;\n              }\n              batchTxs.push(nextTx);\n              j++;\n            }\n            // Execute batch if we have multiple transactions\n            if (batchTxs.length > 1) {\n              await executeBatch(batchTxs, account, completedStatusResults, abortController.signal);\n              // Mark all batched transactions as completed\n              for (const tx of batchTxs) {\n                setCompletedTxs(prev => new Set(prev).add(tx._index));\n              }\n              // Skip ahead\n              i = j - 1;\n              continue;\n            }\n          }\n          // Execute single transaction\n          await executeSingleTx(currentTx, account, completedStatusResults, abortController.signal);\n          // Mark transaction as completed\n          setCompletedTxs(prev => new Set(prev).add(currentTx._index));\n        }\n      }\n      // All done - check if we actually completed everything\n      if (!abortController.signal.aborted) {\n        setCurrentTxIndex(undefined);\n        // Call completion callback with all completed status results\n        if (onComplete) {\n          onComplete(completedStatusResults);\n        }\n      }\n    } catch (err) {\n      console.error(\"Error executing payment\", err);\n      if (err instanceof ApiError) {\n        setError(err);\n      } else {\n        setError(new ApiError({\n          code: \"UNKNOWN_ERROR\",\n          message: (err === null || err === void 0 ? void 0 : err.message) || \"An unknown error occurred\",\n          statusCode: 500\n        }));\n      }\n    } finally {\n      setExecutionState(\"idle\");\n      abortControllerRef.current = null;\n    }\n  }, [executionState, wallet, currentTxIndex, flatTxs, executeSingleTx, executeBatch, onrampStatus, executeOnramp, onComplete, preparedQuote]);\n  // Start execution\n  const start = useCallback(() => {\n    if (executionState === \"idle\") {\n      execute();\n    }\n  }, [execute, executionState]);\n  // Cancel execution\n  const cancel = useCallback(() => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    setExecutionState(\"idle\");\n    if (onrampStatus === \"executing\") {\n      setOnrampStatus(\"pending\");\n    }\n  }, [onrampStatus]);\n  // Retry from failed transaction\n  const retry = useCallback(() => {\n    if (error) {\n      setError(undefined);\n      execute();\n    }\n  }, [error, execute]);\n  const hasInitialized = useRef(false);\n  useEffect(() => {\n    if (autoStart && executionState === \"idle\" && currentTxIndex === undefined && !hasInitialized.current) {\n      hasInitialized.current = true;\n      setExecutionState(\"auto-starting\");\n      // add a delay to ensure the UI is ready\n      setTimeout(() => {\n        start();\n      }, 500);\n    }\n  }, [autoStart, executionState, currentTxIndex, start]);\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, []);\n  return {\n    cancel,\n    currentStep,\n    currentTxIndex,\n    error,\n    executionState,\n    onrampStatus,\n    progress,\n    retry,\n    start,\n    steps: preparedQuote === null || preparedQuote === void 0 ? void 0 : preparedQuote.steps\n  };\n}","map":{"version":3,"names":["useCallback","useEffect","useMemo","useRef","useState","ApiError","getCachedChain","waitForReceipt","flattenRouteSteps","steps","out","forEach","step","stepIdx","_step$transactions","transactions","tx","_txIdx","push","_objectSpread","_index","length","_stepIndex","useStepExecutor","options","wallet","windowAdapter","client","autoStart","onComplete","preparedQuote","flatTxs","currentTxIndex","setCurrentTxIndex","undefined","executionState","setExecutionState","error","setError","completedTxs","setCompletedTxs","Set","onrampStatus","setOnrampStatus","type","abortControllerRef","currentStep","progress","totalSteps","completedSteps","size","Math","round","poller","pollFn","abortSignal","delay","aborted","result","completed","Promise","resolve","timeout","setTimeout","addEventListener","clearTimeout","once","Error","executeSingleTx","account","completedStatusResults","prepareTransaction","sendTransaction","preparedTx","chain","data","to","value","transaction","hash","transactionHash","action","status","statusResult","chainId","typedStatusResult","executeBatch","txs","sendBatchTransaction","serializableTxs","all","map","firstTx","executeOnramp","onrampQuote","open","link","Onramp","id","execute","abortController","AbortController","current","code","message","statusCode","signal","getAccount","startIndex","i","_wallet$getChain","currentTx","currentStepData","concat","getChain","switchChain","canBatch","batchTxs","j","nextTx","prev","add","err","console","start","cancel","abort","retry","hasInitialized"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/react/core/hooks/useStepExecutor.ts"],"sourcesContent":["import { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport type { status as OnrampStatus } from \"../../../bridge/OnrampStatus.js\";\nimport { ApiError } from \"../../../bridge/types/Errors.js\";\nimport type {\n  RouteStep,\n  RouteTransaction,\n} from \"../../../bridge/types/Route.js\";\nimport type { Status } from \"../../../bridge/types/Status.js\";\nimport { getCachedChain } from \"../../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport { waitForReceipt } from \"../../../transaction/actions/wait-for-tx-receipt.js\";\nimport type { Account, Wallet } from \"../../../wallets/interfaces/wallet.js\";\nimport type { WindowAdapter } from \"../adapters/WindowAdapter.js\";\nimport type { BridgePrepareResult } from \"./useBridgePrepare.js\";\n\n/**\n * Type for completed status results from Bridge.status and Onramp.status\n */\nexport type CompletedStatusResult =\n  | ({ type: \"buy\" } & Extract<Status, { status: \"COMPLETED\" }>)\n  | ({ type: \"sell\" } & Extract<Status, { status: \"COMPLETED\" }>)\n  | ({ type: \"transfer\" } & Extract<Status, { status: \"COMPLETED\" }>)\n  | ({ type: \"onramp\" } & Extract<\n      OnrampStatus.Result,\n      { status: \"COMPLETED\" }\n    >);\n\n/**\n * Options for the step executor hook\n */\ninterface StepExecutorOptions {\n  preparedQuote: BridgePrepareResult;\n  /** Wallet instance providing getAccount() & sendTransaction */\n  wallet?: Wallet;\n  /** Window adapter for opening on-ramp URLs (web / RN) */\n  windowAdapter: WindowAdapter;\n  /** Thirdweb client for API calls */\n  client: ThirdwebClient;\n  /** Auto start execution as soon as hook mounts */\n  autoStart?: boolean;\n  /** Callback when all steps complete successfully - receives array of all completed status results */\n  onComplete?: (completedStatuses: CompletedStatusResult[]) => void;\n}\n\n/**\n * Internal flattened transaction type\n */\ninterface FlattenedTx extends RouteTransaction {\n  /** Index in flat array */\n  _index: number;\n  /** Parent step index */\n  _stepIndex: number;\n}\n\n/**\n * Public return type of useStepExecutor\n */\ninterface StepExecutorResult {\n  currentStep?: RouteStep;\n  currentTxIndex?: number;\n  progress: number; // 0â€“100\n  onrampStatus?: \"pending\" | \"executing\" | \"completed\" | \"failed\";\n  executionState: \"idle\" | \"executing\" | \"auto-starting\";\n  steps?: RouteStep[];\n  error?: ApiError;\n  start: () => void;\n  cancel: () => void;\n  retry: () => void;\n}\n\n/**\n * Flatten RouteStep[] into a linear list of transactions preserving ordering & indices.\n */\nfunction flattenRouteSteps(steps: RouteStep[]): FlattenedTx[] {\n  const out: FlattenedTx[] = [];\n  steps.forEach((step, stepIdx) => {\n    step.transactions?.forEach((tx, _txIdx) => {\n      out.push({\n        ...(tx as RouteTransaction),\n        _index: out.length,\n        _stepIndex: stepIdx,\n      });\n    });\n  });\n  return out;\n}\n\n/**\n * Hook that sequentially executes prepared steps.\n * NOTE: initial implementation only exposes progress + basic state machine. Actual execution logic will follow in later subtasks.\n */\nexport function useStepExecutor(\n  options: StepExecutorOptions,\n): StepExecutorResult {\n  const {\n    wallet,\n    windowAdapter,\n    client,\n    autoStart = false,\n    onComplete,\n    preparedQuote,\n  } = options;\n\n  // Flatten all transactions upfront\n  const flatTxs = useMemo(\n    () => (preparedQuote?.steps ? flattenRouteSteps(preparedQuote.steps) : []),\n    [preparedQuote?.steps],\n  );\n\n  // State management\n  const [currentTxIndex, setCurrentTxIndex] = useState<number | undefined>(\n    undefined,\n  );\n  const [executionState, setExecutionState] = useState<\n    \"idle\" | \"executing\" | \"auto-starting\"\n  >(\"idle\");\n  const [error, setError] = useState<ApiError | undefined>(undefined);\n  const [completedTxs, setCompletedTxs] = useState<Set<number>>(new Set());\n  const [onrampStatus, setOnrampStatus] = useState<\n    \"pending\" | \"executing\" | \"completed\" | \"failed\" | undefined\n  >(preparedQuote?.type === \"onramp\" ? \"pending\" : undefined);\n\n  // Cancellation tracking\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  // Get current step based on current tx index\n  const currentStep = useMemo(() => {\n    if (typeof preparedQuote?.steps === \"undefined\") return undefined;\n    if (currentTxIndex === undefined) {\n      return undefined;\n    }\n    const tx = flatTxs[currentTxIndex];\n    return tx ? preparedQuote.steps[tx._stepIndex] : undefined;\n  }, [currentTxIndex, flatTxs, preparedQuote?.steps]);\n\n  // Calculate progress including onramp step\n  const progress = useMemo(() => {\n    if (typeof preparedQuote?.type === \"undefined\") return 0;\n    const totalSteps =\n      flatTxs.length + (preparedQuote.type === \"onramp\" ? 1 : 0);\n    if (totalSteps === 0) {\n      return 0;\n    }\n    const completedSteps =\n      completedTxs.size + (onrampStatus === \"completed\" ? 1 : 0);\n    return Math.round((completedSteps / totalSteps) * 100);\n  }, [completedTxs.size, flatTxs.length, preparedQuote?.type, onrampStatus]);\n\n  // Exponential backoff polling utility\n  const poller = useCallback(\n    async (\n      pollFn: () => Promise<{\n        completed: boolean;\n      }>,\n      abortSignal: AbortSignal,\n    ) => {\n      const delay = 2000; // 2 second poll interval\n\n      while (!abortSignal.aborted) {\n        const result = await pollFn();\n        if (result.completed) {\n          return;\n        }\n\n        await new Promise((resolve) => {\n          const timeout = setTimeout(resolve, delay);\n          abortSignal.addEventListener(\"abort\", () => clearTimeout(timeout), {\n            once: true,\n          });\n        });\n      }\n\n      throw new Error(\"Polling aborted\");\n    },\n    [],\n  );\n\n  // Execute a single transaction\n  const executeSingleTx = useCallback(\n    async (\n      tx: FlattenedTx,\n      account: Account,\n      completedStatusResults: CompletedStatusResult[],\n      abortSignal: AbortSignal,\n    ) => {\n      if (typeof preparedQuote?.type === \"undefined\") {\n        throw new Error(\"No quote generated. This is unexpected.\");\n      }\n      const { prepareTransaction } = await import(\n        \"../../../transaction/prepare-transaction.js\"\n      );\n      const { sendTransaction } = await import(\n        \"../../../transaction/actions/send-transaction.js\"\n      );\n\n      // Prepare the transaction\n      const preparedTx = prepareTransaction({\n        chain: tx.chain,\n        client: tx.client,\n        data: tx.data,\n        to: tx.to,\n        value: tx.value,\n      });\n\n      // Send the transaction\n      const result = await sendTransaction({\n        account,\n        transaction: preparedTx,\n      });\n      const hash = result.transactionHash;\n\n      if (tx.action === \"approval\" || tx.action === \"fee\") {\n        // don't poll status for approval transactions, just wait for confirmation\n        await waitForReceipt(result);\n        await new Promise((resolve) => setTimeout(resolve, 2000)); // Add an extra 2 second delay for RPC to catch up to new state\n        return;\n      }\n\n      // Poll for completion\n      const { status } = await import(\"../../../bridge/Status.js\");\n      await poller(async () => {\n        const statusResult = await status({\n          chainId: tx.chainId,\n          client: tx.client,\n          transactionHash: hash,\n        });\n\n        if (statusResult.status === \"COMPLETED\") {\n          // Add type field from preparedQuote for discriminated union\n          const typedStatusResult = {\n            type: preparedQuote.type,\n            ...statusResult,\n          };\n          completedStatusResults.push(typedStatusResult);\n          return { completed: true };\n        }\n\n        if (statusResult.status === \"FAILED\") {\n          throw new Error(\"Payment failed\");\n        }\n\n        return { completed: false };\n      }, abortSignal);\n    },\n    [poller, preparedQuote?.type],\n  );\n\n  // Execute batch transactions\n  const executeBatch = useCallback(\n    async (\n      txs: FlattenedTx[],\n      account: Account,\n      completedStatusResults: CompletedStatusResult[],\n      abortSignal: AbortSignal,\n    ) => {\n      if (typeof preparedQuote?.type === \"undefined\") {\n        throw new Error(\"No quote generated. This is unexpected.\");\n      }\n      if (!account.sendBatchTransaction) {\n        throw new Error(\"Account does not support batch transactions\");\n      }\n\n      const { prepareTransaction } = await import(\n        \"../../../transaction/prepare-transaction.js\"\n      );\n      const { sendBatchTransaction } = await import(\n        \"../../../transaction/actions/send-batch-transaction.js\"\n      );\n\n      // Prepare and convert all transactions\n      const serializableTxs = await Promise.all(\n        txs.map(async (tx) => {\n          const preparedTx = prepareTransaction({\n            chain: tx.chain,\n            client: tx.client,\n            data: tx.data,\n            to: tx.to,\n            value: tx.value,\n          });\n          return preparedTx;\n        }),\n      );\n\n      // Send batch\n      const result = await sendBatchTransaction({\n        account,\n        transactions: serializableTxs,\n      });\n      // Batch transactions return a single receipt, we need to handle this differently\n      // For now, we'll assume all transactions in the batch succeed together\n\n      // Poll for the first transaction's completion (representative of the batch)\n      if (txs.length === 0) {\n        throw new Error(\"No transactions to batch\");\n      }\n      const firstTx = txs[0];\n      if (!firstTx) {\n        throw new Error(\"Invalid batch transaction\");\n      }\n\n      const { status } = await import(\"../../../bridge/Status.js\");\n      await poller(async () => {\n        const statusResult = await status({\n          chainId: firstTx.chainId,\n          client: firstTx.client,\n          transactionHash: result.transactionHash,\n        });\n\n        if (statusResult.status === \"COMPLETED\") {\n          // Add type field from preparedQuote for discriminated union\n          const typedStatusResult = {\n            type: preparedQuote.type,\n            ...statusResult,\n          };\n          completedStatusResults.push(typedStatusResult);\n          return { completed: true };\n        }\n\n        if (statusResult.status === \"FAILED\") {\n          throw new Error(\"Payment failed\");\n        }\n\n        return { completed: false };\n      }, abortSignal);\n    },\n    [poller, preparedQuote?.type],\n  );\n\n  // Execute onramp step\n  const executeOnramp = useCallback(\n    async (\n      onrampQuote: Extract<BridgePrepareResult, { type: \"onramp\" }>,\n      completedStatusResults: CompletedStatusResult[],\n      abortSignal: AbortSignal,\n    ) => {\n      setOnrampStatus(\"executing\");\n      // Open the payment URL\n      windowAdapter.open(onrampQuote.link);\n\n      // Poll for completion using the session ID\n      const { Onramp } = await import(\"../../../bridge/index.js\");\n      await poller(async () => {\n        const statusResult = await Onramp.status({\n          client: client,\n          id: onrampQuote.id,\n        });\n\n        const status = statusResult.status;\n        if (status === \"COMPLETED\") {\n          /*\n           * The occasional race condition can happen where the onramp provider gives us completed status before the token balance has updated in our RPC.\n           * We add this pause so the simulation doesn't fail on the next step.\n           */\n          await new Promise((resolve) => setTimeout(resolve, 2000));\n          setOnrampStatus(\"completed\");\n          // Add type field for discriminated union\n          const typedStatusResult = {\n            type: \"onramp\" as const,\n            ...statusResult,\n          };\n          completedStatusResults.push(typedStatusResult);\n          return { completed: true };\n        } else if (status === \"FAILED\") {\n          setOnrampStatus(\"failed\");\n        }\n\n        return { completed: false };\n      }, abortSignal);\n    },\n    [poller, client, windowAdapter],\n  );\n\n  // Main execution function\n  const execute = useCallback(async () => {\n    if (typeof preparedQuote?.type === \"undefined\") {\n      throw new Error(\"No quote generated. This is unexpected.\");\n    }\n    if (executionState !== \"idle\") {\n      return;\n    }\n\n    setExecutionState(\"executing\");\n    setError(undefined);\n    const completedStatusResults: CompletedStatusResult[] = [];\n\n    // Create new abort controller\n    const abortController = new AbortController();\n    abortControllerRef.current = abortController;\n\n    try {\n      if (flatTxs.length > 0 && !wallet) {\n        throw new ApiError({\n          code: \"INVALID_INPUT\",\n          message: \"No wallet provided to execute transactions\",\n          statusCode: 400,\n        });\n      }\n\n      // Execute onramp first if configured and not already completed\n      if (preparedQuote.type === \"onramp\" && onrampStatus === \"pending\") {\n        await executeOnramp(\n          preparedQuote,\n          completedStatusResults,\n          abortController.signal,\n        );\n      }\n\n      if (flatTxs.length > 0) {\n        // Then execute transactions\n        if (!wallet) {\n          throw new ApiError({\n            code: \"INVALID_INPUT\",\n            message: \"No wallet provided to execute transactions\",\n            statusCode: 400,\n          });\n        }\n        const account = wallet.getAccount();\n        if (!account) {\n          throw new ApiError({\n            code: \"INVALID_INPUT\",\n            message: \"Wallet not connected\",\n            statusCode: 400,\n          });\n        }\n\n        // Start from where we left off, or from the beginning\n        const startIndex = currentTxIndex ?? 0;\n\n        for (let i = startIndex; i < flatTxs.length; i++) {\n          if (abortController.signal.aborted) {\n            break;\n          }\n\n          const currentTx = flatTxs[i];\n          if (!currentTx) {\n            continue; // Skip invalid index\n          }\n\n          setCurrentTxIndex(i);\n          const currentStepData = preparedQuote.steps[currentTx._stepIndex];\n          if (!currentStepData) {\n            throw new Error(`Invalid step index: ${currentTx._stepIndex}`);\n          }\n\n          // switch chain if needed\n          if (currentTx.chainId !== wallet.getChain()?.id) {\n            await wallet.switchChain(getCachedChain(currentTx.chainId));\n          }\n\n          // Check if we can batch transactions\n          const canBatch =\n            account.sendBatchTransaction !== undefined &&\n            i < flatTxs.length - 1; // Not the last transaction\n\n          if (canBatch) {\n            // Find consecutive transactions on the same chain\n            const batchTxs: FlattenedTx[] = [currentTx];\n            let j = i + 1;\n            while (j < flatTxs.length) {\n              const nextTx = flatTxs[j];\n              if (!nextTx || nextTx.chainId !== currentTx.chainId) {\n                break;\n              }\n              batchTxs.push(nextTx);\n              j++;\n            }\n\n            // Execute batch if we have multiple transactions\n            if (batchTxs.length > 1) {\n              await executeBatch(\n                batchTxs,\n                account,\n                completedStatusResults,\n                abortController.signal,\n              );\n\n              // Mark all batched transactions as completed\n              for (const tx of batchTxs) {\n                setCompletedTxs((prev) => new Set(prev).add(tx._index));\n              }\n\n              // Skip ahead\n              i = j - 1;\n              continue;\n            }\n          }\n\n          // Execute single transaction\n          await executeSingleTx(\n            currentTx,\n            account,\n            completedStatusResults,\n            abortController.signal,\n          );\n\n          // Mark transaction as completed\n          setCompletedTxs((prev) => new Set(prev).add(currentTx._index));\n        }\n      }\n      // All done - check if we actually completed everything\n      if (!abortController.signal.aborted) {\n        setCurrentTxIndex(undefined);\n\n        // Call completion callback with all completed status results\n        if (onComplete) {\n          onComplete(completedStatusResults);\n        }\n      }\n    } catch (err) {\n      console.error(\"Error executing payment\", err);\n      if (err instanceof ApiError) {\n        setError(err);\n      } else {\n        setError(\n          new ApiError({\n            code: \"UNKNOWN_ERROR\",\n            message: (err as Error)?.message || \"An unknown error occurred\",\n            statusCode: 500,\n          }),\n        );\n      }\n    } finally {\n      setExecutionState(\"idle\");\n      abortControllerRef.current = null;\n    }\n  }, [\n    executionState,\n    wallet,\n    currentTxIndex,\n    flatTxs,\n    executeSingleTx,\n    executeBatch,\n    onrampStatus,\n    executeOnramp,\n    onComplete,\n    preparedQuote,\n  ]);\n\n  // Start execution\n  const start = useCallback(() => {\n    if (executionState === \"idle\") {\n      execute();\n    }\n  }, [execute, executionState]);\n\n  // Cancel execution\n  const cancel = useCallback(() => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    setExecutionState(\"idle\");\n    if (onrampStatus === \"executing\") {\n      setOnrampStatus(\"pending\");\n    }\n  }, [onrampStatus]);\n\n  // Retry from failed transaction\n  const retry = useCallback(() => {\n    if (error) {\n      setError(undefined);\n      execute();\n    }\n  }, [error, execute]);\n\n  const hasInitialized = useRef(false);\n\n  useEffect(() => {\n    if (\n      autoStart &&\n      executionState === \"idle\" &&\n      currentTxIndex === undefined &&\n      !hasInitialized.current\n    ) {\n      hasInitialized.current = true;\n      setExecutionState(\"auto-starting\");\n      // add a delay to ensure the UI is ready\n      setTimeout(() => {\n        start();\n      }, 500);\n    }\n  }, [autoStart, executionState, currentTxIndex, start]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, []);\n\n  return {\n    cancel,\n    currentStep,\n    currentTxIndex,\n    error,\n    executionState,\n    onrampStatus,\n    progress,\n    retry,\n    start,\n    steps: preparedQuote?.steps,\n  };\n}\n"],"mappings":";AAAA,SAASA,WAAW,EAAEC,SAAS,EAAEC,OAAO,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAEzE,SAASC,QAAQ,QAAQ,iCAAiC;AAM1D,SAASC,cAAc,QAAQ,0BAA0B;AAEzD,SAASC,cAAc,QAAQ,qDAAqD;AA4DpF;;;AAGA,SAASC,iBAAiBA,CAACC,KAAkB;EAC3C,MAAMC,GAAG,GAAkB,EAAE;EAC7BD,KAAK,CAACE,OAAO,CAAC,CAACC,IAAI,EAAEC,OAAO,KAAI;IAAA,IAAAC,kBAAA;IAC9B,CAAAA,kBAAA,GAAAF,IAAI,CAACG,YAAY,cAAAD,kBAAA,eAAjBA,kBAAA,CAAmBH,OAAO,CAAC,CAACK,EAAE,EAAEC,MAAM,KAAI;MACxCP,GAAG,CAACQ,IAAI,CAAAC,aAAA,CAAAA,aAAA,KACFH,EAAuB;QAC3BI,MAAM,EAAEV,GAAG,CAACW,MAAM;QAClBC,UAAU,EAAET;MAAO,EACpB,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC,CAAC;EACF,OAAOH,GAAG;AACZ;AAEA;;;;AAIA,OAAM,SAAUa,eAAeA,CAC7BC,OAA4B;EAE5B,MAAM;IACJC,MAAM;IACNC,aAAa;IACbC,MAAM;IACNC,SAAS,GAAG,KAAK;IACjBC,UAAU;IACVC;EAAa,CACd,GAAGN,OAAO;EAEX;EACA,MAAMO,OAAO,GAAG7B,OAAO,CACrB,MAAO4B,aAAa,aAAbA,aAAa,eAAbA,aAAa,CAAErB,KAAK,GAAGD,iBAAiB,CAACsB,aAAa,CAACrB,KAAK,CAAC,GAAG,EAAG,EAC1E,CAACqB,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAErB,KAAK,CAAC,CACvB;EAED;EACA,MAAM,CAACuB,cAAc,EAAEC,iBAAiB,CAAC,GAAG7B,QAAQ,CAClD8B,SAAS,CACV;EACD,MAAM,CAACC,cAAc,EAAEC,iBAAiB,CAAC,GAAGhC,QAAQ,CAElD,MAAM,CAAC;EACT,MAAM,CAACiC,KAAK,EAAEC,QAAQ,CAAC,GAAGlC,QAAQ,CAAuB8B,SAAS,CAAC;EACnE,MAAM,CAACK,YAAY,EAAEC,eAAe,CAAC,GAAGpC,QAAQ,CAAc,IAAIqC,GAAG,EAAE,CAAC;EACxE,MAAM,CAACC,YAAY,EAAEC,eAAe,CAAC,GAAGvC,QAAQ,CAE9C,CAAA0B,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAEc,IAAI,MAAK,QAAQ,GAAG,SAAS,GAAGV,SAAS,CAAC;EAE3D;EACA,MAAMW,kBAAkB,GAAG1C,MAAM,CAAyB,IAAI,CAAC;EAE/D;EACA,MAAM2C,WAAW,GAAG5C,OAAO,CAAC,MAAK;IAC/B,IAAI,QAAO4B,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAErB,KAAK,MAAK,WAAW,EAAE,OAAOyB,SAAS;IACjE,IAAIF,cAAc,KAAKE,SAAS,EAAE;MAChC,OAAOA,SAAS;IAClB;IACA,MAAMlB,EAAE,GAAGe,OAAO,CAACC,cAAc,CAAC;IAClC,OAAOhB,EAAE,GAAGc,aAAa,CAACrB,KAAK,CAACO,EAAE,CAACM,UAAU,CAAC,GAAGY,SAAS;EAC5D,CAAC,EAAE,CAACF,cAAc,EAAED,OAAO,EAAED,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAErB,KAAK,CAAC,CAAC;EAEnD;EACA,MAAMsC,QAAQ,GAAG7C,OAAO,CAAC,MAAK;IAC5B,IAAI,QAAO4B,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAEc,IAAI,MAAK,WAAW,EAAE,OAAO,CAAC;IACxD,MAAMI,UAAU,GACdjB,OAAO,CAACV,MAAM,IAAIS,aAAa,CAACc,IAAI,KAAK,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC;IAC5D,IAAII,UAAU,KAAK,CAAC,EAAE;MACpB,OAAO,CAAC;IACV;IACA,MAAMC,cAAc,GAClBV,YAAY,CAACW,IAAI,IAAIR,YAAY,KAAK,WAAW,GAAG,CAAC,GAAG,CAAC,CAAC;IAC5D,OAAOS,IAAI,CAACC,KAAK,CAAEH,cAAc,GAAGD,UAAU,GAAI,GAAG,CAAC;EACxD,CAAC,EAAE,CAACT,YAAY,CAACW,IAAI,EAAEnB,OAAO,CAACV,MAAM,EAAES,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAEc,IAAI,EAAEF,YAAY,CAAC,CAAC;EAE1E;EACA,MAAMW,MAAM,GAAGrD,WAAW,CACxB,OACEsD,MAEE,EACFC,WAAwB,KACtB;IACF,MAAMC,KAAK,GAAG,IAAI,CAAC,CAAC;IAEpB,OAAO,CAACD,WAAW,CAACE,OAAO,EAAE;MAC3B,MAAMC,MAAM,GAAG,MAAMJ,MAAM,EAAE;MAC7B,IAAII,MAAM,CAACC,SAAS,EAAE;QACpB;MACF;MAEA,MAAM,IAAIC,OAAO,CAAEC,OAAO,IAAI;QAC5B,MAAMC,OAAO,GAAGC,UAAU,CAACF,OAAO,EAAEL,KAAK,CAAC;QAC1CD,WAAW,CAACS,gBAAgB,CAAC,OAAO,EAAE,MAAMC,YAAY,CAACH,OAAO,CAAC,EAAE;UACjEI,IAAI,EAAE;SACP,CAAC;MACJ,CAAC,CAAC;IACJ;IAEA,MAAM,IAAIC,KAAK,CAAC,iBAAiB,CAAC;EACpC,CAAC,EACD,EAAE,CACH;EAED;EACA,MAAMC,eAAe,GAAGpE,WAAW,CACjC,OACEgB,EAAe,EACfqD,OAAgB,EAChBC,sBAA+C,EAC/Cf,WAAwB,KACtB;IACF,IAAI,QAAOzB,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAEc,IAAI,MAAK,WAAW,EAAE;MAC9C,MAAM,IAAIuB,KAAK,CAAC,yCAAyC,CAAC;IAC5D;IACA,MAAM;MAAEI;IAAkB,CAAE,GAAG,MAAM,MAAM,CACzC,6CAA6C,CAC9C;IACD,MAAM;MAAEC;IAAe,CAAE,GAAG,MAAM,MAAM,CACtC,kDAAkD,CACnD;IAED;IACA,MAAMC,UAAU,GAAGF,kBAAkB,CAAC;MACpCG,KAAK,EAAE1D,EAAE,CAAC0D,KAAK;MACf/C,MAAM,EAAEX,EAAE,CAACW,MAAM;MACjBgD,IAAI,EAAE3D,EAAE,CAAC2D,IAAI;MACbC,EAAE,EAAE5D,EAAE,CAAC4D,EAAE;MACTC,KAAK,EAAE7D,EAAE,CAAC6D;KACX,CAAC;IAEF;IACA,MAAMnB,MAAM,GAAG,MAAMc,eAAe,CAAC;MACnCH,OAAO;MACPS,WAAW,EAAEL;KACd,CAAC;IACF,MAAMM,IAAI,GAAGrB,MAAM,CAACsB,eAAe;IAEnC,IAAIhE,EAAE,CAACiE,MAAM,KAAK,UAAU,IAAIjE,EAAE,CAACiE,MAAM,KAAK,KAAK,EAAE;MACnD;MACA,MAAM1E,cAAc,CAACmD,MAAM,CAAC;MAC5B,MAAM,IAAIE,OAAO,CAAEC,OAAO,IAAKE,UAAU,CAACF,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;MAC3D;IACF;IAEA;IACA,MAAM;MAAEqB;IAAM,CAAE,GAAG,MAAM,MAAM,CAAC,2BAA2B,CAAC;IAC5D,MAAM7B,MAAM,CAAC,YAAW;MACtB,MAAM8B,YAAY,GAAG,MAAMD,MAAM,CAAC;QAChCE,OAAO,EAAEpE,EAAE,CAACoE,OAAO;QACnBzD,MAAM,EAAEX,EAAE,CAACW,MAAM;QACjBqD,eAAe,EAAED;OAClB,CAAC;MAEF,IAAII,YAAY,CAACD,MAAM,KAAK,WAAW,EAAE;QACvC;QACA,MAAMG,iBAAiB,GAAAlE,aAAA;UACrByB,IAAI,EAAEd,aAAa,CAACc;QAAI,GACrBuC,YAAY,CAChB;QACDb,sBAAsB,CAACpD,IAAI,CAACmE,iBAAiB,CAAC;QAC9C,OAAO;UAAE1B,SAAS,EAAE;QAAI,CAAE;MAC5B;MAEA,IAAIwB,YAAY,CAACD,MAAM,KAAK,QAAQ,EAAE;QACpC,MAAM,IAAIf,KAAK,CAAC,gBAAgB,CAAC;MACnC;MAEA,OAAO;QAAER,SAAS,EAAE;MAAK,CAAE;IAC7B,CAAC,EAAEJ,WAAW,CAAC;EACjB,CAAC,EACD,CAACF,MAAM,EAAEvB,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAEc,IAAI,CAAC,CAC9B;EAED;EACA,MAAM0C,YAAY,GAAGtF,WAAW,CAC9B,OACEuF,GAAkB,EAClBlB,OAAgB,EAChBC,sBAA+C,EAC/Cf,WAAwB,KACtB;IACF,IAAI,QAAOzB,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAEc,IAAI,MAAK,WAAW,EAAE;MAC9C,MAAM,IAAIuB,KAAK,CAAC,yCAAyC,CAAC;IAC5D;IACA,IAAI,CAACE,OAAO,CAACmB,oBAAoB,EAAE;MACjC,MAAM,IAAIrB,KAAK,CAAC,6CAA6C,CAAC;IAChE;IAEA,MAAM;MAAEI;IAAkB,CAAE,GAAG,MAAM,MAAM,CACzC,6CAA6C,CAC9C;IACD,MAAM;MAAEiB;IAAoB,CAAE,GAAG,MAAM,MAAM,CAC3C,wDAAwD,CACzD;IAED;IACA,MAAMC,eAAe,GAAG,MAAM7B,OAAO,CAAC8B,GAAG,CACvCH,GAAG,CAACI,GAAG,CAAC,MAAO3E,EAAE,IAAI;MACnB,MAAMyD,UAAU,GAAGF,kBAAkB,CAAC;QACpCG,KAAK,EAAE1D,EAAE,CAAC0D,KAAK;QACf/C,MAAM,EAAEX,EAAE,CAACW,MAAM;QACjBgD,IAAI,EAAE3D,EAAE,CAAC2D,IAAI;QACbC,EAAE,EAAE5D,EAAE,CAAC4D,EAAE;QACTC,KAAK,EAAE7D,EAAE,CAAC6D;OACX,CAAC;MACF,OAAOJ,UAAU;IACnB,CAAC,CAAC,CACH;IAED;IACA,MAAMf,MAAM,GAAG,MAAM8B,oBAAoB,CAAC;MACxCnB,OAAO;MACPtD,YAAY,EAAE0E;KACf,CAAC;IACF;IACA;IAEA;IACA,IAAIF,GAAG,CAAClE,MAAM,KAAK,CAAC,EAAE;MACpB,MAAM,IAAI8C,KAAK,CAAC,0BAA0B,CAAC;IAC7C;IACA,MAAMyB,OAAO,GAAGL,GAAG,CAAC,CAAC,CAAC;IACtB,IAAI,CAACK,OAAO,EAAE;MACZ,MAAM,IAAIzB,KAAK,CAAC,2BAA2B,CAAC;IAC9C;IAEA,MAAM;MAAEe;IAAM,CAAE,GAAG,MAAM,MAAM,CAAC,2BAA2B,CAAC;IAC5D,MAAM7B,MAAM,CAAC,YAAW;MACtB,MAAM8B,YAAY,GAAG,MAAMD,MAAM,CAAC;QAChCE,OAAO,EAAEQ,OAAO,CAACR,OAAO;QACxBzD,MAAM,EAAEiE,OAAO,CAACjE,MAAM;QACtBqD,eAAe,EAAEtB,MAAM,CAACsB;OACzB,CAAC;MAEF,IAAIG,YAAY,CAACD,MAAM,KAAK,WAAW,EAAE;QACvC;QACA,MAAMG,iBAAiB,GAAAlE,aAAA;UACrByB,IAAI,EAAEd,aAAa,CAACc;QAAI,GACrBuC,YAAY,CAChB;QACDb,sBAAsB,CAACpD,IAAI,CAACmE,iBAAiB,CAAC;QAC9C,OAAO;UAAE1B,SAAS,EAAE;QAAI,CAAE;MAC5B;MAEA,IAAIwB,YAAY,CAACD,MAAM,KAAK,QAAQ,EAAE;QACpC,MAAM,IAAIf,KAAK,CAAC,gBAAgB,CAAC;MACnC;MAEA,OAAO;QAAER,SAAS,EAAE;MAAK,CAAE;IAC7B,CAAC,EAAEJ,WAAW,CAAC;EACjB,CAAC,EACD,CAACF,MAAM,EAAEvB,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAEc,IAAI,CAAC,CAC9B;EAED;EACA,MAAMiD,aAAa,GAAG7F,WAAW,CAC/B,OACE8F,WAA6D,EAC7DxB,sBAA+C,EAC/Cf,WAAwB,KACtB;IACFZ,eAAe,CAAC,WAAW,CAAC;IAC5B;IACAjB,aAAa,CAACqE,IAAI,CAACD,WAAW,CAACE,IAAI,CAAC;IAEpC;IACA,MAAM;MAAEC;IAAM,CAAE,GAAG,MAAM,MAAM,CAAC,0BAA0B,CAAC;IAC3D,MAAM5C,MAAM,CAAC,YAAW;MACtB,MAAM8B,YAAY,GAAG,MAAMc,MAAM,CAACf,MAAM,CAAC;QACvCvD,MAAM,EAAEA,MAAM;QACduE,EAAE,EAAEJ,WAAW,CAACI;OACjB,CAAC;MAEF,MAAMhB,MAAM,GAAGC,YAAY,CAACD,MAAM;MAClC,IAAIA,MAAM,KAAK,WAAW,EAAE;QAC1B;;;;QAIA,MAAM,IAAItB,OAAO,CAAEC,OAAO,IAAKE,UAAU,CAACF,OAAO,EAAE,IAAI,CAAC,CAAC;QACzDlB,eAAe,CAAC,WAAW,CAAC;QAC5B;QACA,MAAM0C,iBAAiB,GAAAlE,aAAA;UACrByB,IAAI,EAAE;QAAiB,GACpBuC,YAAY,CAChB;QACDb,sBAAsB,CAACpD,IAAI,CAACmE,iBAAiB,CAAC;QAC9C,OAAO;UAAE1B,SAAS,EAAE;QAAI,CAAE;MAC5B,CAAC,MAAM,IAAIuB,MAAM,KAAK,QAAQ,EAAE;QAC9BvC,eAAe,CAAC,QAAQ,CAAC;MAC3B;MAEA,OAAO;QAAEgB,SAAS,EAAE;MAAK,CAAE;IAC7B,CAAC,EAAEJ,WAAW,CAAC;EACjB,CAAC,EACD,CAACF,MAAM,EAAE1B,MAAM,EAAED,aAAa,CAAC,CAChC;EAED;EACA,MAAMyE,OAAO,GAAGnG,WAAW,CAAC,YAAW;IACrC,IAAI,QAAO8B,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAEc,IAAI,MAAK,WAAW,EAAE;MAC9C,MAAM,IAAIuB,KAAK,CAAC,yCAAyC,CAAC;IAC5D;IACA,IAAIhC,cAAc,KAAK,MAAM,EAAE;MAC7B;IACF;IAEAC,iBAAiB,CAAC,WAAW,CAAC;IAC9BE,QAAQ,CAACJ,SAAS,CAAC;IACnB,MAAMoC,sBAAsB,GAA4B,EAAE;IAE1D;IACA,MAAM8B,eAAe,GAAG,IAAIC,eAAe,EAAE;IAC7CxD,kBAAkB,CAACyD,OAAO,GAAGF,eAAe;IAE5C,IAAI;MACF,IAAIrE,OAAO,CAACV,MAAM,GAAG,CAAC,IAAI,CAACI,MAAM,EAAE;QACjC,MAAM,IAAIpB,QAAQ,CAAC;UACjBkG,IAAI,EAAE,eAAe;UACrBC,OAAO,EAAE,4CAA4C;UACrDC,UAAU,EAAE;SACb,CAAC;MACJ;MAEA;MACA,IAAI3E,aAAa,CAACc,IAAI,KAAK,QAAQ,IAAIF,YAAY,KAAK,SAAS,EAAE;QACjE,MAAMmD,aAAa,CACjB/D,aAAa,EACbwC,sBAAsB,EACtB8B,eAAe,CAACM,MAAM,CACvB;MACH;MAEA,IAAI3E,OAAO,CAACV,MAAM,GAAG,CAAC,EAAE;QACtB;QACA,IAAI,CAACI,MAAM,EAAE;UACX,MAAM,IAAIpB,QAAQ,CAAC;YACjBkG,IAAI,EAAE,eAAe;YACrBC,OAAO,EAAE,4CAA4C;YACrDC,UAAU,EAAE;WACb,CAAC;QACJ;QACA,MAAMpC,OAAO,GAAG5C,MAAM,CAACkF,UAAU,EAAE;QACnC,IAAI,CAACtC,OAAO,EAAE;UACZ,MAAM,IAAIhE,QAAQ,CAAC;YACjBkG,IAAI,EAAE,eAAe;YACrBC,OAAO,EAAE,sBAAsB;YAC/BC,UAAU,EAAE;WACb,CAAC;QACJ;QAEA;QACA,MAAMG,UAAU,GAAG5E,cAAc,aAAdA,cAAc,cAAdA,cAAc,GAAI,CAAC;QAEtC,KAAK,IAAI6E,CAAC,GAAGD,UAAU,EAAEC,CAAC,GAAG9E,OAAO,CAACV,MAAM,EAAEwF,CAAC,EAAE,EAAE;UAAA,IAAAC,gBAAA;UAChD,IAAIV,eAAe,CAACM,MAAM,CAACjD,OAAO,EAAE;YAClC;UACF;UAEA,MAAMsD,SAAS,GAAGhF,OAAO,CAAC8E,CAAC,CAAC;UAC5B,IAAI,CAACE,SAAS,EAAE;YACd,SAAS,CAAC;UACZ;UAEA9E,iBAAiB,CAAC4E,CAAC,CAAC;UACpB,MAAMG,eAAe,GAAGlF,aAAa,CAACrB,KAAK,CAACsG,SAAS,CAACzF,UAAU,CAAC;UACjE,IAAI,CAAC0F,eAAe,EAAE;YACpB,MAAM,IAAI7C,KAAK,wBAAA8C,MAAA,CAAwBF,SAAS,CAACzF,UAAU,CAAE,CAAC;UAChE;UAEA;UACA,IAAIyF,SAAS,CAAC3B,OAAO,OAAA0B,gBAAA,GAAKrF,MAAM,CAACyF,QAAQ,EAAE,cAAAJ,gBAAA,uBAAjBA,gBAAA,CAAmBZ,EAAE,GAAE;YAC/C,MAAMzE,MAAM,CAAC0F,WAAW,CAAC7G,cAAc,CAACyG,SAAS,CAAC3B,OAAO,CAAC,CAAC;UAC7D;UAEA;UACA,MAAMgC,QAAQ,GACZ/C,OAAO,CAACmB,oBAAoB,KAAKtD,SAAS,IAC1C2E,CAAC,GAAG9E,OAAO,CAACV,MAAM,GAAG,CAAC,CAAC,CAAC;UAE1B,IAAI+F,QAAQ,EAAE;YACZ;YACA,MAAMC,QAAQ,GAAkB,CAACN,SAAS,CAAC;YAC3C,IAAIO,CAAC,GAAGT,CAAC,GAAG,CAAC;YACb,OAAOS,CAAC,GAAGvF,OAAO,CAACV,MAAM,EAAE;cACzB,MAAMkG,MAAM,GAAGxF,OAAO,CAACuF,CAAC,CAAC;cACzB,IAAI,CAACC,MAAM,IAAIA,MAAM,CAACnC,OAAO,KAAK2B,SAAS,CAAC3B,OAAO,EAAE;gBACnD;cACF;cACAiC,QAAQ,CAACnG,IAAI,CAACqG,MAAM,CAAC;cACrBD,CAAC,EAAE;YACL;YAEA;YACA,IAAID,QAAQ,CAAChG,MAAM,GAAG,CAAC,EAAE;cACvB,MAAMiE,YAAY,CAChB+B,QAAQ,EACRhD,OAAO,EACPC,sBAAsB,EACtB8B,eAAe,CAACM,MAAM,CACvB;cAED;cACA,KAAK,MAAM1F,EAAE,IAAIqG,QAAQ,EAAE;gBACzB7E,eAAe,CAAEgF,IAAI,IAAK,IAAI/E,GAAG,CAAC+E,IAAI,CAAC,CAACC,GAAG,CAACzG,EAAE,CAACI,MAAM,CAAC,CAAC;cACzD;cAEA;cACAyF,CAAC,GAAGS,CAAC,GAAG,CAAC;cACT;YACF;UACF;UAEA;UACA,MAAMlD,eAAe,CACnB2C,SAAS,EACT1C,OAAO,EACPC,sBAAsB,EACtB8B,eAAe,CAACM,MAAM,CACvB;UAED;UACAlE,eAAe,CAAEgF,IAAI,IAAK,IAAI/E,GAAG,CAAC+E,IAAI,CAAC,CAACC,GAAG,CAACV,SAAS,CAAC3F,MAAM,CAAC,CAAC;QAChE;MACF;MACA;MACA,IAAI,CAACgF,eAAe,CAACM,MAAM,CAACjD,OAAO,EAAE;QACnCxB,iBAAiB,CAACC,SAAS,CAAC;QAE5B;QACA,IAAIL,UAAU,EAAE;UACdA,UAAU,CAACyC,sBAAsB,CAAC;QACpC;MACF;IACF,CAAC,CAAC,OAAOoD,GAAG,EAAE;MACZC,OAAO,CAACtF,KAAK,CAAC,yBAAyB,EAAEqF,GAAG,CAAC;MAC7C,IAAIA,GAAG,YAAYrH,QAAQ,EAAE;QAC3BiC,QAAQ,CAACoF,GAAG,CAAC;MACf,CAAC,MAAM;QACLpF,QAAQ,CACN,IAAIjC,QAAQ,CAAC;UACXkG,IAAI,EAAE,eAAe;UACrBC,OAAO,EAAG,CAAAkB,GAAa,aAAbA,GAAa,uBAAbA,GAAa,CAAElB,OAAO,KAAI,2BAA2B;UAC/DC,UAAU,EAAE;SACb,CAAC,CACH;MACH;IACF,CAAC,SAAS;MACRrE,iBAAiB,CAAC,MAAM,CAAC;MACzBS,kBAAkB,CAACyD,OAAO,GAAG,IAAI;IACnC;EACF,CAAC,EAAE,CACDnE,cAAc,EACdV,MAAM,EACNO,cAAc,EACdD,OAAO,EACPqC,eAAe,EACfkB,YAAY,EACZ5C,YAAY,EACZmD,aAAa,EACbhE,UAAU,EACVC,aAAa,CACd,CAAC;EAEF;EACA,MAAM8F,KAAK,GAAG5H,WAAW,CAAC,MAAK;IAC7B,IAAImC,cAAc,KAAK,MAAM,EAAE;MAC7BgE,OAAO,EAAE;IACX;EACF,CAAC,EAAE,CAACA,OAAO,EAAEhE,cAAc,CAAC,CAAC;EAE7B;EACA,MAAM0F,MAAM,GAAG7H,WAAW,CAAC,MAAK;IAC9B,IAAI6C,kBAAkB,CAACyD,OAAO,EAAE;MAC9BzD,kBAAkB,CAACyD,OAAO,CAACwB,KAAK,EAAE;IACpC;IACA1F,iBAAiB,CAAC,MAAM,CAAC;IACzB,IAAIM,YAAY,KAAK,WAAW,EAAE;MAChCC,eAAe,CAAC,SAAS,CAAC;IAC5B;EACF,CAAC,EAAE,CAACD,YAAY,CAAC,CAAC;EAElB;EACA,MAAMqF,KAAK,GAAG/H,WAAW,CAAC,MAAK;IAC7B,IAAIqC,KAAK,EAAE;MACTC,QAAQ,CAACJ,SAAS,CAAC;MACnBiE,OAAO,EAAE;IACX;EACF,CAAC,EAAE,CAAC9D,KAAK,EAAE8D,OAAO,CAAC,CAAC;EAEpB,MAAM6B,cAAc,GAAG7H,MAAM,CAAC,KAAK,CAAC;EAEpCF,SAAS,CAAC,MAAK;IACb,IACE2B,SAAS,IACTO,cAAc,KAAK,MAAM,IACzBH,cAAc,KAAKE,SAAS,IAC5B,CAAC8F,cAAc,CAAC1B,OAAO,EACvB;MACA0B,cAAc,CAAC1B,OAAO,GAAG,IAAI;MAC7BlE,iBAAiB,CAAC,eAAe,CAAC;MAClC;MACA2B,UAAU,CAAC,MAAK;QACd6D,KAAK,EAAE;MACT,CAAC,EAAE,GAAG,CAAC;IACT;EACF,CAAC,EAAE,CAAChG,SAAS,EAAEO,cAAc,EAAEH,cAAc,EAAE4F,KAAK,CAAC,CAAC;EAEtD;EACA3H,SAAS,CAAC,MAAK;IACb,OAAO,MAAK;MACV,IAAI4C,kBAAkB,CAACyD,OAAO,EAAE;QAC9BzD,kBAAkB,CAACyD,OAAO,CAACwB,KAAK,EAAE;MACpC;IACF,CAAC;EACH,CAAC,EAAE,EAAE,CAAC;EAEN,OAAO;IACLD,MAAM;IACN/E,WAAW;IACXd,cAAc;IACdK,KAAK;IACLF,cAAc;IACdO,YAAY;IACZK,QAAQ;IACRgF,KAAK;IACLH,KAAK;IACLnH,KAAK,EAAEqB,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAErB;GACvB;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}