{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { getOwnedNFTs as getInsightNFTs } from \"../../../insight/index.js\";\nimport { getNFT } from \"./getNFT.js\";\nimport { getOwnedTokenIds } from \"./getOwnedTokenIds.js\";\n/**\n * Retrieves the owned NFTs for a given owner.\n * This extension only works with ERC721 contracts that support the [`tokenOfOwnerByIndex`](https://portal.thirdweb.com/references/typescript/v5/erc721/tokenOfOwnerByIndex) method\n * @param options - The options for retrieving the owned NFTs.\n * @returns A promise that resolves to an array of NFTs owned by the specified owner.\n * @extension ERC721\n * @example\n * ```ts\n * import { getOwnedNFTs } from \"thirdweb/extensions/erc721\";\n *\n * const ownedNFTs = await getOwnedNFTs({\n *  contract,\n *  owner: \"0x1234...\",\n * });\n * ```\n */\nexport async function getOwnedNFTs(options) {\n  const {\n    useIndexer = true\n  } = options;\n  if (useIndexer) {\n    try {\n      return await getOwnedNFTsFromInsight(options);\n    } catch (_unused) {\n      return await getOwnedNFTsFromRPC(options);\n    }\n  }\n  return await getOwnedNFTsFromRPC(options);\n}\nasync function getOwnedNFTsFromRPC(options) {\n  const tokenIds = await getOwnedTokenIds(options);\n  return Promise.all(tokenIds.map(tokenId => getNFT({\n    contract: options.contract,\n    tokenId,\n    useIndexer: false\n  }).then(nft => _objectSpread(_objectSpread({}, nft), {}, {\n    // add the owner to the NFT since we know it\n    owner: options.owner\n  }))));\n}\nasync function getOwnedNFTsFromInsight(options) {\n  const limit = 50;\n  const nfts = [];\n  let page = 0;\n  let hasMore = true;\n  // TODO (insight): add support for contract address filters\n  while (hasMore) {\n    const pageResults = await getInsightNFTs({\n      chains: [options.contract.chain],\n      client: options.contract.client,\n      ownerAddress: options.owner,\n      contractAddresses: [options.contract.address],\n      queryOptions: {\n        limit,\n        page\n      }\n    });\n    nfts.push(...pageResults);\n    // If we got fewer results than the limit, we've reached the end\n    if (pageResults.length < limit) {\n      hasMore = false;\n    } else {\n      page++;\n    }\n  }\n  const results = nfts;\n  return results.filter(n => n.tokenAddress.toLowerCase() === options.contract.address.toLowerCase()).map(result => _objectSpread(_objectSpread({}, result), {}, {\n    owner: options.owner\n  }));\n}","map":{"version":3,"names":["getOwnedNFTs","getInsightNFTs","getNFT","getOwnedTokenIds","options","useIndexer","getOwnedNFTsFromInsight","_unused","getOwnedNFTsFromRPC","tokenIds","Promise","all","map","tokenId","contract","then","nft","_objectSpread","owner","limit","nfts","page","hasMore","pageResults","chains","chain","client","ownerAddress","contractAddresses","address","queryOptions","push","length","results","filter","n","tokenAddress","toLowerCase","result"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/extensions/erc721/read/getOwnedNFTs.ts"],"sourcesContent":["import { getOwnedNFTs as getInsightNFTs } from \"../../../insight/index.js\";\nimport type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport type { NFT } from \"../../../utils/nft/parseNft.js\";\nimport { getNFT } from \"./getNFT.js\";\nimport {\n  type GetOwnedTokenIdsParams,\n  getOwnedTokenIds,\n} from \"./getOwnedTokenIds.js\";\n\n/**\n * @extension ERC721\n */\nexport type GetOwnedNFTsParams = GetOwnedTokenIdsParams & {\n  useIndexer?: boolean;\n};\n\n/**\n * Retrieves the owned NFTs for a given owner.\n * This extension only works with ERC721 contracts that support the [`tokenOfOwnerByIndex`](https://portal.thirdweb.com/references/typescript/v5/erc721/tokenOfOwnerByIndex) method\n * @param options - The options for retrieving the owned NFTs.\n * @returns A promise that resolves to an array of NFTs owned by the specified owner.\n * @extension ERC721\n * @example\n * ```ts\n * import { getOwnedNFTs } from \"thirdweb/extensions/erc721\";\n *\n * const ownedNFTs = await getOwnedNFTs({\n *  contract,\n *  owner: \"0x1234...\",\n * });\n * ```\n */\nexport async function getOwnedNFTs(\n  options: BaseTransactionOptions<GetOwnedNFTsParams>,\n): Promise<NFT[]> {\n  const { useIndexer = true } = options;\n  if (useIndexer) {\n    try {\n      return await getOwnedNFTsFromInsight(options);\n    } catch {\n      return await getOwnedNFTsFromRPC(options);\n    }\n  }\n  return await getOwnedNFTsFromRPC(options);\n}\n\nasync function getOwnedNFTsFromRPC(\n  options: BaseTransactionOptions<GetOwnedNFTsParams>,\n): Promise<NFT[]> {\n  const tokenIds = await getOwnedTokenIds(options);\n\n  return Promise.all(\n    tokenIds.map((tokenId) =>\n      getNFT({\n        contract: options.contract,\n        tokenId,\n        useIndexer: false,\n      }).then((nft) => ({\n        ...nft,\n        // add the owner to the NFT since we know it\n        owner: options.owner,\n      })),\n    ),\n  );\n}\n\nasync function getOwnedNFTsFromInsight(\n  options: BaseTransactionOptions<GetOwnedNFTsParams>,\n): Promise<NFT[]> {\n  const limit = 50;\n  const nfts: NFT[] = [];\n  let page = 0;\n  let hasMore = true;\n\n  // TODO (insight): add support for contract address filters\n  while (hasMore) {\n    const pageResults = await getInsightNFTs({\n      chains: [options.contract.chain],\n      client: options.contract.client,\n      ownerAddress: options.owner,\n      contractAddresses: [options.contract.address],\n      queryOptions: {\n        limit,\n        page,\n      },\n    });\n\n    nfts.push(...pageResults);\n\n    // If we got fewer results than the limit, we've reached the end\n    if (pageResults.length < limit) {\n      hasMore = false;\n    } else {\n      page++;\n    }\n  }\n\n  const results = nfts;\n\n  return results\n    .filter(\n      (n) =>\n        n.tokenAddress.toLowerCase() === options.contract.address.toLowerCase(),\n    )\n    .map((result) => ({\n      ...result,\n      owner: options.owner,\n    }));\n}\n"],"mappings":";AAAA,SAASA,YAAY,IAAIC,cAAc,QAAQ,2BAA2B;AAG1E,SAASC,MAAM,QAAQ,aAAa;AACpC,SAEEC,gBAAgB,QACX,uBAAuB;AAS9B;;;;;;;;;;;;;;;;AAgBA,OAAO,eAAeH,YAAYA,CAChCI,OAAmD;EAEnD,MAAM;IAAEC,UAAU,GAAG;EAAI,CAAE,GAAGD,OAAO;EACrC,IAAIC,UAAU,EAAE;IACd,IAAI;MACF,OAAO,MAAMC,uBAAuB,CAACF,OAAO,CAAC;IAC/C,CAAC,CAAC,OAAAG,OAAA,EAAM;MACN,OAAO,MAAMC,mBAAmB,CAACJ,OAAO,CAAC;IAC3C;EACF;EACA,OAAO,MAAMI,mBAAmB,CAACJ,OAAO,CAAC;AAC3C;AAEA,eAAeI,mBAAmBA,CAChCJ,OAAmD;EAEnD,MAAMK,QAAQ,GAAG,MAAMN,gBAAgB,CAACC,OAAO,CAAC;EAEhD,OAAOM,OAAO,CAACC,GAAG,CAChBF,QAAQ,CAACG,GAAG,CAAEC,OAAO,IACnBX,MAAM,CAAC;IACLY,QAAQ,EAAEV,OAAO,CAACU,QAAQ;IAC1BD,OAAO;IACPR,UAAU,EAAE;GACb,CAAC,CAACU,IAAI,CAAEC,GAAG,IAAAC,aAAA,CAAAA,aAAA,KACPD,GAAG;IACN;IACAE,KAAK,EAAEd,OAAO,CAACc;EAAK,EACpB,CAAC,CACJ,CACF;AACH;AAEA,eAAeZ,uBAAuBA,CACpCF,OAAmD;EAEnD,MAAMe,KAAK,GAAG,EAAE;EAChB,MAAMC,IAAI,GAAU,EAAE;EACtB,IAAIC,IAAI,GAAG,CAAC;EACZ,IAAIC,OAAO,GAAG,IAAI;EAElB;EACA,OAAOA,OAAO,EAAE;IACd,MAAMC,WAAW,GAAG,MAAMtB,cAAc,CAAC;MACvCuB,MAAM,EAAE,CAACpB,OAAO,CAACU,QAAQ,CAACW,KAAK,CAAC;MAChCC,MAAM,EAAEtB,OAAO,CAACU,QAAQ,CAACY,MAAM;MAC/BC,YAAY,EAAEvB,OAAO,CAACc,KAAK;MAC3BU,iBAAiB,EAAE,CAACxB,OAAO,CAACU,QAAQ,CAACe,OAAO,CAAC;MAC7CC,YAAY,EAAE;QACZX,KAAK;QACLE;;KAEH,CAAC;IAEFD,IAAI,CAACW,IAAI,CAAC,GAAGR,WAAW,CAAC;IAEzB;IACA,IAAIA,WAAW,CAACS,MAAM,GAAGb,KAAK,EAAE;MAC9BG,OAAO,GAAG,KAAK;IACjB,CAAC,MAAM;MACLD,IAAI,EAAE;IACR;EACF;EAEA,MAAMY,OAAO,GAAGb,IAAI;EAEpB,OAAOa,OAAO,CACXC,MAAM,CACJC,CAAC,IACAA,CAAC,CAACC,YAAY,CAACC,WAAW,EAAE,KAAKjC,OAAO,CAACU,QAAQ,CAACe,OAAO,CAACQ,WAAW,EAAE,CAC1E,CACAzB,GAAG,CAAE0B,MAAM,IAAArB,aAAA,CAAAA,aAAA,KACPqB,MAAM;IACTpB,KAAK,EAAEd,OAAO,CAACc;EAAK,EACpB,CAAC;AACP","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}