{"ast":null,"code":"import { isAddress } from \"../../utils/address.js\";\nimport { getToken } from \"./get-token.js\";\n/**\n * Get a price of a token (using tokenAddress + chainId) in fiat.\n * Only USD is supported at the moment.\n * @example\n * ### Basic usage\n * For native token (non-ERC20), you should use NATIVE_TOKEN_ADDRESS as the value for `tokenAddress`\n * ```ts\n * import { convertCryptoToFiat } from \"thirdweb/pay\";\n *\n * // Get Ethereum price\n * const result = convertCryptoToFiat({\n *   fromTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   to: \"USD\",\n *   chain: ethereum,\n *   fromAmount: 1,\n * });\n *\n * // Result: `{ result: 3404.11 }`\n * ```\n * @buyCrypto\n * @returns a number representing the price (in selected fiat) of \"x\" token, with \"x\" being the `fromAmount`.\n */\nexport async function convertCryptoToFiat(options) {\n  const {\n    client,\n    fromTokenAddress,\n    chain,\n    fromAmount,\n    to\n  } = options;\n  if (Number(fromAmount) === 0) {\n    return {\n      result: 0\n    };\n  }\n  // Testnets just don't work with our current provider(s)\n  if (chain.testnet === true) {\n    throw new Error(\"Cannot fetch price for a testnet (chainId: \".concat(chain.id, \")\"));\n  }\n  // Some provider that we are using will return `0` for unsupported token\n  // so we should do some basic input validations before sending the request\n  // Make sure it's a valid EVM address\n  if (!isAddress(fromTokenAddress)) {\n    throw new Error(\"Invalid fromTokenAddress. Expected a valid EVM contract address\");\n  }\n  const token = await getToken(client, fromTokenAddress, chain.id);\n  const price = (token === null || token === void 0 ? void 0 : token.prices[to]) || 0;\n  if (!token || price === 0) {\n    throw new Error(\"Error: Failed to fetch price for token \".concat(fromTokenAddress, \" on chainId: \").concat(chain.id));\n  }\n  return {\n    result: price * fromAmount\n  };\n}","map":{"version":3,"names":["isAddress","getToken","convertCryptoToFiat","options","client","fromTokenAddress","chain","fromAmount","to","Number","result","testnet","Error","concat","id","token","price","prices"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/pay/convert/cryptoToFiat.ts"],"sourcesContent":["import type { Address } from \"abitype\";\nimport type { Chain } from \"../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { isAddress } from \"../../utils/address.js\";\nimport { getToken } from \"./get-token.js\";\nimport type { SupportedFiatCurrency } from \"./type.js\";\n\n/**\n * Props for the `convertCryptoToFiat` function\n * @buyCrypto\n */\nexport type ConvertCryptoToFiatParams = {\n  client: ThirdwebClient;\n  /**\n   * The contract address of the token\n   * For native token, use NATIVE_TOKEN_ADDRESS\n   */\n  fromTokenAddress: Address;\n  /**\n   * The amount of token to convert to fiat value\n   */\n  fromAmount: number;\n  /**\n   * The chain that the token is deployed to\n   */\n  chain: Chain;\n  /**\n   * The fiat symbol. e.g \"USD\"\n   */\n  to: SupportedFiatCurrency;\n};\n\n/**\n * Get a price of a token (using tokenAddress + chainId) in fiat.\n * Only USD is supported at the moment.\n * @example\n * ### Basic usage\n * For native token (non-ERC20), you should use NATIVE_TOKEN_ADDRESS as the value for `tokenAddress`\n * ```ts\n * import { convertCryptoToFiat } from \"thirdweb/pay\";\n *\n * // Get Ethereum price\n * const result = convertCryptoToFiat({\n *   fromTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   to: \"USD\",\n *   chain: ethereum,\n *   fromAmount: 1,\n * });\n *\n * // Result: `{ result: 3404.11 }`\n * ```\n * @buyCrypto\n * @returns a number representing the price (in selected fiat) of \"x\" token, with \"x\" being the `fromAmount`.\n */\nexport async function convertCryptoToFiat(\n  options: ConvertCryptoToFiatParams,\n): Promise<{ result: number }> {\n  const { client, fromTokenAddress, chain, fromAmount, to } = options;\n  if (Number(fromAmount) === 0) {\n    return { result: 0 };\n  }\n  // Testnets just don't work with our current provider(s)\n  if (chain.testnet === true) {\n    throw new Error(`Cannot fetch price for a testnet (chainId: ${chain.id})`);\n  }\n  // Some provider that we are using will return `0` for unsupported token\n  // so we should do some basic input validations before sending the request\n\n  // Make sure it's a valid EVM address\n  if (!isAddress(fromTokenAddress)) {\n    throw new Error(\n      \"Invalid fromTokenAddress. Expected a valid EVM contract address\",\n    );\n  }\n  const token = await getToken(client, fromTokenAddress, chain.id);\n  const price = token?.prices[to] || 0;\n  if (!token || price === 0) {\n    throw new Error(\n      `Error: Failed to fetch price for token ${fromTokenAddress} on chainId: ${chain.id}`,\n    );\n  }\n  return { result: price * fromAmount };\n}\n"],"mappings":"AAGA,SAASA,SAAS,QAAQ,wBAAwB;AAClD,SAASC,QAAQ,QAAQ,gBAAgB;AA4BzC;;;;;;;;;;;;;;;;;;;;;;AAsBA,OAAO,eAAeC,mBAAmBA,CACvCC,OAAkC;EAElC,MAAM;IAAEC,MAAM;IAAEC,gBAAgB;IAAEC,KAAK;IAAEC,UAAU;IAAEC;EAAE,CAAE,GAAGL,OAAO;EACnE,IAAIM,MAAM,CAACF,UAAU,CAAC,KAAK,CAAC,EAAE;IAC5B,OAAO;MAAEG,MAAM,EAAE;IAAC,CAAE;EACtB;EACA;EACA,IAAIJ,KAAK,CAACK,OAAO,KAAK,IAAI,EAAE;IAC1B,MAAM,IAAIC,KAAK,+CAAAC,MAAA,CAA+CP,KAAK,CAACQ,EAAE,MAAG,CAAC;EAC5E;EACA;EACA;EAEA;EACA,IAAI,CAACd,SAAS,CAACK,gBAAgB,CAAC,EAAE;IAChC,MAAM,IAAIO,KAAK,CACb,iEAAiE,CAClE;EACH;EACA,MAAMG,KAAK,GAAG,MAAMd,QAAQ,CAACG,MAAM,EAAEC,gBAAgB,EAAEC,KAAK,CAACQ,EAAE,CAAC;EAChE,MAAME,KAAK,GAAG,CAAAD,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEE,MAAM,CAACT,EAAE,CAAC,KAAI,CAAC;EACpC,IAAI,CAACO,KAAK,IAAIC,KAAK,KAAK,CAAC,EAAE;IACzB,MAAM,IAAIJ,KAAK,2CAAAC,MAAA,CAC6BR,gBAAgB,mBAAAQ,MAAA,CAAgBP,KAAK,CAACQ,EAAE,CAAE,CACrF;EACH;EACA,OAAO;IAAEJ,MAAM,EAAEM,KAAK,GAAGT;EAAU,CAAE;AACvC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}