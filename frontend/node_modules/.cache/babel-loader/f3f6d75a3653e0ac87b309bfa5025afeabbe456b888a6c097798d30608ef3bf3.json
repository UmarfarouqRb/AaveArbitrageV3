{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport Le from \"@walletconnect/sign-client\";\nimport { isValidObject as _, isCaipNamespace as ae, parseNamespaceKey as F, mergeArrays as k, parseChainId as U, calcExpiry as Me, isExpired as ce, getSdkError as oe, isValidArray as W } from \"@walletconnect/utils\";\nimport { pino as Be, getDefaultLoggerOptions as Ge } from \"@walletconnect/logger\";\nimport { formatJsonRpcRequest as he, formatJsonRpcResult as Je } from \"@walletconnect/jsonrpc-utils\";\nimport P, { HttpConnection as ze } from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider as g } from \"@walletconnect/jsonrpc-provider\";\nimport ke from \"events\";\nconst pe = \"error\",\n  We = \"wss://relay.walletconnect.org\",\n  Ke = \"wc\",\n  Ve = \"universal_provider\",\n  x = \"\".concat(Ke, \"@2:\").concat(Ve, \":\"),\n  de = \"https://rpc.walletconnect.org/v1/\",\n  ue = \"generic\",\n  Ye = \"\".concat(de, \"bundler\"),\n  $ = \"call_status\",\n  Xe = 86400,\n  m = {\n    DEFAULT_CHAIN_CHANGED: \"default_chain_changed\"\n  };\nfunction K(s) {\n  return s == null || typeof s != \"object\" && typeof s != \"function\";\n}\nfunction le(s) {\n  return Object.getOwnPropertySymbols(s).filter(e => Object.prototype.propertyIsEnumerable.call(s, e));\n}\nfunction fe(s) {\n  return s == null ? s === void 0 ? \"[object Undefined]\" : \"[object Null]\" : Object.prototype.toString.call(s);\n}\nconst Qe = \"[object RegExp]\",\n  me = \"[object String]\",\n  ve = \"[object Number]\",\n  ge = \"[object Boolean]\",\n  Pe = \"[object Arguments]\",\n  Ze = \"[object Symbol]\",\n  Te = \"[object Date]\",\n  et = \"[object Map]\",\n  tt = \"[object Set]\",\n  st = \"[object Array]\",\n  it = \"[object ArrayBuffer]\",\n  rt = \"[object Object]\",\n  nt = \"[object DataView]\",\n  at = \"[object Uint8Array]\",\n  ct = \"[object Uint8ClampedArray]\",\n  ot = \"[object Uint16Array]\",\n  ht = \"[object Uint32Array]\",\n  pt = \"[object Int8Array]\",\n  dt = \"[object Int16Array]\",\n  ut = \"[object Int32Array]\",\n  lt = \"[object Float32Array]\",\n  ft = \"[object Float64Array]\";\nfunction V(s) {\n  return ArrayBuffer.isView(s) && !(s instanceof DataView);\n}\nfunction mt(s, e) {\n  return O(s, void 0, s, new Map(), e);\n}\nfunction O(s, e, t) {\n  let i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Map();\n  let n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : void 0;\n  const a = n === null || n === void 0 ? void 0 : n(s, e, t, i);\n  if (a != null) return a;\n  if (K(s)) return s;\n  if (i.has(s)) return i.get(s);\n  if (Array.isArray(s)) {\n    const r = new Array(s.length);\n    i.set(s, r);\n    for (let c = 0; c < s.length; c++) r[c] = O(s[c], c, t, i, n);\n    return Object.hasOwn(s, \"index\") && (r.index = s.index), Object.hasOwn(s, \"input\") && (r.input = s.input), r;\n  }\n  if (s instanceof Date) return new Date(s.getTime());\n  if (s instanceof RegExp) {\n    const r = new RegExp(s.source, s.flags);\n    return r.lastIndex = s.lastIndex, r;\n  }\n  if (s instanceof Map) {\n    const r = new Map();\n    i.set(s, r);\n    for (const [c, o] of s) r.set(c, O(o, c, t, i, n));\n    return r;\n  }\n  if (s instanceof Set) {\n    const r = new Set();\n    i.set(s, r);\n    for (const c of s) r.add(O(c, void 0, t, i, n));\n    return r;\n  }\n  if (typeof Buffer < \"u\" && Buffer.isBuffer(s)) return s.subarray();\n  if (V(s)) {\n    const r = new (Object.getPrototypeOf(s).constructor)(s.length);\n    i.set(s, r);\n    for (let c = 0; c < s.length; c++) r[c] = O(s[c], c, t, i, n);\n    return r;\n  }\n  if (s instanceof ArrayBuffer || typeof SharedArrayBuffer < \"u\" && s instanceof SharedArrayBuffer) return s.slice(0);\n  if (s instanceof DataView) {\n    const r = new DataView(s.buffer.slice(0), s.byteOffset, s.byteLength);\n    return i.set(s, r), y(r, s, t, i, n), r;\n  }\n  if (typeof File < \"u\" && s instanceof File) {\n    const r = new File([s], s.name, {\n      type: s.type\n    });\n    return i.set(s, r), y(r, s, t, i, n), r;\n  }\n  if (s instanceof Blob) {\n    const r = new Blob([s], {\n      type: s.type\n    });\n    return i.set(s, r), y(r, s, t, i, n), r;\n  }\n  if (s instanceof Error) {\n    const r = new s.constructor();\n    return i.set(s, r), r.message = s.message, r.name = s.name, r.stack = s.stack, r.cause = s.cause, y(r, s, t, i, n), r;\n  }\n  if (typeof s == \"object\" && vt(s)) {\n    const r = Object.create(Object.getPrototypeOf(s));\n    return i.set(s, r), y(r, s, t, i, n), r;\n  }\n  return s;\n}\nfunction y(s, e) {\n  let t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : s;\n  let i = arguments.length > 3 ? arguments[3] : undefined;\n  let n = arguments.length > 4 ? arguments[4] : undefined;\n  const a = [...Object.keys(e), ...le(e)];\n  for (let r = 0; r < a.length; r++) {\n    const c = a[r],\n      o = Object.getOwnPropertyDescriptor(s, c);\n    (o == null || o.writable) && (s[c] = O(e[c], c, t, i, n));\n  }\n}\nfunction vt(s) {\n  switch (fe(s)) {\n    case Pe:\n    case st:\n    case it:\n    case nt:\n    case ge:\n    case Te:\n    case lt:\n    case ft:\n    case pt:\n    case dt:\n    case ut:\n    case et:\n    case ve:\n    case rt:\n    case Qe:\n    case tt:\n    case me:\n    case Ze:\n    case at:\n    case ct:\n    case ot:\n    case ht:\n      return !0;\n    default:\n      return !1;\n  }\n}\nfunction gt(s, e) {\n  return mt(s, (t, i, n, a) => {\n    const r = e === null || e === void 0 ? void 0 : e(t, i, n, a);\n    if (r != null) return r;\n    if (typeof s == \"object\") switch (Object.prototype.toString.call(s)) {\n      case ve:\n      case me:\n      case ge:\n        {\n          const c = new s.constructor(s === null || s === void 0 ? void 0 : s.valueOf());\n          return y(c, s), c;\n        }\n      case Pe:\n        {\n          const c = {};\n          return y(c, s), c.length = s.length, c[Symbol.iterator] = s[Symbol.iterator], c;\n        }\n      default:\n        return;\n    }\n  });\n}\nfunction we(s) {\n  return gt(s);\n}\nfunction ye(s) {\n  return s !== null && typeof s == \"object\" && fe(s) === \"[object Arguments]\";\n}\nfunction be(s) {\n  return typeof s == \"object\" && s !== null;\n}\nfunction Pt() {}\nfunction wt(s) {\n  return V(s);\n}\nfunction yt(s) {\n  if (typeof s != \"object\" || s == null) return !1;\n  if (Object.getPrototypeOf(s) === null) return !0;\n  if (Object.prototype.toString.call(s) !== \"[object Object]\") {\n    var _Object$getOwnPropert;\n    const t = s[Symbol.toStringTag];\n    return t == null || !((_Object$getOwnPropert = Object.getOwnPropertyDescriptor(s, Symbol.toStringTag)) !== null && _Object$getOwnPropert !== void 0 && _Object$getOwnPropert.writable) ? !1 : s.toString() === \"[object \".concat(t, \"]\");\n  }\n  let e = s;\n  for (; Object.getPrototypeOf(e) !== null;) e = Object.getPrototypeOf(e);\n  return Object.getPrototypeOf(s) === e;\n}\nfunction bt(s) {\n  if (K(s)) return s;\n  if (Array.isArray(s) || V(s) || s instanceof ArrayBuffer || typeof SharedArrayBuffer < \"u\" && s instanceof SharedArrayBuffer) return s.slice(0);\n  const e = Object.getPrototypeOf(s),\n    t = e.constructor;\n  if (s instanceof Date || s instanceof Map || s instanceof Set) return new t(s);\n  if (s instanceof RegExp) {\n    const i = new t(s);\n    return i.lastIndex = s.lastIndex, i;\n  }\n  if (s instanceof DataView) return new t(s.buffer.slice(0));\n  if (s instanceof Error) {\n    const i = new t(s.message);\n    return i.stack = s.stack, i.name = s.name, i.cause = s.cause, i;\n  }\n  if (typeof File < \"u\" && s instanceof File) return new t([s], s.name, {\n    type: s.type,\n    lastModified: s.lastModified\n  });\n  if (typeof s == \"object\") {\n    const i = Object.create(e);\n    return Object.assign(i, s);\n  }\n  return s;\n}\nfunction It(s) {\n  for (var _len = arguments.length, e = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    e[_key - 1] = arguments[_key];\n  }\n  const t = e.slice(0, -1),\n    i = e[e.length - 1];\n  let n = s;\n  for (let a = 0; a < t.length; a++) {\n    const r = t[a];\n    n = L(n, r, i, new Map());\n  }\n  return n;\n}\nfunction L(s, e, t, i) {\n  if (K(s) && (s = Object(s)), e == null || typeof e != \"object\") return s;\n  if (i.has(e)) return bt(i.get(e));\n  if (i.set(e, s), Array.isArray(e)) {\n    e = e.slice();\n    for (let a = 0; a < e.length; a++) {\n      var _e$a;\n      e[a] = (_e$a = e[a]) !== null && _e$a !== void 0 ? _e$a : void 0;\n    }\n  }\n  const n = [...Object.keys(e), ...le(e)];\n  for (let a = 0; a < n.length; a++) {\n    const r = n[a];\n    let c = e[r],\n      o = s[r];\n    if (ye(c) && (c = _objectSpread({}, c)), ye(o) && (o = _objectSpread({}, o)), typeof Buffer < \"u\" && Buffer.isBuffer(c) && (c = we(c)), Array.isArray(c)) if (typeof o == \"object\" && o != null) {\n      const u = [],\n        p = Reflect.ownKeys(o);\n      for (let w = 0; w < p.length; w++) {\n        const l = p[w];\n        u[l] = o[l];\n      }\n      o = u;\n    } else o = [];\n    const d = t(o, c, r, s, e, i);\n    d != null ? s[r] = d : Array.isArray(c) || be(o) && be(c) ? s[r] = L(o, c, t, i) : o == null && yt(c) ? s[r] = L({}, c, t, i) : o == null && wt(c) ? s[r] = we(c) : (o === void 0 || c !== void 0) && (s[r] = c);\n  }\n  return s;\n}\nfunction $t(s) {\n  for (var _len2 = arguments.length, e = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    e[_key2 - 1] = arguments[_key2];\n  }\n  return It(s, ...e, Pt);\n}\nvar Ot = Object.defineProperty,\n  Ct = Object.defineProperties,\n  At = Object.getOwnPropertyDescriptors,\n  Ie = Object.getOwnPropertySymbols,\n  Et = Object.prototype.hasOwnProperty,\n  Ht = Object.prototype.propertyIsEnumerable,\n  $e = (s, e, t) => e in s ? Ot(s, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : s[e] = t,\n  M = (s, e) => {\n    for (var t in e || (e = {})) Et.call(e, t) && $e(s, t, e[t]);\n    if (Ie) for (var t of Ie(e)) Ht.call(e, t) && $e(s, t, e[t]);\n    return s;\n  },\n  St = (s, e) => Ct(s, At(e));\nfunction f(s, e, t) {\n  var i;\n  const n = U(s);\n  return ((i = e.rpcMap) == null ? void 0 : i[n.reference]) || \"\".concat(de, \"?chainId=\").concat(n.namespace, \":\").concat(n.reference, \"&projectId=\").concat(t);\n}\nfunction b(s) {\n  return s.includes(\":\") ? s.split(\":\")[1] : s;\n}\nfunction Oe(s) {\n  return s.map(e => \"\".concat(e.split(\":\")[0], \":\").concat(e.split(\":\")[1]));\n}\nfunction Nt(s, e) {\n  const t = Object.keys(e.namespaces).filter(n => n.includes(s));\n  if (!t.length) return [];\n  const i = [];\n  return t.forEach(n => {\n    const a = e.namespaces[n].accounts;\n    i.push(...a);\n  }), i;\n}\nfunction Ce(s) {\n  return Object.fromEntries(Object.entries(s).filter(_ref => {\n    let [e, t] = _ref;\n    var i, n;\n    return ((i = t === null || t === void 0 ? void 0 : t.chains) == null ? void 0 : i.length) && ((n = t === null || t === void 0 ? void 0 : t.chains) == null ? void 0 : n.length) > 0;\n  }));\n}\nfunction B() {\n  let s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const t = Ce(Ae(s)),\n    i = Ce(Ae(e));\n  return $t(t, i);\n}\nfunction Ae(s) {\n  var e, t, i, n, a;\n  const r = {};\n  if (!_(s)) return r;\n  for (const [c, o] of Object.entries(s)) {\n    const d = ae(c) ? [c] : o.chains,\n      u = o.methods || [],\n      p = o.events || [],\n      w = o.rpcMap || {},\n      l = F(c);\n    r[l] = St(M(M({}, r[l]), o), {\n      chains: k(d, (e = r[l]) == null ? void 0 : e.chains),\n      methods: k(u, (t = r[l]) == null ? void 0 : t.methods),\n      events: k(p, (i = r[l]) == null ? void 0 : i.events)\n    }), (_(w) || _(((n = r[l]) == null ? void 0 : n.rpcMap) || {})) && (r[l].rpcMap = M(M({}, w), (a = r[l]) == null ? void 0 : a.rpcMap));\n  }\n  return r;\n}\nfunction Ee(s) {\n  return s.includes(\":\") ? s.split(\":\")[2] : s;\n}\nfunction He(s) {\n  const e = {};\n  for (const [t, i] of Object.entries(s)) {\n    const n = i.methods || [],\n      a = i.events || [],\n      r = i.accounts || [],\n      c = ae(t) ? [t] : i.chains ? i.chains : Oe(i.accounts);\n    e[t] = {\n      chains: c,\n      methods: n,\n      events: a,\n      accounts: r\n    };\n  }\n  return e;\n}\nfunction Y(s) {\n  return typeof s == \"number\" ? s : s.includes(\"0x\") ? parseInt(s, 16) : (s = s.includes(\":\") ? s.split(\":\")[1] : s, isNaN(Number(s)) ? s : Number(s));\n}\nfunction qt(s) {\n  try {\n    const e = JSON.parse(s);\n    return typeof e == \"object\" && e !== null && !Array.isArray(e);\n  } catch (_unused) {\n    return !1;\n  }\n}\nconst Se = {},\n  h = s => Se[s],\n  X = (s, e) => {\n    Se[s] = e;\n  };\nvar Dt = Object.defineProperty,\n  Ne = Object.getOwnPropertySymbols,\n  jt = Object.prototype.hasOwnProperty,\n  Rt = Object.prototype.propertyIsEnumerable,\n  qe = (s, e, t) => e in s ? Dt(s, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : s[e] = t,\n  De = (s, e) => {\n    for (var t in e || (e = {})) jt.call(e, t) && qe(s, t, e[t]);\n    if (Ne) for (var t of Ne(e)) Rt.call(e, t) && qe(s, t, e[t]);\n    return s;\n  };\nconst je = \"eip155\",\n  _t = [\"atomic\", \"flow-control\", \"paymasterService\", \"sessionKeys\", \"auxiliaryFunds\"],\n  Ft = s => s && s.startsWith(\"0x\") ? BigInt(s).toString(10) : s,\n  Q = s => s && s.startsWith(\"0x\") ? s : \"0x\".concat(BigInt(s).toString(16)),\n  Re = s => Object.keys(s).filter(e => _t.includes(e)).reduce((e, t) => (e[t] = Ut(s[t]), e), {}),\n  Ut = s => typeof s == \"string\" && qt(s) ? JSON.parse(s) : s,\n  xt = (s, e, t) => {\n    const {\n        sessionProperties: i = {},\n        scopedProperties: n = {}\n      } = s,\n      a = {};\n    if (!_(n) && !_(i)) return;\n    const r = Re(i);\n    for (const c of t) {\n      const o = Ft(c);\n      if (!o) continue;\n      a[Q(o)] = r;\n      const d = n === null || n === void 0 ? void 0 : n[\"\".concat(je, \":\").concat(o)];\n      if (d) {\n        const u = d === null || d === void 0 ? void 0 : d[\"\".concat(je, \":\").concat(o, \":\").concat(e)];\n        a[Q(o)] = De(De({}, a[Q(o)]), Re(u || d));\n      }\n    }\n    for (const [c, o] of Object.entries(a)) Object.keys(o).length === 0 && delete a[c];\n    return Object.keys(a).length > 0 ? a : void 0;\n  };\nvar Lt = Object.defineProperty,\n  Mt = (s, e, t) => e in s ? Lt(s, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : s[e] = t,\n  Bt = (s, e, t) => Mt(s, typeof e != \"symbol\" ? e + \"\" : e, t);\nlet Z;\nclass re {\n  constructor(e) {\n    Bt(this, \"storage\"), this.storage = e;\n  }\n  async getItem(e) {\n    return await this.storage.getItem(e);\n  }\n  async setItem(e, t) {\n    return await this.storage.setItem(e, t);\n  }\n  async removeItem(e) {\n    return await this.storage.removeItem(e);\n  }\n  static getStorage(e) {\n    return Z || (Z = new re(e)), Z;\n  }\n}\nvar Gt = Object.defineProperty,\n  Jt = Object.defineProperties,\n  zt = Object.getOwnPropertyDescriptors,\n  _e = Object.getOwnPropertySymbols,\n  kt = Object.prototype.hasOwnProperty,\n  Wt = Object.prototype.propertyIsEnumerable,\n  Fe = (s, e, t) => e in s ? Gt(s, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : s[e] = t,\n  Kt = (s, e) => {\n    for (var t in e || (e = {})) kt.call(e, t) && Fe(s, t, e[t]);\n    if (_e) for (var t of _e(e)) Wt.call(e, t) && Fe(s, t, e[t]);\n    return s;\n  },\n  Vt = (s, e) => Jt(s, zt(e));\nasync function Yt(s, e) {\n  const t = U(s.result.capabilities.caip345.caip2),\n    i = s.result.capabilities.caip345.transactionHashes,\n    n = await Promise.allSettled(i.map(p => Xt(t.reference, p, e))),\n    a = n.filter(p => p.status === \"fulfilled\").map(p => p.value).filter(p => p);\n  n.filter(p => p.status === \"rejected\").forEach(p => console.warn(\"Failed to fetch transaction receipt:\", p.reason));\n  const r = !a.length || a.some(p => !p),\n    c = a.every(p => (p === null || p === void 0 ? void 0 : p.status) === \"0x1\"),\n    o = a.every(p => (p === null || p === void 0 ? void 0 : p.status) === \"0x0\"),\n    d = a.some(p => (p === null || p === void 0 ? void 0 : p.status) === \"0x0\");\n  let u;\n  return r ? u = 100 : c ? u = 200 : o ? u = 500 : d && (u = 600), {\n    id: s.result.id,\n    version: s.request.version,\n    atomic: s.request.atomicRequired,\n    chainId: s.request.chainId,\n    capabilities: s.result.capabilities,\n    receipts: a,\n    status: u\n  };\n}\nasync function Xt(s, e, t) {\n  return await t(parseInt(s)).request(he(\"eth_getTransactionReceipt\", [e]));\n}\nasync function Qt(_ref2) {\n  let {\n    sendCalls: s,\n    storage: e\n  } = _ref2;\n  const t = await e.getItem($);\n  await e.setItem($, Vt(Kt({}, t), {\n    [s.result.id]: {\n      request: s.request,\n      result: s.result,\n      expiry: Me(Xe)\n    }\n  }));\n}\nasync function Zt(_ref3) {\n  let {\n    resultId: s,\n    storage: e\n  } = _ref3;\n  const t = await e.getItem($);\n  if (t) {\n    delete t[s], await e.setItem($, t);\n    for (const i in t) ce(t[i].expiry) && delete t[i];\n    await e.setItem($, t);\n  }\n}\nasync function Tt(_ref4) {\n  let {\n    resultId: s,\n    storage: e\n  } = _ref4;\n  const t = await e.getItem($),\n    i = t === null || t === void 0 ? void 0 : t[s];\n  if (i && !ce(i.expiry)) return i;\n  await Zt({\n    resultId: s,\n    storage: e\n  });\n}\nvar es = Object.defineProperty,\n  ts = (s, e, t) => e in s ? es(s, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : s[e] = t,\n  C = (s, e, t) => ts(s, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass ss {\n  constructor(e) {\n    C(this, \"name\", \"polkadot\"), C(this, \"client\"), C(this, \"httpProviders\"), C(this, \"events\"), C(this, \"namespace\"), C(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(m.DEFAULT_CHAIN_CHANGED, \"\".concat(this.name, \":\").concat(e));\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]) || [] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      var i;\n      const n = b(t);\n      e[n] = this.createHttpProvider(n, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = \"\".concat(this.name, \":\").concat(this.chainId),\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(\"JSON-RPC provider for \".concat(e, \" not found\"));\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || f(e, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(\"No RPC url provided for chainId: \".concat(e));\n    return new g(new P(i, h(\"disableProviderPing\")));\n  }\n}\nvar is = Object.defineProperty,\n  rs = Object.defineProperties,\n  ns = Object.getOwnPropertyDescriptors,\n  Ue = Object.getOwnPropertySymbols,\n  as = Object.prototype.hasOwnProperty,\n  cs = Object.prototype.propertyIsEnumerable,\n  T = (s, e, t) => e in s ? is(s, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : s[e] = t,\n  ee = (s, e) => {\n    for (var t in e || (e = {})) as.call(e, t) && T(s, t, e[t]);\n    if (Ue) for (var t of Ue(e)) cs.call(e, t) && T(s, t, e[t]);\n    return s;\n  },\n  te = (s, e) => rs(s, ns(e)),\n  I = (s, e, t) => T(s, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass os {\n  constructor(e) {\n    I(this, \"name\", \"eip155\"), I(this, \"client\"), I(this, \"chainId\"), I(this, \"namespace\"), I(this, \"httpProviders\"), I(this, \"events\"), I(this, \"storage\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain()), this.storage = re.getStorage(this.client.core.storage);\n  }\n  async request(e) {\n    switch (e.request.method) {\n      case \"eth_requestAccounts\":\n        return this.getAccounts();\n      case \"eth_accounts\":\n        return this.getAccounts();\n      case \"wallet_switchEthereumChain\":\n        return await this.handleSwitchChain(e);\n      case \"eth_chainId\":\n        return parseInt(this.getDefaultChain());\n      case \"wallet_getCapabilities\":\n        return await this.getCapabilities(e);\n      case \"wallet_getCallsStatus\":\n        return await this.getCallStatus(e);\n      case \"wallet_sendCalls\":\n        return await this.sendCalls(e);\n    }\n    return this.namespace.methods.includes(e.request.method) ? await this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  setDefaultChain(e, t) {\n    this.httpProviders[e] || this.setHttpProvider(parseInt(e), t), this.chainId = parseInt(e), this.events.emit(m.DEFAULT_CHAIN_CHANGED, \"\".concat(this.name, \":\").concat(e));\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId.toString();\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  createHttpProvider(e, t) {\n    const i = t || f(\"\".concat(this.name, \":\").concat(e), this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(\"No RPC url provided for chainId: \".concat(e));\n    return new g(new ze(i, h(\"disableProviderPing\")));\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      var i;\n      const n = parseInt(b(t));\n      e[n] = this.createHttpProvider(n, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);\n    }), e;\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? [...new Set(e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]))] : [];\n  }\n  getHttpProvider(e) {\n    const t = e || this.chainId;\n    return this.httpProviders[t] || (this.httpProviders = te(ee({}, this.httpProviders), {\n      [t]: this.createHttpProvider(t)\n    }), this.httpProviders[t]);\n  }\n  async handleSwitchChain(e) {\n    var t, i;\n    let n = e.request.params ? (t = e.request.params[0]) == null ? void 0 : t.chainId : \"0x0\";\n    n = n.startsWith(\"0x\") ? n : \"0x\".concat(n);\n    const a = parseInt(n, 16);\n    if (this.isChainApproved(a)) this.setDefaultChain(\"\".concat(a));else if (this.namespace.methods.includes(\"wallet_switchEthereumChain\")) await this.client.request({\n      topic: e.topic,\n      request: {\n        method: e.request.method,\n        params: [{\n          chainId: n\n        }]\n      },\n      chainId: (i = this.namespace.chains) == null ? void 0 : i[0]\n    }), this.setDefaultChain(\"\".concat(a));else throw new Error(\"Failed to switch to chain 'eip155:\".concat(a, \"'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.\"));\n    return null;\n  }\n  isChainApproved(e) {\n    return this.namespace.chains.includes(\"\".concat(this.name, \":\").concat(e));\n  }\n  async getCapabilities(e) {\n    var t, i, n, a, r;\n    const c = (i = (t = e.request) == null ? void 0 : t.params) == null ? void 0 : i[0],\n      o = ((a = (n = e.request) == null ? void 0 : n.params) == null ? void 0 : a[1]) || [];\n    if (!c) throw new Error(\"Missing address parameter in `wallet_getCapabilities` request\");\n    const d = this.client.session.get(e.topic),\n      u = ((r = d === null || d === void 0 ? void 0 : d.sessionProperties) == null ? void 0 : r.capabilities) || {},\n      p = \"\".concat(c).concat(o.join(\",\")),\n      w = u === null || u === void 0 ? void 0 : u[p];\n    if (w) return w;\n    let l;\n    try {\n      l = xt(d, c, o);\n    } catch (z) {\n      console.warn(\"Failed to extract capabilities from session\", z);\n    }\n    if (l) return l;\n    const ne = await this.client.request(e);\n    try {\n      await this.client.session.update(e.topic, {\n        sessionProperties: te(ee({}, d.sessionProperties || {}), {\n          capabilities: te(ee({}, u || {}), {\n            [p]: ne\n          })\n        })\n      });\n    } catch (z) {\n      console.warn(\"Failed to update session with capabilities\", z);\n    }\n    return ne;\n  }\n  async getCallStatus(e) {\n    var t, i, n;\n    const a = this.client.session.get(e.topic),\n      r = (t = a.sessionProperties) == null ? void 0 : t.bundler_name;\n    if (r) {\n      const d = this.getBundlerUrl(e.chainId, r);\n      try {\n        return await this.getUserOperationReceipt(d, e);\n      } catch (u) {\n        console.warn(\"Failed to fetch call status from bundler\", u, d);\n      }\n    }\n    const c = (i = a.sessionProperties) == null ? void 0 : i.bundler_url;\n    if (c) try {\n      return await this.getUserOperationReceipt(c, e);\n    } catch (d) {\n      console.warn(\"Failed to fetch call status from custom bundler\", d, c);\n    }\n    const o = await Tt({\n      resultId: (n = e.request.params) == null ? void 0 : n[0],\n      storage: this.storage\n    });\n    if (o) try {\n      return await Yt(o, this.getHttpProvider.bind(this));\n    } catch (d) {\n      console.warn(\"Failed to fetch call status from stored send calls\", d, o);\n    }\n    if (this.namespace.methods.includes(e.request.method)) return await this.client.request(e);\n    throw new Error(\"Fetching call status not approved by the wallet.\");\n  }\n  async getUserOperationReceipt(e, t) {\n    var i;\n    const n = new URL(e),\n      a = await fetch(n, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(he(\"eth_getUserOperationReceipt\", [(i = t.request.params) == null ? void 0 : i[0]]))\n      });\n    if (!a.ok) throw new Error(\"Failed to fetch user operation receipt - \".concat(a.status));\n    return await a.json();\n  }\n  getBundlerUrl(e, t) {\n    return \"\".concat(Ye, \"?projectId=\").concat(this.client.core.projectId, \"&chainId=\").concat(e, \"&bundler=\").concat(t);\n  }\n  async sendCalls(e) {\n    var t, i, n;\n    const a = await this.client.request(e),\n      r = (t = e.request.params) == null ? void 0 : t[0],\n      c = a === null || a === void 0 ? void 0 : a.id,\n      o = (a === null || a === void 0 ? void 0 : a.capabilities) || {},\n      d = (i = o === null || o === void 0 ? void 0 : o.caip345) == null ? void 0 : i.caip2,\n      u = (n = o === null || o === void 0 ? void 0 : o.caip345) == null ? void 0 : n.transactionHashes;\n    return !c || !d || !(u != null && u.length) || (await Qt({\n      sendCalls: {\n        request: r,\n        result: a\n      },\n      storage: this.storage\n    })), a;\n  }\n}\nvar hs = Object.defineProperty,\n  ps = (s, e, t) => e in s ? hs(s, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : s[e] = t,\n  A = (s, e, t) => ps(s, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass ds {\n  constructor(e) {\n    A(this, \"name\", \"solana\"), A(this, \"client\"), A(this, \"httpProviders\"), A(this, \"events\"), A(this, \"namespace\"), A(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(m.DEFAULT_CHAIN_CHANGED, \"\".concat(this.name, \":\").concat(e));\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? [...new Set(e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      var i;\n      const n = b(t);\n      e[n] = this.createHttpProvider(n, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = \"\".concat(this.name, \":\").concat(this.chainId),\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(\"JSON-RPC provider for \".concat(e, \" not found\"));\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || f(e, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(\"No RPC url provided for chainId: \".concat(e));\n    return new g(new P(i, h(\"disableProviderPing\")));\n  }\n}\nvar us = Object.defineProperty,\n  ls = (s, e, t) => e in s ? us(s, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : s[e] = t,\n  E = (s, e, t) => ls(s, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass fs {\n  constructor(e) {\n    E(this, \"name\", \"cosmos\"), E(this, \"client\"), E(this, \"httpProviders\"), E(this, \"events\"), E(this, \"namespace\"), E(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(m.DEFAULT_CHAIN_CHANGED, \"\".concat(this.name, \":\").concat(this.chainId));\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? [...new Set(e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      var i;\n      const n = b(t);\n      e[n] = this.createHttpProvider(n, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = \"\".concat(this.name, \":\").concat(this.chainId),\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(\"JSON-RPC provider for \".concat(e, \" not found\"));\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || f(e, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(\"No RPC url provided for chainId: \".concat(e));\n    return new g(new P(i, h(\"disableProviderPing\")));\n  }\n}\nvar ms = Object.defineProperty,\n  vs = (s, e, t) => e in s ? ms(s, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : s[e] = t,\n  H = (s, e, t) => vs(s, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass gs {\n  constructor(e) {\n    H(this, \"name\", \"algorand\"), H(this, \"client\"), H(this, \"httpProviders\"), H(this, \"events\"), H(this, \"namespace\"), H(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    if (!this.httpProviders[e]) {\n      const i = t || f(\"\".concat(this.name, \":\").concat(e), this.namespace, this.client.core.projectId);\n      if (!i) throw new Error(\"No RPC url provided for chainId: \".concat(e));\n      this.setHttpProvider(e, i);\n    }\n    this.chainId = e, this.events.emit(m.DEFAULT_CHAIN_CHANGED, \"\".concat(this.name, \":\").concat(this.chainId));\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? [...new Set(e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      var i;\n      e[t] = this.createHttpProvider(t, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = \"\".concat(this.name, \":\").concat(this.chainId),\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(\"JSON-RPC provider for \".concat(e, \" not found\"));\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || f(e, this.namespace, this.client.core.projectId);\n    return typeof i > \"u\" ? void 0 : new g(new P(i, h(\"disableProviderPing\")));\n  }\n}\nvar Ps = Object.defineProperty,\n  ws = (s, e, t) => e in s ? Ps(s, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : s[e] = t,\n  S = (s, e, t) => ws(s, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass ys {\n  constructor(e) {\n    S(this, \"name\", \"cip34\"), S(this, \"client\"), S(this, \"httpProviders\"), S(this, \"events\"), S(this, \"namespace\"), S(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(m.DEFAULT_CHAIN_CHANGED, \"\".concat(this.name, \":\").concat(this.chainId));\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? [...new Set(e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      const i = this.getCardanoRPCUrl(t),\n        n = b(t);\n      e[n] = this.createHttpProvider(n, i);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = \"\".concat(this.name, \":\").concat(this.chainId),\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(\"JSON-RPC provider for \".concat(e, \" not found\"));\n    return t;\n  }\n  getCardanoRPCUrl(e) {\n    const t = this.namespace.rpcMap;\n    if (t) return t[e];\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || this.getCardanoRPCUrl(e);\n    if (!i) throw new Error(\"No RPC url provided for chainId: \".concat(e));\n    return new g(new P(i, h(\"disableProviderPing\")));\n  }\n}\nvar bs = Object.defineProperty,\n  Is = (s, e, t) => e in s ? bs(s, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : s[e] = t,\n  N = (s, e, t) => Is(s, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass $s {\n  constructor(e) {\n    N(this, \"name\", \"elrond\"), N(this, \"client\"), N(this, \"httpProviders\"), N(this, \"events\"), N(this, \"namespace\"), N(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(m.DEFAULT_CHAIN_CHANGED, \"\".concat(this.name, \":\").concat(e));\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? [...new Set(e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      var i;\n      const n = b(t);\n      e[n] = this.createHttpProvider(n, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = \"\".concat(this.name, \":\").concat(this.chainId),\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(\"JSON-RPC provider for \".concat(e, \" not found\"));\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || f(e, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(\"No RPC url provided for chainId: \".concat(e));\n    return new g(new P(i, h(\"disableProviderPing\")));\n  }\n}\nvar Os = Object.defineProperty,\n  Cs = (s, e, t) => e in s ? Os(s, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : s[e] = t,\n  q = (s, e, t) => Cs(s, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass As {\n  constructor(e) {\n    q(this, \"name\", \"multiversx\"), q(this, \"client\"), q(this, \"httpProviders\"), q(this, \"events\"), q(this, \"namespace\"), q(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(m.DEFAULT_CHAIN_CHANGED, \"\".concat(this.name, \":\").concat(e));\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? [...new Set(e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      var i;\n      const n = b(t);\n      e[n] = this.createHttpProvider(n, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = \"\".concat(this.name, \":\").concat(this.chainId),\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(\"JSON-RPC provider for \".concat(e, \" not found\"));\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || f(e, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(\"No RPC url provided for chainId: \".concat(e));\n    return new g(new P(i, h(\"disableProviderPing\")));\n  }\n}\nvar Es = Object.defineProperty,\n  Hs = (s, e, t) => e in s ? Es(s, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : s[e] = t,\n  D = (s, e, t) => Hs(s, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass Ss {\n  constructor(e) {\n    D(this, \"name\", \"near\"), D(this, \"client\"), D(this, \"httpProviders\"), D(this, \"events\"), D(this, \"namespace\"), D(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    if (this.chainId = e, !this.httpProviders[e]) {\n      const i = t || f(\"\".concat(this.name, \":\").concat(e), this.namespace);\n      if (!i) throw new Error(\"No RPC url provided for chainId: \".concat(e));\n      this.setHttpProvider(e, i);\n    }\n    this.events.emit(m.DEFAULT_CHAIN_CHANGED, \"\".concat(this.name, \":\").concat(this.chainId));\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]) || [] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      var i;\n      e[t] = this.createHttpProvider(t, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = \"\".concat(this.name, \":\").concat(this.chainId),\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(\"JSON-RPC provider for \".concat(e, \" not found\"));\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || f(e, this.namespace);\n    return typeof i > \"u\" ? void 0 : new g(new P(i, h(\"disableProviderPing\")));\n  }\n}\nvar Ns = Object.defineProperty,\n  qs = (s, e, t) => e in s ? Ns(s, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : s[e] = t,\n  j = (s, e, t) => qs(s, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass Ds {\n  constructor(e) {\n    j(this, \"name\", \"tezos\"), j(this, \"client\"), j(this, \"httpProviders\"), j(this, \"events\"), j(this, \"namespace\"), j(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);\n  }\n  setDefaultChain(e, t) {\n    if (this.chainId = e, !this.httpProviders[e]) {\n      const i = t || f(\"\".concat(this.name, \":\").concat(e), this.namespace);\n      if (!i) throw new Error(\"No RPC url provided for chainId: \".concat(e));\n      this.setHttpProvider(e, i);\n    }\n    this.events.emit(m.DEFAULT_CHAIN_CHANGED, \"\".concat(this.name, \":\").concat(this.chainId));\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]) || [] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      e[t] = this.createHttpProvider(t);\n    }), e;\n  }\n  getHttpProvider() {\n    const e = \"\".concat(this.name, \":\").concat(this.chainId),\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(\"JSON-RPC provider for \".concat(e, \" not found\"));\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || f(e, this.namespace);\n    return typeof i > \"u\" ? void 0 : new g(new P(i));\n  }\n}\nvar js = Object.defineProperty,\n  Rs = (s, e, t) => e in s ? js(s, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : s[e] = t,\n  R = (s, e, t) => Rs(s, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass _s {\n  constructor(e) {\n    R(this, \"name\", ue), R(this, \"client\"), R(this, \"httpProviders\"), R(this, \"events\"), R(this, \"namespace\"), R(this, \"chainId\"), this.namespace = e.namespace, this.events = h(\"events\"), this.client = h(\"client\"), this.chainId = this.getDefaultChain(), this.name = this.getNamespaceName(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace.chains = [...new Set((this.namespace.chains || []).concat(e.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(e.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(e.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(e.events || []))], this.httpProviders = this.createHttpProviders();\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider(e.chainId).request(e.request);\n  }\n  setDefaultChain(e, t) {\n    this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(m.DEFAULT_CHAIN_CHANGED, \"\".concat(this.name, \":\").concat(e));\n  }\n  getDefaultChain() {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  getNamespaceName() {\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return U(e).namespace;\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? [...new Set(e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]))] : [];\n  }\n  createHttpProviders() {\n    var e, t;\n    const i = {};\n    return (t = (e = this.namespace) == null ? void 0 : e.accounts) == null || t.forEach(n => {\n      const a = U(n);\n      i[a.reference] = this.createHttpProvider(n);\n    }), i;\n  }\n  getHttpProvider(e) {\n    const t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(\"JSON-RPC provider for \".concat(e, \" not found\"));\n    return t;\n  }\n  setHttpProvider(e, t) {\n    const i = this.createHttpProvider(e, t);\n    i && (this.httpProviders[e] = i);\n  }\n  createHttpProvider(e, t) {\n    const i = t || f(e, this.namespace, this.client.core.projectId);\n    if (!i) throw new Error(\"No RPC url provided for chainId: \".concat(e));\n    return new g(new P(i, h(\"disableProviderPing\")));\n  }\n}\nvar Fs = Object.defineProperty,\n  Us = Object.defineProperties,\n  xs = Object.getOwnPropertyDescriptors,\n  xe = Object.getOwnPropertySymbols,\n  Ls = Object.prototype.hasOwnProperty,\n  Ms = Object.prototype.propertyIsEnumerable,\n  se = (s, e, t) => e in s ? Fs(s, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : s[e] = t,\n  G = (s, e) => {\n    for (var t in e || (e = {})) Ls.call(e, t) && se(s, t, e[t]);\n    if (xe) for (var t of xe(e)) Ms.call(e, t) && se(s, t, e[t]);\n    return s;\n  },\n  ie = (s, e) => Us(s, xs(e)),\n  v = (s, e, t) => se(s, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass J {\n  constructor(e) {\n    v(this, \"client\"), v(this, \"namespaces\"), v(this, \"optionalNamespaces\"), v(this, \"sessionProperties\"), v(this, \"scopedProperties\"), v(this, \"events\", new ke()), v(this, \"rpcProviders\", {}), v(this, \"session\"), v(this, \"providerOpts\"), v(this, \"logger\"), v(this, \"uri\"), v(this, \"disableProviderPing\", !1), this.providerOpts = e, this.logger = typeof (e === null || e === void 0 ? void 0 : e.logger) < \"u\" && typeof (e === null || e === void 0 ? void 0 : e.logger) != \"string\" ? e.logger : Be(Ge({\n      level: (e === null || e === void 0 ? void 0 : e.logger) || pe\n    })), this.disableProviderPing = (e === null || e === void 0 ? void 0 : e.disableProviderPing) || !1;\n  }\n  static async init(e) {\n    const t = new J(e);\n    return await t.initialize(), t;\n  }\n  async request(e, t, i) {\n    const [n, a] = this.validateChain(t);\n    if (!this.session) throw new Error(\"Please call connect() before request()\");\n    return await this.getProvider(n).request({\n      request: G({}, e),\n      chainId: \"\".concat(n, \":\").concat(a),\n      topic: this.session.topic,\n      expiry: i\n    });\n  }\n  sendAsync(e, t, i, n) {\n    const a = new Date().getTime();\n    this.request(e, i, n).then(r => t(null, Je(a, r))).catch(r => t(r, void 0));\n  }\n  async enable() {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    return this.session || (await this.connect({\n      namespaces: this.namespaces,\n      optionalNamespaces: this.optionalNamespaces,\n      sessionProperties: this.sessionProperties,\n      scopedProperties: this.scopedProperties\n    })), await this.requestAccounts();\n  }\n  async disconnect() {\n    var e;\n    if (!this.session) throw new Error(\"Please call connect() before enable()\");\n    await this.client.disconnect({\n      topic: (e = this.session) == null ? void 0 : e.topic,\n      reason: oe(\"USER_DISCONNECTED\")\n    }), await this.cleanup();\n  }\n  async connect(e) {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    if (this.setNamespaces(e), this.cleanupPendingPairings(), !e.skipPairing) return await this.pair(e.pairingTopic);\n  }\n  async authenticate(e, t) {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    this.setNamespaces(e), await this.cleanupPendingPairings();\n    const {\n      uri: i,\n      response: n\n    } = await this.client.authenticate(e, t);\n    i && (this.uri = i, this.events.emit(\"display_uri\", i));\n    const a = await n();\n    if (this.session = a.session, this.session) {\n      const r = He(this.session.namespaces);\n      this.namespaces = B(this.namespaces, r), await this.persist(\"namespaces\", this.namespaces), this.onConnect();\n    }\n    return a;\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  get isWalletConnect() {\n    return !0;\n  }\n  async pair(e) {\n    const {\n      uri: t,\n      approval: i\n    } = await this.client.connect({\n      pairingTopic: e,\n      requiredNamespaces: this.namespaces,\n      optionalNamespaces: this.optionalNamespaces,\n      sessionProperties: this.sessionProperties,\n      scopedProperties: this.scopedProperties\n    });\n    t && (this.uri = t, this.events.emit(\"display_uri\", t));\n    const n = await i();\n    this.session = n;\n    const a = He(n.namespaces);\n    return this.namespaces = B(this.namespaces, a), await this.persist(\"namespaces\", this.namespaces), await this.persist(\"optionalNamespaces\", this.optionalNamespaces), this.onConnect(), this.session;\n  }\n  setDefaultChain(e, t) {\n    try {\n      if (!this.session) return;\n      const [i, n] = this.validateChain(e);\n      this.getProvider(i).setDefaultChain(n, t);\n    } catch (i) {\n      if (!/Please call connect/.test(i.message)) throw i;\n    }\n  }\n  async cleanupPendingPairings() {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    try {\n      this.logger.info(\"Cleaning up inactive pairings...\");\n      const t = this.client.pairing.getAll();\n      if (!W(t)) return;\n      for (const i of t) e.deletePairings ? this.client.core.expirer.set(i.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(i.topic);\n      this.logger.info(\"Inactive pairings cleared: \".concat(t.length));\n    } catch (t) {\n      this.logger.warn(\"Failed to cleanup pending pairings\", t);\n    }\n  }\n  abortPairingAttempt() {\n    this.logger.warn(\"abortPairingAttempt is deprecated. This is now a no-op.\");\n  }\n  async checkStorage() {\n    this.namespaces = (await this.getFromStore(\"namespaces\")) || {}, this.optionalNamespaces = (await this.getFromStore(\"optionalNamespaces\")) || {}, this.session && this.createProviders();\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();\n  }\n  async createClient() {\n    var e, t;\n    if (this.client = this.providerOpts.client || (await Le.init({\n      core: this.providerOpts.core,\n      logger: this.providerOpts.logger || pe,\n      relayUrl: this.providerOpts.relayUrl || We,\n      projectId: this.providerOpts.projectId,\n      metadata: this.providerOpts.metadata,\n      storageOptions: this.providerOpts.storageOptions,\n      storage: this.providerOpts.storage,\n      name: this.providerOpts.name,\n      customStoragePrefix: this.providerOpts.customStoragePrefix,\n      telemetryEnabled: this.providerOpts.telemetryEnabled\n    })), this.providerOpts.session) try {\n      this.session = this.client.session.get(this.providerOpts.session.topic);\n    } catch (i) {\n      throw this.logger.error(\"Failed to get session\", i), new Error(\"The provided session: \".concat((t = (e = this.providerOpts) == null ? void 0 : e.session) == null ? void 0 : t.topic, \" doesn't exist in the Sign client\"));\n    } else {\n      const i = this.client.session.getAll();\n      this.session = i[0];\n    }\n    this.logger.trace(\"SignClient Initialized\");\n  }\n  createProviders() {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    if (!this.session) throw new Error(\"Session not initialized. Please call connect() before enable()\");\n    const e = [...new Set(Object.keys(this.session.namespaces).map(t => F(t)))];\n    X(\"client\", this.client), X(\"events\", this.events), X(\"disableProviderPing\", this.disableProviderPing), e.forEach(t => {\n      if (!this.session) return;\n      const i = Nt(t, this.session);\n      if ((i === null || i === void 0 ? void 0 : i.length) === 0) return;\n      const n = Oe(i),\n        a = B(this.namespaces, this.optionalNamespaces),\n        r = ie(G({}, a[t]), {\n          accounts: i,\n          chains: n\n        });\n      switch (t) {\n        case \"eip155\":\n          this.rpcProviders[t] = new os({\n            namespace: r\n          });\n          break;\n        case \"algorand\":\n          this.rpcProviders[t] = new gs({\n            namespace: r\n          });\n          break;\n        case \"solana\":\n          this.rpcProviders[t] = new ds({\n            namespace: r\n          });\n          break;\n        case \"cosmos\":\n          this.rpcProviders[t] = new fs({\n            namespace: r\n          });\n          break;\n        case \"polkadot\":\n          this.rpcProviders[t] = new ss({\n            namespace: r\n          });\n          break;\n        case \"cip34\":\n          this.rpcProviders[t] = new ys({\n            namespace: r\n          });\n          break;\n        case \"elrond\":\n          this.rpcProviders[t] = new $s({\n            namespace: r\n          });\n          break;\n        case \"multiversx\":\n          this.rpcProviders[t] = new As({\n            namespace: r\n          });\n          break;\n        case \"near\":\n          this.rpcProviders[t] = new Ss({\n            namespace: r\n          });\n          break;\n        case \"tezos\":\n          this.rpcProviders[t] = new Ds({\n            namespace: r\n          });\n          break;\n        default:\n          this.rpcProviders[t] = new _s({\n            namespace: r\n          });\n      }\n    });\n  }\n  registerEventListeners() {\n    if (typeof this.client > \"u\") throw new Error(\"Sign Client is not initialized\");\n    this.client.on(\"session_ping\", e => {\n      var t;\n      const {\n        topic: i\n      } = e;\n      i === ((t = this.session) == null ? void 0 : t.topic) && this.events.emit(\"session_ping\", e);\n    }), this.client.on(\"session_event\", e => {\n      var t;\n      const {\n        params: i,\n        topic: n\n      } = e;\n      if (n !== ((t = this.session) == null ? void 0 : t.topic)) return;\n      const {\n        event: a\n      } = i;\n      if (a.name === \"accountsChanged\") {\n        const r = a.data;\n        r && W(r) && this.events.emit(\"accountsChanged\", r.map(Ee));\n      } else if (a.name === \"chainChanged\") {\n        const r = i.chainId,\n          c = i.event.data,\n          o = F(r),\n          d = Y(r) !== Y(c) ? \"\".concat(o, \":\").concat(Y(c)) : r;\n        this.onChainChanged(d);\n      } else this.events.emit(a.name, a.data);\n      this.events.emit(\"session_event\", e);\n    }), this.client.on(\"session_update\", _ref5 => {\n      let {\n        topic: e,\n        params: t\n      } = _ref5;\n      var i, n;\n      if (e !== ((i = this.session) == null ? void 0 : i.topic)) return;\n      const {\n          namespaces: a\n        } = t,\n        r = (n = this.client) == null ? void 0 : n.session.get(e);\n      this.session = ie(G({}, r), {\n        namespaces: a\n      }), this.onSessionUpdate(), this.events.emit(\"session_update\", {\n        topic: e,\n        params: t\n      });\n    }), this.client.on(\"session_delete\", async e => {\n      var t;\n      e.topic === ((t = this.session) == null ? void 0 : t.topic) && (await this.cleanup(), this.events.emit(\"session_delete\", e), this.events.emit(\"disconnect\", ie(G({}, oe(\"USER_DISCONNECTED\")), {\n        data: e.topic\n      })));\n    }), this.on(m.DEFAULT_CHAIN_CHANGED, e => {\n      this.onChainChanged(e, !0);\n    });\n  }\n  getProvider(e) {\n    return this.rpcProviders[e] || this.rpcProviders[ue];\n  }\n  onSessionUpdate() {\n    Object.keys(this.rpcProviders).forEach(e => {\n      var t;\n      this.getProvider(e).updateNamespace((t = this.session) == null ? void 0 : t.namespaces[e]);\n    });\n  }\n  setNamespaces(e) {\n    const {\n      namespaces: t = {},\n      optionalNamespaces: i = {},\n      sessionProperties: n,\n      scopedProperties: a\n    } = e;\n    this.optionalNamespaces = B(t, i), this.sessionProperties = n, this.scopedProperties = a;\n  }\n  validateChain(e) {\n    const [t, i] = (e === null || e === void 0 ? void 0 : e.split(\":\")) || [\"\", \"\"];\n    if (!this.namespaces || !Object.keys(this.namespaces).length) return [t, i];\n    if (t && !Object.keys(this.namespaces || {}).map(r => F(r)).includes(t)) throw new Error(\"Namespace '\".concat(t, \"' is not configured. Please call connect() first with namespace config.\"));\n    if (t && i) return [t, i];\n    const n = F(Object.keys(this.namespaces)[0]),\n      a = this.rpcProviders[n].getDefaultChain();\n    return [n, a];\n  }\n  async requestAccounts() {\n    const [e] = this.validateChain();\n    return await this.getProvider(e).requestAccounts();\n  }\n  async onChainChanged(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n    if (!this.namespaces) return;\n    const [i, n] = this.validateChain(e);\n    if (!n) return;\n    this.updateNamespaceChain(i, n);\n    const a = this.getProvider(i).getDefaultChain();\n    t ? (this.events.emit(\"chainChanged\", n), this.emitAccountsChangedOnChainChange({\n      namespace: i,\n      previousChainId: a,\n      newChainId: e\n    })) : this.getProvider(i).setDefaultChain(n), await this.persist(\"namespaces\", this.namespaces);\n  }\n  emitAccountsChangedOnChainChange(_ref6) {\n    let {\n      namespace: e,\n      previousChainId: t,\n      newChainId: i\n    } = _ref6;\n    var n, a;\n    try {\n      if (t === i) return;\n      const r = (a = (n = this.session) == null ? void 0 : n.namespaces[e]) == null ? void 0 : a.accounts;\n      if (!r) return;\n      const c = r.filter(o => o.includes(\"\".concat(i, \":\"))).map(Ee);\n      if (!W(c)) return;\n      this.events.emit(\"accountsChanged\", c);\n    } catch (r) {\n      this.logger.warn(\"Failed to emit accountsChanged on chain change\", r);\n    }\n  }\n  updateNamespaceChain(e, t) {\n    if (!this.namespaces) return;\n    const i = this.namespaces[e] ? e : \"\".concat(e, \":\").concat(t),\n      n = {\n        chains: [],\n        methods: [],\n        events: [],\n        defaultChain: t\n      };\n    this.namespaces[i] ? this.namespaces[i] && (this.namespaces[i].defaultChain = t) : this.namespaces[i] = n;\n  }\n  onConnect() {\n    this.createProviders(), this.events.emit(\"connect\", {\n      session: this.session\n    });\n  }\n  async cleanup() {\n    this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, await this.deleteFromStore(\"namespaces\"), await this.deleteFromStore(\"optionalNamespaces\"), await this.deleteFromStore(\"sessionProperties\"), this.session = void 0, this.cleanupPendingPairings({\n      deletePairings: !0\n    }), await this.cleanupStorage();\n  }\n  async persist(e, t) {\n    var i;\n    const n = ((i = this.session) == null ? void 0 : i.topic) || \"\";\n    await this.client.core.storage.setItem(\"\".concat(x, \"/\").concat(e).concat(n), t);\n  }\n  async getFromStore(e) {\n    var t;\n    const i = ((t = this.session) == null ? void 0 : t.topic) || \"\";\n    return await this.client.core.storage.getItem(\"\".concat(x, \"/\").concat(e).concat(i));\n  }\n  async deleteFromStore(e) {\n    var t;\n    const i = ((t = this.session) == null ? void 0 : t.topic) || \"\";\n    await this.client.core.storage.removeItem(\"\".concat(x, \"/\").concat(e).concat(i));\n  }\n  async cleanupStorage() {\n    var e;\n    try {\n      if (((e = this.client) == null ? void 0 : e.session.length) > 0) return;\n      const t = await this.client.core.storage.getKeys();\n      for (const i of t) i.startsWith(x) && (await this.client.core.storage.removeItem(i));\n    } catch (t) {\n      this.logger.warn(\"Failed to cleanup storage\", t);\n    }\n  }\n}\nconst Bs = J;\nexport { Bs as UniversalProvider, J as default };","map":{"version":3,"names":[],"sources":["/home/user/Arbitrage/frontend/node_modules/@walletconnect/universal-provider/src/constants/values.ts","/home/user/Arbitrage/frontend/node_modules/@walletconnect/universal-provider/src/constants/events.ts","/home/user/Arbitrage/frontend/node_modules/node_modules/es-toolkit/dist/predicate/isPrimitive.mjs","/home/user/Arbitrage/frontend/node_modules/node_modules/es-toolkit/dist/compat/_internal/getSymbols.mjs","/home/user/Arbitrage/frontend/node_modules/node_modules/es-toolkit/dist/compat/_internal/getTag.mjs","/home/user/Arbitrage/frontend/node_modules/node_modules/es-toolkit/dist/compat/_internal/tags.mjs","/home/user/Arbitrage/frontend/node_modules/node_modules/es-toolkit/dist/predicate/isTypedArray.mjs","/home/user/Arbitrage/frontend/node_modules/node_modules/es-toolkit/dist/object/cloneDeepWith.mjs","/home/user/Arbitrage/frontend/node_modules/node_modules/es-toolkit/dist/compat/object/cloneDeepWith.mjs","/home/user/Arbitrage/frontend/node_modules/node_modules/es-toolkit/dist/compat/object/cloneDeep.mjs","/home/user/Arbitrage/frontend/node_modules/node_modules/es-toolkit/dist/compat/predicate/isArguments.mjs","/home/user/Arbitrage/frontend/node_modules/node_modules/es-toolkit/dist/compat/predicate/isObjectLike.mjs","/home/user/Arbitrage/frontend/node_modules/node_modules/es-toolkit/dist/function/noop.mjs","/home/user/Arbitrage/frontend/node_modules/node_modules/es-toolkit/dist/compat/predicate/isTypedArray.mjs","/home/user/Arbitrage/frontend/node_modules/node_modules/es-toolkit/dist/compat/predicate/isPlainObject.mjs","/home/user/Arbitrage/frontend/node_modules/node_modules/es-toolkit/dist/object/clone.mjs","/home/user/Arbitrage/frontend/node_modules/node_modules/es-toolkit/dist/compat/object/mergeWith.mjs","/home/user/Arbitrage/frontend/node_modules/node_modules/es-toolkit/dist/compat/object/merge.mjs","/home/user/Arbitrage/frontend/node_modules/@walletconnect/universal-provider/src/utils/misc.ts","/home/user/Arbitrage/frontend/node_modules/@walletconnect/universal-provider/src/utils/globals.ts","/home/user/Arbitrage/frontend/node_modules/@walletconnect/universal-provider/src/utils/caip25.ts","/home/user/Arbitrage/frontend/node_modules/@walletconnect/universal-provider/src/utils/storage.ts","/home/user/Arbitrage/frontend/node_modules/@walletconnect/universal-provider/src/utils/eip5792.ts","/home/user/Arbitrage/frontend/node_modules/@walletconnect/universal-provider/src/providers/polkadot.ts","/home/user/Arbitrage/frontend/node_modules/@walletconnect/universal-provider/src/providers/eip155.ts","/home/user/Arbitrage/frontend/node_modules/@walletconnect/universal-provider/src/providers/solana.ts","/home/user/Arbitrage/frontend/node_modules/@walletconnect/universal-provider/src/providers/cosmos.ts","/home/user/Arbitrage/frontend/node_modules/@walletconnect/universal-provider/src/providers/algorand.ts","/home/user/Arbitrage/frontend/node_modules/@walletconnect/universal-provider/src/providers/cardano.ts","/home/user/Arbitrage/frontend/node_modules/@walletconnect/universal-provider/src/providers/elrond.ts","/home/user/Arbitrage/frontend/node_modules/@walletconnect/universal-provider/src/providers/multiversx.ts","/home/user/Arbitrage/frontend/node_modules/@walletconnect/universal-provider/src/providers/near.ts","/home/user/Arbitrage/frontend/node_modules/@walletconnect/universal-provider/src/providers/tezos.ts","/home/user/Arbitrage/frontend/node_modules/@walletconnect/universal-provider/src/providers/generic.ts","/home/user/Arbitrage/frontend/node_modules/@walletconnect/universal-provider/src/UniversalProvider.ts","/home/user/Arbitrage/frontend/node_modules/@walletconnect/universal-provider/src/index.ts"],"sourcesContent":["export const LOGGER = \"error\";\n\nexport const RELAY_URL = \"wss://relay.walletconnect.org\";\n\nexport const PROTOCOL = \"wc\";\nexport const WC_VERSION = 2;\nexport const CONTEXT = \"universal_provider\";\n\nexport const STORAGE = `${PROTOCOL}@${WC_VERSION}:${CONTEXT}:`;\n\nexport const RPC_URL = \"https://rpc.walletconnect.org/v1/\";\n\nexport const GENERIC_SUBPROVIDER_NAME = \"generic\";\n\nexport const BUNDLER_URL = `${RPC_URL}bundler`;\n\nexport const CALL_STATUS_STORAGE_KEY = \"call_status\";\n\nexport const CALL_STATUS_RESULT_EXPIRY = 86400; // 24 hours in seconds\n","export const PROVIDER_EVENTS = {\n  DEFAULT_CHAIN_CHANGED: \"default_chain_changed\",\n};\n","function isPrimitive(value) {\n    return value == null || (typeof value !== 'object' && typeof value !== 'function');\n}\n\nexport { isPrimitive };\n","function getSymbols(object) {\n    return Object.getOwnPropertySymbols(object).filter(symbol => Object.prototype.propertyIsEnumerable.call(object, symbol));\n}\n\nexport { getSymbols };\n","function getTag(value) {\n    if (value == null) {\n        return value === undefined ? '[object Undefined]' : '[object Null]';\n    }\n    return Object.prototype.toString.call(value);\n}\n\nexport { getTag };\n","const regexpTag = '[object RegExp]';\nconst stringTag = '[object String]';\nconst numberTag = '[object Number]';\nconst booleanTag = '[object Boolean]';\nconst argumentsTag = '[object Arguments]';\nconst symbolTag = '[object Symbol]';\nconst dateTag = '[object Date]';\nconst mapTag = '[object Map]';\nconst setTag = '[object Set]';\nconst arrayTag = '[object Array]';\nconst functionTag = '[object Function]';\nconst arrayBufferTag = '[object ArrayBuffer]';\nconst objectTag = '[object Object]';\nconst errorTag = '[object Error]';\nconst dataViewTag = '[object DataView]';\nconst uint8ArrayTag = '[object Uint8Array]';\nconst uint8ClampedArrayTag = '[object Uint8ClampedArray]';\nconst uint16ArrayTag = '[object Uint16Array]';\nconst uint32ArrayTag = '[object Uint32Array]';\nconst bigUint64ArrayTag = '[object BigUint64Array]';\nconst int8ArrayTag = '[object Int8Array]';\nconst int16ArrayTag = '[object Int16Array]';\nconst int32ArrayTag = '[object Int32Array]';\nconst bigInt64ArrayTag = '[object BigInt64Array]';\nconst float32ArrayTag = '[object Float32Array]';\nconst float64ArrayTag = '[object Float64Array]';\n\nexport { argumentsTag, arrayBufferTag, arrayTag, bigInt64ArrayTag, bigUint64ArrayTag, booleanTag, dataViewTag, dateTag, errorTag, float32ArrayTag, float64ArrayTag, functionTag, int16ArrayTag, int32ArrayTag, int8ArrayTag, mapTag, numberTag, objectTag, regexpTag, setTag, stringTag, symbolTag, uint16ArrayTag, uint32ArrayTag, uint8ArrayTag, uint8ClampedArrayTag };\n","function isTypedArray(x) {\n    return ArrayBuffer.isView(x) && !(x instanceof DataView);\n}\n\nexport { isTypedArray };\n","import { getSymbols } from '../compat/_internal/getSymbols.mjs';\nimport { getTag } from '../compat/_internal/getTag.mjs';\nimport { uint32ArrayTag, uint16ArrayTag, uint8ClampedArrayTag, uint8ArrayTag, symbolTag, stringTag, setTag, regexpTag, objectTag, numberTag, mapTag, int32ArrayTag, int16ArrayTag, int8ArrayTag, float64ArrayTag, float32ArrayTag, dateTag, booleanTag, dataViewTag, arrayBufferTag, arrayTag, argumentsTag } from '../compat/_internal/tags.mjs';\nimport { isPrimitive } from '../predicate/isPrimitive.mjs';\nimport { isTypedArray } from '../predicate/isTypedArray.mjs';\n\nfunction cloneDeepWith(obj, cloneValue) {\n    return cloneDeepWithImpl(obj, undefined, obj, new Map(), cloneValue);\n}\nfunction cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack = new Map(), cloneValue = undefined) {\n    const cloned = cloneValue?.(valueToClone, keyToClone, objectToClone, stack);\n    if (cloned != null) {\n        return cloned;\n    }\n    if (isPrimitive(valueToClone)) {\n        return valueToClone;\n    }\n    if (stack.has(valueToClone)) {\n        return stack.get(valueToClone);\n    }\n    if (Array.isArray(valueToClone)) {\n        const result = new Array(valueToClone.length);\n        stack.set(valueToClone, result);\n        for (let i = 0; i < valueToClone.length; i++) {\n            result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);\n        }\n        if (Object.hasOwn(valueToClone, 'index')) {\n            result.index = valueToClone.index;\n        }\n        if (Object.hasOwn(valueToClone, 'input')) {\n            result.input = valueToClone.input;\n        }\n        return result;\n    }\n    if (valueToClone instanceof Date) {\n        return new Date(valueToClone.getTime());\n    }\n    if (valueToClone instanceof RegExp) {\n        const result = new RegExp(valueToClone.source, valueToClone.flags);\n        result.lastIndex = valueToClone.lastIndex;\n        return result;\n    }\n    if (valueToClone instanceof Map) {\n        const result = new Map();\n        stack.set(valueToClone, result);\n        for (const [key, value] of valueToClone) {\n            result.set(key, cloneDeepWithImpl(value, key, objectToClone, stack, cloneValue));\n        }\n        return result;\n    }\n    if (valueToClone instanceof Set) {\n        const result = new Set();\n        stack.set(valueToClone, result);\n        for (const value of valueToClone) {\n            result.add(cloneDeepWithImpl(value, undefined, objectToClone, stack, cloneValue));\n        }\n        return result;\n    }\n    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(valueToClone)) {\n        return valueToClone.subarray();\n    }\n    if (isTypedArray(valueToClone)) {\n        const result = new (Object.getPrototypeOf(valueToClone).constructor)(valueToClone.length);\n        stack.set(valueToClone, result);\n        for (let i = 0; i < valueToClone.length; i++) {\n            result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);\n        }\n        return result;\n    }\n    if (valueToClone instanceof ArrayBuffer ||\n        (typeof SharedArrayBuffer !== 'undefined' && valueToClone instanceof SharedArrayBuffer)) {\n        return valueToClone.slice(0);\n    }\n    if (valueToClone instanceof DataView) {\n        const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);\n        stack.set(valueToClone, result);\n        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n        return result;\n    }\n    if (typeof File !== 'undefined' && valueToClone instanceof File) {\n        const result = new File([valueToClone], valueToClone.name, {\n            type: valueToClone.type,\n        });\n        stack.set(valueToClone, result);\n        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n        return result;\n    }\n    if (valueToClone instanceof Blob) {\n        const result = new Blob([valueToClone], { type: valueToClone.type });\n        stack.set(valueToClone, result);\n        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n        return result;\n    }\n    if (valueToClone instanceof Error) {\n        const result = new valueToClone.constructor();\n        stack.set(valueToClone, result);\n        result.message = valueToClone.message;\n        result.name = valueToClone.name;\n        result.stack = valueToClone.stack;\n        result.cause = valueToClone.cause;\n        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n        return result;\n    }\n    if (typeof valueToClone === 'object' && isCloneableObject(valueToClone)) {\n        const result = Object.create(Object.getPrototypeOf(valueToClone));\n        stack.set(valueToClone, result);\n        copyProperties(result, valueToClone, objectToClone, stack, cloneValue);\n        return result;\n    }\n    return valueToClone;\n}\nfunction copyProperties(target, source, objectToClone = target, stack, cloneValue) {\n    const keys = [...Object.keys(source), ...getSymbols(source)];\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const descriptor = Object.getOwnPropertyDescriptor(target, key);\n        if (descriptor == null || descriptor.writable) {\n            target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack, cloneValue);\n        }\n    }\n}\nfunction isCloneableObject(object) {\n    switch (getTag(object)) {\n        case argumentsTag:\n        case arrayTag:\n        case arrayBufferTag:\n        case dataViewTag:\n        case booleanTag:\n        case dateTag:\n        case float32ArrayTag:\n        case float64ArrayTag:\n        case int8ArrayTag:\n        case int16ArrayTag:\n        case int32ArrayTag:\n        case mapTag:\n        case numberTag:\n        case objectTag:\n        case regexpTag:\n        case setTag:\n        case stringTag:\n        case symbolTag:\n        case uint8ArrayTag:\n        case uint8ClampedArrayTag:\n        case uint16ArrayTag:\n        case uint32ArrayTag: {\n            return true;\n        }\n        default: {\n            return false;\n        }\n    }\n}\n\nexport { cloneDeepWith, cloneDeepWithImpl, copyProperties };\n","import { cloneDeepWith as cloneDeepWith$1, copyProperties } from '../../object/cloneDeepWith.mjs';\nimport { argumentsTag, booleanTag, stringTag, numberTag } from '../_internal/tags.mjs';\n\nfunction cloneDeepWith(obj, cloneValue) {\n    return cloneDeepWith$1(obj, (value, key, object, stack) => {\n        const cloned = cloneValue?.(value, key, object, stack);\n        if (cloned != null) {\n            return cloned;\n        }\n        if (typeof obj !== 'object') {\n            return undefined;\n        }\n        switch (Object.prototype.toString.call(obj)) {\n            case numberTag:\n            case stringTag:\n            case booleanTag: {\n                const result = new obj.constructor(obj?.valueOf());\n                copyProperties(result, obj);\n                return result;\n            }\n            case argumentsTag: {\n                const result = {};\n                copyProperties(result, obj);\n                result.length = obj.length;\n                result[Symbol.iterator] = obj[Symbol.iterator];\n                return result;\n            }\n            default: {\n                return undefined;\n            }\n        }\n    });\n}\n\nexport { cloneDeepWith };\n","import { cloneDeepWith } from './cloneDeepWith.mjs';\n\nfunction cloneDeep(obj) {\n    return cloneDeepWith(obj);\n}\n\nexport { cloneDeep };\n","import { getTag } from '../_internal/getTag.mjs';\n\nfunction isArguments(value) {\n    return value !== null && typeof value === 'object' && getTag(value) === '[object Arguments]';\n}\n\nexport { isArguments };\n","function isObjectLike(value) {\n    return typeof value === 'object' && value !== null;\n}\n\nexport { isObjectLike };\n","function noop() { }\n\nexport { noop };\n","import { isTypedArray as isTypedArray$1 } from '../../predicate/isTypedArray.mjs';\n\nfunction isTypedArray(x) {\n    return isTypedArray$1(x);\n}\n\nexport { isTypedArray };\n","function isPlainObject(object) {\n    if (typeof object !== 'object') {\n        return false;\n    }\n    if (object == null) {\n        return false;\n    }\n    if (Object.getPrototypeOf(object) === null) {\n        return true;\n    }\n    if (Object.prototype.toString.call(object) !== '[object Object]') {\n        const tag = object[Symbol.toStringTag];\n        if (tag == null) {\n            return false;\n        }\n        const isTagReadonly = !Object.getOwnPropertyDescriptor(object, Symbol.toStringTag)?.writable;\n        if (isTagReadonly) {\n            return false;\n        }\n        return object.toString() === `[object ${tag}]`;\n    }\n    let proto = object;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(object) === proto;\n}\n\nexport { isPlainObject };\n","import { isPrimitive } from '../predicate/isPrimitive.mjs';\nimport { isTypedArray } from '../predicate/isTypedArray.mjs';\n\nfunction clone(obj) {\n    if (isPrimitive(obj)) {\n        return obj;\n    }\n    if (Array.isArray(obj) ||\n        isTypedArray(obj) ||\n        obj instanceof ArrayBuffer ||\n        (typeof SharedArrayBuffer !== 'undefined' && obj instanceof SharedArrayBuffer)) {\n        return obj.slice(0);\n    }\n    const prototype = Object.getPrototypeOf(obj);\n    const Constructor = prototype.constructor;\n    if (obj instanceof Date || obj instanceof Map || obj instanceof Set) {\n        return new Constructor(obj);\n    }\n    if (obj instanceof RegExp) {\n        const newRegExp = new Constructor(obj);\n        newRegExp.lastIndex = obj.lastIndex;\n        return newRegExp;\n    }\n    if (obj instanceof DataView) {\n        return new Constructor(obj.buffer.slice(0));\n    }\n    if (obj instanceof Error) {\n        const newError = new Constructor(obj.message);\n        newError.stack = obj.stack;\n        newError.name = obj.name;\n        newError.cause = obj.cause;\n        return newError;\n    }\n    if (typeof File !== 'undefined' && obj instanceof File) {\n        const newFile = new Constructor([obj], obj.name, { type: obj.type, lastModified: obj.lastModified });\n        return newFile;\n    }\n    if (typeof obj === 'object') {\n        const newObject = Object.create(prototype);\n        return Object.assign(newObject, obj);\n    }\n    return obj;\n}\n\nexport { clone };\n","import { cloneDeep } from './cloneDeep.mjs';\nimport { clone } from '../../object/clone.mjs';\nimport { isPrimitive } from '../../predicate/isPrimitive.mjs';\nimport { getSymbols } from '../_internal/getSymbols.mjs';\nimport { isArguments } from '../predicate/isArguments.mjs';\nimport { isObjectLike } from '../predicate/isObjectLike.mjs';\nimport { isPlainObject } from '../predicate/isPlainObject.mjs';\nimport { isTypedArray } from '../predicate/isTypedArray.mjs';\n\nfunction mergeWith(object, ...otherArgs) {\n    const sources = otherArgs.slice(0, -1);\n    const merge = otherArgs[otherArgs.length - 1];\n    let result = object;\n    for (let i = 0; i < sources.length; i++) {\n        const source = sources[i];\n        result = mergeWithDeep(result, source, merge, new Map());\n    }\n    return result;\n}\nfunction mergeWithDeep(target, source, merge, stack) {\n    if (isPrimitive(target)) {\n        target = Object(target);\n    }\n    if (source == null || typeof source !== 'object') {\n        return target;\n    }\n    if (stack.has(source)) {\n        return clone(stack.get(source));\n    }\n    stack.set(source, target);\n    if (Array.isArray(source)) {\n        source = source.slice();\n        for (let i = 0; i < source.length; i++) {\n            source[i] = source[i] ?? undefined;\n        }\n    }\n    const sourceKeys = [...Object.keys(source), ...getSymbols(source)];\n    for (let i = 0; i < sourceKeys.length; i++) {\n        const key = sourceKeys[i];\n        let sourceValue = source[key];\n        let targetValue = target[key];\n        if (isArguments(sourceValue)) {\n            sourceValue = { ...sourceValue };\n        }\n        if (isArguments(targetValue)) {\n            targetValue = { ...targetValue };\n        }\n        if (typeof Buffer !== 'undefined' && Buffer.isBuffer(sourceValue)) {\n            sourceValue = cloneDeep(sourceValue);\n        }\n        if (Array.isArray(sourceValue)) {\n            if (typeof targetValue === 'object' && targetValue != null) {\n                const cloned = [];\n                const targetKeys = Reflect.ownKeys(targetValue);\n                for (let i = 0; i < targetKeys.length; i++) {\n                    const targetKey = targetKeys[i];\n                    cloned[targetKey] = targetValue[targetKey];\n                }\n                targetValue = cloned;\n            }\n            else {\n                targetValue = [];\n            }\n        }\n        const merged = merge(targetValue, sourceValue, key, target, source, stack);\n        if (merged != null) {\n            target[key] = merged;\n        }\n        else if (Array.isArray(sourceValue)) {\n            target[key] = mergeWithDeep(targetValue, sourceValue, merge, stack);\n        }\n        else if (isObjectLike(targetValue) && isObjectLike(sourceValue)) {\n            target[key] = mergeWithDeep(targetValue, sourceValue, merge, stack);\n        }\n        else if (targetValue == null && isPlainObject(sourceValue)) {\n            target[key] = mergeWithDeep({}, sourceValue, merge, stack);\n        }\n        else if (targetValue == null && isTypedArray(sourceValue)) {\n            target[key] = cloneDeep(sourceValue);\n        }\n        else if (targetValue === undefined || sourceValue !== undefined) {\n            target[key] = sourceValue;\n        }\n    }\n    return target;\n}\n\nexport { mergeWith };\n","import { mergeWith } from './mergeWith.mjs';\nimport { noop } from '../../function/noop.mjs';\n\nfunction merge(object, ...sources) {\n    return mergeWith(object, ...sources, noop);\n}\n\nexport { merge };\n","import { SessionTypes } from \"@walletconnect/types\";\nimport {\n  isCaipNamespace,\n  isValidObject,\n  mergeArrays,\n  parseChainId,\n  parseNamespaceKey,\n} from \"@walletconnect/utils\";\nimport { RPC_URL } from \"../constants\";\nimport { Namespace, NamespaceConfig } from \"../types\";\nimport { merge } from \"es-toolkit/compat\";\n\nexport function getRpcUrl(chainId: string, rpc: Namespace, projectId?: string): string | undefined {\n  const chain = parseChainId(chainId);\n  return (\n    rpc.rpcMap?.[chain.reference] ||\n    `${RPC_URL}?chainId=${chain.namespace}:${chain.reference}&projectId=${projectId}`\n  );\n}\n\nexport function getChainId(chain: string): string {\n  return chain.includes(\":\") ? chain.split(\":\")[1] : chain;\n}\n\nexport function validateChainApproval(chain: string, chains: string[]): void {\n  if (!chains.includes(chain)) {\n    throw new Error(\n      `Chain '${chain}' not approved. Please use one of the following: ${chains.toString()}`,\n    );\n  }\n}\n\nexport function getChainsFromApprovedSession(accounts: string[]): string[] {\n  return accounts.map((address) => `${address.split(\":\")[0]}:${address.split(\":\")[1]}`);\n}\n\nexport function getAccountsFromSession(namespace: string, session: SessionTypes.Struct): string[] {\n  // match namespaces e.g. eip155 with eip155:1\n  const matchedNamespaceKeys = Object.keys(session.namespaces).filter((key) =>\n    key.includes(namespace),\n  );\n  if (!matchedNamespaceKeys.length) return [];\n  const accounts: string[] = [];\n  matchedNamespaceKeys.forEach((key) => {\n    const accountsForNamespace = session.namespaces[key].accounts;\n    accounts.push(...accountsForNamespace);\n  });\n  return accounts;\n}\n\nexport function filterNamespacesWithNoChains(namespaces: NamespaceConfig): NamespaceConfig {\n  return Object.fromEntries(\n    Object.entries(namespaces).filter(([_, ns]) => ns?.chains?.length && ns?.chains?.length > 0),\n  );\n}\n\nexport function mergeRequiredOptionalNamespaces(\n  required: NamespaceConfig = {},\n  optional: NamespaceConfig = {},\n) {\n  const requiredNamespaces = filterNamespacesWithNoChains(normalizeNamespaces(required));\n  const optionalNamespaces = filterNamespacesWithNoChains(normalizeNamespaces(optional));\n  return merge(requiredNamespaces, optionalNamespaces);\n}\n\n/**\n * Converts\n * {\n *  \"eip155:1\": {...},\n *  \"eip155:2\": {...},\n * }\n * into\n * {\n *  \"eip155\": {\n *      chains: [\"eip155:1\", \"eip155:2\"],\n *      ...\n *    }\n * }\n *\n */\nexport function normalizeNamespaces(namespaces: NamespaceConfig): NamespaceConfig {\n  const normalizedNamespaces: NamespaceConfig = {};\n  if (!isValidObject(namespaces)) return normalizedNamespaces;\n\n  for (const [key, values] of Object.entries(namespaces)) {\n    const chains = isCaipNamespace(key) ? [key] : values.chains;\n    const methods = values.methods || [];\n    const events = values.events || [];\n    const rpcMap = values.rpcMap || {};\n    const normalizedKey = parseNamespaceKey(key);\n    normalizedNamespaces[normalizedKey] = {\n      ...normalizedNamespaces[normalizedKey],\n      ...values,\n      chains: mergeArrays(chains, normalizedNamespaces[normalizedKey]?.chains),\n      methods: mergeArrays(methods, normalizedNamespaces[normalizedKey]?.methods),\n      events: mergeArrays(events, normalizedNamespaces[normalizedKey]?.events),\n    };\n    // avoid adding empty `rpcMap: {}` if there are no values for it\n    if (isValidObject(rpcMap) || isValidObject(normalizedNamespaces[normalizedKey]?.rpcMap || {})) {\n      normalizedNamespaces[normalizedKey].rpcMap = {\n        ...rpcMap,\n        ...normalizedNamespaces[normalizedKey]?.rpcMap,\n      };\n    }\n  }\n  return normalizedNamespaces;\n}\n\nexport function parseCaip10Account(caip10Account: string): string {\n  return caip10Account.includes(\":\") ? caip10Account.split(\":\")[2] : caip10Account;\n}\n\n/**\n * Populates the chains array for each namespace with the chains extracted from the accounts if are otherwise missing\n */\nexport function populateNamespacesChains(\n  namespaces: SessionTypes.Namespaces,\n): Record<string, SessionTypes.Namespace> {\n  const parsedNamespaces: Record<string, SessionTypes.Namespace> = {};\n  for (const [key, values] of Object.entries(namespaces)) {\n    const methods = values.methods || [];\n    const events = values.events || [];\n    const accounts = values.accounts || [];\n    // If the key includes a CAIP separator `:` we know it's a namespace + chainId (e.g. `eip155:1`)\n    const chains = isCaipNamespace(key)\n      ? [key]\n      : values.chains\n        ? values.chains\n        : getChainsFromApprovedSession(values.accounts);\n    parsedNamespaces[key] = {\n      chains,\n      methods,\n      events,\n      accounts,\n    };\n  }\n  return parsedNamespaces;\n}\n\nexport function convertChainIdToNumber(chainId: string | number): number | string {\n  if (typeof chainId === \"number\") return chainId;\n  if (chainId.includes(\"0x\")) {\n    return parseInt(chainId, 16);\n  }\n\n  chainId = chainId.includes(\":\") ? chainId.split(\":\")[1] : chainId;\n  return isNaN(Number(chainId)) ? chainId : Number(chainId);\n}\n\nexport function isValidJSONObject(str: string): boolean {\n  try {\n    const parsed = JSON.parse(str);\n    return typeof parsed === \"object\" && parsed !== null && !Array.isArray(parsed);\n  } catch {\n    return false;\n  }\n}\n","const globals = {};\nexport const getGlobal = (key: string) => {\n  return globals[key];\n};\n\nexport const setGlobal = (key: string, value: unknown) => {\n  globals[key] = value;\n};\n","import { SessionTypes } from \"@walletconnect/types\";\nimport { isValidObject } from \"@walletconnect/utils\";\n\nimport { isValidJSONObject } from \"./misc\";\n\nconst EIP155_PREFIX = \"eip155\";\nconst CAPABILITIES_KEYS = [\n  \"atomic\",\n  \"flow-control\",\n  \"paymasterService\",\n  \"sessionKeys\",\n  \"auxiliaryFunds\",\n];\n\nconst hexToDecimal = (hex?: string) => {\n  return hex && hex.startsWith(\"0x\") ? BigInt(hex).toString(10) : hex;\n};\n\nconst decimalToHex = (decimal: string) => {\n  return decimal && decimal.startsWith(\"0x\") ? decimal : `0x${BigInt(decimal).toString(16)}`;\n};\n\nconst getCapabilitiesFromObject = (object: Record<string, any>) => {\n  const capabilitiesKeys = Object.keys(object).filter((item) => CAPABILITIES_KEYS.includes(item));\n\n  return capabilitiesKeys.reduce(\n    (acc, key) => {\n      acc[key] = parseCapabilityValue(object[key]);\n      return acc;\n    },\n    {} as Record<string, any>,\n  );\n};\n\nconst parseCapabilityValue = (value: any) => {\n  if (typeof value === \"string\" && isValidJSONObject(value)) {\n    return JSON.parse(value);\n  }\n  return value;\n};\n\nexport const extractCapabilitiesFromSession = (\n  session: SessionTypes.Struct,\n  address: string,\n  chainIds: string[],\n) => {\n  const { sessionProperties = {}, scopedProperties = {} } = session;\n  const result: Record<string, any> = {};\n\n  if (!isValidObject(scopedProperties) && !isValidObject(sessionProperties)) {\n    return;\n  }\n\n  // get all capabilities from sessionProperties as they apply to all chains/addresses\n  const globalCapabilities = getCapabilitiesFromObject(sessionProperties);\n\n  for (const chain of chainIds) {\n    const chainId = hexToDecimal(chain);\n    if (!chainId) {\n      continue;\n    }\n\n    result[decimalToHex(chainId)] = globalCapabilities;\n\n    const chainSpecific = scopedProperties?.[`${EIP155_PREFIX}:${chainId}`];\n\n    if (chainSpecific) {\n      const addressSpecific = chainSpecific?.[`${EIP155_PREFIX}:${chainId}:${address}`];\n\n      // use the address specific capabilities if they exist, otherwise use the chain specific capabilities\n      result[decimalToHex(chainId)] = {\n        ...result[decimalToHex(chainId)],\n        ...getCapabilitiesFromObject(addressSpecific || chainSpecific),\n      };\n    }\n  }\n\n  // remove any chains that have no capabilities\n  for (const [key, value] of Object.entries(result)) {\n    if (Object.keys(value).length === 0) {\n      delete result[key];\n    }\n  }\n\n  return Object.keys(result).length > 0 ? result : undefined;\n};\n","import { IKeyValueStorage } from \"@walletconnect/keyvaluestorage\";\n\nlet storage: Storage;\n\nexport class Storage {\n  private storage: IKeyValueStorage;\n  constructor(storage: IKeyValueStorage) {\n    this.storage = storage;\n  }\n\n  async getItem<T>(key: string): Promise<T | undefined> {\n    return await this.storage.getItem<T>(key);\n  }\n\n  async setItem<T>(key: string, value: T) {\n    return await this.storage.setItem(key, value);\n  }\n\n  async removeItem(key: string) {\n    return await this.storage.removeItem(key);\n  }\n\n  static getStorage(kvStorage: IKeyValueStorage) {\n    if (!storage) {\n      storage = new Storage(kvStorage);\n    }\n    return storage;\n  }\n}\n","import { calcExpiry, isExpired, parseChainId } from \"@walletconnect/utils\";\nimport { formatJsonRpcRequest } from \"@walletconnect/jsonrpc-utils\";\nimport JsonRpcProvider from \"@walletconnect/jsonrpc-provider\";\n\nimport { StoredSendCalls, StoreSendCallsParams } from \"../types\";\nimport { CALL_STATUS_RESULT_EXPIRY, CALL_STATUS_STORAGE_KEY } from \"../constants\";\nimport { Storage } from \"./storage\";\n\nexport async function prepareCallStatusFromStoredSendCalls(\n  storedSendCalls: StoredSendCalls,\n  getHttpProvider: (chainId: number) => JsonRpcProvider,\n) {\n  const chainId = parseChainId(storedSendCalls.result.capabilities.caip345.caip2);\n  const hashes = storedSendCalls.result.capabilities.caip345.transactionHashes;\n  const allPromises = await Promise.allSettled(\n    hashes.map((hash) => getTransactionReceipt(chainId.reference, hash, getHttpProvider)),\n  );\n  const receipts = allPromises\n    .filter((r) => r.status === \"fulfilled\")\n    .map((r) => r.value)\n    .filter((r) => r);\n\n  // log failed transactions\n  allPromises\n    .filter((r) => r.status === \"rejected\")\n    .forEach((r) => console.warn(\"Failed to fetch transaction receipt:\", r.reason));\n\n  const someReceiptsPending = !receipts.length || receipts.some((r) => !r);\n  const allReceiptsSuccessful = receipts.every((r) => r?.status === \"0x1\");\n  const allReceiptsFailed = receipts.every((r) => r?.status === \"0x0\");\n  const someReceiptsFailed = receipts.some((r) => r?.status === \"0x0\");\n\n  let status;\n  if (someReceiptsPending) {\n    //100 = some pending\n    status = 100;\n  } else if (allReceiptsSuccessful) {\n    // 200 = all successful\n    status = 200;\n  } else if (allReceiptsFailed) {\n    // 500 = all failed\n    status = 500;\n  } else if (someReceiptsFailed) {\n    // 600 = some failures\n    status = 600;\n  }\n\n  return {\n    id: storedSendCalls.result.id,\n    version: storedSendCalls.request.version,\n    atomic: storedSendCalls.request.atomicRequired,\n    chainId: storedSendCalls.request.chainId,\n    capabilities: storedSendCalls.result.capabilities,\n    receipts,\n    status,\n  };\n}\n\nexport async function getTransactionReceipt(\n  chainId: string,\n  transactionHash: string,\n  getHttpProvider: (chainId: number) => JsonRpcProvider,\n) {\n  return await getHttpProvider(parseInt(chainId)).request(\n    formatJsonRpcRequest(\"eth_getTransactionReceipt\", [transactionHash]),\n  );\n}\n\nexport async function storeSendCalls({\n  sendCalls,\n  storage,\n}: {\n  sendCalls: StoreSendCallsParams;\n  storage: Storage;\n}) {\n  const sendCallsStatusResults =\n    await storage.getItem<Record<string, StoredSendCalls>>(CALL_STATUS_STORAGE_KEY);\n\n  await storage.setItem(CALL_STATUS_STORAGE_KEY, {\n    ...sendCallsStatusResults,\n    [sendCalls.result.id]: {\n      request: sendCalls.request,\n      result: sendCalls.result,\n      expiry: calcExpiry(CALL_STATUS_RESULT_EXPIRY),\n    },\n  });\n}\n\nexport async function deleteSendCallsResult({\n  resultId,\n  storage,\n}: {\n  resultId: string;\n  storage: Storage;\n}) {\n  const sendCallsStatusResults =\n    await storage.getItem<Record<string, StoredSendCalls>>(CALL_STATUS_STORAGE_KEY);\n  if (!sendCallsStatusResults) return;\n\n  delete sendCallsStatusResults[resultId];\n  await storage.setItem(CALL_STATUS_STORAGE_KEY, sendCallsStatusResults);\n\n  // delete old expired results\n  for (const resultId in sendCallsStatusResults) {\n    if (isExpired(sendCallsStatusResults[resultId].expiry)) {\n      delete sendCallsStatusResults[resultId];\n    }\n  }\n  await storage.setItem(CALL_STATUS_STORAGE_KEY, sendCallsStatusResults);\n}\n\nexport async function getStoredSendCalls({\n  resultId,\n  storage,\n}: {\n  resultId: string;\n  storage: Storage;\n}): Promise<StoredSendCalls | undefined> {\n  const storedSendCalls =\n    await storage.getItem<Record<string, StoredSendCalls>>(CALL_STATUS_STORAGE_KEY);\n\n  const result = storedSendCalls?.[resultId];\n  if (result && !isExpired(result.expiry)) {\n    return result;\n  } else {\n    await deleteSendCallsResult({ resultId, storage });\n  }\n\n  return undefined;\n}\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\n\nimport { getChainId, getGlobal, getRpcUrl } from \"../utils\";\n\nclass PolkadotProvider implements IProvider {\n  public name = \"polkadot\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);\n  }\n\n  // ---------------- PRIVATE ---------------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return (\n      accounts\n        // get the accounts from the active chain\n        .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n        // remove namespace & chainId from the string\n        .map((account) => account.split(\":\")[2]) || []\n    );\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const parsedChainId = getChainId(chain);\n      http[parsedChainId] = this.createHttpProvider(parsedChainId, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default PolkadotProvider;\n","import Client from \"@walletconnect/sign-client\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport { HttpConnection } from \"@walletconnect/jsonrpc-http-connection\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport { formatJsonRpcRequest } from \"@walletconnect/jsonrpc-utils\";\n\nimport {\n  IProvider,\n  RpcProvidersMap,\n  SubProviderOpts,\n  RequestParams,\n  SessionNamespace,\n  SendCallsResult,\n} from \"../types\";\n\nimport {\n  extractCapabilitiesFromSession,\n  getChainId,\n  getGlobal,\n  getRpcUrl,\n  getStoredSendCalls,\n  prepareCallStatusFromStoredSendCalls,\n  Storage,\n  storeSendCalls,\n} from \"../utils\";\nimport EventEmitter from \"events\";\nimport { BUNDLER_URL, PROVIDER_EVENTS } from \"../constants\";\n\nclass Eip155Provider implements IProvider {\n  public name = \"eip155\";\n  public client: Client;\n  // the active chainId on the dapp\n  public chainId: number;\n  public namespace: SessionNamespace;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public storage: Storage;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.httpProviders = this.createHttpProviders();\n    this.chainId = parseInt(this.getDefaultChain());\n    this.storage = Storage.getStorage(this.client.core.storage);\n  }\n\n  public async request<T = unknown>(args: RequestParams): Promise<T> {\n    switch (args.request.method) {\n      case \"eth_requestAccounts\":\n        return this.getAccounts() as unknown as T;\n      case \"eth_accounts\":\n        return this.getAccounts() as unknown as T;\n      case \"wallet_switchEthereumChain\": {\n        return (await this.handleSwitchChain(args)) as unknown as T;\n      }\n      case \"eth_chainId\":\n        return parseInt(this.getDefaultChain()) as unknown as T;\n      case \"wallet_getCapabilities\":\n        return (await this.getCapabilities(args)) as unknown as T;\n      case \"wallet_getCallsStatus\":\n        return (await this.getCallStatus(args)) as unknown as T;\n      case \"wallet_sendCalls\":\n        return (await this.sendCalls(args)) as unknown as T;\n      default:\n        break;\n    }\n    if (this.namespace.methods.includes(args.request.method)) {\n      return await this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(parseInt(chainId), rpcUrl);\n    }\n    this.chainId = parseInt(chainId);\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId.toString();\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private createHttpProvider(\n    chainId: number,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc =\n      rpcUrl || getRpcUrl(`${this.name}:${chainId}`, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n\n  private setHttpProvider(chainId: number, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const parsedChain = parseInt(getChainId(chain));\n      http[parsedChain] = this.createHttpProvider(parsedChain, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private getHttpProvider(chainId?: number): JsonRpcProvider {\n    const chain = chainId || this.chainId;\n    const http = this.httpProviders[chain];\n    if (http) {\n      return http;\n    }\n\n    this.httpProviders = {\n      ...this.httpProviders,\n      [chain]: this.createHttpProvider(chain),\n    };\n    return this.httpProviders[chain];\n  }\n\n  private async handleSwitchChain(args: RequestParams): Promise<any> {\n    let hexChainId = args.request.params ? args.request.params[0]?.chainId : \"0x0\";\n    hexChainId = hexChainId.startsWith(\"0x\") ? hexChainId : `0x${hexChainId}`;\n    const parsedChainId = parseInt(hexChainId, 16);\n    // if chainId is already approved, switch locally\n    if (this.isChainApproved(parsedChainId)) {\n      this.setDefaultChain(`${parsedChainId}`);\n    } else if (this.namespace.methods.includes(\"wallet_switchEthereumChain\")) {\n      // try to switch chain within the wallet\n      await this.client.request({\n        topic: args.topic,\n        request: {\n          method: args.request.method,\n          params: [\n            {\n              chainId: hexChainId,\n            },\n          ],\n        },\n        chainId: this.namespace.chains?.[0], // Sending a previously unapproved chainId will cause namespace validation failure so we must set request chainId to the first chainId in the namespace to avoid it\n      } as EngineTypes.RequestParams);\n      this.setDefaultChain(`${parsedChainId}`);\n    } else {\n      throw new Error(\n        `Failed to switch to chain 'eip155:${parsedChainId}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`,\n      );\n    }\n    return null;\n  }\n\n  private isChainApproved(chainId: number): boolean {\n    return this.namespace.chains.includes(`${this.name}:${chainId}`);\n  }\n\n  /**\n   * util method to get the capabilities for given address and chainIds from the wallet\n   * 1. check if the capabilities are stored in the sessionProperties legacy way - address+chainIds for backwards compatibility\n   * 2. check if the capabilities are stored in the sessionProperties\n   * 3. check if the capabilities are stored in the scopedProperties\n   * 4. if not, send the request to the wallet\n   * 5. update the session with the capabilities so they can be retrieved later\n   * 6. return the capabilities\n   */\n  private async getCapabilities(args: RequestParams) {\n    // if capabilities are stored in the session, return them, else send the request to the wallet\n    const address = args.request?.params?.[0];\n    const chainIds: string[] = args.request?.params?.[1] || [];\n\n    if (!address) throw new Error(\"Missing address parameter in `wallet_getCapabilities` request\");\n    const session = this.client.session.get(args.topic);\n    const sessionCapabilities = session?.sessionProperties?.capabilities || {};\n\n    // cache key is address + chainIds to allow requests to be made to different chains\n    const capabilitiesKey = `${address}${chainIds.join(\",\")}`;\n    const legacyCapabilities = sessionCapabilities?.[capabilitiesKey];\n    if (legacyCapabilities) {\n      return legacyCapabilities;\n    }\n    let cachedCapabilities;\n    try {\n      cachedCapabilities = extractCapabilitiesFromSession(session, address, chainIds);\n    } catch (error) {\n      console.warn(\"Failed to extract capabilities from session\", error);\n    }\n\n    if (cachedCapabilities) {\n      return cachedCapabilities;\n    }\n\n    // intentionally omit catching errors/rejection during `request` to allow the error to bubble up\n    const capabilities = await this.client.request(args as EngineTypes.RequestParams);\n    try {\n      // update the session with the capabilities so they can be retrieved later\n      await this.client.session.update(args.topic, {\n        sessionProperties: {\n          ...(session.sessionProperties || {}),\n          capabilities: {\n            ...(sessionCapabilities || {}),\n            [capabilitiesKey]: capabilities,\n          } as any, // by spec sessionProperties should be <string, string> but here are used as objects?\n        },\n      });\n    } catch (error) {\n      console.warn(\"Failed to update session with capabilities\", error);\n    }\n    return capabilities;\n  }\n\n  private async getCallStatus(args: RequestParams) {\n    const session = this.client.session.get(args.topic);\n    const bundlerName = session.sessionProperties?.bundler_name as string;\n    if (bundlerName) {\n      const bundlerUrl = this.getBundlerUrl(args.chainId, bundlerName);\n      try {\n        return await this.getUserOperationReceipt(bundlerUrl, args);\n      } catch (error) {\n        console.warn(\"Failed to fetch call status from bundler\", error, bundlerUrl);\n      }\n    }\n    const customUrl = session.sessionProperties?.bundler_url as string;\n    if (customUrl) {\n      try {\n        return await this.getUserOperationReceipt(customUrl, args);\n      } catch (error) {\n        console.warn(\"Failed to fetch call status from custom bundler\", error, customUrl);\n      }\n    }\n\n    const storedSendCalls = await getStoredSendCalls({\n      resultId: args.request.params?.[0] as string,\n      storage: this.storage,\n    });\n    if (storedSendCalls) {\n      try {\n        return await prepareCallStatusFromStoredSendCalls(\n          storedSendCalls,\n          this.getHttpProvider.bind(this),\n        );\n      } catch (error) {\n        console.warn(\"Failed to fetch call status from stored send calls\", error, storedSendCalls);\n      }\n    }\n\n    if (this.namespace.methods.includes(args.request.method)) {\n      return await this.client.request(args as EngineTypes.RequestParams);\n    }\n\n    throw new Error(\"Fetching call status not approved by the wallet.\");\n  }\n\n  private async getUserOperationReceipt(bundlerUrl: string, args: RequestParams) {\n    const url = new URL(bundlerUrl);\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(\n        formatJsonRpcRequest(\"eth_getUserOperationReceipt\", [args.request.params?.[0]]),\n      ),\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch user operation receipt - ${response.status}`);\n    }\n    return await response.json();\n  }\n\n  private getBundlerUrl(cap2ChainId: string, bundlerName: string) {\n    return `${BUNDLER_URL}?projectId=${this.client.core.projectId}&chainId=${cap2ChainId}&bundler=${bundlerName}`;\n  }\n\n  private async sendCalls(args: RequestParams) {\n    const result = await this.client.request<SendCallsResult>(args as EngineTypes.RequestParams);\n    const sendCallsParams = args.request.params?.[0];\n    const resultId = result?.id;\n    const capabilities = result?.capabilities || {};\n    const caip2 = capabilities?.caip345?.caip2;\n    const transactionHashes = capabilities?.caip345?.transactionHashes;\n\n    if (!resultId || !caip2 || !transactionHashes?.length) {\n      return result;\n    }\n\n    await storeSendCalls({\n      sendCalls: { request: sendCallsParams, result },\n      storage: this.storage,\n    });\n    return result;\n  }\n}\n\nexport default Eip155Provider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getChainId, getGlobal, getRpcUrl } from \"../utils\";\n\nclass SolanaProvider implements IProvider {\n  public name = \"solana\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  // --------- PRIVATE --------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const parsedChainId = getChainId(chain);\n      http[parsedChainId] = this.createHttpProvider(parsedChainId, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default SolanaProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getChainId, getGlobal, getRpcUrl } from \"../utils\";\n\nclass CosmosProvider implements IProvider {\n  public name = \"cosmos\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n\n  // ---------------- PRIVATE ---------------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const parsedChainId = getChainId(chain);\n      http[parsedChainId] = this.createHttpProvider(parsedChainId, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default CosmosProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getGlobal, getRpcUrl } from \"../utils\";\n\nclass AlgorandProvider implements IProvider {\n  public name = \"algorand\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      const rpc =\n        rpcUrl || getRpcUrl(`${this.name}:${chainId}`, this.namespace, this.client.core.projectId);\n      if (!rpc) {\n        throw new Error(`No RPC url provided for chainId: ${chainId}`);\n      }\n      this.setHttpProvider(chainId, rpc);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  // --------- PRIVATE --------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      http[chain] = this.createHttpProvider(chain, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (typeof rpc === \"undefined\") return undefined;\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default AlgorandProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getChainId, getGlobal } from \"../utils\";\n\nclass CardanoProvider implements IProvider {\n  public name = \"cip34\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n\n  // ------------- PRIVATE -------------- /\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const rpcURL = this.getCardanoRPCUrl(chain);\n      const parsedChain = getChainId(chain);\n      http[parsedChain] = this.createHttpProvider(parsedChain, rpcURL);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private getCardanoRPCUrl(chainId: string): string | undefined {\n    const rpcMap = this.namespace.rpcMap;\n    if (!rpcMap) return undefined;\n    return rpcMap[chainId];\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || this.getCardanoRPCUrl(chainId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default CardanoProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getChainId, getGlobal, getRpcUrl } from \"../utils\";\n\n// Old wallet connect provider for Elrond\nclass ElrondProvider implements IProvider {\n  public name = \"elrond\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  // --------- PRIVATE --------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const parsedChainId = getChainId(chain);\n      http[parsedChainId] = this.createHttpProvider(parsedChainId, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default ElrondProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getChainId, getGlobal, getRpcUrl } from \"../utils\";\n\nclass MultiversXProvider implements IProvider {\n  public name = \"multiversx\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  // --------- PRIVATE --------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      const parsedChainId = getChainId(chain);\n      http[parsedChainId] = this.createHttpProvider(parsedChainId, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default MultiversXProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getGlobal, getRpcUrl } from \"../utils\";\n\nclass NearProvider implements IProvider {\n  public name = \"near\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    this.chainId = chainId;\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      const rpc = rpcUrl || getRpcUrl(`${this.name}:${chainId}`, this.namespace);\n      if (!rpc) {\n        throw new Error(`No RPC url provided for chainId: ${chainId}`);\n      }\n      this.setHttpProvider(chainId, rpc);\n    }\n\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n\n  // ---------------- PRIVATE ---------------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return (\n      accounts\n        // get the accounts from the active chain\n        .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n        // remove namespace & chainId from the string\n        .map((account) => account.split(\":\")[2]) || []\n    );\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace.chains.forEach((chain) => {\n      http[chain] = this.createHttpProvider(chain, this.namespace.rpcMap?.[chain]);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace);\n    if (typeof rpc === \"undefined\") return undefined;\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default NearProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\n\nimport { getRpcUrl, getGlobal } from \"../utils\";\n\nclass TezosProvider implements IProvider {\n  public name = \"tezos\";\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace = Object.assign(this.namespace, namespace);\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider().request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    this.chainId = chainId;\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      const rpc = rpcUrl || getRpcUrl(`${this.name}:${chainId}`, this.namespace);\n      if (!rpc) {\n        throw new Error(`No RPC url provided for chainId: ${chainId}`);\n      }\n      this.setHttpProvider(chainId, rpc);\n    }\n\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);\n  }\n\n  // ---------------- PRIVATE ---------------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return (\n      accounts\n        // get the accounts from the active chain\n        .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n        // remove namespace & chainId from the string\n        .map((account) => account.split(\":\")[2]) || []\n    );\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http: any = {};\n    this.namespace.chains.forEach((chain) => {\n      http[chain] = this.createHttpProvider(chain);\n    });\n    return http;\n  }\n\n  private getHttpProvider(): JsonRpcProvider {\n    const chain = `${this.name}:${this.chainId}`;\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(\n    chainId: string,\n    rpcUrl?: string | undefined,\n  ): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace);\n    if (typeof rpc === \"undefined\") return undefined;\n    const http = new JsonRpcProvider(new HttpConnection(rpc));\n    return http;\n  }\n}\n\nexport default TezosProvider;\n","import HttpConnection from \"@walletconnect/jsonrpc-http-connection\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport Client from \"@walletconnect/sign-client\";\nimport { EngineTypes, SessionTypes } from \"@walletconnect/types\";\nimport EventEmitter from \"events\";\nimport { GENERIC_SUBPROVIDER_NAME, PROVIDER_EVENTS } from \"../constants\";\nimport {\n  IProvider,\n  RequestParams,\n  RpcProvidersMap,\n  SessionNamespace,\n  SubProviderOpts,\n} from \"../types\";\nimport { getGlobal, getRpcUrl } from \"../utils\";\nimport { parseChainId } from \"@walletconnect/utils\";\n\nclass GenericProvider implements IProvider {\n  public name = GENERIC_SUBPROVIDER_NAME;\n  public client: Client;\n  public httpProviders: RpcProvidersMap;\n  public events: EventEmitter;\n  public namespace: SessionNamespace;\n  public chainId: string;\n\n  constructor(opts: SubProviderOpts) {\n    this.namespace = opts.namespace;\n    this.events = getGlobal(\"events\");\n    this.client = getGlobal(\"client\");\n    this.chainId = this.getDefaultChain();\n    this.name = this.getNamespaceName();\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public updateNamespace(namespace: SessionTypes.Namespace) {\n    this.namespace.chains = [\n      ...new Set((this.namespace.chains || []).concat(namespace.chains || [])),\n    ];\n    this.namespace.accounts = [\n      ...new Set((this.namespace.accounts || []).concat(namespace.accounts || [])),\n    ];\n    this.namespace.methods = [\n      ...new Set((this.namespace.methods || []).concat(namespace.methods || [])),\n    ];\n    this.namespace.events = [\n      ...new Set((this.namespace.events || []).concat(namespace.events || [])),\n    ];\n    this.httpProviders = this.createHttpProviders();\n  }\n\n  public requestAccounts(): string[] {\n    return this.getAccounts();\n  }\n\n  public request<T = unknown>(args: RequestParams): Promise<T> {\n    if (this.namespace.methods.includes(args.request.method)) {\n      return this.client.request(args as EngineTypes.RequestParams);\n    }\n    return this.getHttpProvider(args.chainId).request(args.request);\n  }\n\n  public setDefaultChain(chainId: string, rpcUrl?: string | undefined) {\n    // http provider exists so just set the chainId\n    if (!this.httpProviders[chainId]) {\n      this.setHttpProvider(chainId, rpcUrl);\n    }\n    this.chainId = chainId;\n    this.events.emit(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, `${this.name}:${chainId}`);\n  }\n\n  public getDefaultChain(): string {\n    if (this.chainId) return this.chainId;\n    if (this.namespace.defaultChain) return this.namespace.defaultChain;\n\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return chainId.split(\":\")[1];\n  }\n\n  public getNamespaceName(): string {\n    const chainId = this.namespace.chains[0];\n    if (!chainId) throw new Error(`ChainId not found`);\n\n    return parseChainId(chainId).namespace;\n  }\n\n  // --------- PRIVATE --------- //\n\n  private getAccounts(): string[] {\n    const accounts = this.namespace.accounts;\n    if (!accounts) {\n      return [];\n    }\n\n    return [\n      ...new Set(\n        accounts\n          // get the accounts from the active chain\n          .filter((account) => account.split(\":\")[1] === this.chainId.toString())\n          // remove namespace & chainId from the string\n          .map((account) => account.split(\":\")[2]),\n      ),\n    ];\n  }\n\n  private createHttpProviders(): RpcProvidersMap {\n    const http = {};\n    this.namespace?.accounts?.forEach((account) => {\n      const chain = parseChainId(account);\n      http[chain.reference] = this.createHttpProvider(account);\n    });\n    return http;\n  }\n\n  private getHttpProvider(chain: string): JsonRpcProvider {\n    const http = this.httpProviders[chain];\n    if (typeof http === \"undefined\") {\n      throw new Error(`JSON-RPC provider for ${chain} not found`);\n    }\n    return http;\n  }\n\n  private setHttpProvider(chainId: string, rpcUrl?: string): void {\n    const http = this.createHttpProvider(chainId, rpcUrl);\n    if (http) {\n      this.httpProviders[chainId] = http;\n    }\n  }\n\n  private createHttpProvider(chainId: string, rpcUrl?: string): JsonRpcProvider | undefined {\n    const rpc = rpcUrl || getRpcUrl(chainId, this.namespace, this.client.core.projectId);\n    if (!rpc) {\n      throw new Error(`No RPC url provided for chainId: ${chainId}`);\n    }\n    const http = new JsonRpcProvider(new HttpConnection(rpc, getGlobal(\"disableProviderPing\")));\n    return http;\n  }\n}\n\nexport default GenericProvider;\n","import SignClient from \"@walletconnect/sign-client\";\nimport { SessionTypes } from \"@walletconnect/types\";\nimport { JsonRpcResult } from \"@walletconnect/jsonrpc-types\";\nimport { getSdkError, isValidArray, parseNamespaceKey } from \"@walletconnect/utils\";\nimport { getDefaultLoggerOptions, Logger, pino } from \"@walletconnect/logger\";\nimport {\n  convertChainIdToNumber,\n  getAccountsFromSession,\n  getChainsFromApprovedSession,\n  mergeRequiredOptionalNamespaces,\n  parseCaip10Account,\n  populateNamespacesChains,\n  setGlobal,\n} from \"./utils\";\nimport PolkadotProvider from \"./providers/polkadot\";\nimport Eip155Provider from \"./providers/eip155\";\nimport SolanaProvider from \"./providers/solana\";\nimport CosmosProvider from \"./providers/cosmos\";\nimport AlgorandProvider from \"./providers/algorand\";\nimport CardanoProvider from \"./providers/cardano\";\nimport ElrondProvider from \"./providers/elrond\";\nimport MultiversXProvider from \"./providers/multiversx\";\nimport NearProvider from \"./providers/near\";\nimport TezosProvider from \"./providers/tezos\";\nimport GenericProvider from \"./providers/generic\";\n\nimport {\n  IUniversalProvider,\n  IProvider,\n  RpcProviderMap,\n  ConnectParams,\n  RequestArguments,\n  UniversalProviderOpts,\n  NamespaceConfig,\n  PairingsCleanupOpts,\n  ProviderAccounts,\n  AuthenticateParams,\n} from \"./types\";\n\nimport { RELAY_URL, LOGGER, STORAGE, PROVIDER_EVENTS, GENERIC_SUBPROVIDER_NAME } from \"./constants\";\nimport EventEmitter from \"events\";\nimport { formatJsonRpcResult } from \"@walletconnect/jsonrpc-utils\";\n\nexport class UniversalProvider implements IUniversalProvider {\n  public client!: SignClient;\n  public namespaces?: NamespaceConfig;\n  public optionalNamespaces?: NamespaceConfig;\n  public sessionProperties?: SessionTypes.SessionProperties;\n  public scopedProperties?: SessionTypes.ScopedProperties;\n  public events: EventEmitter = new EventEmitter();\n  public rpcProviders: RpcProviderMap = {};\n  public session?: SessionTypes.Struct;\n  public providerOpts: UniversalProviderOpts;\n  public logger: Logger;\n  public uri: string | undefined;\n\n  private disableProviderPing = false;\n\n  static async init(opts: UniversalProviderOpts) {\n    const provider = new UniversalProvider(opts);\n    await provider.initialize();\n    return provider;\n  }\n\n  constructor(opts: UniversalProviderOpts) {\n    this.providerOpts = opts;\n    this.logger =\n      typeof opts?.logger !== \"undefined\" && typeof opts?.logger !== \"string\"\n        ? opts.logger\n        : pino(getDefaultLoggerOptions({ level: opts?.logger || LOGGER }));\n    this.disableProviderPing = opts?.disableProviderPing || false;\n  }\n\n  public async request<T = unknown>(\n    args: RequestArguments,\n    chain?: string | undefined,\n    expiry?: number | undefined,\n  ): Promise<T> {\n    const [namespace, chainId] = this.validateChain(chain);\n\n    if (!this.session) {\n      throw new Error(\"Please call connect() before request()\");\n    }\n\n    return await this.getProvider(namespace).request({\n      request: {\n        ...args,\n      },\n      chainId: `${namespace}:${chainId}`,\n      topic: this.session.topic,\n      expiry,\n    });\n  }\n\n  public sendAsync(\n    args: RequestArguments,\n    callback: (error: Error | null, response: JsonRpcResult) => void,\n    chain?: string | undefined,\n    expiry?: number | undefined,\n  ): void {\n    const id = new Date().getTime();\n    this.request(args, chain, expiry)\n      .then((response) => callback(null, formatJsonRpcResult(id, response)))\n      .catch((error) => callback(error, undefined as any));\n  }\n\n  public async enable(): Promise<ProviderAccounts> {\n    if (!this.client) {\n      throw new Error(\"Sign Client not initialized\");\n    }\n    if (!this.session) {\n      await this.connect({\n        namespaces: this.namespaces,\n        optionalNamespaces: this.optionalNamespaces,\n        sessionProperties: this.sessionProperties,\n        scopedProperties: this.scopedProperties,\n      });\n    }\n    const accounts = await this.requestAccounts();\n    return accounts as ProviderAccounts;\n  }\n\n  public async disconnect(): Promise<void> {\n    if (!this.session) {\n      throw new Error(\"Please call connect() before enable()\");\n    }\n    await this.client.disconnect({\n      topic: this.session?.topic,\n      reason: getSdkError(\"USER_DISCONNECTED\"),\n    });\n    await this.cleanup();\n  }\n\n  public async connect(opts: ConnectParams): Promise<SessionTypes.Struct | undefined> {\n    if (!this.client) {\n      throw new Error(\"Sign Client not initialized\");\n    }\n    this.setNamespaces(opts);\n    // omit `await` to avoid delaying the pairing flow\n    this.cleanupPendingPairings();\n    if (opts.skipPairing) return;\n\n    return await this.pair(opts.pairingTopic);\n  }\n\n  public async authenticate(opts: AuthenticateParams, walletUniversalLink?: string) {\n    if (!this.client) {\n      throw new Error(\"Sign Client not initialized\");\n    }\n    this.setNamespaces(opts);\n    await this.cleanupPendingPairings();\n\n    const { uri, response } = await this.client.authenticate(opts, walletUniversalLink);\n    if (uri) {\n      this.uri = uri;\n      this.events.emit(\"display_uri\", uri);\n    }\n    const result = await response();\n    this.session = result.session;\n    if (this.session) {\n      // assign namespaces from session if not already defined\n      const approved = populateNamespacesChains(this.session.namespaces) as NamespaceConfig;\n      this.namespaces = mergeRequiredOptionalNamespaces(this.namespaces, approved);\n      await this.persist(\"namespaces\", this.namespaces);\n      this.onConnect();\n    }\n    return result;\n  }\n\n  public on(event: any, listener: any): void {\n    this.events.on(event, listener);\n  }\n\n  public once(event: string, listener: any): void {\n    this.events.once(event, listener);\n  }\n\n  public removeListener(event: string, listener: any): void {\n    this.events.removeListener(event, listener);\n  }\n\n  public off(event: string, listener: any): void {\n    this.events.off(event, listener);\n  }\n\n  get isWalletConnect() {\n    return true;\n  }\n\n  public async pair(pairingTopic: string | undefined): Promise<SessionTypes.Struct> {\n    const { uri, approval } = await this.client.connect({\n      pairingTopic,\n      requiredNamespaces: this.namespaces,\n      optionalNamespaces: this.optionalNamespaces,\n      sessionProperties: this.sessionProperties,\n      scopedProperties: this.scopedProperties,\n    });\n\n    if (uri) {\n      this.uri = uri;\n      this.events.emit(\"display_uri\", uri);\n    }\n\n    const session = await approval();\n    this.session = session;\n    // assign namespaces from session if not already defined\n    const approved = populateNamespacesChains(session.namespaces) as NamespaceConfig;\n    this.namespaces = mergeRequiredOptionalNamespaces(this.namespaces, approved);\n    await this.persist(\"namespaces\", this.namespaces);\n    await this.persist(\"optionalNamespaces\", this.optionalNamespaces);\n\n    this.onConnect();\n    return this.session;\n  }\n\n  public setDefaultChain(chain: string, rpcUrl?: string | undefined) {\n    try {\n      // ignore without active session\n      if (!this.session) return;\n      const [namespace, chainId] = this.validateChain(chain);\n      const provider = this.getProvider(namespace);\n      provider.setDefaultChain(chainId, rpcUrl);\n    } catch (error) {\n      // ignore the error if the fx is used prematurely before namespaces are set\n      if (!/Please call connect/.test((error as Error).message)) throw error;\n    }\n  }\n\n  public async cleanupPendingPairings(opts: PairingsCleanupOpts = {}): Promise<void> {\n    try {\n      this.logger.info(\"Cleaning up inactive pairings...\");\n      const inactivePairings = this.client.pairing.getAll();\n\n      if (!isValidArray(inactivePairings)) return;\n\n      for (const pairing of inactivePairings) {\n        if (opts.deletePairings) {\n          this.client.core.expirer.set(pairing.topic, 0);\n        } else {\n          await this.client.core.relayer.subscriber.unsubscribe(pairing.topic);\n        }\n      }\n\n      this.logger.info(`Inactive pairings cleared: ${inactivePairings.length}`);\n    } catch (error) {\n      this.logger.warn(\"Failed to cleanup pending pairings\", error);\n    }\n  }\n\n  public abortPairingAttempt() {\n    this.logger.warn(\"abortPairingAttempt is deprecated. This is now a no-op.\");\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async checkStorage() {\n    this.namespaces = (await this.getFromStore(`namespaces`)) || {};\n    this.optionalNamespaces = (await this.getFromStore(`optionalNamespaces`)) || {};\n    if (this.session) this.createProviders();\n  }\n\n  private async initialize() {\n    this.logger.trace(`Initialized`);\n    await this.createClient();\n    await this.checkStorage();\n    this.registerEventListeners();\n  }\n\n  private async createClient() {\n    this.client =\n      this.providerOpts.client ||\n      (await SignClient.init({\n        core: this.providerOpts.core,\n        logger: this.providerOpts.logger || LOGGER,\n        relayUrl: this.providerOpts.relayUrl || RELAY_URL,\n        projectId: this.providerOpts.projectId,\n        metadata: this.providerOpts.metadata,\n        storageOptions: this.providerOpts.storageOptions,\n        storage: this.providerOpts.storage,\n        name: this.providerOpts.name,\n        customStoragePrefix: this.providerOpts.customStoragePrefix,\n        telemetryEnabled: this.providerOpts.telemetryEnabled,\n      }));\n\n    if (this.providerOpts.session) {\n      try {\n        this.session = this.client.session.get(this.providerOpts.session.topic);\n      } catch (error) {\n        this.logger.error(\"Failed to get session\", error);\n        throw new Error(\n          `The provided session: ${this.providerOpts?.session?.topic} doesn't exist in the Sign client`,\n        );\n      }\n    } else {\n      const sessions = this.client.session.getAll();\n      this.session = sessions[0];\n    }\n    this.logger.trace(`SignClient Initialized`);\n  }\n\n  private createProviders(): void {\n    if (!this.client) {\n      throw new Error(\"Sign Client not initialized\");\n    }\n\n    if (!this.session) {\n      throw new Error(\"Session not initialized. Please call connect() before enable()\");\n    }\n\n    const providersToCreate = [\n      ...new Set(\n        Object.keys(this.session.namespaces).map((namespace) => parseNamespaceKey(namespace)),\n      ),\n    ];\n\n    setGlobal(\"client\", this.client);\n    setGlobal(\"events\", this.events);\n    setGlobal(\"disableProviderPing\", this.disableProviderPing);\n\n    providersToCreate.forEach((namespace) => {\n      if (!this.session) return;\n      const accounts = getAccountsFromSession(namespace, this.session);\n      if (accounts?.length === 0) {\n        return;\n      }\n      const approvedChains = getChainsFromApprovedSession(accounts);\n      const mergedNamespaces = mergeRequiredOptionalNamespaces(\n        this.namespaces,\n        this.optionalNamespaces,\n      );\n      const combinedNamespace = {\n        ...mergedNamespaces[namespace],\n        accounts,\n        chains: approvedChains,\n      };\n      switch (namespace) {\n        case \"eip155\":\n          this.rpcProviders[namespace] = new Eip155Provider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"algorand\":\n          this.rpcProviders[namespace] = new AlgorandProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"solana\":\n          this.rpcProviders[namespace] = new SolanaProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"cosmos\":\n          this.rpcProviders[namespace] = new CosmosProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"polkadot\":\n          this.rpcProviders[namespace] = new PolkadotProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"cip34\":\n          this.rpcProviders[namespace] = new CardanoProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"elrond\":\n          this.rpcProviders[namespace] = new ElrondProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"multiversx\":\n          this.rpcProviders[namespace] = new MultiversXProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"near\":\n          this.rpcProviders[namespace] = new NearProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        case \"tezos\":\n          this.rpcProviders[namespace] = new TezosProvider({\n            namespace: combinedNamespace,\n          });\n          break;\n        default:\n          this.rpcProviders[namespace] = new GenericProvider({\n            namespace: combinedNamespace,\n          });\n      }\n    });\n  }\n\n  private registerEventListeners(): void {\n    if (typeof this.client === \"undefined\") {\n      throw new Error(\"Sign Client is not initialized\");\n    }\n\n    this.client.on(\"session_ping\", (args) => {\n      const { topic } = args;\n      if (topic !== this.session?.topic) return;\n      this.events.emit(\"session_ping\", args);\n    });\n\n    this.client.on(\"session_event\", (args) => {\n      const { params, topic } = args;\n      if (topic !== this.session?.topic) return;\n      const { event } = params;\n      if (event.name === \"accountsChanged\") {\n        const accounts = event.data;\n        if (accounts && isValidArray(accounts))\n          this.events.emit(\"accountsChanged\", accounts.map(parseCaip10Account));\n      } else if (event.name === \"chainChanged\") {\n        const requestChainId = params.chainId;\n        const payloadChainId = params.event.data as number;\n        const namespace = parseNamespaceKey(requestChainId);\n        // chainIds might differ between the request & payload - request is always in CAIP2 format, while payload might be string, number, CAIP2 or hex\n        // take priority of the payload chainId\n        const chainIdToProcess =\n          convertChainIdToNumber(requestChainId) !== convertChainIdToNumber(payloadChainId)\n            ? `${namespace}:${convertChainIdToNumber(payloadChainId)}`\n            : requestChainId;\n\n        this.onChainChanged(chainIdToProcess);\n      } else {\n        this.events.emit(event.name, event.data);\n      }\n\n      this.events.emit(\"session_event\", args);\n    });\n\n    this.client.on(\"session_update\", ({ topic, params }) => {\n      if (topic !== this.session?.topic) return;\n      const { namespaces } = params;\n      const _session = this.client?.session.get(topic);\n      this.session = { ..._session, namespaces } as SessionTypes.Struct;\n      this.onSessionUpdate();\n      this.events.emit(\"session_update\", { topic, params });\n    });\n\n    this.client.on(\"session_delete\", async (payload) => {\n      if (payload.topic !== this.session?.topic) return;\n      await this.cleanup();\n      this.events.emit(\"session_delete\", payload);\n      this.events.emit(\"disconnect\", {\n        ...getSdkError(\"USER_DISCONNECTED\"),\n        data: payload.topic,\n      });\n    });\n\n    this.on(PROVIDER_EVENTS.DEFAULT_CHAIN_CHANGED, (caip2ChainId: string) => {\n      this.onChainChanged(caip2ChainId, true);\n    });\n  }\n\n  private getProvider(namespace: string): IProvider {\n    return this.rpcProviders[namespace] || this.rpcProviders[GENERIC_SUBPROVIDER_NAME];\n  }\n\n  private onSessionUpdate(): void {\n    Object.keys(this.rpcProviders).forEach((namespace: string) => {\n      this.getProvider(namespace).updateNamespace(\n        this.session?.namespaces[namespace] as SessionTypes.BaseNamespace,\n      );\n    });\n  }\n\n  private setNamespaces(params: ConnectParams): void {\n    const {\n      namespaces = {},\n      optionalNamespaces = {},\n      sessionProperties,\n      scopedProperties,\n    } = params;\n\n    // requiredNamespaces are deprecated, assign them to optionalNamespaces\n    this.optionalNamespaces = mergeRequiredOptionalNamespaces(namespaces, optionalNamespaces);\n    this.sessionProperties = sessionProperties;\n    this.scopedProperties = scopedProperties;\n  }\n\n  private validateChain(chain?: string): [string, string] {\n    const [namespace, chainId] = chain?.split(\":\") || [\"\", \"\"];\n    if (!this.namespaces || !Object.keys(this.namespaces).length) return [namespace, chainId];\n    // validate namespace\n    if (namespace) {\n      if (\n        // some namespaces might be defined with inline chainId e.g. eip155:1\n        // and we need to parse them\n        !Object.keys(this.namespaces || {})\n          .map((key) => parseNamespaceKey(key))\n          .includes(namespace)\n      ) {\n        throw new Error(\n          `Namespace '${namespace}' is not configured. Please call connect() first with namespace config.`,\n        );\n      }\n    }\n    if (namespace && chainId) {\n      return [namespace, chainId];\n    }\n    const defaultNamespace = parseNamespaceKey(Object.keys(this.namespaces)[0]);\n    const defaultChain = this.rpcProviders[defaultNamespace].getDefaultChain();\n    return [defaultNamespace, defaultChain];\n  }\n\n  private async requestAccounts(): Promise<string[]> {\n    const [namespace] = this.validateChain();\n    return await this.getProvider(namespace).requestAccounts();\n  }\n\n  private async onChainChanged(caip2Chain: string, internal = false): Promise<void> {\n    if (!this.namespaces) return;\n\n    const [namespace, chainId] = this.validateChain(caip2Chain);\n\n    if (!chainId) return;\n\n    this.updateNamespaceChain(namespace, chainId);\n\n    const previousChainId = this.getProvider(namespace).getDefaultChain();\n    if (!internal) {\n      this.getProvider(namespace).setDefaultChain(chainId);\n    } else {\n      // emit the events during the `internal` cycle of chain change\n      // otherwise events are emitted twice\n      // once on the chainChanged event and once triggered by `this.getProvider(namespace).setDefaultChain(chainId);`\n      this.events.emit(\"chainChanged\", chainId);\n      this.emitAccountsChangedOnChainChange({ namespace, previousChainId, newChainId: caip2Chain });\n    }\n\n    await this.persist(\"namespaces\", this.namespaces);\n  }\n\n  /**\n   * Emits `accountsChanged` event when a chain is changed and there are new accounts on the new chain\n   */\n  private emitAccountsChangedOnChainChange({\n    namespace,\n    previousChainId,\n    newChainId,\n  }: {\n    namespace: string;\n    previousChainId: string;\n    newChainId: string;\n  }): void {\n    try {\n      if (previousChainId === newChainId) {\n        return;\n      }\n\n      const accounts = this.session?.namespaces[namespace]?.accounts;\n      if (!accounts) return;\n      const newChainIdAccounts = accounts\n        .filter((account) => account.includes(`${newChainId}:`))\n        .map(parseCaip10Account);\n      if (!isValidArray(newChainIdAccounts)) return;\n      this.events.emit(\"accountsChanged\", newChainIdAccounts);\n    } catch (error) {\n      this.logger.warn(\"Failed to emit accountsChanged on chain change\", error);\n    }\n  }\n\n  private updateNamespaceChain(namespace: string, chainId: string): void {\n    if (!this.namespaces) return;\n\n    const namespaceKey = this.namespaces[namespace] ? namespace : `${namespace}:${chainId}`;\n\n    const defaultNamespace = {\n      chains: [],\n      methods: [],\n      events: [],\n      defaultChain: chainId,\n    };\n\n    if (!this.namespaces[namespaceKey]) {\n      this.namespaces[namespaceKey] = defaultNamespace;\n    } else if (this.namespaces[namespaceKey]) {\n      this.namespaces[namespaceKey].defaultChain = chainId;\n    }\n  }\n\n  private onConnect() {\n    this.createProviders();\n    this.events.emit(\"connect\", { session: this.session });\n  }\n\n  private async cleanup() {\n    this.namespaces = undefined;\n    this.optionalNamespaces = undefined;\n    this.sessionProperties = undefined;\n    await this.deleteFromStore(\"namespaces\");\n    await this.deleteFromStore(\"optionalNamespaces\");\n    await this.deleteFromStore(\"sessionProperties\");\n    // reset the session after removing from store as the topic is used there\n    this.session = undefined;\n    this.cleanupPendingPairings({ deletePairings: true });\n    await this.cleanupStorage();\n  }\n\n  private async persist(key: string, data: unknown) {\n    const topic = this.session?.topic || \"\";\n    await this.client.core.storage.setItem(`${STORAGE}/${key}${topic}`, data);\n  }\n\n  private async getFromStore(key: string) {\n    const topic = this.session?.topic || \"\";\n    return await this.client.core.storage.getItem(`${STORAGE}/${key}${topic}`);\n  }\n\n  private async deleteFromStore(key: string) {\n    const topic = this.session?.topic || \"\";\n    await this.client.core.storage.removeItem(`${STORAGE}/${key}${topic}`);\n  }\n\n  // remove all storage items if there are no sessions left\n  private async cleanupStorage() {\n    try {\n      if (this.client?.session.length > 0) {\n        return;\n      }\n      const keys = await this.client.core.storage.getKeys();\n      for (const key of keys) {\n        if (key.startsWith(STORAGE)) {\n          await this.client.core.storage.removeItem(key);\n        }\n      }\n    } catch (error) {\n      this.logger.warn(\"Failed to cleanup storage\", error);\n    }\n  }\n}\nexport default UniversalProvider;\n","import { UniversalProvider as Provider } from \"./UniversalProvider\";\nexport * from \"./types\";\nexport const UniversalProvider = Provider;\nexport default Provider;\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}