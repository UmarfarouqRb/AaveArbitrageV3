{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"contract\", \"method\", \"params\"];\nimport { parseAbiItem } from \"abitype\";\nimport { encodeAbiParameters } from \"../utils/abi/encodeAbiParameters.js\";\nimport { prepareMethod } from \"../utils/abi/prepare-method.js\";\nimport { resolvePromisedValue } from \"../utils/promise/resolve-promised-value.js\";\nimport { prepareTransaction } from \"./prepare-transaction.js\";\nimport { isAbiFunction } from \"./utils.js\";\n/**\n * Prepares a contract call by resolving the ABI function, parameters and encoded data. Optionally specify other properties such as value or gas price.\n * @param options - The options for preparing the contract call.\n * @returns A promise that resolves to the prepared transaction.\n * @transaction\n * @example\n *\n * ### Usage with a human-readable method signature:\n *\n * ```ts\n * import { prepareContractCall } from \"thirdweb\";\n *\n * const transaction = prepareContractCall({\n *  contract,\n *  method: \"function transfer(address to, uint256 value)\",\n *  params: [to, value],\n * });\n * ```\n *\n * ### Usage with explicit gas price and/or value:\n *\n * ```ts\n * import { prepareContractCall } from \"thirdweb\";\n * import { toWei } from \"thirdweb/utils\";\n *\n * const transaction = prepareContractCall({\n *  contract,\n *  method: \"function transfer(address to, uint256 value)\",\n *  params: [to, value],\n *  maxFeePerGas: 30n,\n *  maxPriorityFeePerGas: 1n,\n *  value: toWei(\"0.01\"),\n * });\n * ```\n *\n * ### Usage with ERC20 value:\n *\n * For transactions that transfer ERC20 tokens, you can specify the value as the amount of tokens to transfer.\n *\n * You can use this in conjuction with the [`getApprovalForTransaction`](https://portal.thirdweb.com/references/typescript/v5/getApprovalForTransaction) function to easily create approval transactions for ERC20 tokens.\n *\n * This value will also be read by the react hooks and UI components to present to total cost to the user.\n *\n * ```ts\n * import { prepareContractCall } from \"thirdweb\";\n * import { toWei } from \"thirdweb/utils\";\n *\n * const transaction = prepareContractCall({\n *  contract,\n *  method: \"function payWithCoin()\",\n *  params: [],\n *  erc20Value: {\n *    tokenAddress: \"0x...\", // the address of the ERC20 token\n *    amountWei: toWei(\"0.1\"), // the amount of tokens to transfer in wei\n *  },\n * });\n * ```\n *\n * ### Usage with a JSON ABI function object:\n *\n * ```ts\n * import { prepareContractCall } from \"thirdweb\";\n *\n * const transaction = prepareContractCall({\n *  contract,\n *  method: {\n *    name: \"transfer\",\n *    type: \"function\",\n *    inputs: [\n *      { name: \"to\", type: \"address\" },\n *      { name: \"value\", type: \"uint256\" },\n *    ],\n *    outputs: [],\n *    stateMutability: \"payable\"\n *   },\n *  params: [to, value],\n * });\n * ```\n *\n * ### Usage with the ABI defined on the contract:\n *\n * ```ts\n * import { getContract, prepareContractCall } from \"thirdweb\";\n * const contract = getContract({\n *  ..., // chain, address, client\n *  abi: [...] // ABI with a \"transfer\" method\n * });\n * const transaction = prepareContractCall({\n *  contract,\n *  method: \"transfer\", // <- this gets inferred from the contract\n *  params: [to, value],\n * });\n * ```\n *\n * ### Passing extra call data to the transaction\n * ```ts\n * import { getContract, prepareContractCall } from \"thirdweb\";\n * const contract = getContract({\n *   ..., // chain, address, client\n * });\n *\n * const transaction = prepareContractCall({\n *   contract,\n *   method: \"function transfer(address to, uint256 value)\",\n *   params: [...],\n *   // The extra call data MUST be encoded to hex before passing\n *   extraCallData: \"0x.......\"\n * });\n * ```\n */\nexport function prepareContractCall(options) {\n  const {\n      contract,\n      method,\n      params\n    } = options,\n    rest = _objectWithoutProperties(options, _excluded);\n  const preparedMethodPromise = () => (async _contract$abi => {\n    if (Array.isArray(method)) {\n      return method;\n    }\n    if (isAbiFunction(method)) {\n      return prepareMethod(method);\n    }\n    if (typeof method === \"function\") {\n      return prepareMethod(\n      // @ts-expect-error - method *is* function in this case\n      await method(contract));\n    }\n    // if the method starts with the string `function ` we always will want to try to parse it\n    if (typeof method === \"string\" && method.startsWith(\"function \")) {\n      // @ts-expect-error - method *is* string in this case\n      const abiItem = parseAbiItem(method);\n      if (abiItem.type === \"function\") {\n        return prepareMethod(abiItem);\n      }\n      throw new Error(\"\\\"method\\\" passed is not of type \\\"function\\\"\");\n    }\n    // check if we have a \"abi\" on the contract\n    if (contract.abi && ((_contract$abi = contract.abi) === null || _contract$abi === void 0 ? void 0 : _contract$abi.length) > 0) {\n      var _contract$abi2;\n      // extract the abiFunction from it\n      const abiFunction = (_contract$abi2 = contract.abi) === null || _contract$abi2 === void 0 ? void 0 : _contract$abi2.find(item => item.type === \"function\" && item.name === method);\n      // if we were able to find it -> return it\n      if (abiFunction) {\n        return prepareMethod(abiFunction);\n      }\n    }\n    throw new Error(\"Could not resolve method \\\"\".concat(method, \"\\\".\"));\n  })();\n  return prepareTransaction(_objectSpread(_objectSpread({}, rest), {}, {\n    chain: contract.chain,\n    client: contract.client,\n    data: async () => {\n      let preparedM;\n      if (Array.isArray(method)) {\n        preparedM = method;\n      } else {\n        preparedM = await preparedMethodPromise();\n      }\n      if (preparedM[1].length === 0) {\n        // just return the fn sig directly -> no params\n        return preparedM[0];\n      }\n      // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n      // we can do this because we know the specific formats of the values\n      return preparedM[0] + encodeAbiParameters(preparedM[1],\n      // @ts-expect-error - TODO: fix this type issue\n      await resolvePromisedValue(params !== null && params !== void 0 ? params : [])).slice(2);\n    },\n    // these always inferred from the contract\n    to: contract.address\n  }), {\n    contract: contract,\n    preparedMethod: preparedMethodPromise\n  });\n}","map":{"version":3,"names":["parseAbiItem","encodeAbiParameters","prepareMethod","resolvePromisedValue","prepareTransaction","isAbiFunction","prepareContractCall","options","contract","method","params","rest","_objectWithoutProperties","_excluded","preparedMethodPromise","_contract$abi","Array","isArray","startsWith","abiItem","type","Error","abi","length","_contract$abi2","abiFunction","find","item","name","concat","_objectSpread","chain","client","data","preparedM","slice","to","address","preparedMethod"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/transaction/prepare-contract-call.ts"],"sourcesContent":["import {\n  type Abi,\n  type AbiFunction,\n  type ExtractAbiFunctionNames,\n  parseAbiItem,\n} from \"abitype\";\nimport type { TransactionRequest } from \"viem\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\nimport { encodeAbiParameters } from \"../utils/abi/encodeAbiParameters.js\";\nimport {\n  type PreparedMethod,\n  prepareMethod,\n} from \"../utils/abi/prepare-method.js\";\nimport { resolvePromisedValue } from \"../utils/promise/resolve-promised-value.js\";\nimport {\n  type PrepareTransactionOptions,\n  prepareTransaction,\n} from \"./prepare-transaction.js\";\nimport type {\n  BaseTransactionOptions,\n  ParamsOption,\n  ParseMethod,\n} from \"./types.js\";\nimport { isAbiFunction } from \"./utils.js\";\n\nexport type PrepareContractCallOptions<\n  TAbi extends Abi = [],\n  TMethod extends\n    | AbiFunction\n    | string\n    | ((\n        contract: ThirdwebContract<TAbi>,\n      ) => Promise<AbiFunction>) = TAbi extends { length: 0 }\n    ? AbiFunction | string\n    : ExtractAbiFunctionNames<TAbi>,\n  TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n> = BaseTransactionOptions<\n  Omit<\n    TransactionRequest,\n    | \"from\"\n    | \"to\"\n    | \"data\"\n    | \"value\"\n    | \"accessList\"\n    | \"gas\"\n    | \"gasPrice\"\n    | \"maxFeePerGas\"\n    | \"maxPriorityFeePerGas\"\n    | \"nonce\"\n    | \"authorizationList\"\n  > & {\n    contract: ThirdwebContract<TAbi>;\n    method: TMethod | TPreparedMethod;\n  } & ParamsOption<TPreparedMethod[1]> &\n    Omit<PrepareTransactionOptions, \"to\" | \"data\" | \"chain\" | \"client\">,\n  TAbi\n>;\n\n/**\n * Prepares a contract call by resolving the ABI function, parameters and encoded data. Optionally specify other properties such as value or gas price.\n * @param options - The options for preparing the contract call.\n * @returns A promise that resolves to the prepared transaction.\n * @transaction\n * @example\n *\n * ### Usage with a human-readable method signature:\n *\n * ```ts\n * import { prepareContractCall } from \"thirdweb\";\n *\n * const transaction = prepareContractCall({\n *  contract,\n *  method: \"function transfer(address to, uint256 value)\",\n *  params: [to, value],\n * });\n * ```\n *\n * ### Usage with explicit gas price and/or value:\n *\n * ```ts\n * import { prepareContractCall } from \"thirdweb\";\n * import { toWei } from \"thirdweb/utils\";\n *\n * const transaction = prepareContractCall({\n *  contract,\n *  method: \"function transfer(address to, uint256 value)\",\n *  params: [to, value],\n *  maxFeePerGas: 30n,\n *  maxPriorityFeePerGas: 1n,\n *  value: toWei(\"0.01\"),\n * });\n * ```\n *\n * ### Usage with ERC20 value:\n *\n * For transactions that transfer ERC20 tokens, you can specify the value as the amount of tokens to transfer.\n *\n * You can use this in conjuction with the [`getApprovalForTransaction`](https://portal.thirdweb.com/references/typescript/v5/getApprovalForTransaction) function to easily create approval transactions for ERC20 tokens.\n *\n * This value will also be read by the react hooks and UI components to present to total cost to the user.\n *\n * ```ts\n * import { prepareContractCall } from \"thirdweb\";\n * import { toWei } from \"thirdweb/utils\";\n *\n * const transaction = prepareContractCall({\n *  contract,\n *  method: \"function payWithCoin()\",\n *  params: [],\n *  erc20Value: {\n *    tokenAddress: \"0x...\", // the address of the ERC20 token\n *    amountWei: toWei(\"0.1\"), // the amount of tokens to transfer in wei\n *  },\n * });\n * ```\n *\n * ### Usage with a JSON ABI function object:\n *\n * ```ts\n * import { prepareContractCall } from \"thirdweb\";\n *\n * const transaction = prepareContractCall({\n *  contract,\n *  method: {\n *    name: \"transfer\",\n *    type: \"function\",\n *    inputs: [\n *      { name: \"to\", type: \"address\" },\n *      { name: \"value\", type: \"uint256\" },\n *    ],\n *    outputs: [],\n *    stateMutability: \"payable\"\n *   },\n *  params: [to, value],\n * });\n * ```\n *\n * ### Usage with the ABI defined on the contract:\n *\n * ```ts\n * import { getContract, prepareContractCall } from \"thirdweb\";\n * const contract = getContract({\n *  ..., // chain, address, client\n *  abi: [...] // ABI with a \"transfer\" method\n * });\n * const transaction = prepareContractCall({\n *  contract,\n *  method: \"transfer\", // <- this gets inferred from the contract\n *  params: [to, value],\n * });\n * ```\n *\n * ### Passing extra call data to the transaction\n * ```ts\n * import { getContract, prepareContractCall } from \"thirdweb\";\n * const contract = getContract({\n *   ..., // chain, address, client\n * });\n *\n * const transaction = prepareContractCall({\n *   contract,\n *   method: \"function transfer(address to, uint256 value)\",\n *   params: [...],\n *   // The extra call data MUST be encoded to hex before passing\n *   extraCallData: \"0x.......\"\n * });\n * ```\n */\nexport function prepareContractCall<\n  const TAbi extends Abi,\n  const TMethod extends TAbi extends {\n    length: 0;\n  }\n    ?\n        | AbiFunction\n        | `function ${string}`\n        | ((contract: ThirdwebContract<TAbi>) => Promise<AbiFunction>)\n    : ExtractAbiFunctionNames<TAbi>,\n  const TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n>(options: PrepareContractCallOptions<TAbi, TMethod, TPreparedMethod>) {\n  type ParsedMethod_ = ParseMethod<TAbi, TMethod>;\n  type PreparedMethod_ = PreparedMethod<ParsedMethod_>;\n  const { contract, method, params, ...rest } = options;\n\n  const preparedMethodPromise = () =>\n    (async () => {\n      if (Array.isArray(method)) {\n        return method as PreparedMethod_;\n      }\n      if (isAbiFunction(method)) {\n        return prepareMethod(method as ParsedMethod_) as PreparedMethod_;\n      }\n\n      if (typeof method === \"function\") {\n        return prepareMethod(\n          // @ts-expect-error - method *is* function in this case\n          (await method(contract)) as ParsedMethod_,\n        ) as PreparedMethod_;\n      }\n      // if the method starts with the string `function ` we always will want to try to parse it\n      if (typeof method === \"string\" && method.startsWith(\"function \")) {\n        // @ts-expect-error - method *is* string in this case\n        const abiItem = parseAbiItem(method);\n        if (abiItem.type === \"function\") {\n          return prepareMethod(abiItem as ParsedMethod_) as PreparedMethod_;\n        }\n        throw new Error(`\"method\" passed is not of type \"function\"`);\n      }\n      // check if we have a \"abi\" on the contract\n      if (contract.abi && contract.abi?.length > 0) {\n        // extract the abiFunction from it\n        const abiFunction = contract.abi?.find(\n          (item) => item.type === \"function\" && item.name === method,\n        );\n        // if we were able to find it -> return it\n        if (abiFunction) {\n          return prepareMethod(abiFunction as ParsedMethod_) as PreparedMethod_;\n        }\n      }\n      throw new Error(`Could not resolve method \"${method}\".`);\n    })();\n\n  return prepareTransaction(\n    {\n      ...rest,\n      chain: contract.chain,\n      client: contract.client,\n      data: async () => {\n        let preparedM: PreparedMethod_;\n        if (Array.isArray(method)) {\n          preparedM = method as PreparedMethod_;\n        } else {\n          preparedM = await preparedMethodPromise();\n        }\n\n        if (preparedM[1].length === 0) {\n          // just return the fn sig directly -> no params\n          return preparedM[0];\n        }\n\n        // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n        // we can do this because we know the specific formats of the values\n        return (preparedM[0] +\n          encodeAbiParameters(\n            preparedM[1],\n            // @ts-expect-error - TODO: fix this type issue\n            await resolvePromisedValue(params ?? []),\n          ).slice(2)) as `${(typeof preparedM)[0]}${string}`;\n      },\n      // these always inferred from the contract\n      to: contract.address,\n    },\n    {\n      contract: contract,\n      preparedMethod: preparedMethodPromise,\n    },\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}