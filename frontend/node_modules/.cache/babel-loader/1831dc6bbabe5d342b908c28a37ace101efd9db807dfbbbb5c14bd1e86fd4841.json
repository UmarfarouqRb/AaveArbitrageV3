{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"queryOptions\", \"contract\"],\n  _excluded2 = [\"queryOptions\"];\nimport { queryOptions as defineQuery, useQuery } from \"@tanstack/react-query\";\nimport { readContract } from \"../../../../transaction/read-contract.js\";\nimport { getFunctionId } from \"../../../../utils/function-id.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nexport function useReadContract(extensionOrOptions, options) {\n  let queryKey;\n  let queryFn;\n  let queryOpts;\n  // extension case\n  if (typeof extensionOrOptions === \"function\") {\n    if (!options) {\n      throw new Error(\"Missing second argument for \\\"useReadContract(<extension>, <options>)\\\" hook.\");\n    }\n    const {\n        queryOptions,\n        contract\n      } = options,\n      params = _objectWithoutProperties(options, _excluded);\n    queryOpts = queryOptions;\n    queryKey = [\"readContract\", contract.chain.id, contract.address, getFunctionId(extensionOrOptions), stringify(params)];\n    queryFn = () => extensionOrOptions(_objectSpread(_objectSpread({}, params), {}, {\n      contract\n    }));\n  }\n  // raw tx case\n  if (\"method\" in extensionOrOptions) {\n    const {\n        queryOptions\n      } = extensionOrOptions,\n      tx = _objectWithoutProperties(extensionOrOptions, _excluded2);\n    queryOpts = queryOptions;\n    queryKey = [\"readContract\", tx.contract.chain.id, tx.contract.address, tx.method, stringify(tx.params)];\n    queryFn = () => readContract(extensionOrOptions);\n  }\n  if (!queryKey || !queryFn) {\n    throw new Error(\"Invalid \\\"useReadContract\\\" options. Expected either a read extension or a transaction object.\");\n  }\n  return useQuery(defineQuery(_objectSpread({\n    queryFn: queryFn,\n    queryKey: queryKey\n  }, queryOpts !== null && queryOpts !== void 0 ? queryOpts : {})));\n}","map":{"version":3,"names":["queryOptions","defineQuery","useQuery","readContract","getFunctionId","stringify","useReadContract","extensionOrOptions","options","queryKey","queryFn","queryOpts","Error","contract","params","_objectWithoutProperties","_excluded","chain","id","address","_objectSpread","tx","_excluded2","method"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/react/core/hooks/contract/useReadContract.ts"],"sourcesContent":["import {\n  queryOptions as defineQuery,\n  type UseQueryResult,\n  useQuery,\n} from \"@tanstack/react-query\";\nimport type { Abi, AbiFunction, ExtractAbiFunctionNames } from \"abitype\";\nimport type {\n  AbiOfLength,\n  AsyncGetAbiFunctionFromContract,\n} from \"../../../../contract/types.js\";\nimport type { Extension } from \"../../../../extensions/types.js\";\nimport {\n  type ReadContractOptions,\n  type ReadContractResult,\n  readContract,\n} from \"../../../../transaction/read-contract.js\";\nimport type {\n  BaseTransactionOptions,\n  ParseMethod,\n} from \"../../../../transaction/types.js\";\nimport type { PreparedMethod } from \"../../../../utils/abi/prepare-method.js\";\nimport { getFunctionId } from \"../../../../utils/function-id.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nimport type {\n  PickedOnceQueryOptions,\n  WithPickedOnceQueryOptions,\n} from \"../types.js\";\n\n/**\n * A hook to read state from a contract that automatically updates when the contract changes.\n *\n * You can use raw read calls or read [extensions](https://portal.thirdweb.com/react/v5/extensions) to read from a\n * contract.\n *\n * @param options - The options for reading from a contract\n * @returns a UseQueryResult object.\n * @example\n * ```jsx\n * import { getContract } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { useReadContract } from \"thirdweb/react\";\n *\n * const contract = getContract({\n *   client,\n *   address: \"0x...\",\n *   chain: sepolia,\n * });\n *\n * const { data, isLoading } = useReadContract({\n *   contract,\n *   method: \"function tokenURI(uint256 tokenId) returns (string)\"\n *   params: [1n],\n * });\n * ```\n * @contract\n */\nexport function useReadContract<\n  const TAbi extends Abi,\n  const TMethod extends TAbi extends AbiOfLength<0>\n    ? AbiFunction | string\n    : ExtractAbiFunctionNames<TAbi>,\n>(\n  options: WithPickedOnceQueryOptions<ReadContractOptions<TAbi, TMethod>>,\n): UseQueryResult<\n  ReadContractResult<PreparedMethod<ParseMethod<TAbi, TMethod>>[2]>\n>;\n/**\n * A hook to read state from a contract that automatically updates when the contract changes.\n * You can use raw read calls or read [extensions](https://portal.thirdweb.com/react/v5/extensions) to read from a\n * contract.\n *\n * @param extension - An extension to call.\n * @param options - The read extension params.\n * @returns a UseQueryResult object.\n * @example\n *\n * Read a contract extension let you do complex contract queries with less code.\n *\n * ```jsx\n * import { useReadContract } from \"thirdweb/react\";\n * import { getOwnedNFTs } form \"thirdweb/extensions/erc721\";\n *\n * const { data, isLoading } = useReadContract(getOwnedNFTs, { contract, owner: address });\n * ```\n */\nexport function useReadContract<\n  const TAbi extends Abi,\n  const TParams extends object,\n  TResult,\n>(\n  extension: Extension<TAbi, TParams, TResult>,\n  options: WithPickedOnceQueryOptions<BaseTransactionOptions<TParams, TAbi>>,\n): UseQueryResult<TResult>;\n\nexport function useReadContract<\n  const TAbi extends Abi,\n  const TMethod extends TAbi extends AbiOfLength<0>\n    ? AbiFunction | `function ${string}` | AsyncGetAbiFunctionFromContract<TAbi>\n    : ExtractAbiFunctionNames<TAbi>,\n  const TParams extends object,\n  TResult,\n>(\n  extensionOrOptions:\n    | Extension<TAbi, TParams, TResult>\n    | WithPickedOnceQueryOptions<ReadContractOptions<TAbi, TMethod>>,\n  options?: WithPickedOnceQueryOptions<BaseTransactionOptions<TParams, TAbi>>,\n) {\n  type QueryKey = readonly [\n    \"readContract\",\n    number | string,\n    string,\n    string | PreparedMethod<ParseMethod<TAbi, TMethod>>,\n    string,\n  ];\n  type QueryFn = () => Promise<\n    TResult | ReadContractResult<PreparedMethod<ParseMethod<TAbi, TMethod>>[2]>\n  >;\n\n  let queryKey: QueryKey | undefined;\n  let queryFn: QueryFn | undefined;\n  let queryOpts: PickedOnceQueryOptions | undefined;\n\n  // extension case\n  if (typeof extensionOrOptions === \"function\") {\n    if (!options) {\n      throw new Error(\n        `Missing second argument for \"useReadContract(<extension>, <options>)\" hook.`,\n      ) as never;\n    }\n    const { queryOptions, contract, ...params } = options;\n    queryOpts = queryOptions;\n\n    queryKey = [\n      \"readContract\",\n      contract.chain.id,\n      contract.address,\n      getFunctionId(extensionOrOptions),\n      stringify(params),\n    ] as const;\n\n    queryFn = () =>\n      extensionOrOptions({\n        ...(params as TParams),\n        contract,\n      });\n  }\n  // raw tx case\n  if (\"method\" in extensionOrOptions) {\n    const { queryOptions, ...tx } = extensionOrOptions;\n    queryOpts = queryOptions;\n\n    queryKey = [\n      \"readContract\",\n      tx.contract.chain.id,\n      tx.contract.address,\n      tx.method,\n      stringify(tx.params),\n    ] as const;\n\n    queryFn = () => readContract(extensionOrOptions);\n  }\n\n  if (!queryKey || !queryFn) {\n    throw new Error(\n      `Invalid \"useReadContract\" options. Expected either a read extension or a transaction object.`,\n    ) as never;\n  }\n\n  return useQuery(\n    defineQuery({\n      queryFn: queryFn as QueryFn,\n      queryKey: queryKey as QueryKey,\n      ...(queryOpts ?? {}),\n    }),\n  );\n}\n"],"mappings":";;;;AAAA,SACEA,YAAY,IAAIC,WAAW,EAE3BC,QAAQ,QACH,uBAAuB;AAO9B,SAGEC,YAAY,QACP,0CAA0C;AAMjD,SAASC,aAAa,QAAQ,kCAAkC;AAChE,SAASC,SAAS,QAAQ,2BAA2B;AAwErD,OAAM,SAAUC,eAAeA,CAQ7BC,kBAEkE,EAClEC,OAA2E;EAa3E,IAAIC,QAA8B;EAClC,IAAIC,OAA4B;EAChC,IAAIC,SAA6C;EAEjD;EACA,IAAI,OAAOJ,kBAAkB,KAAK,UAAU,EAAE;IAC5C,IAAI,CAACC,OAAO,EAAE;MACZ,MAAM,IAAII,KAAK,gFACgE,CACrE;IACZ;IACA,MAAM;QAAEZ,YAAY;QAAEa;MAAmB,CAAE,GAAGL,OAAO;MAAlBM,MAAM,GAAAC,wBAAA,CAAKP,OAAO,EAAAQ,SAAA;IACrDL,SAAS,GAAGX,YAAY;IAExBS,QAAQ,GAAG,CACT,cAAc,EACdI,QAAQ,CAACI,KAAK,CAACC,EAAE,EACjBL,QAAQ,CAACM,OAAO,EAChBf,aAAa,CAACG,kBAAkB,CAAC,EACjCF,SAAS,CAACS,MAAM,CAAC,CACT;IAEVJ,OAAO,GAAGA,CAAA,KACRH,kBAAkB,CAAAa,aAAA,CAAAA,aAAA,KACZN,MAAkB;MACtBD;IAAQ,EACT,CAAC;EACN;EACA;EACA,IAAI,QAAQ,IAAIN,kBAAkB,EAAE;IAClC,MAAM;QAAEP;MAAmB,CAAE,GAAGO,kBAAkB;MAAzBc,EAAE,GAAAN,wBAAA,CAAKR,kBAAkB,EAAAe,UAAA;IAClDX,SAAS,GAAGX,YAAY;IAExBS,QAAQ,GAAG,CACT,cAAc,EACdY,EAAE,CAACR,QAAQ,CAACI,KAAK,CAACC,EAAE,EACpBG,EAAE,CAACR,QAAQ,CAACM,OAAO,EACnBE,EAAE,CAACE,MAAM,EACTlB,SAAS,CAACgB,EAAE,CAACP,MAAM,CAAC,CACZ;IAEVJ,OAAO,GAAGA,CAAA,KAAMP,YAAY,CAACI,kBAAkB,CAAC;EAClD;EAEA,IAAI,CAACE,QAAQ,IAAI,CAACC,OAAO,EAAE;IACzB,MAAM,IAAIE,KAAK,iGACiF,CACtF;EACZ;EAEA,OAAOV,QAAQ,CACbD,WAAW,CAAAmB,aAAA;IACTV,OAAO,EAAEA,OAAkB;IAC3BD,QAAQ,EAAEA;EAAoB,GAC1BE,SAAS,aAATA,SAAS,cAATA,SAAS,GAAI,EAAE,CACpB,CAAC,CACH;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}