{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { getTypesForEIP712Domain, SwitchChainError, serializeTypedData, UserRejectedRequestError, validateTypedData } from \"viem\";\nimport { trackTransaction } from \"../../analytics/track/transaction.js\";\nimport { getCachedChain, getRpcUrlForChain } from \"../../chains/utils.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { numberToHex, stringToHex, uint8ArrayToHex } from \"../../utils/encoding/hex.js\";\nimport { stringify } from \"../../utils/json.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parse-typed-data.js\";\nimport { getSavedConnectParamsFromStorage, saveConnectParamsToStorage } from \"../../utils/storage/walletStorage.js\";\nimport { formatWalletConnectUrl } from \"../../utils/url.js\";\nimport { getWalletInfo } from \"../__generated__/getWalletInfo.js\";\nimport { getDefaultAppMetadata } from \"../utils/defaultDappMetadata.js\";\nimport { normalizeChainId } from \"../utils/normalizeChainId.js\";\nimport { DEFAULT_PROJECT_ID, NAMESPACE } from \"./constants.js\";\nlet cachedProvider = null;\nconst storageKeys = {\n  lastUsedChainId: \"tw.wc.lastUsedChainId\",\n  requestedChains: \"tw.wc.requestedChains\"\n};\n/**\n * Checks if the provided wallet is a Wallet Connect wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is a Wallet Connect wallet, false otherwise.\n */\nexport function isWalletConnect(wallet) {\n  return wallet.id === \"walletConnect\";\n}\n/**\n * @internal\n */\nexport async function connectWC(options, emitter, walletId, storage, sessionHandler) {\n  var _chainsToRequest$;\n  const provider = await initProvider(options, walletId, sessionHandler);\n  const wcOptions = options.walletConnect;\n  let {\n    onDisplayUri\n  } = wcOptions || {};\n  const walletInfo = await getWalletInfo(walletId);\n  // use default sessionHandler unless onDisplayUri is explicitly provided\n  if (!onDisplayUri && sessionHandler) {\n    const deeplinkHandler = uri => {\n      const appUrl = walletInfo.mobile.native || walletInfo.mobile.universal;\n      if (!appUrl) {\n        // generic wc uri\n        sessionHandler(uri);\n        return;\n      }\n      const fullUrl = formatWalletConnectUrl(appUrl, uri).redirect;\n      sessionHandler(fullUrl);\n    };\n    onDisplayUri = deeplinkHandler;\n  }\n  if (onDisplayUri) {\n    provider.events.addListener(\"display_uri\", onDisplayUri);\n  }\n  let optionalChains = wcOptions === null || wcOptions === void 0 ? void 0 : wcOptions.optionalChains;\n  let chainToRequest = options.chain;\n  // ignore the given options chains - and set the safe supported chains\n  if (walletId === \"global.safe\") {\n    optionalChains = chainsToRequestForSafe.map(getCachedChain);\n    if (chainToRequest && !optionalChains.includes(chainToRequest)) {\n      chainToRequest = undefined;\n    }\n  }\n  // For UniversalProvider, we still need chain configuration for session management\n  const {\n    chains: chainsToRequest,\n    rpcMap\n  } = getChainsToRequest({\n    chain: chainToRequest,\n    client: options.client,\n    optionalChains: optionalChains\n  });\n  // For UniversalProvider, we need to connect with namespaces\n  await provider.connect(_objectSpread(_objectSpread({}, wcOptions !== null && wcOptions !== void 0 && wcOptions.pairingTopic ? {\n    pairingTopic: wcOptions === null || wcOptions === void 0 ? void 0 : wcOptions.pairingTopic\n  } : {}), {}, {\n    optionalNamespaces: {\n      [NAMESPACE]: {\n        chains: chainsToRequest,\n        events: [\"chainChanged\", \"accountsChanged\"],\n        methods: [\"eth_sendTransaction\", \"eth_signTransaction\", \"eth_sign\", \"personal_sign\", \"eth_signTypedData\", \"eth_signTypedData_v4\", \"wallet_switchEthereumChain\", \"wallet_addEthereumChain\"],\n        rpcMap\n      }\n    }\n  }));\n  setRequestedChainsIds(chainsToRequest.map(x => Number(x.split(\":\")[1])), storage);\n  const currentChainId = ((_chainsToRequest$ = chainsToRequest[0]) === null || _chainsToRequest$ === void 0 ? void 0 : _chainsToRequest$.split(\":\")[1]) || 1;\n  const providerChainId = normalizeChainId(currentChainId);\n  const account = firstAccountOn(provider.session, \"eip155:1\"); // grab the address from mainnet if available\n  const address = account;\n  if (!address) {\n    throw new Error(\"No accounts found on provider.\");\n  }\n  const chain = options.chain && options.chain.id === providerChainId ? options.chain : getCachedChain(providerChainId);\n  if (options) {\n    var _options$walletConnec, _options$walletConnec2;\n    const savedParams = {\n      chain: options.chain,\n      optionalChains: (_options$walletConnec = options.walletConnect) === null || _options$walletConnec === void 0 ? void 0 : _options$walletConnec.optionalChains,\n      pairingTopic: (_options$walletConnec2 = options.walletConnect) === null || _options$walletConnec2 === void 0 ? void 0 : _options$walletConnec2.pairingTopic\n    };\n    if (storage) {\n      saveConnectParamsToStorage(storage, walletId, savedParams);\n    }\n  }\n  if (onDisplayUri) {\n    provider.events.removeListener(\"display_uri\", onDisplayUri);\n  }\n  return onConnect(address, chain, provider, emitter, storage, options.client, walletInfo, sessionHandler);\n}\nasync function ensureTargetChain(provider, chain, walletInfo) {\n  if (!provider.session) {\n    throw new Error(\"No session found on provider.\");\n  }\n  const TARGET_CAIP = \"eip155:\".concat(chain.id);\n  const TARGET_HEX = numberToHex(chain.id);\n  // Fast path: already enabled\n  if (hasChainEnabled(provider.session, TARGET_CAIP)) {\n    provider.setDefaultChain(TARGET_CAIP);\n    return;\n  }\n  // 1) Try switch\n  try {\n    await requestAndOpenWallet({\n      provider,\n      payload: {\n        method: \"wallet_switchEthereumChain\",\n        params: [{\n          chainId: TARGET_HEX\n        }]\n      },\n      chain: TARGET_CAIP,\n      // route to target\n      walletInfo\n    });\n    provider.setDefaultChain(TARGET_CAIP);\n    return;\n  } catch (err) {\n    var _err$code, _err$data;\n    const code = (_err$code = err === null || err === void 0 ? void 0 : err.code) !== null && _err$code !== void 0 ? _err$code : err === null || err === void 0 || (_err$data = err.data) === null || _err$data === void 0 || (_err$data = _err$data.originalError) === null || _err$data === void 0 ? void 0 : _err$data.code;\n    // 4001 user rejected; stop\n    if (code === 4001) throw new Error(\"User rejected chain switch\");\n    // fall through on 4902 or unknown -> try add\n  }\n  // 2) Add the chain via any chain we already have\n  const routeChain = anyRoutableChain(provider.session);\n  if (!routeChain) throw new Error(\"No routable chain to send wallet_addEthereumChain\");\n  try {\n    var _chain$blockExplorers, _chain$blockExplorers2;\n    await requestAndOpenWallet({\n      provider,\n      payload: {\n        method: \"wallet_addEthereumChain\",\n        params: [{\n          chainId: TARGET_HEX,\n          chainName: chain.name,\n          nativeCurrency: chain.nativeCurrency,\n          rpcUrls: [chain.rpc],\n          blockExplorerUrls: [(_chain$blockExplorers = (_chain$blockExplorers2 = chain.blockExplorers) === null || _chain$blockExplorers2 === void 0 || (_chain$blockExplorers2 = _chain$blockExplorers2[0]) === null || _chain$blockExplorers2 === void 0 ? void 0 : _chain$blockExplorers2.url) !== null && _chain$blockExplorers !== void 0 ? _chain$blockExplorers : \"\"]\n        }]\n      },\n      chain: routeChain,\n      // route via known-good chain, not the target\n      walletInfo\n    });\n  } catch (err) {\n    var _err$code2, _err$data2;\n    const code = (_err$code2 = err === null || err === void 0 ? void 0 : err.code) !== null && _err$code2 !== void 0 ? _err$code2 : err === null || err === void 0 || (_err$data2 = err.data) === null || _err$data2 === void 0 || (_err$data2 = _err$data2.originalError) === null || _err$data2 === void 0 ? void 0 : _err$data2.code;\n    if (code === 4001) throw new Error(\"User rejected add chain\");\n    throw new Error(\"Add chain failed: \".concat((err === null || err === void 0 ? void 0 : err.message) || String(err)));\n  }\n  // 3) Re-try switch after add\n  await requestAndOpenWallet({\n    provider,\n    payload: {\n      method: \"wallet_switchEthereumChain\",\n      params: [{\n        chainId: TARGET_HEX\n      }]\n    },\n    chain: TARGET_CAIP,\n    walletInfo\n  });\n  provider.setDefaultChain(TARGET_CAIP);\n  // 4) Verify enablement\n  if (!hasChainEnabled(provider.session, TARGET_CAIP)) {\n    throw new Error(\"Target chain still not enabled by wallet\");\n  }\n}\nfunction getNS(session) {\n  var _session$namespaces;\n  return session === null || session === void 0 || (_session$namespaces = session.namespaces) === null || _session$namespaces === void 0 ? void 0 : _session$namespaces.eip155;\n}\nfunction hasChainEnabled(session, caip) {\n  var _ns$accounts;\n  const ns = getNS(session);\n  return !!(ns !== null && ns !== void 0 && (_ns$accounts = ns.accounts) !== null && _ns$accounts !== void 0 && _ns$accounts.some(a => a.startsWith(\"\".concat(caip, \":\"))));\n}\nfunction firstAccountOn(session, caip) {\n  var _ns$accounts2, _hit$split$;\n  const ns = getNS(session);\n  const hit = (ns === null || ns === void 0 || (_ns$accounts2 = ns.accounts) === null || _ns$accounts2 === void 0 ? void 0 : _ns$accounts2.find(a => a.startsWith(\"\".concat(caip, \":\")))) || (ns === null || ns === void 0 ? void 0 : ns.accounts[0]);\n  return hit ? (_hit$split$ = hit.split(\":\")[2]) !== null && _hit$split$ !== void 0 ? _hit$split$ : null : null;\n}\nfunction anyRoutableChain(session) {\n  var _ns$accounts$0$split$, _ns$accounts3;\n  const ns = getNS(session);\n  return (_ns$accounts$0$split$ = ns === null || ns === void 0 || (_ns$accounts3 = ns.accounts) === null || _ns$accounts3 === void 0 || (_ns$accounts3 = _ns$accounts3[0]) === null || _ns$accounts3 === void 0 || (_ns$accounts3 = _ns$accounts3.split(\":\")) === null || _ns$accounts3 === void 0 || (_ns$accounts3 = _ns$accounts3.slice(0, 2)) === null || _ns$accounts3 === void 0 ? void 0 : _ns$accounts3.join(\":\")) !== null && _ns$accounts$0$split$ !== void 0 ? _ns$accounts$0$split$ : null; // e.g. \"eip155:1\"\n}\n/**\n * Auto connect to already connected wallet connect session.\n * @internal\n */\nexport async function autoConnectWC(options, emitter, walletId, storage, sessionHandler) {\n  var _provider$session, _namespaceAccounts$, _options$chain;\n  const savedConnectParams = storage ? await getSavedConnectParamsFromStorage(storage, walletId) : null;\n  const walletInfo = await getWalletInfo(walletId);\n  const provider = await initProvider(savedConnectParams ? {\n    chain: savedConnectParams.chain,\n    client: options.client,\n    walletConnect: {\n      optionalChains: savedConnectParams.optionalChains,\n      pairingTopic: savedConnectParams.pairingTopic\n    }\n  } : {\n    client: options.client,\n    walletConnect: {}\n  }, walletId, sessionHandler);\n  if (!provider.session) {\n    await provider.disconnect();\n    throw new Error(\"No wallet connect session found on provider.\");\n  }\n  // For UniversalProvider, get accounts from enable() method\n  const namespaceAccounts = (_provider$session = provider.session) === null || _provider$session === void 0 || (_provider$session = _provider$session.namespaces) === null || _provider$session === void 0 || (_provider$session = _provider$session[NAMESPACE]) === null || _provider$session === void 0 ? void 0 : _provider$session.accounts;\n  const address = namespaceAccounts === null || namespaceAccounts === void 0 || (_namespaceAccounts$ = namespaceAccounts[0]) === null || _namespaceAccounts$ === void 0 ? void 0 : _namespaceAccounts$.split(\":\")[2];\n  if (!address) {\n    throw new Error(\"No accounts found on provider.\");\n  }\n  // For UniversalProvider, get chainId from the session namespaces or use default\n  const currentChainId = ((_options$chain = options.chain) === null || _options$chain === void 0 ? void 0 : _options$chain.id) || 1;\n  const providerChainId = normalizeChainId(currentChainId);\n  const chain = options.chain && options.chain.id === providerChainId ? options.chain : getCachedChain(providerChainId);\n  return onConnect(address, chain, provider, emitter, storage, options.client, walletInfo, sessionHandler);\n}\n// Connection utils -----------------------------------------------------------------------------------------------\nasync function initProvider(options, walletId, sessionRequestHandler) {\n  var _wcOptions$appMetadat, _wcOptions$appMetadat2, _wcOptions$appMetadat3, _wcOptions$appMetadat4;\n  if (cachedProvider) {\n    return cachedProvider;\n  }\n  const walletInfo = await getWalletInfo(walletId);\n  const wcOptions = options.walletConnect;\n  const {\n    UniversalProvider\n  } = await import(\"@walletconnect/universal-provider\");\n  let optionalChains = wcOptions === null || wcOptions === void 0 ? void 0 : wcOptions.optionalChains;\n  let chainToRequest = options.chain;\n  // ignore the given options chains - and set the safe supported chains\n  if (walletId === \"global.safe\") {\n    optionalChains = chainsToRequestForSafe.map(getCachedChain);\n    if (chainToRequest && !optionalChains.includes(chainToRequest)) {\n      chainToRequest = undefined;\n    }\n  }\n  const provider = await UniversalProvider.init({\n    metadata: {\n      description: (wcOptions === null || wcOptions === void 0 || (_wcOptions$appMetadat = wcOptions.appMetadata) === null || _wcOptions$appMetadat === void 0 ? void 0 : _wcOptions$appMetadat.description) || getDefaultAppMetadata().description,\n      icons: [(wcOptions === null || wcOptions === void 0 || (_wcOptions$appMetadat2 = wcOptions.appMetadata) === null || _wcOptions$appMetadat2 === void 0 ? void 0 : _wcOptions$appMetadat2.logoUrl) || getDefaultAppMetadata().logoUrl],\n      name: (wcOptions === null || wcOptions === void 0 || (_wcOptions$appMetadat3 = wcOptions.appMetadata) === null || _wcOptions$appMetadat3 === void 0 ? void 0 : _wcOptions$appMetadat3.name) || getDefaultAppMetadata().name,\n      url: (wcOptions === null || wcOptions === void 0 || (_wcOptions$appMetadat4 = wcOptions.appMetadata) === null || _wcOptions$appMetadat4 === void 0 ? void 0 : _wcOptions$appMetadat4.url) || getDefaultAppMetadata().url,\n      redirect: {\n        native: walletInfo.mobile.native || undefined,\n        universal: walletInfo.mobile.universal || undefined\n      }\n    },\n    projectId: (wcOptions === null || wcOptions === void 0 ? void 0 : wcOptions.projectId) || DEFAULT_PROJECT_ID\n  });\n  provider.events.setMaxListeners(Number.POSITIVE_INFINITY);\n  if (walletId !== \"walletConnect\") {\n    async function handleSessionRequest() {\n      var _provider$session2;\n      const walletLinkToOpen = ((_provider$session2 = provider.session) === null || _provider$session2 === void 0 || (_provider$session2 = _provider$session2.peer) === null || _provider$session2 === void 0 || (_provider$session2 = _provider$session2.metadata) === null || _provider$session2 === void 0 || (_provider$session2 = _provider$session2.redirect) === null || _provider$session2 === void 0 ? void 0 : _provider$session2.native) || walletInfo.mobile.native || walletInfo.mobile.universal;\n      if (sessionRequestHandler && walletLinkToOpen) {\n        // TODO: propagate error when this fails\n        await sessionRequestHandler(walletLinkToOpen);\n      }\n    }\n    // For UniversalProvider, use different event handling\n    provider.on(\"session_request_sent\", handleSessionRequest);\n    provider.events.addListener(\"disconnect\", () => {\n      provider.off(\"session_request_sent\", handleSessionRequest);\n      cachedProvider = null;\n    });\n  }\n  cachedProvider = provider;\n  return provider;\n}\nfunction createAccount(_ref) {\n  let {\n    provider,\n    address,\n    client,\n    chain,\n    sessionRequestHandler,\n    walletInfo\n  } = _ref;\n  const account = {\n    address: getAddress(address),\n    async sendTransaction(tx) {\n      var _tx$to;\n      const transactionHash = await requestAndOpenWallet({\n        provider,\n        payload: {\n          method: \"eth_sendTransaction\",\n          params: [{\n            data: tx.data,\n            from: getAddress(address),\n            gas: tx.gas ? numberToHex(tx.gas) : undefined,\n            to: tx.to,\n            value: tx.value ? numberToHex(tx.value) : undefined\n          }]\n        },\n        chain: \"eip155:\".concat(tx.chainId),\n        walletInfo,\n        sessionRequestHandler\n      });\n      trackTransaction({\n        chainId: tx.chainId,\n        client: client,\n        contractAddress: (_tx$to = tx.to) !== null && _tx$to !== void 0 ? _tx$to : undefined,\n        gasPrice: tx.gasPrice,\n        transactionHash,\n        walletAddress: getAddress(address),\n        walletType: \"walletConnect\"\n      });\n      return {\n        transactionHash\n      };\n    },\n    async signMessage(_ref2) {\n      let {\n        message\n      } = _ref2;\n      const messageToSign = (() => {\n        if (typeof message === \"string\") {\n          return stringToHex(message);\n        }\n        if (message.raw instanceof Uint8Array) {\n          return uint8ArrayToHex(message.raw);\n        }\n        return message.raw;\n      })();\n      return requestAndOpenWallet({\n        provider,\n        payload: {\n          method: \"personal_sign\",\n          params: [messageToSign, this.address]\n        },\n        chain: \"eip155:\".concat(chain.id),\n        walletInfo,\n        sessionRequestHandler\n      });\n    },\n    async signTypedData(_data) {\n      const data = parseTypedData(_data);\n      const {\n        domain,\n        message,\n        primaryType\n      } = data;\n      const types = _objectSpread({\n        EIP712Domain: getTypesForEIP712Domain({\n          domain\n        })\n      }, data.types);\n      // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n      // as we can't statically check this with TypeScript.\n      validateTypedData({\n        domain,\n        message,\n        primaryType,\n        types\n      });\n      const typedData = serializeTypedData({\n        domain: domain !== null && domain !== void 0 ? domain : {},\n        message,\n        primaryType,\n        types\n      });\n      return await requestAndOpenWallet({\n        provider,\n        payload: {\n          method: \"eth_signTypedData_v4\",\n          params: [this.address, typedData]\n        },\n        chain: \"eip155:\".concat(chain.id),\n        walletInfo,\n        sessionRequestHandler\n      });\n    }\n  };\n  return account;\n}\nasync function requestAndOpenWallet(args) {\n  var _provider$session3;\n  const {\n    provider,\n    payload,\n    chain,\n    walletInfo,\n    sessionRequestHandler\n  } = args;\n  const resultPromise = provider.request(payload, chain);\n  const walletLinkToOpen = ((_provider$session3 = provider.session) === null || _provider$session3 === void 0 || (_provider$session3 = _provider$session3.peer) === null || _provider$session3 === void 0 || (_provider$session3 = _provider$session3.metadata) === null || _provider$session3 === void 0 || (_provider$session3 = _provider$session3.redirect) === null || _provider$session3 === void 0 ? void 0 : _provider$session3.native) || walletInfo.mobile.native || walletInfo.mobile.universal;\n  if (sessionRequestHandler && walletLinkToOpen) {\n    await sessionRequestHandler(walletLinkToOpen);\n  }\n  return resultPromise;\n}\nfunction onConnect(address, chain, provider, emitter, storage, client, walletInfo, sessionRequestHandler) {\n  const account = createAccount({\n    address,\n    chain,\n    client,\n    provider,\n    sessionRequestHandler,\n    walletInfo\n  });\n  async function disconnect() {\n    provider.removeListener(\"accountsChanged\", onAccountsChanged);\n    provider.removeListener(\"chainChanged\", onChainChanged);\n    provider.removeListener(\"disconnect\", onDisconnect);\n    await provider.disconnect();\n    cachedProvider = null;\n  }\n  function onDisconnect() {\n    setRequestedChainsIds([], storage);\n    storage === null || storage === void 0 || storage.removeItem(storageKeys.lastUsedChainId);\n    disconnect();\n    emitter.emit(\"disconnect\", undefined);\n  }\n  function onAccountsChanged(accounts) {\n    if (accounts[0]) {\n      const newAccount = createAccount({\n        address: getAddress(accounts[0]),\n        chain,\n        client,\n        provider,\n        sessionRequestHandler,\n        walletInfo\n      });\n      emitter.emit(\"accountChanged\", newAccount);\n      emitter.emit(\"accountsChanged\", accounts);\n    } else {\n      onDisconnect();\n    }\n  }\n  function onChainChanged(newChainId) {\n    const newChain = getCachedChain(normalizeChainId(newChainId));\n    emitter.emit(\"chainChanged\", newChain);\n    storage === null || storage === void 0 || storage.setItem(storageKeys.lastUsedChainId, String(newChainId));\n  }\n  provider.on(\"accountsChanged\", onAccountsChanged);\n  provider.on(\"chainChanged\", onChainChanged);\n  provider.on(\"disconnect\", onDisconnect);\n  provider.on(\"session_delete\", onDisconnect);\n  return [account, chain, disconnect, newChain => switchChainWC(provider, newChain, walletInfo)];\n}\nasync function switchChainWC(provider, chain, walletInfo) {\n  try {\n    await ensureTargetChain(provider, chain, walletInfo);\n  } catch (error) {\n    const message = typeof error === \"string\" ? error : error === null || error === void 0 ? void 0 : error.message;\n    if (/user rejected request/i.test(message)) {\n      throw new UserRejectedRequestError(error);\n    }\n    throw new SwitchChainError(error);\n  }\n}\n/**\n * Set the requested chains to the storage.\n * @internal\n */\nfunction setRequestedChainsIds(chains, storage) {\n  storage === null || storage === void 0 || storage.setItem(storageKeys.requestedChains, stringify(chains));\n}\nfunction getChainsToRequest(options) {\n  const rpcMap = {};\n  const chainIds = [];\n  if (options.chain) {\n    rpcMap[options.chain.id] = getRpcUrlForChain({\n      chain: options.chain,\n      client: options.client\n    });\n    chainIds.push(options.chain.id);\n  }\n  // limit optional chains to 10\n  const optionalChains = ((options === null || options === void 0 ? void 0 : options.optionalChains) || []).slice(0, 10);\n  for (const chain of optionalChains) {\n    rpcMap[chain.id] = getRpcUrlForChain({\n      chain: chain,\n      client: options.client\n    });\n    chainIds.push(chain.id);\n  }\n  // always include mainnet\n  // many wallets only support a handful of chains, but mainnet is always supported\n  // we will add additional chains in switchChain if needed\n  if (!chainIds.includes(1)) {\n    rpcMap[1] = getCachedChain(1).rpc;\n    chainIds.push(1);\n  }\n  return {\n    chains: chainIds.map(x => \"eip155:\".concat(x)),\n    rpcMap\n  };\n}\nconst chainsToRequestForSafe = [1,\n// Ethereum Mainnet\n11155111,\n// Sepolia Testnet\n42161,\n// Arbitrum One Mainnet\n43114,\n// Avalanche Mainnet\n8453,\n// Base Mainnet\n1313161554,\n// Aurora Mainnet\n84532,\n// Base Sepolia Testnet\n56,\n// Binance Smart Chain Mainnet\n42220,\n// Celo Mainnet\n100,\n// Gnosis Mainnet\n10,\n// Optimism Mainnet\n137,\n// Polygon Mainnet\n1101,\n// Polygon zkEVM Mainnet\n324,\n// zkSync Era mainnet\n534352 // Scroll mainnet\n];","map":{"version":3,"names":["getTypesForEIP712Domain","SwitchChainError","serializeTypedData","UserRejectedRequestError","validateTypedData","trackTransaction","getCachedChain","getRpcUrlForChain","getAddress","numberToHex","stringToHex","uint8ArrayToHex","stringify","parseTypedData","getSavedConnectParamsFromStorage","saveConnectParamsToStorage","formatWalletConnectUrl","getWalletInfo","getDefaultAppMetadata","normalizeChainId","DEFAULT_PROJECT_ID","NAMESPACE","cachedProvider","storageKeys","lastUsedChainId","requestedChains","isWalletConnect","wallet","id","connectWC","options","emitter","walletId","storage","sessionHandler","_chainsToRequest$","provider","initProvider","wcOptions","walletConnect","onDisplayUri","walletInfo","deeplinkHandler","uri","appUrl","mobile","native","universal","fullUrl","redirect","events","addListener","optionalChains","chainToRequest","chain","chainsToRequestForSafe","map","includes","undefined","chains","chainsToRequest","rpcMap","getChainsToRequest","client","connect","_objectSpread","pairingTopic","optionalNamespaces","methods","setRequestedChainsIds","x","Number","split","currentChainId","providerChainId","account","firstAccountOn","session","address","Error","_options$walletConnec","_options$walletConnec2","savedParams","removeListener","onConnect","ensureTargetChain","TARGET_CAIP","concat","TARGET_HEX","hasChainEnabled","setDefaultChain","requestAndOpenWallet","payload","method","params","chainId","err","_err$code","_err$data","code","data","originalError","routeChain","anyRoutableChain","_chain$blockExplorers","_chain$blockExplorers2","chainName","name","nativeCurrency","rpcUrls","rpc","blockExplorerUrls","blockExplorers","url","_err$code2","_err$data2","message","String","getNS","_session$namespaces","namespaces","eip155","caip","_ns$accounts","ns","accounts","some","a","startsWith","_ns$accounts2","_hit$split$","hit","find","_ns$accounts$0$split$","_ns$accounts3","slice","join","autoConnectWC","_provider$session","_namespaceAccounts$","_options$chain","savedConnectParams","disconnect","namespaceAccounts","sessionRequestHandler","_wcOptions$appMetadat","_wcOptions$appMetadat2","_wcOptions$appMetadat3","_wcOptions$appMetadat4","UniversalProvider","init","metadata","description","appMetadata","icons","logoUrl","projectId","setMaxListeners","POSITIVE_INFINITY","handleSessionRequest","_provider$session2","walletLinkToOpen","peer","on","off","createAccount","_ref","sendTransaction","tx","_tx$to","transactionHash","from","gas","to","value","contractAddress","gasPrice","walletAddress","walletType","signMessage","_ref2","messageToSign","raw","Uint8Array","signTypedData","_data","domain","primaryType","types","EIP712Domain","typedData","args","_provider$session3","resultPromise","request","onAccountsChanged","onChainChanged","onDisconnect","removeItem","emit","newAccount","newChainId","newChain","setItem","switchChainWC","error","test","chainIds","push"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/wallets/wallet-connect/controller.ts"],"sourcesContent":["import type {\n  RequestArguments,\n  UniversalProvider,\n} from \"@walletconnect/universal-provider\";\nimport type { Address } from \"abitype\";\nimport {\n  getTypesForEIP712Domain,\n  type ProviderRpcError,\n  type SignTypedDataParameters,\n  SwitchChainError,\n  serializeTypedData,\n  UserRejectedRequestError,\n  validateTypedData,\n} from \"viem\";\nimport { trackTransaction } from \"../../analytics/track/transaction.js\";\nimport type { Chain } from \"../../chains/types.js\";\nimport { getCachedChain, getRpcUrlForChain } from \"../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport {\n  type Hex,\n  numberToHex,\n  stringToHex,\n  uint8ArrayToHex,\n} from \"../../utils/encoding/hex.js\";\nimport { stringify } from \"../../utils/json.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parse-typed-data.js\";\nimport type { AsyncStorage } from \"../../utils/storage/AsyncStorage.js\";\nimport {\n  getSavedConnectParamsFromStorage,\n  saveConnectParamsToStorage,\n} from \"../../utils/storage/walletStorage.js\";\nimport { formatWalletConnectUrl } from \"../../utils/url.js\";\nimport { getWalletInfo } from \"../__generated__/getWalletInfo.js\";\nimport type { WCSupportedWalletIds } from \"../__generated__/wallet-ids.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n  Wallet,\n} from \"../interfaces/wallet.js\";\nimport type { DisconnectFn, SwitchChainFn } from \"../types.js\";\nimport { getDefaultAppMetadata } from \"../utils/defaultDappMetadata.js\";\nimport { normalizeChainId } from \"../utils/normalizeChainId.js\";\nimport type { WalletEmitter } from \"../wallet-emitter.js\";\nimport type { WalletInfo } from \"../wallet-info.js\";\nimport type { WalletId } from \"../wallet-types.js\";\nimport { DEFAULT_PROJECT_ID, NAMESPACE } from \"./constants.js\";\nimport type { WCAutoConnectOptions, WCConnectOptions } from \"./types.js\";\n\ntype WCProvider = InstanceType<typeof UniversalProvider>;\n\nlet cachedProvider: WCProvider | null = null;\n\ntype SavedConnectParams = {\n  optionalChains?: Chain[];\n  chain?: Chain;\n  pairingTopic?: string;\n};\n\nconst storageKeys = {\n  lastUsedChainId: \"tw.wc.lastUsedChainId\",\n  requestedChains: \"tw.wc.requestedChains\",\n};\n\n/**\n * Checks if the provided wallet is a Wallet Connect wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is a Wallet Connect wallet, false otherwise.\n */\nexport function isWalletConnect(\n  wallet: Wallet<WalletId>,\n): wallet is Wallet<\"walletConnect\"> {\n  return wallet.id === \"walletConnect\";\n}\n\n/**\n * @internal\n */\nexport async function connectWC(\n  options: WCConnectOptions,\n  emitter: WalletEmitter<WCSupportedWalletIds>,\n  walletId: WCSupportedWalletIds | \"walletConnect\",\n  storage: AsyncStorage,\n  sessionHandler?: (uri: string) => void | Promise<void>,\n): Promise<ReturnType<typeof onConnect>> {\n  const provider = await initProvider(options, walletId, sessionHandler);\n  const wcOptions = options.walletConnect;\n\n  let { onDisplayUri } = wcOptions || {};\n  const walletInfo = await getWalletInfo(walletId);\n\n  // use default sessionHandler unless onDisplayUri is explicitly provided\n  if (!onDisplayUri && sessionHandler) {\n    const deeplinkHandler = (uri: string) => {\n      const appUrl = walletInfo.mobile.native || walletInfo.mobile.universal;\n      if (!appUrl) {\n        // generic wc uri\n        sessionHandler(uri);\n        return;\n      }\n      const fullUrl = formatWalletConnectUrl(appUrl, uri).redirect;\n      sessionHandler(fullUrl);\n    };\n    onDisplayUri = deeplinkHandler;\n  }\n\n  if (onDisplayUri) {\n    provider.events.addListener(\"display_uri\", onDisplayUri);\n  }\n\n  let optionalChains: Chain[] | undefined = wcOptions?.optionalChains;\n  let chainToRequest = options.chain;\n\n  // ignore the given options chains - and set the safe supported chains\n  if (walletId === \"global.safe\") {\n    optionalChains = chainsToRequestForSafe.map(getCachedChain);\n    if (chainToRequest && !optionalChains.includes(chainToRequest)) {\n      chainToRequest = undefined;\n    }\n  }\n\n  // For UniversalProvider, we still need chain configuration for session management\n  const { chains: chainsToRequest, rpcMap } = getChainsToRequest({\n    chain: chainToRequest,\n    client: options.client,\n    optionalChains: optionalChains,\n  });\n\n  // For UniversalProvider, we need to connect with namespaces\n  await provider.connect({\n    ...(wcOptions?.pairingTopic\n      ? { pairingTopic: wcOptions?.pairingTopic }\n      : {}),\n    optionalNamespaces: {\n      [NAMESPACE]: {\n        chains: chainsToRequest,\n        events: [\"chainChanged\", \"accountsChanged\"],\n        methods: [\n          \"eth_sendTransaction\",\n          \"eth_signTransaction\",\n          \"eth_sign\",\n          \"personal_sign\",\n          \"eth_signTypedData\",\n          \"eth_signTypedData_v4\",\n          \"wallet_switchEthereumChain\",\n          \"wallet_addEthereumChain\",\n        ],\n        rpcMap,\n      },\n    },\n  });\n\n  setRequestedChainsIds(\n    chainsToRequest.map((x) => Number(x.split(\":\")[1])),\n    storage,\n  );\n  const currentChainId = chainsToRequest[0]?.split(\":\")[1] || 1;\n  const providerChainId = normalizeChainId(currentChainId);\n  const account = firstAccountOn(provider.session, `eip155:1`); // grab the address from mainnet if available\n  const address = account;\n  if (!address) {\n    throw new Error(\"No accounts found on provider.\");\n  }\n\n  const chain =\n    options.chain && options.chain.id === providerChainId\n      ? options.chain\n      : getCachedChain(providerChainId);\n\n  if (options) {\n    const savedParams: SavedConnectParams = {\n      chain: options.chain,\n      optionalChains: options.walletConnect?.optionalChains,\n      pairingTopic: options.walletConnect?.pairingTopic,\n    };\n\n    if (storage) {\n      saveConnectParamsToStorage(storage, walletId, savedParams);\n    }\n  }\n\n  if (onDisplayUri) {\n    provider.events.removeListener(\"display_uri\", onDisplayUri);\n  }\n\n  return onConnect(\n    address,\n    chain,\n    provider,\n    emitter,\n    storage,\n    options.client,\n    walletInfo,\n    sessionHandler,\n  );\n}\n\nasync function ensureTargetChain(\n  provider: Awaited<ReturnType<typeof initProvider>>,\n  chain: Chain,\n  walletInfo: WalletInfo,\n) {\n  if (!provider.session) {\n    throw new Error(\"No session found on provider.\");\n  }\n  const TARGET_CAIP = `eip155:${chain.id}`;\n  const TARGET_HEX = numberToHex(chain.id);\n\n  // Fast path: already enabled\n  if (hasChainEnabled(provider.session, TARGET_CAIP)) {\n    provider.setDefaultChain(TARGET_CAIP);\n    return;\n  }\n\n  // 1) Try switch\n  try {\n    await requestAndOpenWallet({\n      provider,\n      payload: {\n        method: \"wallet_switchEthereumChain\",\n        params: [{ chainId: TARGET_HEX }],\n      },\n      chain: TARGET_CAIP, // route to target\n      walletInfo,\n    });\n    provider.setDefaultChain(TARGET_CAIP);\n    return;\n  } catch (err: any) {\n    const code = err?.code ?? err?.data?.originalError?.code;\n    // 4001 user rejected; stop\n    if (code === 4001) throw new Error(\"User rejected chain switch\");\n    // fall through on 4902 or unknown -> try add\n  }\n\n  // 2) Add the chain via any chain we already have\n  const routeChain = anyRoutableChain(provider.session);\n  if (!routeChain)\n    throw new Error(\"No routable chain to send wallet_addEthereumChain\");\n\n  try {\n    await requestAndOpenWallet({\n      provider,\n      payload: {\n        method: \"wallet_addEthereumChain\",\n        params: [\n          {\n            chainId: TARGET_HEX,\n            chainName: chain.name,\n            nativeCurrency: chain.nativeCurrency,\n            rpcUrls: [chain.rpc],\n            blockExplorerUrls: [chain.blockExplorers?.[0]?.url ?? \"\"],\n          },\n        ],\n      },\n      chain: routeChain, // route via known-good chain, not the target\n      walletInfo,\n    });\n  } catch (err: any) {\n    const code = err?.code ?? err?.data?.originalError?.code;\n    if (code === 4001) throw new Error(\"User rejected add chain\");\n    throw new Error(`Add chain failed: ${err?.message || String(err)}`);\n  }\n\n  // 3) Re-try switch after add\n  await requestAndOpenWallet({\n    provider,\n    payload: {\n      method: \"wallet_switchEthereumChain\",\n      params: [{ chainId: TARGET_HEX }],\n    },\n    chain: TARGET_CAIP,\n    walletInfo,\n  });\n  provider.setDefaultChain(TARGET_CAIP);\n\n  // 4) Verify enablement\n  if (!hasChainEnabled(provider.session, TARGET_CAIP)) {\n    throw new Error(\"Target chain still not enabled by wallet\");\n  }\n}\n\ntype WCSession = Awaited<ReturnType<typeof UniversalProvider.init>>[\"session\"];\n\nfunction getNS(session: WCSession) {\n  return session?.namespaces?.eip155;\n}\nfunction hasChainEnabled(session: WCSession, caip: string) {\n  const ns = getNS(session);\n  return !!ns?.accounts?.some((a) => a.startsWith(`${caip}:`));\n}\nfunction firstAccountOn(session: WCSession, caip: string): string | null {\n  const ns = getNS(session);\n  const hit =\n    ns?.accounts?.find((a) => a.startsWith(`${caip}:`)) || ns?.accounts[0];\n  return hit ? (hit.split(\":\")[2] ?? null) : null;\n}\nfunction anyRoutableChain(session: WCSession): string | null {\n  const ns = getNS(session);\n  return ns?.accounts?.[0]?.split(\":\")?.slice(0, 2)?.join(\":\") ?? null; // e.g. \"eip155:1\"\n}\n\n/**\n * Auto connect to already connected wallet connect session.\n * @internal\n */\nexport async function autoConnectWC(\n  options: WCAutoConnectOptions,\n  emitter: WalletEmitter<WCSupportedWalletIds>,\n  walletId: WCSupportedWalletIds | \"walletConnect\",\n  storage: AsyncStorage,\n  sessionHandler?: (uri: string) => void | Promise<void>,\n): Promise<ReturnType<typeof onConnect>> {\n  const savedConnectParams: SavedConnectParams | null = storage\n    ? await getSavedConnectParamsFromStorage(storage, walletId)\n    : null;\n\n  const walletInfo = await getWalletInfo(walletId);\n\n  const provider = await initProvider(\n    savedConnectParams\n      ? {\n          chain: savedConnectParams.chain,\n          client: options.client,\n          walletConnect: {\n            optionalChains: savedConnectParams.optionalChains,\n            pairingTopic: savedConnectParams.pairingTopic,\n          },\n        }\n      : {\n          client: options.client,\n          walletConnect: {},\n        },\n    walletId,\n    sessionHandler,\n  );\n\n  if (!provider.session) {\n    await provider.disconnect();\n    throw new Error(\"No wallet connect session found on provider.\");\n  }\n\n  // For UniversalProvider, get accounts from enable() method\n  const namespaceAccounts = provider.session?.namespaces?.[NAMESPACE]?.accounts;\n  const address = namespaceAccounts?.[0]?.split(\":\")[2];\n\n  if (!address) {\n    throw new Error(\"No accounts found on provider.\");\n  }\n\n  // For UniversalProvider, get chainId from the session namespaces or use default\n  const currentChainId = options.chain?.id || 1;\n  const providerChainId = normalizeChainId(currentChainId);\n\n  const chain =\n    options.chain && options.chain.id === providerChainId\n      ? options.chain\n      : getCachedChain(providerChainId);\n\n  return onConnect(\n    address,\n    chain,\n    provider,\n    emitter,\n    storage,\n    options.client,\n    walletInfo,\n    sessionHandler,\n  );\n}\n\n// Connection utils -----------------------------------------------------------------------------------------------\n\nasync function initProvider(\n  options: WCConnectOptions,\n  walletId: WCSupportedWalletIds | \"walletConnect\",\n  sessionRequestHandler?: (uri: string) => void | Promise<void>,\n) {\n  if (cachedProvider) {\n    return cachedProvider;\n  }\n\n  const walletInfo = await getWalletInfo(walletId);\n  const wcOptions = options.walletConnect;\n  const { UniversalProvider } = await import(\n    \"@walletconnect/universal-provider\"\n  );\n\n  let optionalChains: Chain[] | undefined = wcOptions?.optionalChains;\n  let chainToRequest = options.chain;\n\n  // ignore the given options chains - and set the safe supported chains\n  if (walletId === \"global.safe\") {\n    optionalChains = chainsToRequestForSafe.map(getCachedChain);\n    if (chainToRequest && !optionalChains.includes(chainToRequest)) {\n      chainToRequest = undefined;\n    }\n  }\n\n  const provider = await UniversalProvider.init({\n    metadata: {\n      description:\n        wcOptions?.appMetadata?.description ||\n        getDefaultAppMetadata().description,\n      icons: [\n        wcOptions?.appMetadata?.logoUrl || getDefaultAppMetadata().logoUrl,\n      ],\n      name: wcOptions?.appMetadata?.name || getDefaultAppMetadata().name,\n      url: wcOptions?.appMetadata?.url || getDefaultAppMetadata().url,\n      redirect: {\n        native: walletInfo.mobile.native || undefined,\n        universal: walletInfo.mobile.universal || undefined,\n      },\n    },\n    projectId: wcOptions?.projectId || DEFAULT_PROJECT_ID,\n  });\n\n  provider.events.setMaxListeners(Number.POSITIVE_INFINITY);\n\n  if (walletId !== \"walletConnect\") {\n    async function handleSessionRequest() {\n      const walletLinkToOpen =\n        provider.session?.peer?.metadata?.redirect?.native ||\n        walletInfo.mobile.native ||\n        walletInfo.mobile.universal;\n\n      if (sessionRequestHandler && walletLinkToOpen) {\n        // TODO: propagate error when this fails\n        await sessionRequestHandler(walletLinkToOpen);\n      }\n    }\n\n    // For UniversalProvider, use different event handling\n    provider.on(\"session_request_sent\", handleSessionRequest);\n    provider.events.addListener(\"disconnect\", () => {\n      provider.off(\"session_request_sent\", handleSessionRequest);\n      cachedProvider = null;\n    });\n  }\n\n  cachedProvider = provider;\n\n  return provider;\n}\n\nfunction createAccount({\n  provider,\n  address,\n  client,\n  chain,\n  sessionRequestHandler,\n  walletInfo,\n}: {\n  provider: WCProvider;\n  address: string;\n  client: ThirdwebClient;\n  chain: Chain;\n  sessionRequestHandler?: (uri: string) => void | Promise<void>;\n  walletInfo: WalletInfo;\n}) {\n  const account: Account = {\n    address: getAddress(address),\n    async sendTransaction(tx: SendTransactionOption) {\n      const transactionHash = (await requestAndOpenWallet({\n        provider,\n        payload: {\n          method: \"eth_sendTransaction\",\n          params: [\n            {\n              data: tx.data,\n              from: getAddress(address),\n              gas: tx.gas ? numberToHex(tx.gas) : undefined,\n              to: tx.to as Address,\n              value: tx.value ? numberToHex(tx.value) : undefined,\n            },\n          ],\n        },\n        chain: `eip155:${tx.chainId}`,\n        walletInfo,\n        sessionRequestHandler,\n      })) as Hex;\n\n      trackTransaction({\n        chainId: tx.chainId,\n        client: client,\n        contractAddress: tx.to ?? undefined,\n        gasPrice: tx.gasPrice,\n        transactionHash,\n        walletAddress: getAddress(address),\n        walletType: \"walletConnect\",\n      });\n\n      return {\n        transactionHash,\n      };\n    },\n    async signMessage({ message }) {\n      const messageToSign = (() => {\n        if (typeof message === \"string\") {\n          return stringToHex(message);\n        }\n        if (message.raw instanceof Uint8Array) {\n          return uint8ArrayToHex(message.raw);\n        }\n        return message.raw;\n      })();\n      return requestAndOpenWallet({\n        provider,\n        payload: {\n          method: \"personal_sign\",\n          params: [messageToSign, this.address],\n        },\n        chain: `eip155:${chain.id}`,\n        walletInfo,\n        sessionRequestHandler,\n      });\n    },\n    async signTypedData(_data) {\n      const data = parseTypedData(_data);\n      const { domain, message, primaryType } =\n        data as unknown as SignTypedDataParameters;\n\n      const types = {\n        EIP712Domain: getTypesForEIP712Domain({ domain }),\n        ...data.types,\n      };\n\n      // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n      // as we can't statically check this with TypeScript.\n      validateTypedData({ domain, message, primaryType, types });\n\n      const typedData = serializeTypedData({\n        domain: domain ?? {},\n        message,\n        primaryType,\n        types,\n      });\n\n      return await requestAndOpenWallet({\n        provider,\n        payload: {\n          method: \"eth_signTypedData_v4\",\n          params: [this.address, typedData],\n        },\n        chain: `eip155:${chain.id}`,\n        walletInfo,\n        sessionRequestHandler,\n      });\n    },\n  };\n\n  return account;\n}\n\nasync function requestAndOpenWallet(args: {\n  provider: WCProvider;\n  payload: RequestArguments;\n  chain?: string;\n  walletInfo: WalletInfo;\n  sessionRequestHandler?: (uri: string) => void | Promise<void>;\n}) {\n  const { provider, payload, chain, walletInfo, sessionRequestHandler } = args;\n  const resultPromise: Promise<`0x${string}`> = provider.request(\n    payload,\n    chain,\n  );\n\n  const walletLinkToOpen =\n    provider.session?.peer?.metadata?.redirect?.native ||\n    walletInfo.mobile.native ||\n    walletInfo.mobile.universal;\n\n  if (sessionRequestHandler && walletLinkToOpen) {\n    await sessionRequestHandler(walletLinkToOpen);\n  }\n\n  return resultPromise;\n}\n\nfunction onConnect(\n  address: string,\n  chain: Chain,\n  provider: WCProvider,\n  emitter: WalletEmitter<WCSupportedWalletIds>,\n  storage: AsyncStorage,\n  client: ThirdwebClient,\n  walletInfo: WalletInfo,\n  sessionRequestHandler?: (uri: string) => void | Promise<void>,\n): [Account, Chain, DisconnectFn, SwitchChainFn] {\n  const account = createAccount({\n    address,\n    chain,\n    client,\n    provider,\n    sessionRequestHandler,\n    walletInfo,\n  });\n\n  async function disconnect() {\n    provider.removeListener(\"accountsChanged\", onAccountsChanged);\n    provider.removeListener(\"chainChanged\", onChainChanged);\n    provider.removeListener(\"disconnect\", onDisconnect);\n    await provider.disconnect();\n    cachedProvider = null;\n  }\n\n  function onDisconnect() {\n    setRequestedChainsIds([], storage);\n    storage?.removeItem(storageKeys.lastUsedChainId);\n    disconnect();\n    emitter.emit(\"disconnect\", undefined);\n  }\n\n  function onAccountsChanged(accounts: string[]) {\n    if (accounts[0]) {\n      const newAccount = createAccount({\n        address: getAddress(accounts[0]),\n        chain,\n        client,\n        provider,\n        sessionRequestHandler,\n        walletInfo,\n      });\n      emitter.emit(\"accountChanged\", newAccount);\n      emitter.emit(\"accountsChanged\", accounts);\n    } else {\n      onDisconnect();\n    }\n  }\n\n  function onChainChanged(newChainId: string) {\n    const newChain = getCachedChain(normalizeChainId(newChainId));\n    emitter.emit(\"chainChanged\", newChain);\n    storage?.setItem(storageKeys.lastUsedChainId, String(newChainId));\n  }\n\n  provider.on(\"accountsChanged\", onAccountsChanged);\n  provider.on(\"chainChanged\", onChainChanged);\n  provider.on(\"disconnect\", onDisconnect);\n  provider.on(\"session_delete\", onDisconnect);\n\n  return [\n    account,\n    chain,\n    disconnect,\n    (newChain) => switchChainWC(provider, newChain, walletInfo),\n  ];\n}\n\nasync function switchChainWC(\n  provider: WCProvider,\n  chain: Chain,\n  walletInfo: WalletInfo,\n) {\n  try {\n    await ensureTargetChain(provider, chain, walletInfo);\n  } catch (error) {\n    const message =\n      typeof error === \"string\" ? error : (error as ProviderRpcError)?.message;\n    if (/user rejected request/i.test(message)) {\n      throw new UserRejectedRequestError(error as Error);\n    }\n\n    throw new SwitchChainError(error as Error);\n  }\n}\n\n/**\n * Set the requested chains to the storage.\n * @internal\n */\nfunction setRequestedChainsIds(\n  chains: number[] | undefined,\n  storage: AsyncStorage,\n) {\n  storage?.setItem(storageKeys.requestedChains, stringify(chains));\n}\n\nfunction getChainsToRequest(options: {\n  chain?: Chain;\n  optionalChains?: Chain[];\n  client: ThirdwebClient;\n}): {\n  rpcMap: Record<number, string>;\n  chains: string[];\n} {\n  const rpcMap: Record<number, string> = {};\n  const chainIds: number[] = [];\n\n  if (options.chain) {\n    rpcMap[options.chain.id] = getRpcUrlForChain({\n      chain: options.chain,\n      client: options.client,\n    });\n    chainIds.push(options.chain.id);\n  }\n\n  // limit optional chains to 10\n  const optionalChains = (options?.optionalChains || []).slice(0, 10);\n\n  for (const chain of optionalChains) {\n    rpcMap[chain.id] = getRpcUrlForChain({\n      chain: chain,\n      client: options.client,\n    });\n    chainIds.push(chain.id);\n  }\n\n  // always include mainnet\n  // many wallets only support a handful of chains, but mainnet is always supported\n  // we will add additional chains in switchChain if needed\n  if (!chainIds.includes(1)) {\n    rpcMap[1] = getCachedChain(1).rpc;\n    chainIds.push(1);\n  }\n\n  return {\n    chains: chainIds.map((x) => `eip155:${x}`),\n    rpcMap,\n  };\n}\n\nconst chainsToRequestForSafe = [\n  1, // Ethereum Mainnet\n  11155111, // Sepolia Testnet\n  42161, // Arbitrum One Mainnet\n  43114, // Avalanche Mainnet\n  8453, // Base Mainnet\n  1313161554, // Aurora Mainnet\n  84532, // Base Sepolia Testnet\n  56, // Binance Smart Chain Mainnet\n  42220, // Celo Mainnet\n  100, // Gnosis Mainnet\n  10, // Optimism Mainnet\n  137, // Polygon Mainnet\n  1101, // Polygon zkEVM Mainnet\n  324, // zkSync Era mainnet\n  534352, // Scroll mainnet\n];\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}