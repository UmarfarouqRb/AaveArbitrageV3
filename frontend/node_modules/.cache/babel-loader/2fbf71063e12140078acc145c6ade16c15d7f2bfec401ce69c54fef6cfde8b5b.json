{"ast":null,"code":"import { labelhash } from \"viem\";\nimport { stringToBytes } from \"../encoding/to-bytes.js\";\nimport { encodeLabelhash } from \"./encodeLabelhash.js\";\n/**\n * Encodes a DNS packet into a ByteArray containing a UDP payload.\n * @param packet\n * @internal\n */\nexport function packetToBytes(packet) {\n  // strip leading and trailing `.`\n  const value = packet.replace(/^\\.|\\.$/gm, \"\");\n  if (value.length === 0) {\n    return new Uint8Array(1);\n  }\n  const bytes = new Uint8Array(stringToBytes(value).byteLength + 2);\n  let offset = 0;\n  const list = value.split(\".\");\n  for (let i = 0; i < list.length; i++) {\n    const item = list[i];\n    let encoded = stringToBytes(item);\n    // if the length is > 255, make the encoded label value a labelhash\n    // this is compatible with the universal resolver\n    if (encoded.byteLength > 255) {\n      encoded = stringToBytes(encodeLabelhash(labelhash(item)));\n    }\n    bytes[offset] = encoded.length;\n    bytes.set(encoded, offset + 1);\n    offset += encoded.length + 1;\n  }\n  if (bytes.byteLength !== offset + 1) {\n    return bytes.slice(0, offset + 1);\n  }\n  return bytes;\n}","map":{"version":3,"names":["labelhash","stringToBytes","encodeLabelhash","packetToBytes","packet","value","replace","length","Uint8Array","bytes","byteLength","offset","list","split","i","item","encoded","set","slice"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/utils/ens/packetToBytes.ts"],"sourcesContent":["import { type ByteArray, labelhash } from \"viem\";\nimport { stringToBytes } from \"../encoding/to-bytes.js\";\nimport { encodeLabelhash } from \"./encodeLabelhash.js\";\n\n/**\n * Encodes a DNS packet into a ByteArray containing a UDP payload.\n * @param packet\n * @internal\n */\nexport function packetToBytes(packet: string): ByteArray {\n  // strip leading and trailing `.`\n  const value = packet.replace(/^\\.|\\.$/gm, \"\");\n  if (value.length === 0) {\n    return new Uint8Array(1);\n  }\n\n  const bytes = new Uint8Array(stringToBytes(value).byteLength + 2);\n\n  let offset = 0;\n  const list = value.split(\".\");\n  for (let i = 0; i < list.length; i++) {\n    const item = list[i] as string;\n    let encoded = stringToBytes(item);\n    // if the length is > 255, make the encoded label value a labelhash\n    // this is compatible with the universal resolver\n    if (encoded.byteLength > 255) {\n      encoded = stringToBytes(encodeLabelhash(labelhash(item)));\n    }\n    bytes[offset] = encoded.length;\n    bytes.set(encoded, offset + 1);\n    offset += encoded.length + 1;\n  }\n\n  if (bytes.byteLength !== offset + 1) {\n    return bytes.slice(0, offset + 1);\n  }\n\n  return bytes;\n}\n"],"mappings":"AAAA,SAAyBA,SAAS,QAAQ,MAAM;AAChD,SAASC,aAAa,QAAQ,yBAAyB;AACvD,SAASC,eAAe,QAAQ,sBAAsB;AAEtD;;;;;AAKA,OAAM,SAAUC,aAAaA,CAACC,MAAc;EAC1C;EACA,MAAMC,KAAK,GAAGD,MAAM,CAACE,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC;EAC7C,IAAID,KAAK,CAACE,MAAM,KAAK,CAAC,EAAE;IACtB,OAAO,IAAIC,UAAU,CAAC,CAAC,CAAC;EAC1B;EAEA,MAAMC,KAAK,GAAG,IAAID,UAAU,CAACP,aAAa,CAACI,KAAK,CAAC,CAACK,UAAU,GAAG,CAAC,CAAC;EAEjE,IAAIC,MAAM,GAAG,CAAC;EACd,MAAMC,IAAI,GAAGP,KAAK,CAACQ,KAAK,CAAC,GAAG,CAAC;EAC7B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,IAAI,CAACL,MAAM,EAAEO,CAAC,EAAE,EAAE;IACpC,MAAMC,IAAI,GAAGH,IAAI,CAACE,CAAC,CAAW;IAC9B,IAAIE,OAAO,GAAGf,aAAa,CAACc,IAAI,CAAC;IACjC;IACA;IACA,IAAIC,OAAO,CAACN,UAAU,GAAG,GAAG,EAAE;MAC5BM,OAAO,GAAGf,aAAa,CAACC,eAAe,CAACF,SAAS,CAACe,IAAI,CAAC,CAAC,CAAC;IAC3D;IACAN,KAAK,CAACE,MAAM,CAAC,GAAGK,OAAO,CAACT,MAAM;IAC9BE,KAAK,CAACQ,GAAG,CAACD,OAAO,EAAEL,MAAM,GAAG,CAAC,CAAC;IAC9BA,MAAM,IAAIK,OAAO,CAACT,MAAM,GAAG,CAAC;EAC9B;EAEA,IAAIE,KAAK,CAACC,UAAU,KAAKC,MAAM,GAAG,CAAC,EAAE;IACnC,OAAOF,KAAK,CAACS,KAAK,CAAC,CAAC,EAAEP,MAAM,GAAG,CAAC,CAAC;EACnC;EAEA,OAAOF,KAAK;AACd","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}