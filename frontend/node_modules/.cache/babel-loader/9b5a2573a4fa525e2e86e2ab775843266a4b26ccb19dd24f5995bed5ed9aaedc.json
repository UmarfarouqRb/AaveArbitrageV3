{"ast":null,"code":"const extraPrefixesMap = {\n  $body_: \"body\",\n  $headers_: \"headers\",\n  $path_: \"path\",\n  $query_: \"query\"\n};\nconst extraPrefixes = Object.entries(extraPrefixesMap);\nconst buildKeyMap = (fields, map) => {\n  if (!map) {\n    map = new Map();\n  }\n  for (const config of fields) {\n    if (\"in\" in config) {\n      if (config.key) {\n        map.set(config.key, {\n          in: config.in,\n          map: config.map\n        });\n      }\n    } else if (config.args) {\n      buildKeyMap(config.args, map);\n    }\n  }\n  return map;\n};\nconst stripEmptySlots = params => {\n  for (const [slot, value] of Object.entries(params)) {\n    if (value && typeof value === \"object\" && !Object.keys(value).length) {\n      delete params[slot];\n    }\n  }\n};\nexport const buildClientParams = (args, fields) => {\n  const params = {\n    body: {},\n    headers: {},\n    path: {},\n    query: {}\n  };\n  const map = buildKeyMap(fields);\n  let config;\n  for (const [index, arg] of args.entries()) {\n    if (fields[index]) {\n      config = fields[index];\n    }\n    if (!config) {\n      continue;\n    }\n    if (\"in\" in config) {\n      if (config.key) {\n        const field = map.get(config.key);\n        const name = field.map || config.key;\n        params[field.in][name] = arg;\n      } else {\n        params.body = arg;\n      }\n    } else {\n      for (const [key, value] of Object.entries(arg !== null && arg !== void 0 ? arg : {})) {\n        const field = map.get(key);\n        if (field) {\n          const name = field.map || key;\n          params[field.in][name] = value;\n        } else {\n          const extra = extraPrefixes.find(_ref => {\n            let [prefix] = _ref;\n            return key.startsWith(prefix);\n          });\n          if (extra) {\n            const [prefix, slot] = extra;\n            params[slot][key.slice(prefix.length)] = value;\n          } else {\n            for (const [slot, allowed] of Object.entries((_config$allowExtra = config.allowExtra) !== null && _config$allowExtra !== void 0 ? _config$allowExtra : {})) {\n              var _config$allowExtra;\n              if (allowed) {\n                params[slot][key] = value;\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  stripEmptySlots(params);\n  return params;\n};","map":{"version":3,"names":["extraPrefixesMap","$body_","$headers_","$path_","$query_","extraPrefixes","Object","entries","buildKeyMap","fields","map","Map","config","key","set","in","args","stripEmptySlots","params","slot","value","keys","length","buildClientParams","body","headers","path","query","index","arg","field","get","name","extra","find","_ref","prefix","startsWith","slice","allowed","_config$allowExtra","allowExtra"],"sources":["/home/user/Arbitrage/frontend/node_modules/@thirdweb-dev/insight/src/client/core/params.ts"],"sourcesContent":["type Slot = \"body\" | \"headers\" | \"path\" | \"query\";\n\nexport type Field =\n\t| {\n\t\t\tin: Exclude<Slot, \"body\">;\n\t\t\tkey: string;\n\t\t\tmap?: string;\n\t  }\n\t| {\n\t\t\tin: Extract<Slot, \"body\">;\n\t\t\tkey?: string;\n\t\t\tmap?: string;\n\t  };\n\nexport interface Fields {\n\tallowExtra?: Partial<Record<Slot, boolean>>;\n\targs?: ReadonlyArray<Field>;\n}\n\nexport type FieldsConfig = ReadonlyArray<Field | Fields>;\n\nconst extraPrefixesMap: Record<string, Slot> = {\n\t$body_: \"body\",\n\t$headers_: \"headers\",\n\t$path_: \"path\",\n\t$query_: \"query\",\n};\nconst extraPrefixes = Object.entries(extraPrefixesMap);\n\ntype KeyMap = Map<\n\tstring,\n\t{\n\t\tin: Slot;\n\t\tmap?: string;\n\t}\n>;\n\nconst buildKeyMap = (fields: FieldsConfig, map?: KeyMap): KeyMap => {\n\tif (!map) {\n\t\tmap = new Map();\n\t}\n\n\tfor (const config of fields) {\n\t\tif (\"in\" in config) {\n\t\t\tif (config.key) {\n\t\t\t\tmap.set(config.key, {\n\t\t\t\t\tin: config.in,\n\t\t\t\t\tmap: config.map,\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (config.args) {\n\t\t\tbuildKeyMap(config.args, map);\n\t\t}\n\t}\n\n\treturn map;\n};\n\ninterface Params {\n\tbody: unknown;\n\theaders: Record<string, unknown>;\n\tpath: Record<string, unknown>;\n\tquery: Record<string, unknown>;\n}\n\nconst stripEmptySlots = (params: Params) => {\n\tfor (const [slot, value] of Object.entries(params)) {\n\t\tif (value && typeof value === \"object\" && !Object.keys(value).length) {\n\t\t\tdelete params[slot as Slot];\n\t\t}\n\t}\n};\n\nexport const buildClientParams = (\n\targs: ReadonlyArray<unknown>,\n\tfields: FieldsConfig,\n) => {\n\tconst params: Params = {\n\t\tbody: {},\n\t\theaders: {},\n\t\tpath: {},\n\t\tquery: {},\n\t};\n\n\tconst map = buildKeyMap(fields);\n\n\tlet config: FieldsConfig[number] | undefined;\n\n\tfor (const [index, arg] of args.entries()) {\n\t\tif (fields[index]) {\n\t\t\tconfig = fields[index];\n\t\t}\n\n\t\tif (!config) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (\"in\" in config) {\n\t\t\tif (config.key) {\n\t\t\t\tconst field = map.get(config.key)!;\n\t\t\t\tconst name = field.map || config.key;\n\t\t\t\t(params[field.in] as Record<string, unknown>)[name] = arg;\n\t\t\t} else {\n\t\t\t\tparams.body = arg;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const [key, value] of Object.entries(arg ?? {})) {\n\t\t\t\tconst field = map.get(key);\n\n\t\t\t\tif (field) {\n\t\t\t\t\tconst name = field.map || key;\n\t\t\t\t\t(params[field.in] as Record<string, unknown>)[name] = value;\n\t\t\t\t} else {\n\t\t\t\t\tconst extra = extraPrefixes.find(([prefix]) =>\n\t\t\t\t\t\tkey.startsWith(prefix),\n\t\t\t\t\t);\n\n\t\t\t\t\tif (extra) {\n\t\t\t\t\t\tconst [prefix, slot] = extra;\n\t\t\t\t\t\t(params[slot] as Record<string, unknown>)[\n\t\t\t\t\t\t\tkey.slice(prefix.length)\n\t\t\t\t\t\t] = value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const [slot, allowed] of Object.entries(\n\t\t\t\t\t\t\tconfig.allowExtra ?? {},\n\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\tif (allowed) {\n\t\t\t\t\t\t\t\t(params[slot as Slot] as Record<string, unknown>)[key] = value;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstripEmptySlots(params);\n\n\treturn params;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}