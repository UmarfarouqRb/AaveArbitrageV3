{"ast":null,"code":"import { LruMap } from \"./caching/lru.js\";\nimport { stringToBytes } from \"./encoding/to-bytes.js\";\nimport { keccak256 } from \"./hashing/keccak256.js\";\nconst ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;\nconst IS_ADDRESS_CACHE = new LruMap(4096);\n/**\n * Checks if a given string is a valid address.\n * @param address The address to check.\n * @returns True if the address is valid, false otherwise.\n * @example\n * ```ts\n * import { isAddress } from 'thirdweb/utils';\n *\n * isAddress('0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed');\n * //=> true\n * ```\n * @utils\n */\nexport function isAddress(address) {\n  if (IS_ADDRESS_CACHE.has(address)) {\n    // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set\n    return IS_ADDRESS_CACHE.get(address);\n  }\n  const result = ADDRESS_REGEX.test(address) && (address.toLowerCase() === address || checksumAddress(address) === address);\n  IS_ADDRESS_CACHE.set(address, result);\n  return result;\n}\n/**\n * Calculates the checksum address for the given address.\n * @param address - The address to calculate the checksum for.\n * @returns The checksum address.\n * @example\n * ```ts\n * import { checksumAddress } from 'thirdweb/utils';\n *\n * checksumAddress('0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed');\n * //=> '0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed'\n * ```\n * @utils\n */\nexport function checksumAddress(address) {\n  const hexAddress = address.substring(2).toLowerCase();\n  const hash = keccak256(stringToBytes(hexAddress), \"bytes\");\n  const address_ = hexAddress.split(\"\");\n  for (let i = 0; i < 40; i += 2) {\n    // biome-ignore lint/style/noNonNullAssertion: TODO\n    if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n      // biome-ignore lint/style/noNonNullAssertion: TODO\n      address_[i] = address_[i].toUpperCase();\n    }\n    // biome-ignore lint/style/noNonNullAssertion: TODO\n    if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n      // biome-ignore lint/style/noNonNullAssertion: TODO\n      address_[i + 1] = address_[i + 1].toUpperCase();\n    }\n  }\n  return \"0x\".concat(address_.join(\"\"));\n}\n/**\n * Retrieves the address after performing validation and checksumming.\n * @param address - The address to be validated and checksummed.\n * @returns The validated and checksummed address.\n * @throws Error if the address is invalid.\n * @example\n * ```ts\n * import { getAddress } from 'thirdweb/utils';\n *\n * getAddress('0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed');\n * //=> '0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed'\n * ```\n * @utils\n */\nexport function getAddress(address) {\n  if (!isAddress(address)) {\n    throw new Error(\"Invalid address: \".concat(address));\n  }\n  return checksumAddress(address);\n}\n/**\n * Checksums and formats an address if valid. Note this function does not check if the provided address is an ENS.\n * @param address - The address to shorten.\n * @param length - The number of characters to keep from the start and end of the address.\n * @returns The shortened address.\n * @example\n * ```ts\n * import { shortenAddress } from 'thirdweb/utils';\n *\n * shortenAddress('0xa0cf798816d4b9b9866b5330eea46a18382f251e');\n * //=> '0xA0Cf...251e'\n * ```\n * @utils\n */\nexport function shortenAddress(address) {\n  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\n  const _address = getAddress(address);\n  return shortenHex(_address, length);\n}\n/**\n * Shortens a hexadecimal string without performing any validation or checksumming.\n * @param hex - The hexadecimal string to shorten.\n * @param length - The number of characters to keep from the start and end of the string.\n * @returns The shortened hexadecimal string.\n * @example\n * ```ts\n * import { shortenHex } from 'thirdweb/utils';\n *\n * shortenHex('0xa0cf798816d4b9b9866b5330eea46a18382f251e');\n * //=> '0xa0cf...251e'\n * ```\n * @utils\n */\nexport function shortenHex(hex) {\n  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\n  return \"\".concat(hex.slice(0, length + 2), \"...\").concat(hex.slice(-length));\n}","map":{"version":3,"names":["LruMap","stringToBytes","keccak256","ADDRESS_REGEX","IS_ADDRESS_CACHE","isAddress","address","has","get","result","test","toLowerCase","checksumAddress","set","hexAddress","substring","hash","address_","split","i","toUpperCase","concat","join","getAddress","Error","shortenAddress","length","arguments","undefined","_address","shortenHex","hex","slice"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/utils/address.ts"],"sourcesContent":["import { LruMap } from \"./caching/lru.js\";\nimport { stringToBytes } from \"./encoding/to-bytes.js\";\nimport { keccak256 } from \"./hashing/keccak256.js\";\n\nexport type AddressInput = string;\nexport type Address = `0x${string}`;\n\nconst ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;\nconst IS_ADDRESS_CACHE = new LruMap<boolean>(4096);\n\n/**\n * Checks if a given string is a valid address.\n * @param address The address to check.\n * @returns True if the address is valid, false otherwise.\n * @example\n * ```ts\n * import { isAddress } from 'thirdweb/utils';\n *\n * isAddress('0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed');\n * //=> true\n * ```\n * @utils\n */\nexport function isAddress(address: string): address is Address {\n  if (IS_ADDRESS_CACHE.has(address)) {\n    // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set\n    return IS_ADDRESS_CACHE.get(address)!;\n  }\n  const result =\n    ADDRESS_REGEX.test(address) &&\n    (address.toLowerCase() === address || checksumAddress(address) === address);\n  IS_ADDRESS_CACHE.set(address, result);\n  return result;\n}\n\n/**\n * Calculates the checksum address for the given address.\n * @param address - The address to calculate the checksum for.\n * @returns The checksum address.\n * @example\n * ```ts\n * import { checksumAddress } from 'thirdweb/utils';\n *\n * checksumAddress('0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed');\n * //=> '0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed'\n * ```\n * @utils\n */\nexport function checksumAddress(address: string): Address {\n  const hexAddress = address.substring(2).toLowerCase();\n  const hash = keccak256(stringToBytes(hexAddress), \"bytes\");\n\n  const address_ = hexAddress.split(\"\");\n  for (let i = 0; i < 40; i += 2) {\n    // biome-ignore lint/style/noNonNullAssertion: TODO\n    if (hash[i >> 1]! >> 4 >= 8 && address[i]) {\n      // biome-ignore lint/style/noNonNullAssertion: TODO\n      address_[i] = address_[i]!.toUpperCase();\n    }\n\n    // biome-ignore lint/style/noNonNullAssertion: TODO\n    if ((hash[i >> 1]! & 0x0f) >= 8 && address[i + 1]) {\n      // biome-ignore lint/style/noNonNullAssertion: TODO\n      address_[i + 1] = address_[i + 1]!.toUpperCase();\n    }\n  }\n\n  return `0x${address_.join(\"\")}`;\n}\n\n/**\n * Retrieves the address after performing validation and checksumming.\n * @param address - The address to be validated and checksummed.\n * @returns The validated and checksummed address.\n * @throws Error if the address is invalid.\n * @example\n * ```ts\n * import { getAddress } from 'thirdweb/utils';\n *\n * getAddress('0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed');\n * //=> '0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed'\n * ```\n * @utils\n */\nexport function getAddress(address: string): Address {\n  if (!isAddress(address)) {\n    throw new Error(`Invalid address: ${address}`);\n  }\n  return checksumAddress(address);\n}\n\n/**\n * Checksums and formats an address if valid. Note this function does not check if the provided address is an ENS.\n * @param address - The address to shorten.\n * @param length - The number of characters to keep from the start and end of the address.\n * @returns The shortened address.\n * @example\n * ```ts\n * import { shortenAddress } from 'thirdweb/utils';\n *\n * shortenAddress('0xa0cf798816d4b9b9866b5330eea46a18382f251e');\n * //=> '0xA0Cf...251e'\n * ```\n * @utils\n */\nexport function shortenAddress(address: string, length = 4) {\n  const _address = getAddress(address);\n  return shortenHex(_address, length);\n}\n\n/**\n * Shortens a hexadecimal string without performing any validation or checksumming.\n * @param hex - The hexadecimal string to shorten.\n * @param length - The number of characters to keep from the start and end of the string.\n * @returns The shortened hexadecimal string.\n * @example\n * ```ts\n * import { shortenHex } from 'thirdweb/utils';\n *\n * shortenHex('0xa0cf798816d4b9b9866b5330eea46a18382f251e');\n * //=> '0xa0cf...251e'\n * ```\n * @utils\n */\nexport function shortenHex(hex: string, length = 4) {\n  return `${hex.slice(0, length + 2)}...${hex.slice(-length)}`;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}