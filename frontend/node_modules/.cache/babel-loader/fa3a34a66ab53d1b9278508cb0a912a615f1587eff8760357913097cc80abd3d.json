{"ast":null,"code":"import { createInAppWallet } from \"../core/wallet/in-app-core.js\";\n/**\n * Creates an app scoped wallet for users based on various authentication methods. Full list of available authentication methods [here](https://portal.thirdweb.com/connect/wallet/sign-in-methods/configure).\n *\n * Can also be configured to use Account Abstraction to directly connect to a ERC4337 smart account based on those authentication methods.\n *\n * @param createOptions - configuration options\n * Refer to [InAppWalletCreationOptions](https://portal.thirdweb.com/references/typescript/v5/InAppWalletCreationOptions) to see the available options.\n * @returns The created in-app wallet.\n * @example\n *\n * ### Login with socials\n *\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets\";\n *\n * const wallet = inAppWallet();\n *\n * const account = await wallet.connect({\n *   client,\n *   chain,\n *   strategy: \"google\", // or \"apple\", \"facebook\",\"discord\", \"github\", \"twitch\", \"x\", \"telegram\", \"line\", \"coinbase\", etc\n * });\n * ```\n *\n * [View all available social auth methods](https://portal.thirdweb.com/connect/wallet/sign-in-methods/configure)\n *\n * ### Enable smart accounts and sponsor gas for your users:\n *\n * With the `executionMode` option, you can enable smart accounts and sponsor gas for your users.\n *\n * **Using EIP-7702** (recommended):\n *\n * On chains with EIP-7702 enabled, you can upgrade the inapp wallet to a smart account, keeping the same address and performance as the regular EOA.\n *\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets\";\n * import { sepolia } from \"thirdweb/chains\";\n *\n * const wallet = inAppWallet({\n *  executionMode: {\n *   mode: \"EIP7702\",\n *   sponsorGas: true,\n *  },\n * });\n *\n * // account will be a smart account with sponsored gas enabled\n * const account = await wallet.connect({\n *   client,\n *   strategy: \"google\",\n * });\n * ```\n *\n * **Using EIP-4337**:\n *\n * On chains without EIP-7702 enabled, you can still use smart accounts using EIP-4337, this will return a different address (the smart contract address) than the regular EOA.\n *\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets/in-app\";\n *\n * const wallet = inAppWallet({\n *  executionMode: {\n *   mode: \"EIP4337\",\n *   smartAccount: {\n *    chain: sepolia, // chain required for EIP-4337\n *    sponsorGas: true,\n *   }\n *  },\n * });\n * ```\n *\n * ### Login with email\n *\n * To login with email, you can use the `preAuthenticate` function to first send a verification code to the user's email, then login with the verification code.\n *\n * ```ts\n * import { inAppWallet, preAuthenticate } from \"thirdweb/wallets/in-app\";\n *\n * const wallet = inAppWallet();\n *\n * // sends a verification code to the provided email\n * await preAuthenticate({\n *   client,\n *   strategy: \"email\",\n *   email: \"example@example.com\",\n * });\n *\n * // login with the verification code\n * const account = await wallet.connect({\n *   client,\n *   chain,\n *   strategy: \"email\",\n *   email: \"example@example.com\",\n *   verificationCode: \"123456\",\n * });\n * ```\n *\n * ### Login with phone number\n *\n * Similar to email, you can login with a phone number by first sending a verification code to the user's phone number, then login with the verification code.\n *\n * ```ts\n * import { inAppWallet, preAuthenticate } from \"thirdweb/wallets/in-app\";\n *\n * const wallet = inAppWallet();\n *\n * // sends a verification code to the provided phone number\n * await preAuthenticate({\n *   client,\n *   strategy: \"phone\",\n *   phoneNumber: \"+1234567890\",\n * });\n *\n * // login with the verification code\n * const account = await wallet.connect({\n *   client,\n *   chain,\n *   strategy: \"phone\",\n *   honeNumber: \"+1234567890\",\n *   verificationCode: \"123456\",\n * });\n * ```\n *\n * ### Login with another wallet (SIWE)\n *\n * You can also login to the in-app wallet with another existing wallet by signing a standard Sign in with Ethereum (SIWE) message.\n *\n * ```ts\n * import { inAppWallet, createWallet } from \"thirdweb/wallets\";\n *\n * const rabby = createWallet(\"io.rabby\");\n * const inAppWallet = inAppWallet();\n *\n * const account = await inAppWallet.connect({\n *    strategy: \"wallet\",\n *    chain: mainnet,\n *    wallet: rabby,\n *    client: MY_CLIENT\n * });\n * ```\n *\n * ### Login with passkey\n *\n * You can also login with a passkey. This mode requires specifying whether it should create a new passkey, or sign in with an existing passkey. We recommend checking if the user has a passkey stored in their browser to automatically login with it.\n *\n * ```ts\n * import { inAppWallet, hasStoredPasskey } from \"thirdweb/wallets/in-app\";\n *\n * const wallet = inAppWallet();\n *\n * const wallet = inAppWallet();\n * const hasPasskey = await hasStoredPasskey(client);\n * await wallet.connect({\n *   client,\n *   strategy: \"passkey\",\n *  type: hasPasskey ? \"sign-in\" : \"sign-up\",\n * });\n * ```\n *\n * ### Connect to a guest account\n *\n * You can also connect to a guest account, this will create a new account for the user instantly and store it in the browser's local storage.\n *\n * You can later \"upgrade\" this account by linking another auth method, like email or phone for example. This will preserve the account's address and history.\n *\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets\";\n *\n * const wallet = inAppWallet();\n *\n * const account = await wallet.connect({\n *   client,\n *   strategy: \"guest\",\n * });\n * ```\n *\n * ### Connect to a backend account\n *\n * For usage in backends, you can create wallets with the `backend` strategy and a stable walletSecret.\n *\n * Make sure to keep that walletSecret safe as it is the key to access that wallet, never expose it to the client.\n *\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets\";\n *\n * const wallet = inAppWallet();\n *\n * const account = await wallet.connect({\n *   client,\n *   strategy: \"backend\",\n *   walletSecret: \"...\", // Your own secret, keep it safe\n * });\n * ```\n *\n * ### Connect with custom JWT (any OIDC provider)\n *\n * You can use any OIDC provider to authenticate your users. Make sure to configure it in your dashboard under in-app wallet settings.\n *\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets\";\n *\n * const wallet = inAppWallet();\n *\n * const account = await wallet.connect({\n *   client,\n *   strategy: \"jwt\",\n *   jwt: \"your_jwt_here\",\n * });\n * ```\n *\n * ### Connect with custom endpoint\n *\n * You can also use your own endpoint to authenticate your users. Make sure to configure it in your dashboard under in-app wallet settings.\n *\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets\";\n *\n * const wallet = inAppWallet();\n *\n * const account = await wallet.connect({\n *   client,\n *   strategy: \"auth_endpoint\",\n *   payload: \"your_auth_payload_here\",\n * });\n * ```\n *\n * ### Specify a logo, icon and name for your login page (Connect UI)\n *\n * You can specify a logo, icon and name for your login page to customize how in-app wallets are displayed in the Connect UI components (ConnectButton and ConnectEmbed).\n *\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets\";\n * const wallet = inAppWallet({\n *  metadata: {\n *    name: \"My App\",\n *    icon: \"https://example.com/icon.png\",\n *    image: {\n *      src: \"https://example.com/logo.png\",\n *      alt: \"My logo\",\n *      width: 100,\n *      height: 100,\n *   },\n *  },\n * });\n * ```\n *\n * ### Hide the ability to export the private key within the Connect Modal UI\n *\n * By default, the Connect Modal will show a button to export the private key of the wallet. You can hide this button by setting the `hidePrivateKeyExport` option to `true`.\n *\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets\";\n * const wallet = inAppWallet({\n *  hidePrivateKeyExport: true\n * });\n * ```\n *\n * ### Open the Oauth window in the same tab\n *\n * By default, the Oauth window will open in a popup window. You can change this behavior by setting the `auth.mode` option to `\"redirect\"`.\n *\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets\";\n * const wallet = inAppWallet({\n *  auth: {\n *    mode: \"redirect\"\n *  }\n * });\n * ```\n *\n * ### Override storage for the wallet state\n *\n * By default, wallet state is stored in the browser's local storage if in the browser, or in-memory storage if not in the browser. You can override this behavior by providing a custom storage object, useful for server side and CLI integrations.\n *\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets\";\n * import { AsyncStorage } from \"thirdweb/storage\";\n *\n * const myStorage: AsyncStorage = {\n *  getItem: async (key) => {\n *    return customGet(`CUSTOM_STORAGE_KEY${key}`);\n *  },\n *  setItem: async (key, value) => {\n *    return customSet(`CUSTOM_STORAGE_KEY${key}`, value);\n *  },\n *  removeItem: async (key) => {\n *    return customRemove(`CUSTOM_STORAGE_KEY${key}`);\n *  },\n * };\n *\n * const wallet = inAppWallet({\n *  storage: myStorage,\n * });\n * ```\n *\n * ### Get the auth token for the wallet\n *\n * You can get the auth token for the wallet by calling `wallet.getAuthToken()`.\n *\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets\";\n *\n * const wallet = inAppWallet();\n *\n * await wallet.connect({\n *   client,\n *   strategy: \"google\",\n * });\n *\n * const authToken = await wallet.getAuthToken(); // this will return a JWT token that can be used to authenticate the user in the backend\n * console.log(authToken);\n * ```\n *\n * @returns The created in-app wallet.\n * @wallet\n */\nexport function inAppWallet(createOptions) {\n  return createInAppWallet({\n    connectorFactory: async client => {\n      var _createOptions$auth;\n      const {\n        InAppWebConnector\n      } = await import(\"./lib/web-connector.js\");\n      return new InAppWebConnector({\n        client,\n        passkeyDomain: createOptions === null || createOptions === void 0 || (_createOptions$auth = createOptions.auth) === null || _createOptions$auth === void 0 ? void 0 : _createOptions$auth.passkeyDomain,\n        storage: createOptions === null || createOptions === void 0 ? void 0 : createOptions.storage\n      });\n    },\n    createOptions\n  });\n}","map":{"version":3,"names":["createInAppWallet","inAppWallet","createOptions","connectorFactory","client","_createOptions$auth","InAppWebConnector","passkeyDomain","auth","storage"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/wallets/in-app/web/in-app.ts"],"sourcesContent":["import type { ThirdwebClient } from \"../../../client/client.js\";\nimport { createInAppWallet } from \"../core/wallet/in-app-core.js\";\nimport type {\n  InAppWallet,\n  InAppWalletCreationOptions,\n} from \"../core/wallet/types.js\";\n\n/**\n * Creates an app scoped wallet for users based on various authentication methods. Full list of available authentication methods [here](https://portal.thirdweb.com/connect/wallet/sign-in-methods/configure).\n *\n * Can also be configured to use Account Abstraction to directly connect to a ERC4337 smart account based on those authentication methods.\n *\n * @param createOptions - configuration options\n * Refer to [InAppWalletCreationOptions](https://portal.thirdweb.com/references/typescript/v5/InAppWalletCreationOptions) to see the available options.\n * @returns The created in-app wallet.\n * @example\n *\n * ### Login with socials\n *\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets\";\n *\n * const wallet = inAppWallet();\n *\n * const account = await wallet.connect({\n *   client,\n *   chain,\n *   strategy: \"google\", // or \"apple\", \"facebook\",\"discord\", \"github\", \"twitch\", \"x\", \"telegram\", \"line\", \"coinbase\", etc\n * });\n * ```\n *\n * [View all available social auth methods](https://portal.thirdweb.com/connect/wallet/sign-in-methods/configure)\n *\n * ### Enable smart accounts and sponsor gas for your users:\n *\n * With the `executionMode` option, you can enable smart accounts and sponsor gas for your users.\n *\n * **Using EIP-7702** (recommended):\n *\n * On chains with EIP-7702 enabled, you can upgrade the inapp wallet to a smart account, keeping the same address and performance as the regular EOA.\n *\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets\";\n * import { sepolia } from \"thirdweb/chains\";\n *\n * const wallet = inAppWallet({\n *  executionMode: {\n *   mode: \"EIP7702\",\n *   sponsorGas: true,\n *  },\n * });\n *\n * // account will be a smart account with sponsored gas enabled\n * const account = await wallet.connect({\n *   client,\n *   strategy: \"google\",\n * });\n * ```\n *\n * **Using EIP-4337**:\n *\n * On chains without EIP-7702 enabled, you can still use smart accounts using EIP-4337, this will return a different address (the smart contract address) than the regular EOA.\n *\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets/in-app\";\n *\n * const wallet = inAppWallet({\n *  executionMode: {\n *   mode: \"EIP4337\",\n *   smartAccount: {\n *    chain: sepolia, // chain required for EIP-4337\n *    sponsorGas: true,\n *   }\n *  },\n * });\n * ```\n *\n * ### Login with email\n *\n * To login with email, you can use the `preAuthenticate` function to first send a verification code to the user's email, then login with the verification code.\n *\n * ```ts\n * import { inAppWallet, preAuthenticate } from \"thirdweb/wallets/in-app\";\n *\n * const wallet = inAppWallet();\n *\n * // sends a verification code to the provided email\n * await preAuthenticate({\n *   client,\n *   strategy: \"email\",\n *   email: \"example@example.com\",\n * });\n *\n * // login with the verification code\n * const account = await wallet.connect({\n *   client,\n *   chain,\n *   strategy: \"email\",\n *   email: \"example@example.com\",\n *   verificationCode: \"123456\",\n * });\n * ```\n *\n * ### Login with phone number\n *\n * Similar to email, you can login with a phone number by first sending a verification code to the user's phone number, then login with the verification code.\n *\n * ```ts\n * import { inAppWallet, preAuthenticate } from \"thirdweb/wallets/in-app\";\n *\n * const wallet = inAppWallet();\n *\n * // sends a verification code to the provided phone number\n * await preAuthenticate({\n *   client,\n *   strategy: \"phone\",\n *   phoneNumber: \"+1234567890\",\n * });\n *\n * // login with the verification code\n * const account = await wallet.connect({\n *   client,\n *   chain,\n *   strategy: \"phone\",\n *   honeNumber: \"+1234567890\",\n *   verificationCode: \"123456\",\n * });\n * ```\n *\n * ### Login with another wallet (SIWE)\n *\n * You can also login to the in-app wallet with another existing wallet by signing a standard Sign in with Ethereum (SIWE) message.\n *\n * ```ts\n * import { inAppWallet, createWallet } from \"thirdweb/wallets\";\n *\n * const rabby = createWallet(\"io.rabby\");\n * const inAppWallet = inAppWallet();\n *\n * const account = await inAppWallet.connect({\n *    strategy: \"wallet\",\n *    chain: mainnet,\n *    wallet: rabby,\n *    client: MY_CLIENT\n * });\n * ```\n *\n * ### Login with passkey\n *\n * You can also login with a passkey. This mode requires specifying whether it should create a new passkey, or sign in with an existing passkey. We recommend checking if the user has a passkey stored in their browser to automatically login with it.\n *\n * ```ts\n * import { inAppWallet, hasStoredPasskey } from \"thirdweb/wallets/in-app\";\n *\n * const wallet = inAppWallet();\n *\n * const wallet = inAppWallet();\n * const hasPasskey = await hasStoredPasskey(client);\n * await wallet.connect({\n *   client,\n *   strategy: \"passkey\",\n *  type: hasPasskey ? \"sign-in\" : \"sign-up\",\n * });\n * ```\n *\n * ### Connect to a guest account\n *\n * You can also connect to a guest account, this will create a new account for the user instantly and store it in the browser's local storage.\n *\n * You can later \"upgrade\" this account by linking another auth method, like email or phone for example. This will preserve the account's address and history.\n *\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets\";\n *\n * const wallet = inAppWallet();\n *\n * const account = await wallet.connect({\n *   client,\n *   strategy: \"guest\",\n * });\n * ```\n *\n * ### Connect to a backend account\n *\n * For usage in backends, you can create wallets with the `backend` strategy and a stable walletSecret.\n *\n * Make sure to keep that walletSecret safe as it is the key to access that wallet, never expose it to the client.\n *\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets\";\n *\n * const wallet = inAppWallet();\n *\n * const account = await wallet.connect({\n *   client,\n *   strategy: \"backend\",\n *   walletSecret: \"...\", // Your own secret, keep it safe\n * });\n * ```\n *\n * ### Connect with custom JWT (any OIDC provider)\n *\n * You can use any OIDC provider to authenticate your users. Make sure to configure it in your dashboard under in-app wallet settings.\n *\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets\";\n *\n * const wallet = inAppWallet();\n *\n * const account = await wallet.connect({\n *   client,\n *   strategy: \"jwt\",\n *   jwt: \"your_jwt_here\",\n * });\n * ```\n *\n * ### Connect with custom endpoint\n *\n * You can also use your own endpoint to authenticate your users. Make sure to configure it in your dashboard under in-app wallet settings.\n *\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets\";\n *\n * const wallet = inAppWallet();\n *\n * const account = await wallet.connect({\n *   client,\n *   strategy: \"auth_endpoint\",\n *   payload: \"your_auth_payload_here\",\n * });\n * ```\n *\n * ### Specify a logo, icon and name for your login page (Connect UI)\n *\n * You can specify a logo, icon and name for your login page to customize how in-app wallets are displayed in the Connect UI components (ConnectButton and ConnectEmbed).\n *\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets\";\n * const wallet = inAppWallet({\n *  metadata: {\n *    name: \"My App\",\n *    icon: \"https://example.com/icon.png\",\n *    image: {\n *      src: \"https://example.com/logo.png\",\n *      alt: \"My logo\",\n *      width: 100,\n *      height: 100,\n *   },\n *  },\n * });\n * ```\n *\n * ### Hide the ability to export the private key within the Connect Modal UI\n *\n * By default, the Connect Modal will show a button to export the private key of the wallet. You can hide this button by setting the `hidePrivateKeyExport` option to `true`.\n *\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets\";\n * const wallet = inAppWallet({\n *  hidePrivateKeyExport: true\n * });\n * ```\n *\n * ### Open the Oauth window in the same tab\n *\n * By default, the Oauth window will open in a popup window. You can change this behavior by setting the `auth.mode` option to `\"redirect\"`.\n *\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets\";\n * const wallet = inAppWallet({\n *  auth: {\n *    mode: \"redirect\"\n *  }\n * });\n * ```\n *\n * ### Override storage for the wallet state\n *\n * By default, wallet state is stored in the browser's local storage if in the browser, or in-memory storage if not in the browser. You can override this behavior by providing a custom storage object, useful for server side and CLI integrations.\n *\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets\";\n * import { AsyncStorage } from \"thirdweb/storage\";\n *\n * const myStorage: AsyncStorage = {\n *  getItem: async (key) => {\n *    return customGet(`CUSTOM_STORAGE_KEY${key}`);\n *  },\n *  setItem: async (key, value) => {\n *    return customSet(`CUSTOM_STORAGE_KEY${key}`, value);\n *  },\n *  removeItem: async (key) => {\n *    return customRemove(`CUSTOM_STORAGE_KEY${key}`);\n *  },\n * };\n *\n * const wallet = inAppWallet({\n *  storage: myStorage,\n * });\n * ```\n *\n * ### Get the auth token for the wallet\n *\n * You can get the auth token for the wallet by calling `wallet.getAuthToken()`.\n *\n * ```ts\n * import { inAppWallet } from \"thirdweb/wallets\";\n *\n * const wallet = inAppWallet();\n *\n * await wallet.connect({\n *   client,\n *   strategy: \"google\",\n * });\n *\n * const authToken = await wallet.getAuthToken(); // this will return a JWT token that can be used to authenticate the user in the backend\n * console.log(authToken);\n * ```\n *\n * @returns The created in-app wallet.\n * @wallet\n */\nexport function inAppWallet(\n  createOptions?: InAppWalletCreationOptions,\n): InAppWallet {\n  return createInAppWallet({\n    connectorFactory: async (client: ThirdwebClient) => {\n      const { InAppWebConnector } = await import(\"./lib/web-connector.js\");\n      return new InAppWebConnector({\n        client,\n        passkeyDomain: createOptions?.auth?.passkeyDomain,\n        storage: createOptions?.storage,\n      });\n    },\n    createOptions,\n  }) as InAppWallet;\n}\n"],"mappings":"AACA,SAASA,iBAAiB,QAAQ,+BAA+B;AAMjE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2TA,OAAM,SAAUC,WAAWA,CACzBC,aAA0C;EAE1C,OAAOF,iBAAiB,CAAC;IACvBG,gBAAgB,EAAE,MAAOC,MAAsB,IAAI;MAAA,IAAAC,mBAAA;MACjD,MAAM;QAAEC;MAAiB,CAAE,GAAG,MAAM,MAAM,CAAC,wBAAwB,CAAC;MACpE,OAAO,IAAIA,iBAAiB,CAAC;QAC3BF,MAAM;QACNG,aAAa,EAAEL,aAAa,aAAbA,aAAa,gBAAAG,mBAAA,GAAbH,aAAa,CAAEM,IAAI,cAAAH,mBAAA,uBAAnBA,mBAAA,CAAqBE,aAAa;QACjDE,OAAO,EAAEP,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAEO;OACzB,CAAC;IACJ,CAAC;IACDP;GACD,CAAgB;AACnB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}