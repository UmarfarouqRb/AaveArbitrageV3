{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { trackConnect } from \"../../../../analytics/track/connect.js\";\nimport { getCachedChain, getCachedChainIfExists } from \"../../../../chains/utils.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nimport { getEcosystemInfo } from \"../../../ecosystem/get-ecosystem-wallet-auth-options.js\";\nimport { createWalletEmitter } from \"../../../wallet-emitter.js\";\nconst connectorCache = new Map();\n/**\n * @internal\n */\nexport async function getOrCreateInAppWalletConnector(client, connectorFactory, ecosystem) {\n  var _client$secretKey;\n  const key = stringify({\n    clientId: client.clientId,\n    ecosystem,\n    partialSecretKey: (_client$secretKey = client.secretKey) === null || _client$secretKey === void 0 ? void 0 : _client$secretKey.slice(0, 5)\n  });\n  if (connectorCache.has(key)) {\n    return connectorCache.get(key);\n  }\n  const connector = await connectorFactory(client);\n  connectorCache.set(key, connector);\n  return connector;\n}\n/**\n * @internal\n */\nexport function createInAppWallet(args) {\n  const {\n    createOptions: _createOptions,\n    connectorFactory,\n    ecosystem\n  } = args;\n  const walletId = ecosystem ? ecosystem.id : \"inApp\";\n  const emitter = createWalletEmitter();\n  let createOptions = _createOptions;\n  let account;\n  let adminAccount; // Admin account if smartAccountOptions were provided with connection\n  let chain;\n  let client;\n  let authToken = null;\n  const resolveSmartAccountOptionsFromEcosystem = async options => {\n    if (ecosystem) {\n      const ecosystemOptions = await getEcosystemInfo(ecosystem.id);\n      const smartAccountOptions = ecosystemOptions === null || ecosystemOptions === void 0 ? void 0 : ecosystemOptions.smartAccountOptions;\n      if (smartAccountOptions) {\n        const executionMode = ecosystemOptions.smartAccountOptions.executionMode;\n        if (executionMode === \"EIP7702\") {\n          createOptions = _objectSpread(_objectSpread({}, createOptions), {}, {\n            executionMode: {\n              mode: \"EIP7702\",\n              sponsorGas: smartAccountOptions.sponsorGas\n            }\n          });\n        } else {\n          var _options$chain;\n          // default to 4337\n          const {\n            defaultChainId\n          } = ecosystemOptions.smartAccountOptions;\n          const preferredChain = (_options$chain = options === null || options === void 0 ? void 0 : options.chain) !== null && _options$chain !== void 0 ? _options$chain : defaultChainId ? getCachedChain(defaultChainId) : undefined;\n          if (!preferredChain) {\n            throw new Error(\"A chain must be provided either via 'chain' in connect options or 'defaultChainId' in ecosystem configuration. Please pass it via connect() or update the ecosystem configuration.\");\n          }\n          createOptions = _objectSpread(_objectSpread({}, createOptions), {}, {\n            smartAccount: {\n              chain: preferredChain,\n              factoryAddress: smartAccountOptions.accountFactoryAddress,\n              sponsorGas: smartAccountOptions.sponsorGas\n            }\n          });\n        }\n      }\n    }\n  };\n  return {\n    autoConnect: async options => {\n      const {\n        autoConnectInAppWallet\n      } = await import(\"./index.js\");\n      const connector = await getOrCreateInAppWalletConnector(options.client, connectorFactory, ecosystem);\n      await resolveSmartAccountOptionsFromEcosystem();\n      const {\n        account: connectedAccount,\n        chain: connectedChain,\n        adminAccount: _adminAccount\n      } = await autoConnectInAppWallet(options, createOptions, connector);\n      // set the states\n      client = options.client;\n      account = connectedAccount;\n      adminAccount = _adminAccount;\n      chain = connectedChain;\n      try {\n        authToken = await connector.storage.getAuthCookie();\n      } catch (error) {\n        console.error(\"Failed to retrieve auth token:\", error);\n        authToken = null;\n      }\n      trackConnect({\n        chainId: chain.id,\n        client: options.client,\n        ecosystem,\n        walletAddress: account.address,\n        walletType: walletId\n      });\n      // return only the account\n      return account;\n    },\n    connect: async options => {\n      const {\n        connectInAppWallet\n      } = await import(\"./index.js\");\n      const connector = await getOrCreateInAppWalletConnector(options.client, connectorFactory, ecosystem);\n      await resolveSmartAccountOptionsFromEcosystem();\n      const {\n        account: connectedAccount,\n        chain: connectedChain,\n        adminAccount: _adminAccount\n      } = await connectInAppWallet(options, createOptions, connector);\n      // set the states\n      client = options.client;\n      account = connectedAccount;\n      adminAccount = _adminAccount;\n      chain = connectedChain;\n      try {\n        authToken = await connector.storage.getAuthCookie();\n      } catch (error) {\n        console.error(\"Failed to retrieve auth token:\", error);\n        authToken = null;\n      }\n      trackConnect({\n        chainId: chain.id,\n        client: options.client,\n        ecosystem,\n        walletAddress: account.address,\n        walletType: walletId\n      });\n      // return only the account\n      return account;\n    },\n    disconnect: async () => {\n      // If no client is assigned, we should be fine just unsetting the states\n      if (client) {\n        const connector = await getOrCreateInAppWalletConnector(client, connectorFactory, ecosystem);\n        const result = await connector.logout();\n        if (!result.success) {\n          throw new Error(\"Failed to logout\");\n        }\n      }\n      account = undefined;\n      adminAccount = undefined;\n      chain = undefined;\n      authToken = null;\n      emitter.emit(\"disconnect\", undefined);\n    },\n    getAccount: () => account,\n    getAdminAccount: () => adminAccount,\n    getAuthToken: () => authToken,\n    getChain() {\n      if (!chain) {\n        return undefined;\n      }\n      chain = getCachedChainIfExists(chain.id) || chain;\n      return chain;\n    },\n    getConfig: () => createOptions,\n    id: walletId,\n    subscribe: emitter.subscribe,\n    switchChain: async newChain => {\n      var _createOptions2, _createOptions3;\n      if (((_createOptions2 = createOptions) !== null && _createOptions2 !== void 0 && _createOptions2.smartAccount || ((_createOptions3 = createOptions) === null || _createOptions3 === void 0 || (_createOptions3 = _createOptions3.executionMode) === null || _createOptions3 === void 0 ? void 0 : _createOptions3.mode) === \"EIP4337\") && client && account) {\n        // if account abstraction is enabled, reconnect to smart account on the new chain\n        const {\n          autoConnectInAppWallet\n        } = await import(\"./index.js\");\n        const connector = await getOrCreateInAppWalletConnector(client, connectorFactory, ecosystem);\n        await resolveSmartAccountOptionsFromEcosystem({\n          chain: newChain\n        });\n        const {\n          account: connectedAccount,\n          chain: connectedChain,\n          adminAccount: _adminAccount\n        } = await autoConnectInAppWallet({\n          chain: newChain,\n          client\n        }, createOptions, connector);\n        adminAccount = _adminAccount;\n        account = connectedAccount;\n        chain = connectedChain;\n      } else {\n        // if not, simply set the new chain\n        chain = newChain;\n      }\n      emitter.emit(\"chainChanged\", newChain);\n    }\n  };\n}","map":{"version":3,"names":["trackConnect","getCachedChain","getCachedChainIfExists","stringify","getEcosystemInfo","createWalletEmitter","connectorCache","Map","getOrCreateInAppWalletConnector","client","connectorFactory","ecosystem","_client$secretKey","key","clientId","partialSecretKey","secretKey","slice","has","get","connector","set","createInAppWallet","args","createOptions","_createOptions","walletId","id","emitter","account","adminAccount","chain","authToken","resolveSmartAccountOptionsFromEcosystem","options","ecosystemOptions","smartAccountOptions","executionMode","_objectSpread","mode","sponsorGas","_options$chain","defaultChainId","preferredChain","undefined","Error","smartAccount","factoryAddress","accountFactoryAddress","autoConnect","autoConnectInAppWallet","connectedAccount","connectedChain","_adminAccount","storage","getAuthCookie","error","console","chainId","walletAddress","address","walletType","connect","connectInAppWallet","disconnect","result","logout","success","emit","getAccount","getAdminAccount","getAuthToken","getChain","getConfig","subscribe","switchChain","newChain","_createOptions2","_createOptions3"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/wallets/in-app/core/wallet/in-app-core.ts"],"sourcesContent":["import { trackConnect } from \"../../../../analytics/track/connect.js\";\nimport type { Chain } from \"../../../../chains/types.js\";\nimport {\n  getCachedChain,\n  getCachedChainIfExists,\n} from \"../../../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nimport { getEcosystemInfo } from \"../../../ecosystem/get-ecosystem-wallet-auth-options.js\";\nimport type { Account, Wallet } from \"../../../interfaces/wallet.js\";\nimport { createWalletEmitter } from \"../../../wallet-emitter.js\";\nimport type {\n  CreateWalletArgs,\n  EcosystemWalletId,\n} from \"../../../wallet-types.js\";\nimport type { InAppConnector } from \"../interfaces/connector.js\";\nimport type { Ecosystem } from \"./types.js\";\n\nconst connectorCache = new Map<string, InAppConnector>();\n\n/**\n * @internal\n */\nexport async function getOrCreateInAppWalletConnector(\n  client: ThirdwebClient,\n  connectorFactory: (client: ThirdwebClient) => Promise<InAppConnector>,\n  ecosystem?: Ecosystem,\n) {\n  const key = stringify({\n    clientId: client.clientId,\n    ecosystem,\n    partialSecretKey: client.secretKey?.slice(0, 5),\n  });\n  if (connectorCache.has(key)) {\n    return connectorCache.get(key) as InAppConnector;\n  }\n  const connector = await connectorFactory(client);\n  connectorCache.set(key, connector);\n  return connector;\n}\n\n/**\n * @internal\n */\nexport function createInAppWallet(args: {\n  createOptions?: CreateWalletArgs<\"inApp\">[1];\n  connectorFactory: (client: ThirdwebClient) => Promise<InAppConnector>;\n  ecosystem?: Ecosystem;\n}): Wallet<\"inApp\" | EcosystemWalletId> {\n  const { createOptions: _createOptions, connectorFactory, ecosystem } = args;\n  const walletId = ecosystem ? ecosystem.id : \"inApp\";\n  const emitter = createWalletEmitter<\"inApp\">();\n  let createOptions = _createOptions;\n  let account: Account | undefined;\n  let adminAccount: Account | undefined; // Admin account if smartAccountOptions were provided with connection\n  let chain: Chain | undefined;\n  let client: ThirdwebClient | undefined;\n  let authToken: string | null = null;\n\n  const resolveSmartAccountOptionsFromEcosystem = async (options?: {\n    chain?: Chain;\n  }) => {\n    if (ecosystem) {\n      const ecosystemOptions = await getEcosystemInfo(ecosystem.id);\n      const smartAccountOptions = ecosystemOptions?.smartAccountOptions;\n      if (smartAccountOptions) {\n        const executionMode =\n          ecosystemOptions.smartAccountOptions.executionMode;\n        if (executionMode === \"EIP7702\") {\n          createOptions = {\n            ...createOptions,\n            executionMode: {\n              mode: \"EIP7702\",\n              sponsorGas: smartAccountOptions.sponsorGas,\n            },\n          };\n        } else {\n          // default to 4337\n          const { defaultChainId } = ecosystemOptions.smartAccountOptions;\n          const preferredChain =\n            options?.chain ??\n            (defaultChainId ? getCachedChain(defaultChainId) : undefined);\n          if (!preferredChain) {\n            throw new Error(\n              `A chain must be provided either via 'chain' in connect options or 'defaultChainId' in ecosystem configuration. Please pass it via connect() or update the ecosystem configuration.`,\n            );\n          }\n          createOptions = {\n            ...createOptions,\n            smartAccount: {\n              chain: preferredChain,\n              factoryAddress: smartAccountOptions.accountFactoryAddress,\n              sponsorGas: smartAccountOptions.sponsorGas,\n            },\n          };\n        }\n      }\n    }\n  };\n\n  return {\n    autoConnect: async (options) => {\n      const { autoConnectInAppWallet } = await import(\"./index.js\");\n\n      const connector = await getOrCreateInAppWalletConnector(\n        options.client,\n        connectorFactory,\n        ecosystem,\n      );\n\n      await resolveSmartAccountOptionsFromEcosystem();\n\n      const {\n        account: connectedAccount,\n        chain: connectedChain,\n        adminAccount: _adminAccount,\n      } = await autoConnectInAppWallet(options, createOptions, connector);\n\n      // set the states\n      client = options.client;\n      account = connectedAccount;\n      adminAccount = _adminAccount;\n      chain = connectedChain;\n      try {\n        authToken = await connector.storage.getAuthCookie();\n      } catch (error) {\n        console.error(\"Failed to retrieve auth token:\", error);\n        authToken = null;\n      }\n      trackConnect({\n        chainId: chain.id,\n        client: options.client,\n        ecosystem,\n        walletAddress: account.address,\n        walletType: walletId,\n      });\n      // return only the account\n      return account;\n    },\n    connect: async (options) => {\n      const { connectInAppWallet } = await import(\"./index.js\");\n      const connector = await getOrCreateInAppWalletConnector(\n        options.client,\n        connectorFactory,\n        ecosystem,\n      );\n\n      await resolveSmartAccountOptionsFromEcosystem();\n\n      const {\n        account: connectedAccount,\n        chain: connectedChain,\n        adminAccount: _adminAccount,\n      } = await connectInAppWallet(options, createOptions, connector);\n\n      // set the states\n      client = options.client;\n      account = connectedAccount;\n      adminAccount = _adminAccount;\n      chain = connectedChain;\n      try {\n        authToken = await connector.storage.getAuthCookie();\n      } catch (error) {\n        console.error(\"Failed to retrieve auth token:\", error);\n        authToken = null;\n      }\n      trackConnect({\n        chainId: chain.id,\n        client: options.client,\n        ecosystem,\n        walletAddress: account.address,\n        walletType: walletId,\n      });\n      // return only the account\n      return account;\n    },\n    disconnect: async () => {\n      // If no client is assigned, we should be fine just unsetting the states\n      if (client) {\n        const connector = await getOrCreateInAppWalletConnector(\n          client,\n          connectorFactory,\n          ecosystem,\n        );\n        const result = await connector.logout();\n        if (!result.success) {\n          throw new Error(\"Failed to logout\");\n        }\n      }\n      account = undefined;\n      adminAccount = undefined;\n      chain = undefined;\n      authToken = null;\n      emitter.emit(\"disconnect\", undefined);\n    },\n    getAccount: () => account,\n    getAdminAccount: () => adminAccount,\n    getAuthToken: () => authToken,\n    getChain() {\n      if (!chain) {\n        return undefined;\n      }\n\n      chain = getCachedChainIfExists(chain.id) || chain;\n      return chain;\n    },\n    getConfig: () => createOptions,\n    id: walletId,\n    subscribe: emitter.subscribe,\n    switchChain: async (newChain) => {\n      if (\n        (createOptions?.smartAccount ||\n          createOptions?.executionMode?.mode === \"EIP4337\") &&\n        client &&\n        account\n      ) {\n        // if account abstraction is enabled, reconnect to smart account on the new chain\n        const { autoConnectInAppWallet } = await import(\"./index.js\");\n        const connector = await getOrCreateInAppWalletConnector(\n          client,\n          connectorFactory,\n          ecosystem,\n        );\n\n        await resolveSmartAccountOptionsFromEcosystem({ chain: newChain });\n\n        const {\n          account: connectedAccount,\n          chain: connectedChain,\n          adminAccount: _adminAccount,\n        } = await autoConnectInAppWallet(\n          {\n            chain: newChain,\n            client,\n          },\n          createOptions,\n          connector,\n        );\n        adminAccount = _adminAccount;\n        account = connectedAccount;\n        chain = connectedChain;\n      } else {\n        // if not, simply set the new chain\n        chain = newChain;\n      }\n      emitter.emit(\"chainChanged\", newChain);\n    },\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}