{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nfunction getVerificationPath() {\n  return \"\".concat(getThirdwebBaseUrl(\"inAppWallet\"), \"/api/2024-05-05/login/passkey/callback\");\n}\nfunction getChallengePath(type, username) {\n  return \"\".concat(getThirdwebBaseUrl(\"inAppWallet\"), \"/api/2024-05-05/login/passkey?type=\").concat(type).concat(username ? \"&username=\".concat(username) : \"\");\n}\nexport async function registerPasskey(options) {\n  var _options$username, _options$ecosystem, _options$ecosystem2, _options$storage;\n  if (!options.passkeyClient.isAvailable()) {\n    throw new Error(\"Passkeys are not available on this device\");\n  }\n  const fetchWithId = getClientFetch(options.client, options.ecosystem);\n  const generatedName = (_options$username = options.username) !== null && _options$username !== void 0 ? _options$username : generateUsername(options.ecosystem);\n  // 1. request challenge from  server\n  const res = await fetchWithId(getChallengePath(\"sign-up\", generatedName));\n  const challengeData = await res.json();\n  if (!challengeData.challenge) {\n    throw new Error(\"No challenge received\");\n  }\n  const challenge = challengeData.challenge;\n  // 2. initiate registration\n  const registration = await options.passkeyClient.register({\n    challenge,\n    name: generatedName,\n    rp: options.rp\n  });\n  const customHeaders = {};\n  if ((_options$ecosystem = options.ecosystem) !== null && _options$ecosystem !== void 0 && _options$ecosystem.partnerId) {\n    customHeaders[\"x-ecosystem-partner-id\"] = options.ecosystem.partnerId;\n  }\n  if ((_options$ecosystem2 = options.ecosystem) !== null && _options$ecosystem2 !== void 0 && _options$ecosystem2.id) {\n    customHeaders[\"x-ecosystem-id\"] = options.ecosystem.id;\n  }\n  // 3. send the registration object to the server\n  const verifRes = await fetchWithId(getVerificationPath(), {\n    body: stringify({\n      authenticatorData: registration.authenticatorData,\n      clientData: registration.clientData,\n      credential: {\n        algorithm: registration.credential.algorithm,\n        publicKey: registration.credential.publicKey\n      },\n      credentialId: registration.credentialId,\n      origin: registration.origin,\n      rpId: options.rp.id,\n      serverVerificationId: challengeData.serverVerificationId,\n      type: \"sign-up\",\n      username: generatedName\n    }),\n    headers: _objectSpread({\n      \"Content-Type\": \"application/json\"\n    }, customHeaders),\n    method: \"POST\"\n  });\n  const verifData = await verifRes.json();\n  if (!verifData || !verifData.storedToken) {\n    var _verifData$message;\n    throw new Error(\"Error verifying passkey: \".concat((_verifData$message = verifData.message) !== null && _verifData$message !== void 0 ? _verifData$message : \"unknown error\"));\n  }\n  // 4. store the credentialId in local storage\n  await ((_options$storage = options.storage) === null || _options$storage === void 0 ? void 0 : _options$storage.savePasskeyCredentialId(registration.credentialId));\n  // 5. returns back the IAW authentication token\n  return verifData;\n}\nexport async function loginWithPasskey(options) {\n  var _options$storage2, _options$ecosystem3, _options$ecosystem4, _options$storage3;\n  if (!options.passkeyClient.isAvailable()) {\n    throw new Error(\"Passkeys are not available on this device\");\n  }\n  const fetchWithId = getClientFetch(options.client, options.ecosystem);\n  // 1. request challenge from  server/iframe\n  const [challengeData, credentialId] = await Promise.all([fetchWithId(getChallengePath(\"sign-in\")).then(r => r.json()), (_options$storage2 = options.storage) === null || _options$storage2 === void 0 ? void 0 : _options$storage2.getPasskeyCredentialId()]);\n  if (!challengeData.challenge) {\n    throw new Error(\"No challenge received\");\n  }\n  const challenge = challengeData.challenge;\n  // 2. initiate login\n  const authentication = await options.passkeyClient.authenticate({\n    challenge,\n    credentialId: credentialId !== null && credentialId !== void 0 ? credentialId : undefined,\n    rp: options.rp\n  });\n  const customHeaders = {};\n  if ((_options$ecosystem3 = options.ecosystem) !== null && _options$ecosystem3 !== void 0 && _options$ecosystem3.partnerId) {\n    customHeaders[\"x-ecosystem-partner-id\"] = options.ecosystem.partnerId;\n  }\n  if ((_options$ecosystem4 = options.ecosystem) !== null && _options$ecosystem4 !== void 0 && _options$ecosystem4.id) {\n    customHeaders[\"x-ecosystem-id\"] = options.ecosystem.id;\n  }\n  const verifRes = await fetchWithId(getVerificationPath(), {\n    body: stringify({\n      authenticatorData: authentication.authenticatorData,\n      clientData: authentication.clientData,\n      credentialId: authentication.credentialId,\n      origin: authentication.origin,\n      rpId: options.rp.id,\n      serverVerificationId: challengeData.serverVerificationId,\n      signature: authentication.signature,\n      type: \"sign-in\"\n    }),\n    headers: _objectSpread({\n      \"Content-Type\": \"application/json\"\n    }, customHeaders),\n    method: \"POST\"\n  });\n  const verifData = await verifRes.json();\n  if (!verifData || !verifData.storedToken) {\n    var _verifData$message2;\n    throw new Error(\"Error verifying passkey: \".concat((_verifData$message2 = verifData.message) !== null && _verifData$message2 !== void 0 ? _verifData$message2 : \"unknown error\"));\n  }\n  // 5. store the credentialId in local storage\n  await ((_options$storage3 = options.storage) === null || _options$storage3 === void 0 ? void 0 : _options$storage3.savePasskeyCredentialId(authentication.credentialId));\n  // 6. return the auth'd user type\n  return verifData;\n}\nfunction generateUsername(ecosystem) {\n  var _ecosystem$id;\n  return \"\".concat((_ecosystem$id = ecosystem === null || ecosystem === void 0 ? void 0 : ecosystem.id) !== null && _ecosystem$id !== void 0 ? _ecosystem$id : \"wallet\", \"-\").concat(new Date().toISOString());\n}","map":{"version":3,"names":["getThirdwebBaseUrl","getClientFetch","stringify","getVerificationPath","concat","getChallengePath","type","username","registerPasskey","options","_options$username","_options$ecosystem","_options$ecosystem2","_options$storage","passkeyClient","isAvailable","Error","fetchWithId","client","ecosystem","generatedName","generateUsername","res","challengeData","json","challenge","registration","register","name","rp","customHeaders","partnerId","id","verifRes","body","authenticatorData","clientData","credential","algorithm","publicKey","credentialId","origin","rpId","serverVerificationId","headers","_objectSpread","method","verifData","storedToken","_verifData$message","message","storage","savePasskeyCredentialId","loginWithPasskey","_options$storage2","_options$ecosystem3","_options$ecosystem4","_options$storage3","Promise","all","then","r","getPasskeyCredentialId","authentication","authenticate","undefined","signature","_verifData$message2","_ecosystem$id","Date","toISOString"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/wallets/in-app/core/authentication/passkeys.ts"],"sourcesContent":["import type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nimport type { Ecosystem } from \"../wallet/types.js\";\nimport type { ClientScopedStorage } from \"./client-scoped-storage.js\";\nimport type { AuthStoredTokenWithCookieReturnType } from \"./types.js\";\n\nfunction getVerificationPath() {\n  return `${getThirdwebBaseUrl(\n    \"inAppWallet\",\n  )}/api/2024-05-05/login/passkey/callback`;\n}\nfunction getChallengePath(type: \"sign-in\" | \"sign-up\", username?: string) {\n  return `${getThirdwebBaseUrl(\n    \"inAppWallet\",\n  )}/api/2024-05-05/login/passkey?type=${type}${\n    username ? `&username=${username}` : \"\"\n  }`;\n}\n\nexport type RegisterResult = {\n  authenticatorData: string;\n  credentialId: string;\n  clientData: string;\n  credential: {\n    publicKey: string;\n    algorithm: string;\n  };\n  origin: string;\n};\n\nexport type AuthenticateResult = {\n  credentialId: string;\n  authenticatorData: string;\n  clientData: string;\n  signature: string;\n  origin: string;\n};\n\nexport type RpInfo = { name: string; id: string };\n\nexport interface PasskeyClient {\n  register: (args: {\n    name: string;\n    challenge: string;\n    rp: RpInfo;\n  }) => Promise<RegisterResult>;\n  authenticate: (args: {\n    credentialId: string | undefined;\n    challenge: string;\n    rp: RpInfo;\n  }) => Promise<AuthenticateResult>;\n  isAvailable: () => boolean;\n}\n\nexport async function registerPasskey(options: {\n  client: ThirdwebClient;\n  passkeyClient: PasskeyClient;\n  storage?: ClientScopedStorage;\n  ecosystem?: Ecosystem;\n  username?: string;\n  rp: RpInfo;\n}): Promise<AuthStoredTokenWithCookieReturnType> {\n  if (!options.passkeyClient.isAvailable()) {\n    throw new Error(\"Passkeys are not available on this device\");\n  }\n  const fetchWithId = getClientFetch(options.client, options.ecosystem);\n  const generatedName = options.username ?? generateUsername(options.ecosystem);\n  // 1. request challenge from  server\n  const res = await fetchWithId(getChallengePath(\"sign-up\", generatedName));\n  const challengeData = await res.json();\n  if (!challengeData.challenge) {\n    throw new Error(\"No challenge received\");\n  }\n  const challenge = challengeData.challenge;\n\n  // 2. initiate registration\n  const registration = await options.passkeyClient.register({\n    challenge,\n    name: generatedName,\n    rp: options.rp,\n  });\n\n  const customHeaders: Record<string, string> = {};\n  if (options.ecosystem?.partnerId) {\n    customHeaders[\"x-ecosystem-partner-id\"] = options.ecosystem.partnerId;\n  }\n  if (options.ecosystem?.id) {\n    customHeaders[\"x-ecosystem-id\"] = options.ecosystem.id;\n  }\n\n  // 3. send the registration object to the server\n  const verifRes = await fetchWithId(getVerificationPath(), {\n    body: stringify({\n      authenticatorData: registration.authenticatorData,\n      clientData: registration.clientData,\n      credential: {\n        algorithm: registration.credential.algorithm,\n        publicKey: registration.credential.publicKey,\n      },\n      credentialId: registration.credentialId,\n      origin: registration.origin,\n      rpId: options.rp.id,\n      serverVerificationId: challengeData.serverVerificationId,\n      type: \"sign-up\",\n      username: generatedName,\n    }),\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...customHeaders,\n    },\n    method: \"POST\",\n  });\n  const verifData = await verifRes.json();\n\n  if (!verifData || !verifData.storedToken) {\n    throw new Error(\n      `Error verifying passkey: ${verifData.message ?? \"unknown error\"}`,\n    );\n  }\n  // 4. store the credentialId in local storage\n  await options.storage?.savePasskeyCredentialId(registration.credentialId);\n\n  // 5. returns back the IAW authentication token\n  return verifData;\n}\n\nexport async function loginWithPasskey(options: {\n  client: ThirdwebClient;\n  passkeyClient: PasskeyClient;\n  rp: RpInfo;\n  storage?: ClientScopedStorage;\n  ecosystem?: Ecosystem;\n}): Promise<AuthStoredTokenWithCookieReturnType> {\n  if (!options.passkeyClient.isAvailable()) {\n    throw new Error(\"Passkeys are not available on this device\");\n  }\n  const fetchWithId = getClientFetch(options.client, options.ecosystem);\n  // 1. request challenge from  server/iframe\n  const [challengeData, credentialId] = await Promise.all([\n    fetchWithId(getChallengePath(\"sign-in\")).then((r) => r.json()),\n    options.storage?.getPasskeyCredentialId(),\n  ]);\n  if (!challengeData.challenge) {\n    throw new Error(\"No challenge received\");\n  }\n  const challenge = challengeData.challenge;\n  // 2. initiate login\n  const authentication = await options.passkeyClient.authenticate({\n    challenge,\n    credentialId: credentialId ?? undefined,\n    rp: options.rp,\n  });\n\n  const customHeaders: Record<string, string> = {};\n  if (options.ecosystem?.partnerId) {\n    customHeaders[\"x-ecosystem-partner-id\"] = options.ecosystem.partnerId;\n  }\n  if (options.ecosystem?.id) {\n    customHeaders[\"x-ecosystem-id\"] = options.ecosystem.id;\n  }\n\n  const verifRes = await fetchWithId(getVerificationPath(), {\n    body: stringify({\n      authenticatorData: authentication.authenticatorData,\n      clientData: authentication.clientData,\n      credentialId: authentication.credentialId,\n      origin: authentication.origin,\n      rpId: options.rp.id,\n      serverVerificationId: challengeData.serverVerificationId,\n      signature: authentication.signature,\n      type: \"sign-in\",\n    }),\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...customHeaders,\n    },\n    method: \"POST\",\n  });\n\n  const verifData = await verifRes.json();\n\n  if (!verifData || !verifData.storedToken) {\n    throw new Error(\n      `Error verifying passkey: ${verifData.message ?? \"unknown error\"}`,\n    );\n  }\n\n  // 5. store the credentialId in local storage\n  await options.storage?.savePasskeyCredentialId(authentication.credentialId);\n\n  // 6. return the auth'd user type\n  return verifData;\n}\n\nfunction generateUsername(ecosystem?: Ecosystem) {\n  return `${ecosystem?.id ?? \"wallet\"}-${new Date().toISOString()}`;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}