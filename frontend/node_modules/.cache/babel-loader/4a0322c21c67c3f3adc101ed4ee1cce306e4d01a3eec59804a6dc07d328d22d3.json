{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { isInsufficientFundsError } from \"../../analytics/track/helpers.js\";\nimport { trackInsufficientFundsError, trackTransaction } from \"../../analytics/track/transaction.js\";\nimport { getCachedChain } from \"../../chains/utils.js\";\nimport { getContract } from \"../../contract/contract.js\";\nimport { allowance } from \"../../extensions/erc20/__generated__/IERC20/read/allowance.js\";\nimport { approve } from \"../../extensions/erc20/write/approve.js\";\nimport { addSessionKey, shouldUpdateSessionKey } from \"../../extensions/erc4337/account/addSessionKey.js\";\nimport { sendTransaction } from \"../../transaction/actions/send-transaction.js\";\nimport { toSerializableTransaction } from \"../../transaction/actions/to-serializable-transaction.js\";\nimport { populateEip712Transaction, signEip712Transaction } from \"../../transaction/actions/zksync/send-eip712-transaction.js\";\nimport { readContract } from \"../../transaction/read-contract.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { isZkSyncChain } from \"../../utils/any-evm/zksync/isZkSyncChain.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parse-typed-data.js\";\nimport { maxUint96 } from \"../../utils/types.js\";\nimport { broadcastZkTransaction, bundleUserOp, getZkPaymasterData } from \"./lib/bundler.js\";\nimport { predictAddress, prepareBatchExecute, prepareExecute } from \"./lib/calls.js\";\nimport { ENTRYPOINT_ADDRESS_v0_6, ENTRYPOINT_ADDRESS_v0_7, getDefaultAccountFactory, getEntryPointVersion } from \"./lib/constants.js\";\nimport { clearAccountDeploying, createUnsignedUserOp, signUserOp, waitForUserOpReceipt } from \"./lib/userop.js\";\nexport { isSmartWallet } from \"./is-smart-wallet.js\";\n/**\n * For in-app wallets, the smart wallet creation is implicit so we track these to be able to retrieve the personal account for a smart account on the wallet API.\n * Note: We have to go account to account here and NOT wallet to account because the smart wallet itself is never exposed to the in-app wallet, only the account.\n * @internal\n */\nconst adminAccountToSmartAccountMap = new WeakMap();\nconst smartAccountToAdminAccountMap = new WeakMap();\n/**\n * @internal\n */\nexport async function connectSmartAccount(connectionOptions, creationOptions) {\n  var _options$overrides, _options$overrides2, _options$overrides3, _options$factoryAddre, _options$overrides4, _options$overrides5, _options$overrides6, _options$overrides7;\n  const {\n    personalAccount,\n    client\n  } = connectionOptions;\n  if (!personalAccount) {\n    throw new Error(\"No personal account provided for smart account connection\");\n  }\n  const options = creationOptions;\n  const chain = creationOptions.chain;\n  const sponsorGas = \"gasless\" in options ? options.gasless : options.sponsorGas;\n  if (await isZkSyncChain(chain)) {\n    return [createZkSyncAccount({\n      chain,\n      connectionOptions,\n      creationOptions,\n      sponsorGas\n    }), chain];\n  }\n  // if factory is passed, but no entrypoint, try to resolve entrypoint from factory\n  if (options.factoryAddress && !((_options$overrides = options.overrides) !== null && _options$overrides !== void 0 && _options$overrides.entrypointAddress)) {\n    const entrypointAddress = await getEntrypointFromFactory(options.factoryAddress, client, chain);\n    if (entrypointAddress) {\n      options.overrides = _objectSpread(_objectSpread({}, options.overrides), {}, {\n        entrypointAddress\n      });\n    }\n  }\n  if ((_options$overrides2 = options.overrides) !== null && _options$overrides2 !== void 0 && _options$overrides2.tokenPaymaster && !((_options$overrides3 = options.overrides) !== null && _options$overrides3 !== void 0 && _options$overrides3.entrypointAddress)) {\n    // if token paymaster is set, but no entrypoint address, set the entrypoint address to v0.7\n    options.overrides = _objectSpread(_objectSpread({}, options.overrides), {}, {\n      entrypointAddress: ENTRYPOINT_ADDRESS_v0_7\n    });\n  }\n  const factoryAddress = (_options$factoryAddre = options.factoryAddress) !== null && _options$factoryAddre !== void 0 ? _options$factoryAddre : getDefaultAccountFactory((_options$overrides4 = options.overrides) === null || _options$overrides4 === void 0 ? void 0 : _options$overrides4.entrypointAddress);\n  const factoryContract = getContract({\n    address: factoryAddress,\n    chain: chain,\n    client: client\n  });\n  const accountAddress = await predictAddress({\n    accountAddress: (_options$overrides5 = options.overrides) === null || _options$overrides5 === void 0 ? void 0 : _options$overrides5.accountAddress,\n    accountSalt: (_options$overrides6 = options.overrides) === null || _options$overrides6 === void 0 ? void 0 : _options$overrides6.accountSalt,\n    adminAddress: personalAccount.address,\n    factoryContract,\n    predictAddressOverride: (_options$overrides7 = options.overrides) === null || _options$overrides7 === void 0 ? void 0 : _options$overrides7.predictAddress\n  }).then(address => address).catch(err => {\n    throw new Error(\"Failed to get account address with factory contract \".concat(factoryContract.address, \" on chain ID \").concat(chain.id, \": \").concat((err === null || err === void 0 ? void 0 : err.message) || \"unknown error\"), {\n      cause: err\n    });\n  });\n  const accountContract = getContract({\n    address: accountAddress,\n    chain,\n    client\n  });\n  const account = await createSmartAccount(_objectSpread(_objectSpread({}, options), {}, {\n    accountContract,\n    chain,\n    client,\n    factoryContract,\n    personalAccount,\n    sponsorGas\n  }));\n  adminAccountToSmartAccountMap.set(personalAccount, account);\n  smartAccountToAdminAccountMap.set(account, personalAccount);\n  if (options.sessionKey) {\n    if (await shouldUpdateSessionKey({\n      accountContract,\n      newPermissions: options.sessionKey.permissions,\n      sessionKeyAddress: options.sessionKey.address\n    })) {\n      const transaction = addSessionKey({\n        account: personalAccount,\n        contract: accountContract,\n        permissions: options.sessionKey.permissions,\n        sessionKeyAddress: options.sessionKey.address\n      });\n      await sendTransaction({\n        account: account,\n        transaction\n      });\n    }\n  }\n  return [account, chain];\n}\n/**\n * @internal\n */\nexport async function disconnectSmartAccount(account) {\n  // look up the personalAccount for the smart wallet\n  const personalAccount = smartAccountToAdminAccountMap.get(account);\n  if (personalAccount) {\n    // remove the mappings\n    adminAccountToSmartAccountMap.delete(personalAccount);\n    smartAccountToAdminAccountMap.delete(account);\n  }\n}\nasync function createSmartAccount(options) {\n  var _options$overrides8;\n  const erc20Paymaster = (_options$overrides8 = options.overrides) === null || _options$overrides8 === void 0 ? void 0 : _options$overrides8.tokenPaymaster;\n  if (erc20Paymaster) {\n    var _options$overrides9;\n    if (getEntryPointVersion(((_options$overrides9 = options.overrides) === null || _options$overrides9 === void 0 ? void 0 : _options$overrides9.entrypointAddress) || ENTRYPOINT_ADDRESS_v0_6) !== \"v0.7\") {\n      throw new Error(\"Token paymaster is only supported for entrypoint version v0.7\");\n    }\n  }\n  const sponsorGas = options.sponsorGas;\n  let accountContract = options.accountContract;\n  const account = {\n    address: getAddress(accountContract.address),\n    async onTransactionRequested(transaction) {\n      var _options$personalAcco, _options$personalAcco2;\n      return (_options$personalAcco = (_options$personalAcco2 = options.personalAccount).onTransactionRequested) === null || _options$personalAcco === void 0 ? void 0 : _options$personalAcco.call(_options$personalAcco2, transaction);\n    },\n    async sendBatchTransaction(transactions) {\n      var _options$overrides0, _transactions$0$to, _transactions$;\n      const executeTx = prepareBatchExecute({\n        accountContract,\n        executeBatchOverride: (_options$overrides0 = options.overrides) === null || _options$overrides0 === void 0 ? void 0 : _options$overrides0.executeBatch,\n        transactions\n      });\n      if (transactions.length === 0) {\n        throw new Error(\"No transactions to send\");\n      }\n      const firstTx = transactions[0];\n      if (!firstTx) {\n        throw new Error(\"No transactions to send\");\n      }\n      const chain = getCachedChain(firstTx.chainId);\n      const result = await _sendUserOp({\n        executeTx,\n        options: _objectSpread(_objectSpread({}, options), {}, {\n          accountContract,\n          chain\n        })\n      });\n      trackTransaction({\n        chainId: chain.id,\n        client: options.client,\n        contractAddress: (_transactions$0$to = (_transactions$ = transactions[0]) === null || _transactions$ === void 0 ? void 0 : _transactions$.to) !== null && _transactions$0$to !== void 0 ? _transactions$0$to : undefined,\n        transactionHash: result.transactionHash,\n        walletAddress: options.accountContract.address,\n        walletType: \"smart\"\n      });\n      return result;\n    },\n    async sendTransaction(transaction) {\n      var _options$overrides11, _transaction$to;\n      // if erc20 paymaster - check allowance and approve if needed\n      let paymasterOverride;\n      if (erc20Paymaster) {\n        var _options$overrides1;\n        await approveERC20({\n          accountContract,\n          erc20Paymaster,\n          options\n        });\n        const paymasterCallback = async () => {\n          return {\n            paymaster: erc20Paymaster.paymasterAddress,\n            paymasterData: \"0x\"\n          };\n        };\n        paymasterOverride = ((_options$overrides1 = options.overrides) === null || _options$overrides1 === void 0 ? void 0 : _options$overrides1.paymaster) || paymasterCallback;\n      } else {\n        var _options$overrides10;\n        paymasterOverride = (_options$overrides10 = options.overrides) === null || _options$overrides10 === void 0 ? void 0 : _options$overrides10.paymaster;\n      }\n      // If this transaction is for a different chain than the initial one, get the account contract for that chain\n      if (transaction.chainId !== accountContract.chain.id) {\n        accountContract = getContract({\n          address: account.address,\n          chain: getCachedChain(transaction.chainId),\n          client: options.client\n        });\n      }\n      const executeTx = prepareExecute({\n        accountContract: accountContract,\n        executeOverride: (_options$overrides11 = options.overrides) === null || _options$overrides11 === void 0 ? void 0 : _options$overrides11.execute,\n        transaction\n      });\n      const chain = getCachedChain(transaction.chainId);\n      const result = await _sendUserOp({\n        executeTx,\n        options: _objectSpread(_objectSpread({}, options), {}, {\n          accountContract,\n          chain,\n          overrides: _objectSpread(_objectSpread({}, options.overrides), {}, {\n            paymaster: paymasterOverride\n          })\n        })\n      });\n      trackTransaction({\n        chainId: chain.id,\n        client: options.client,\n        contractAddress: (_transaction$to = transaction.to) !== null && _transaction$to !== void 0 ? _transaction$to : undefined,\n        transactionHash: result.transactionHash,\n        walletAddress: options.accountContract.address,\n        walletType: \"smart\"\n      });\n      return result;\n    },\n    async signMessage(_ref) {\n      var _options$overrides12;\n      let {\n        message\n      } = _ref;\n      if ((_options$overrides12 = options.overrides) !== null && _options$overrides12 !== void 0 && _options$overrides12.signMessage) {\n        return options.overrides.signMessage({\n          accountContract,\n          adminAccount: options.personalAccount,\n          factoryContract: options.factoryContract,\n          message\n        });\n      }\n      const {\n        smartAccountSignMessage\n      } = await import(\"./lib/signing.js\");\n      return smartAccountSignMessage({\n        accountContract,\n        factoryContract: options.factoryContract,\n        message,\n        options\n      });\n    },\n    async signTypedData(typedData) {\n      var _options$overrides13;\n      if ((_options$overrides13 = options.overrides) !== null && _options$overrides13 !== void 0 && _options$overrides13.signTypedData) {\n        return options.overrides.signTypedData({\n          accountContract,\n          adminAccount: options.personalAccount,\n          factoryContract: options.factoryContract,\n          typedData\n        });\n      }\n      const {\n        smartAccountSignTypedData\n      } = await import(\"./lib/signing.js\");\n      return smartAccountSignTypedData({\n        accountContract,\n        factoryContract: options.factoryContract,\n        options,\n        typedData\n      });\n    },\n    sendCalls: async options => {\n      const {\n        inAppWalletSendCalls\n      } = await import(\"../in-app/core/eip5792/in-app-wallet-calls.js\");\n      const firstCall = options.calls[0];\n      if (!firstCall) {\n        throw new Error(\"No calls to send\");\n      }\n      const client = firstCall.client;\n      const chain = firstCall.chain || options.chain;\n      const id = await inAppWalletSendCalls({\n        account: account,\n        calls: options.calls,\n        chain\n      });\n      return {\n        chain,\n        client,\n        id\n      };\n    },\n    getCallsStatus: async options => {\n      const {\n        inAppWalletGetCallsStatus\n      } = await import(\"../in-app/core/eip5792/in-app-wallet-calls.js\");\n      return inAppWalletGetCallsStatus(options);\n    },\n    getCapabilities: async options => {\n      var _options$chainId;\n      return {\n        [(_options$chainId = options.chainId) !== null && _options$chainId !== void 0 ? _options$chainId : 1]: {\n          atomic: {\n            status: \"supported\"\n          },\n          paymasterService: {\n            supported: sponsorGas !== null && sponsorGas !== void 0 ? sponsorGas : false\n          }\n        }\n      };\n    }\n  };\n  return account;\n}\nasync function approveERC20(args) {\n  var _options$overrides14;\n  const {\n    accountContract,\n    erc20Paymaster,\n    options\n  } = args;\n  const tokenAddress = erc20Paymaster.tokenAddress;\n  const tokenContract = getContract({\n    address: tokenAddress,\n    chain: accountContract.chain,\n    client: accountContract.client\n  });\n  const accountAllowance = await allowance({\n    contract: tokenContract,\n    owner: accountContract.address,\n    spender: erc20Paymaster.paymasterAddress\n  });\n  if (accountAllowance > 0n) {\n    return;\n  }\n  const approveTx = approve({\n    amountWei: maxUint96 - 1n,\n    contract: tokenContract,\n    spender: erc20Paymaster.paymasterAddress\n  });\n  const transaction = await toSerializableTransaction({\n    from: accountContract.address,\n    transaction: approveTx\n  });\n  const executeTx = prepareExecute({\n    accountContract,\n    executeOverride: (_options$overrides14 = options.overrides) === null || _options$overrides14 === void 0 ? void 0 : _options$overrides14.execute,\n    transaction\n  });\n  await _sendUserOp({\n    executeTx,\n    options: _objectSpread(_objectSpread({}, options), {}, {\n      overrides: _objectSpread(_objectSpread({}, options.overrides), {}, {\n        tokenPaymaster: undefined\n      })\n    })\n  });\n}\nfunction createZkSyncAccount(args) {\n  const {\n    creationOptions,\n    connectionOptions,\n    chain\n  } = args;\n  const account = {\n    address: getAddress(connectionOptions.personalAccount.address),\n    async onTransactionRequested(transaction) {\n      var _connectionOptions$pe, _connectionOptions$pe2;\n      return (_connectionOptions$pe = (_connectionOptions$pe2 = connectionOptions.personalAccount).onTransactionRequested) === null || _connectionOptions$pe === void 0 ? void 0 : _connectionOptions$pe.call(_connectionOptions$pe2, transaction);\n    },\n    async sendTransaction(transaction) {\n      var _transaction$to2, _transaction$value, _creationOptions$over3, _creationOptions$over4, _transaction$to3;\n      // override passed tx, we have to refetch gas and fees always\n      const prepTx = {\n        chain: getCachedChain(transaction.chainId),\n        client: connectionOptions.client,\n        data: transaction.data,\n        eip712: transaction.eip712,\n        to: (_transaction$to2 = transaction.to) !== null && _transaction$to2 !== void 0 ? _transaction$to2 : undefined,\n        value: (_transaction$value = transaction.value) !== null && _transaction$value !== void 0 ? _transaction$value : 0n\n      };\n      let serializableTransaction = await populateEip712Transaction({\n        account,\n        transaction: prepTx\n      });\n      if (args.sponsorGas && !serializableTransaction.paymaster) {\n        var _creationOptions$over, _creationOptions$over2;\n        // get paymaster input\n        const pmData = await getZkPaymasterData({\n          options: {\n            bundlerUrl: (_creationOptions$over = creationOptions.overrides) === null || _creationOptions$over === void 0 ? void 0 : _creationOptions$over.bundlerUrl,\n            chain,\n            client: connectionOptions.client,\n            entrypointAddress: (_creationOptions$over2 = creationOptions.overrides) === null || _creationOptions$over2 === void 0 ? void 0 : _creationOptions$over2.entrypointAddress\n          },\n          transaction: serializableTransaction\n        });\n        serializableTransaction = _objectSpread(_objectSpread({}, serializableTransaction), pmData);\n      }\n      // sign\n      const signedTransaction = await signEip712Transaction({\n        account,\n        chainId: chain.id,\n        eip712Transaction: serializableTransaction\n      });\n      // broadcast via bundler\n      const txHash = await broadcastZkTransaction({\n        options: {\n          bundlerUrl: (_creationOptions$over3 = creationOptions.overrides) === null || _creationOptions$over3 === void 0 ? void 0 : _creationOptions$over3.bundlerUrl,\n          chain,\n          client: connectionOptions.client,\n          entrypointAddress: (_creationOptions$over4 = creationOptions.overrides) === null || _creationOptions$over4 === void 0 ? void 0 : _creationOptions$over4.entrypointAddress\n        },\n        signedTransaction,\n        transaction: serializableTransaction\n      });\n      trackTransaction({\n        chainId: chain.id,\n        client: connectionOptions.client,\n        contractAddress: (_transaction$to3 = transaction.to) !== null && _transaction$to3 !== void 0 ? _transaction$to3 : undefined,\n        transactionHash: txHash.transactionHash,\n        walletAddress: account.address,\n        walletType: \"smart\"\n      });\n      return {\n        chain: chain,\n        client: connectionOptions.client,\n        transactionHash: txHash.transactionHash\n      };\n    },\n    async signMessage(_ref2) {\n      let {\n        message\n      } = _ref2;\n      return connectionOptions.personalAccount.signMessage({\n        message\n      });\n    },\n    async signTypedData(_typedData) {\n      const typedData = parseTypedData(_typedData);\n      return connectionOptions.personalAccount.signTypedData(typedData);\n    },\n    sendCalls: async options => {\n      const {\n        inAppWalletSendCalls\n      } = await import(\"../in-app/core/eip5792/in-app-wallet-calls.js\");\n      const firstCall = options.calls[0];\n      if (!firstCall) {\n        throw new Error(\"No calls to send\");\n      }\n      const client = firstCall.client;\n      const chain = firstCall.chain || options.chain;\n      const id = await inAppWalletSendCalls({\n        account: account,\n        calls: options.calls,\n        chain\n      });\n      return {\n        chain,\n        client,\n        id\n      };\n    },\n    getCallsStatus: async options => {\n      const {\n        inAppWalletGetCallsStatus\n      } = await import(\"../in-app/core/eip5792/in-app-wallet-calls.js\");\n      return inAppWalletGetCallsStatus(options);\n    },\n    getCapabilities: async options => {\n      var _options$chainId2, _args$sponsorGas;\n      return {\n        [(_options$chainId2 = options.chainId) !== null && _options$chainId2 !== void 0 ? _options$chainId2 : 1]: {\n          atomic: {\n            status: \"unsupported\"\n          },\n          paymasterService: {\n            supported: (_args$sponsorGas = args.sponsorGas) !== null && _args$sponsorGas !== void 0 ? _args$sponsorGas : false\n          }\n        }\n      };\n    }\n  };\n  return account;\n}\nasync function _sendUserOp(args) {\n  const {\n    executeTx,\n    options\n  } = args;\n  try {\n    var _options$overrides15, _options$overrides16, _options$overrides17, _executeTx$to;\n    const unsignedUserOp = await createUnsignedUserOp({\n      accountContract: options.accountContract,\n      adminAddress: options.personalAccount.address,\n      factoryContract: options.factoryContract,\n      overrides: options.overrides,\n      sponsorGas: options.sponsorGas,\n      transaction: executeTx\n    });\n    const signedUserOp = await signUserOp({\n      adminAccount: options.personalAccount,\n      chain: options.chain,\n      client: options.client,\n      entrypointAddress: (_options$overrides15 = options.overrides) === null || _options$overrides15 === void 0 ? void 0 : _options$overrides15.entrypointAddress,\n      userOp: unsignedUserOp\n    });\n    const bundlerOptions = {\n      bundlerUrl: (_options$overrides16 = options.overrides) === null || _options$overrides16 === void 0 ? void 0 : _options$overrides16.bundlerUrl,\n      chain: options.chain,\n      client: options.client,\n      entrypointAddress: (_options$overrides17 = options.overrides) === null || _options$overrides17 === void 0 ? void 0 : _options$overrides17.entrypointAddress\n    };\n    const userOpHash = await bundleUserOp({\n      options: bundlerOptions,\n      userOp: signedUserOp\n    });\n    // wait for tx receipt rather than return the userOp hash\n    const receipt = await waitForUserOpReceipt(_objectSpread(_objectSpread({}, bundlerOptions), {}, {\n      userOpHash\n    }));\n    trackTransaction({\n      chainId: options.chain.id,\n      client: options.client,\n      contractAddress: await resolvePromisedValue((_executeTx$to = executeTx.to) !== null && _executeTx$to !== void 0 ? _executeTx$to : undefined),\n      transactionHash: receipt.transactionHash,\n      walletAddress: options.accountContract.address,\n      walletType: \"smart\"\n    });\n    return {\n      chain: options.chain,\n      client: options.client,\n      transactionHash: receipt.transactionHash\n    };\n  } catch (error) {\n    // Track insufficient funds errors\n    if (isInsufficientFundsError(error)) {\n      var _executeTx$to2;\n      trackInsufficientFundsError({\n        chainId: options.chain.id,\n        client: options.client,\n        contractAddress: await resolvePromisedValue((_executeTx$to2 = executeTx.to) !== null && _executeTx$to2 !== void 0 ? _executeTx$to2 : undefined),\n        error,\n        transactionValue: await resolvePromisedValue(executeTx.value),\n        walletAddress: options.accountContract.address\n      });\n    }\n    throw error;\n  } finally {\n    // reset the isDeploying flag after every transaction or error\n    clearAccountDeploying(options.accountContract);\n  }\n}\nexport async function getEntrypointFromFactory(factoryAddress, client, chain) {\n  const factoryContract = getContract({\n    address: factoryAddress,\n    chain,\n    client\n  });\n  try {\n    const entrypointAddress = await readContract({\n      contract: factoryContract,\n      method: \"function entrypoint() public view returns (address)\"\n    });\n    return entrypointAddress;\n  } catch (_unused) {\n    return undefined;\n  }\n}","map":{"version":3,"names":["isInsufficientFundsError","trackInsufficientFundsError","trackTransaction","getCachedChain","getContract","allowance","approve","addSessionKey","shouldUpdateSessionKey","sendTransaction","toSerializableTransaction","populateEip712Transaction","signEip712Transaction","readContract","getAddress","isZkSyncChain","resolvePromisedValue","parseTypedData","maxUint96","broadcastZkTransaction","bundleUserOp","getZkPaymasterData","predictAddress","prepareBatchExecute","prepareExecute","ENTRYPOINT_ADDRESS_v0_6","ENTRYPOINT_ADDRESS_v0_7","getDefaultAccountFactory","getEntryPointVersion","clearAccountDeploying","createUnsignedUserOp","signUserOp","waitForUserOpReceipt","isSmartWallet","adminAccountToSmartAccountMap","WeakMap","smartAccountToAdminAccountMap","connectSmartAccount","connectionOptions","creationOptions","_options$overrides","_options$overrides2","_options$overrides3","_options$factoryAddre","_options$overrides4","_options$overrides5","_options$overrides6","_options$overrides7","personalAccount","client","Error","options","chain","sponsorGas","gasless","createZkSyncAccount","factoryAddress","overrides","entrypointAddress","getEntrypointFromFactory","_objectSpread","tokenPaymaster","factoryContract","address","accountAddress","accountSalt","adminAddress","predictAddressOverride","then","catch","err","concat","id","message","cause","accountContract","account","createSmartAccount","set","sessionKey","newPermissions","permissions","sessionKeyAddress","transaction","contract","disconnectSmartAccount","get","delete","_options$overrides8","erc20Paymaster","_options$overrides9","onTransactionRequested","_options$personalAcco","_options$personalAcco2","call","sendBatchTransaction","transactions","_options$overrides0","_transactions$0$to","_transactions$","executeTx","executeBatchOverride","executeBatch","length","firstTx","chainId","result","_sendUserOp","contractAddress","to","undefined","transactionHash","walletAddress","walletType","_options$overrides11","_transaction$to","paymasterOverride","_options$overrides1","approveERC20","paymasterCallback","paymaster","paymasterAddress","paymasterData","_options$overrides10","executeOverride","execute","signMessage","_ref","_options$overrides12","adminAccount","smartAccountSignMessage","signTypedData","typedData","_options$overrides13","smartAccountSignTypedData","sendCalls","inAppWalletSendCalls","firstCall","calls","getCallsStatus","inAppWalletGetCallsStatus","getCapabilities","_options$chainId","atomic","status","paymasterService","supported","args","_options$overrides14","tokenAddress","tokenContract","accountAllowance","owner","spender","approveTx","amountWei","from","_connectionOptions$pe","_connectionOptions$pe2","_transaction$to2","_transaction$value","_creationOptions$over3","_creationOptions$over4","_transaction$to3","prepTx","data","eip712","value","serializableTransaction","_creationOptions$over","_creationOptions$over2","pmData","bundlerUrl","signedTransaction","eip712Transaction","txHash","_ref2","_typedData","_options$chainId2","_args$sponsorGas","_options$overrides15","_options$overrides16","_options$overrides17","_executeTx$to","unsignedUserOp","signedUserOp","userOp","bundlerOptions","userOpHash","receipt","error","_executeTx$to2","transactionValue","method","_unused"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/wallets/smart/index.ts"],"sourcesContent":["import type * as ox__TypedData from \"ox/TypedData\";\nimport { isInsufficientFundsError } from \"../../analytics/track/helpers.js\";\nimport {\n  trackInsufficientFundsError,\n  trackTransaction,\n} from \"../../analytics/track/transaction.js\";\nimport type { Chain } from \"../../chains/types.js\";\nimport { getCachedChain } from \"../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { getContract, type ThirdwebContract } from \"../../contract/contract.js\";\nimport { allowance } from \"../../extensions/erc20/__generated__/IERC20/read/allowance.js\";\nimport { approve } from \"../../extensions/erc20/write/approve.js\";\nimport {\n  addSessionKey,\n  shouldUpdateSessionKey,\n} from \"../../extensions/erc4337/account/addSessionKey.js\";\nimport { sendTransaction } from \"../../transaction/actions/send-transaction.js\";\nimport { toSerializableTransaction } from \"../../transaction/actions/to-serializable-transaction.js\";\nimport type { WaitForReceiptOptions } from \"../../transaction/actions/wait-for-tx-receipt.js\";\nimport {\n  populateEip712Transaction,\n  signEip712Transaction,\n} from \"../../transaction/actions/zksync/send-eip712-transaction.js\";\nimport type { PreparedTransaction } from \"../../transaction/prepare-transaction.js\";\nimport { readContract } from \"../../transaction/read-contract.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { isZkSyncChain } from \"../../utils/any-evm/zksync/isZkSyncChain.js\";\nimport type { Hex } from \"../../utils/encoding/hex.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parse-typed-data.js\";\nimport { maxUint96, type SignableMessage } from \"../../utils/types.js\";\nimport type { Account, SendTransactionOption } from \"../interfaces/wallet.js\";\nimport {\n  broadcastZkTransaction,\n  bundleUserOp,\n  getZkPaymasterData,\n} from \"./lib/bundler.js\";\nimport {\n  predictAddress,\n  prepareBatchExecute,\n  prepareExecute,\n} from \"./lib/calls.js\";\nimport {\n  ENTRYPOINT_ADDRESS_v0_6,\n  ENTRYPOINT_ADDRESS_v0_7,\n  getDefaultAccountFactory,\n  getEntryPointVersion,\n} from \"./lib/constants.js\";\nimport {\n  clearAccountDeploying,\n  createUnsignedUserOp,\n  signUserOp,\n  waitForUserOpReceipt,\n} from \"./lib/userop.js\";\nimport type {\n  BundlerOptions,\n  PaymasterResult,\n  SmartAccountOptions,\n  SmartWalletConnectionOptions,\n  SmartWalletOptions,\n  TokenPaymasterConfig,\n  UserOperationV06,\n  UserOperationV07,\n} from \"./types.js\";\n\nexport { isSmartWallet } from \"./is-smart-wallet.js\";\n\n/**\n * For in-app wallets, the smart wallet creation is implicit so we track these to be able to retrieve the personal account for a smart account on the wallet API.\n * Note: We have to go account to account here and NOT wallet to account because the smart wallet itself is never exposed to the in-app wallet, only the account.\n * @internal\n */\nconst adminAccountToSmartAccountMap = new WeakMap<Account, Account>();\nconst smartAccountToAdminAccountMap = new WeakMap<Account, Account>();\n\n/**\n * @internal\n */\nexport async function connectSmartAccount(\n  connectionOptions: SmartWalletConnectionOptions,\n  creationOptions: SmartWalletOptions,\n): Promise<[Account, Chain]> {\n  const { personalAccount, client } = connectionOptions;\n\n  if (!personalAccount) {\n    throw new Error(\n      \"No personal account provided for smart account connection\",\n    );\n  }\n\n  const options = creationOptions;\n  const chain = creationOptions.chain;\n  const sponsorGas =\n    \"gasless\" in options ? options.gasless : options.sponsorGas;\n  if (await isZkSyncChain(chain)) {\n    return [\n      createZkSyncAccount({\n        chain,\n        connectionOptions,\n        creationOptions,\n        sponsorGas,\n      }),\n      chain,\n    ];\n  }\n\n  // if factory is passed, but no entrypoint, try to resolve entrypoint from factory\n  if (options.factoryAddress && !options.overrides?.entrypointAddress) {\n    const entrypointAddress = await getEntrypointFromFactory(\n      options.factoryAddress,\n      client,\n      chain,\n    );\n    if (entrypointAddress) {\n      options.overrides = {\n        ...options.overrides,\n        entrypointAddress,\n      };\n    }\n  }\n\n  if (\n    options.overrides?.tokenPaymaster &&\n    !options.overrides?.entrypointAddress\n  ) {\n    // if token paymaster is set, but no entrypoint address, set the entrypoint address to v0.7\n    options.overrides = {\n      ...options.overrides,\n      entrypointAddress: ENTRYPOINT_ADDRESS_v0_7,\n    };\n  }\n\n  const factoryAddress =\n    options.factoryAddress ??\n    getDefaultAccountFactory(options.overrides?.entrypointAddress);\n\n  const factoryContract = getContract({\n    address: factoryAddress,\n    chain: chain,\n    client: client,\n  });\n\n  const accountAddress = await predictAddress({\n    accountAddress: options.overrides?.accountAddress,\n    accountSalt: options.overrides?.accountSalt,\n    adminAddress: personalAccount.address,\n    factoryContract,\n    predictAddressOverride: options.overrides?.predictAddress,\n  })\n    .then((address) => address)\n    .catch((err) => {\n      throw new Error(\n        `Failed to get account address with factory contract ${factoryContract.address} on chain ID ${chain.id}: ${err?.message || \"unknown error\"}`,\n        { cause: err },\n      );\n    });\n\n  const accountContract = getContract({\n    address: accountAddress,\n    chain,\n    client,\n  });\n\n  const account = await createSmartAccount({\n    ...options,\n    accountContract,\n    chain,\n    client,\n    factoryContract,\n    personalAccount,\n    sponsorGas,\n  });\n\n  adminAccountToSmartAccountMap.set(personalAccount, account);\n  smartAccountToAdminAccountMap.set(account, personalAccount);\n\n  if (options.sessionKey) {\n    if (\n      await shouldUpdateSessionKey({\n        accountContract,\n        newPermissions: options.sessionKey.permissions,\n        sessionKeyAddress: options.sessionKey.address,\n      })\n    ) {\n      const transaction = addSessionKey({\n        account: personalAccount,\n        contract: accountContract,\n        permissions: options.sessionKey.permissions,\n        sessionKeyAddress: options.sessionKey.address,\n      });\n      await sendTransaction({\n        account: account,\n        transaction,\n      });\n    }\n  }\n\n  return [account, chain] as const;\n}\n\n/**\n * @internal\n */\nexport async function disconnectSmartAccount(account: Account): Promise<void> {\n  // look up the personalAccount for the smart wallet\n  const personalAccount = smartAccountToAdminAccountMap.get(account);\n  if (personalAccount) {\n    // remove the mappings\n    adminAccountToSmartAccountMap.delete(personalAccount);\n    smartAccountToAdminAccountMap.delete(account);\n  }\n}\n\nasync function createSmartAccount(\n  options: SmartAccountOptions,\n): Promise<Account> {\n  const erc20Paymaster = options.overrides?.tokenPaymaster;\n  if (erc20Paymaster) {\n    if (\n      getEntryPointVersion(\n        options.overrides?.entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n      ) !== \"v0.7\"\n    ) {\n      throw new Error(\n        \"Token paymaster is only supported for entrypoint version v0.7\",\n      );\n    }\n  }\n  const sponsorGas = options.sponsorGas;\n  let accountContract = options.accountContract;\n  const account: Account = {\n    address: getAddress(accountContract.address),\n    async onTransactionRequested(transaction) {\n      return options.personalAccount.onTransactionRequested?.(transaction);\n    },\n    async sendBatchTransaction(transactions: SendTransactionOption[]) {\n      const executeTx = prepareBatchExecute({\n        accountContract,\n        executeBatchOverride: options.overrides?.executeBatch,\n        transactions,\n      });\n      if (transactions.length === 0) {\n        throw new Error(\"No transactions to send\");\n      }\n      const firstTx = transactions[0];\n      if (!firstTx) {\n        throw new Error(\"No transactions to send\");\n      }\n      const chain = getCachedChain(firstTx.chainId);\n      const result = await _sendUserOp({\n        executeTx,\n        options: {\n          ...options,\n          accountContract,\n          chain,\n        },\n      });\n      trackTransaction({\n        chainId: chain.id,\n        client: options.client,\n        contractAddress: transactions[0]?.to ?? undefined,\n        transactionHash: result.transactionHash,\n        walletAddress: options.accountContract.address,\n        walletType: \"smart\",\n      });\n      return result;\n    },\n    async sendTransaction(transaction: SendTransactionOption) {\n      // if erc20 paymaster - check allowance and approve if needed\n      let paymasterOverride:\n        | undefined\n        | ((\n            userOp: UserOperationV06 | UserOperationV07,\n          ) => Promise<PaymasterResult>);\n      if (erc20Paymaster) {\n        await approveERC20({\n          accountContract,\n          erc20Paymaster,\n          options,\n        });\n        const paymasterCallback = async (): Promise<PaymasterResult> => {\n          return {\n            paymaster: erc20Paymaster.paymasterAddress as Hex,\n            paymasterData: \"0x\",\n          };\n        };\n        paymasterOverride = options.overrides?.paymaster || paymasterCallback;\n      } else {\n        paymasterOverride = options.overrides?.paymaster;\n      }\n\n      // If this transaction is for a different chain than the initial one, get the account contract for that chain\n      if (transaction.chainId !== accountContract.chain.id) {\n        accountContract = getContract({\n          address: account.address,\n          chain: getCachedChain(transaction.chainId),\n          client: options.client,\n        });\n      }\n\n      const executeTx = prepareExecute({\n        accountContract: accountContract,\n        executeOverride: options.overrides?.execute,\n        transaction,\n      });\n\n      const chain = getCachedChain(transaction.chainId);\n      const result = await _sendUserOp({\n        executeTx,\n        options: {\n          ...options,\n          accountContract,\n          chain,\n          overrides: {\n            ...options.overrides,\n            paymaster: paymasterOverride,\n          },\n        },\n      });\n      trackTransaction({\n        chainId: chain.id,\n        client: options.client,\n        contractAddress: transaction.to ?? undefined,\n        transactionHash: result.transactionHash,\n        walletAddress: options.accountContract.address,\n        walletType: \"smart\",\n      });\n      return result;\n    },\n    async signMessage({ message }: { message: SignableMessage }) {\n      if (options.overrides?.signMessage) {\n        return options.overrides.signMessage({\n          accountContract,\n          adminAccount: options.personalAccount,\n          factoryContract: options.factoryContract,\n          message,\n        });\n      }\n\n      const { smartAccountSignMessage } = await import(\"./lib/signing.js\");\n      return smartAccountSignMessage({\n        accountContract,\n        factoryContract: options.factoryContract,\n        message,\n        options,\n      });\n    },\n    async signTypedData<\n      const typedData extends ox__TypedData.TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(typedData: ox__TypedData.Definition<typedData, primaryType>) {\n      if (options.overrides?.signTypedData) {\n        return options.overrides.signTypedData({\n          accountContract,\n          adminAccount: options.personalAccount,\n          factoryContract: options.factoryContract,\n          typedData,\n        });\n      }\n\n      const { smartAccountSignTypedData } = await import(\"./lib/signing.js\");\n      return smartAccountSignTypedData({\n        accountContract,\n        factoryContract: options.factoryContract,\n        options,\n        typedData,\n      });\n    },\n    sendCalls: async (options) => {\n      const { inAppWalletSendCalls } = await import(\n        \"../in-app/core/eip5792/in-app-wallet-calls.js\"\n      );\n      const firstCall = options.calls[0];\n      if (!firstCall) {\n        throw new Error(\"No calls to send\");\n      }\n      const client = firstCall.client;\n      const chain = firstCall.chain || options.chain;\n      const id = await inAppWalletSendCalls({\n        account: account,\n        calls: options.calls,\n        chain,\n      });\n      return { chain, client, id };\n    },\n    getCallsStatus: async (options) => {\n      const { inAppWalletGetCallsStatus } = await import(\n        \"../in-app/core/eip5792/in-app-wallet-calls.js\"\n      );\n      return inAppWalletGetCallsStatus(options);\n    },\n    getCapabilities: async (options) => {\n      return {\n        [options.chainId ?? 1]: {\n          atomic: {\n            status: \"supported\",\n          },\n          paymasterService: {\n            supported: sponsorGas ?? false,\n          },\n        },\n      };\n    },\n  };\n  return account;\n}\n\nasync function approveERC20(args: {\n  accountContract: ThirdwebContract;\n  options: SmartAccountOptions;\n  erc20Paymaster: TokenPaymasterConfig;\n}) {\n  const { accountContract, erc20Paymaster, options } = args;\n  const tokenAddress = erc20Paymaster.tokenAddress;\n  const tokenContract = getContract({\n    address: tokenAddress,\n    chain: accountContract.chain,\n    client: accountContract.client,\n  });\n  const accountAllowance = await allowance({\n    contract: tokenContract,\n    owner: accountContract.address,\n    spender: erc20Paymaster.paymasterAddress,\n  });\n\n  if (accountAllowance > 0n) {\n    return;\n  }\n\n  const approveTx = approve({\n    amountWei: maxUint96 - 1n,\n    contract: tokenContract,\n    spender: erc20Paymaster.paymasterAddress,\n  });\n  const transaction = await toSerializableTransaction({\n    from: accountContract.address,\n    transaction: approveTx,\n  });\n  const executeTx = prepareExecute({\n    accountContract,\n    executeOverride: options.overrides?.execute,\n    transaction,\n  });\n  await _sendUserOp({\n    executeTx,\n    options: {\n      ...options,\n      overrides: {\n        ...options.overrides,\n        tokenPaymaster: undefined,\n      },\n    },\n  });\n}\n\nfunction createZkSyncAccount(args: {\n  creationOptions: SmartWalletOptions;\n  connectionOptions: SmartWalletConnectionOptions;\n  chain: Chain;\n  sponsorGas: boolean;\n}): Account {\n  const { creationOptions, connectionOptions, chain } = args;\n  const account: Account = {\n    address: getAddress(connectionOptions.personalAccount.address),\n    async onTransactionRequested(transaction) {\n      return connectionOptions.personalAccount.onTransactionRequested?.(\n        transaction,\n      );\n    },\n    async sendTransaction(transaction: SendTransactionOption) {\n      // override passed tx, we have to refetch gas and fees always\n      const prepTx = {\n        chain: getCachedChain(transaction.chainId),\n        client: connectionOptions.client,\n        data: transaction.data,\n        eip712: transaction.eip712,\n        to: transaction.to ?? undefined,\n        value: transaction.value ?? 0n,\n      };\n\n      let serializableTransaction = await populateEip712Transaction({\n        account,\n        transaction: prepTx,\n      });\n\n      if (args.sponsorGas && !serializableTransaction.paymaster) {\n        // get paymaster input\n        const pmData = await getZkPaymasterData({\n          options: {\n            bundlerUrl: creationOptions.overrides?.bundlerUrl,\n            chain,\n            client: connectionOptions.client,\n            entrypointAddress: creationOptions.overrides?.entrypointAddress,\n          },\n          transaction: serializableTransaction,\n        });\n        serializableTransaction = {\n          ...serializableTransaction,\n          ...pmData,\n        };\n      }\n\n      // sign\n      const signedTransaction = await signEip712Transaction({\n        account,\n        chainId: chain.id,\n        eip712Transaction: serializableTransaction,\n      });\n\n      // broadcast via bundler\n      const txHash = await broadcastZkTransaction({\n        options: {\n          bundlerUrl: creationOptions.overrides?.bundlerUrl,\n          chain,\n          client: connectionOptions.client,\n          entrypointAddress: creationOptions.overrides?.entrypointAddress,\n        },\n        signedTransaction,\n        transaction: serializableTransaction,\n      });\n\n      trackTransaction({\n        chainId: chain.id,\n        client: connectionOptions.client,\n        contractAddress: transaction.to ?? undefined,\n        transactionHash: txHash.transactionHash,\n        walletAddress: account.address,\n        walletType: \"smart\",\n      });\n\n      return {\n        chain: chain,\n        client: connectionOptions.client,\n        transactionHash: txHash.transactionHash,\n      };\n    },\n    async signMessage({ message }: { message: SignableMessage }) {\n      return connectionOptions.personalAccount.signMessage({ message });\n    },\n    async signTypedData<\n      const typedData extends ox__TypedData.TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(_typedData: ox__TypedData.Definition<typedData, primaryType>) {\n      const typedData = parseTypedData(_typedData);\n      return connectionOptions.personalAccount.signTypedData(typedData);\n    },\n    sendCalls: async (options) => {\n      const { inAppWalletSendCalls } = await import(\n        \"../in-app/core/eip5792/in-app-wallet-calls.js\"\n      );\n      const firstCall = options.calls[0];\n      if (!firstCall) {\n        throw new Error(\"No calls to send\");\n      }\n      const client = firstCall.client;\n      const chain = firstCall.chain || options.chain;\n      const id = await inAppWalletSendCalls({\n        account: account,\n        calls: options.calls,\n        chain,\n      });\n      return { chain, client, id };\n    },\n    getCallsStatus: async (options) => {\n      const { inAppWalletGetCallsStatus } = await import(\n        \"../in-app/core/eip5792/in-app-wallet-calls.js\"\n      );\n      return inAppWalletGetCallsStatus(options);\n    },\n    getCapabilities: async (options) => {\n      return {\n        [options.chainId ?? 1]: {\n          atomic: {\n            status: \"unsupported\",\n          },\n          paymasterService: {\n            supported: args.sponsorGas ?? false,\n          },\n        },\n      };\n    },\n  };\n  return account;\n}\n\nasync function _sendUserOp(args: {\n  executeTx: PreparedTransaction;\n  options: SmartAccountOptions;\n}): Promise<WaitForReceiptOptions> {\n  const { executeTx, options } = args;\n  try {\n    const unsignedUserOp = await createUnsignedUserOp({\n      accountContract: options.accountContract,\n      adminAddress: options.personalAccount.address,\n      factoryContract: options.factoryContract,\n      overrides: options.overrides,\n      sponsorGas: options.sponsorGas,\n      transaction: executeTx,\n    });\n    const signedUserOp = await signUserOp({\n      adminAccount: options.personalAccount,\n      chain: options.chain,\n      client: options.client,\n      entrypointAddress: options.overrides?.entrypointAddress,\n      userOp: unsignedUserOp,\n    });\n    const bundlerOptions: BundlerOptions = {\n      bundlerUrl: options.overrides?.bundlerUrl,\n      chain: options.chain,\n      client: options.client,\n      entrypointAddress: options.overrides?.entrypointAddress,\n    };\n    const userOpHash = await bundleUserOp({\n      options: bundlerOptions,\n      userOp: signedUserOp,\n    });\n    // wait for tx receipt rather than return the userOp hash\n    const receipt = await waitForUserOpReceipt({\n      ...bundlerOptions,\n      userOpHash,\n    });\n\n    trackTransaction({\n      chainId: options.chain.id,\n      client: options.client,\n      contractAddress: await resolvePromisedValue(executeTx.to ?? undefined),\n      transactionHash: receipt.transactionHash,\n      walletAddress: options.accountContract.address,\n      walletType: \"smart\",\n    });\n\n    return {\n      chain: options.chain,\n      client: options.client,\n      transactionHash: receipt.transactionHash,\n    };\n  } catch (error) {\n    // Track insufficient funds errors\n    if (isInsufficientFundsError(error)) {\n      trackInsufficientFundsError({\n        chainId: options.chain.id,\n        client: options.client,\n        contractAddress: await resolvePromisedValue(executeTx.to ?? undefined),\n        error,\n        transactionValue: await resolvePromisedValue(executeTx.value),\n        walletAddress: options.accountContract.address,\n      });\n    }\n\n    throw error;\n  } finally {\n    // reset the isDeploying flag after every transaction or error\n    clearAccountDeploying(options.accountContract);\n  }\n}\n\nexport async function getEntrypointFromFactory(\n  factoryAddress: string,\n  client: ThirdwebClient,\n  chain: Chain,\n) {\n  const factoryContract = getContract({\n    address: factoryAddress,\n    chain,\n    client,\n  });\n  try {\n    const entrypointAddress = await readContract({\n      contract: factoryContract,\n      method: \"function entrypoint() public view returns (address)\",\n    });\n    return entrypointAddress;\n  } catch {\n    return undefined;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}