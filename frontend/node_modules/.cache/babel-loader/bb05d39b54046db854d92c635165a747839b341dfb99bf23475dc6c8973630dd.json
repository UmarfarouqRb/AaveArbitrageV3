{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { ApiError } from \"../../../bridge/types/Errors.js\";\nimport { getThirdwebBaseUrl } from \"../../../utils/domains.js\";\nimport { getClientFetch } from \"../../../utils/fetch.js\";\nimport { toTokens, toUnits } from \"../../../utils/units.js\";\nimport { useActiveWallet } from \"./wallets/useActiveWallet.js\";\n/**\n * Hook that returns available payment methods for BridgeEmbed\n * Fetches real routes data based on the destination token\n *\n * @param options - Configuration options\n * @param options.destinationToken - The destination token to find routes for\n * @param options.client - ThirdwebClient for API calls\n * @returns Available payment methods with route data\n *\n * @example\n * ```tsx\n * const { data: paymentMethods, isLoading, error } = usePaymentMethods({\n *   destinationToken,\n *   client\n * });\n * ```\n */\nexport function usePaymentMethods(options) {\n  var _payerWallet$getAccou;\n  const {\n    destinationToken,\n    destinationAmount,\n    client,\n    payerWallet,\n    supportedTokens\n  } = options;\n  const localWallet = useActiveWallet(); // TODO (bridge): get all connected wallets\n  const wallet = payerWallet || localWallet;\n  const query = useQuery({\n    enabled: !!wallet,\n    queryFn: async () => {\n      const account = wallet === null || wallet === void 0 ? void 0 : wallet.getAccount();\n      if (!wallet || !account) {\n        throw new Error(\"No wallet connected\");\n      }\n      const url = new URL(\"\".concat(getThirdwebBaseUrl(\"bridge\"), \"/v1/buy/quote/\").concat(account.address));\n      url.searchParams.set(\"destinationChainId\", destinationToken.chainId.toString());\n      url.searchParams.set(\"destinationTokenAddress\", destinationToken.address);\n      url.searchParams.set(\"amount\", toUnits(destinationAmount, destinationToken.decimals).toString());\n      const clientFetch = getClientFetch(client);\n      const response = await clientFetch(url.toString());\n      if (!response.ok) {\n        const errorJson = await response.json();\n        throw new ApiError({\n          code: errorJson.code || \"UNKNOWN_ERROR\",\n          correlationId: errorJson.correlationId || undefined,\n          message: errorJson.message || response.statusText,\n          statusCode: response.status\n        });\n      }\n      const {\n        data: allValidOriginTokens\n      } = await response.json();\n      // Sort by enough balance to pay THEN gross balance\n      const validTokenQuotes = allValidOriginTokens.map(s => ({\n        balance: BigInt(s.balance),\n        originToken: s.token,\n        payerWallet: wallet,\n        type: \"wallet\",\n        quote: s.quote\n      }));\n      const sufficientBalanceQuotes = validTokenQuotes.filter(s => !!s.originToken.prices.USD).sort((a, b) => {\n        return Number.parseFloat(toTokens(b.balance, b.originToken.decimals)) * (b.originToken.prices.USD || 1) - Number.parseFloat(toTokens(a.balance, a.originToken.decimals)) * (a.originToken.prices.USD || 1);\n      });\n      // Filter out quotes that are not included in the supportedTokens (if provided)\n      const tokensToInclude = supportedTokens ? Object.keys(supportedTokens).flatMap(c => {\n        var _supportedTokens$Numb, _supportedTokens$Numb2;\n        return (_supportedTokens$Numb = (_supportedTokens$Numb2 = supportedTokens[Number(c)]) === null || _supportedTokens$Numb2 === void 0 ? void 0 : _supportedTokens$Numb2.map(t => ({\n          chainId: Number(c),\n          address: t.address\n        }))) !== null && _supportedTokens$Numb !== void 0 ? _supportedTokens$Numb : [];\n      }) : [];\n      const finalQuotes = supportedTokens ? sufficientBalanceQuotes.filter(q => tokensToInclude.find(t => t.chainId === q.originToken.chainId && t.address.toLowerCase() === q.originToken.address.toLowerCase())) : sufficientBalanceQuotes;\n      return finalQuotes.map(x => _objectSpread(_objectSpread({}, x), {}, {\n        action: \"buy\"\n      }));\n    },\n    queryKey: [\"payment-methods\", destinationToken.chainId, destinationToken.address, destinationAmount, payerWallet === null || payerWallet === void 0 || (_payerWallet$getAccou = payerWallet.getAccount()) === null || _payerWallet$getAccou === void 0 ? void 0 : _payerWallet$getAccou.address, supportedTokens],\n    // 5 minutes\n    refetchOnWindowFocus: false,\n    staleTime: 5 * 60 * 1000\n  });\n  return {\n    data: query.data || [],\n    error: query.error,\n    isError: query.isError,\n    isLoading: query.isLoading,\n    isSuccess: query.isSuccess,\n    refetch: query.refetch\n  };\n}","map":{"version":3,"names":["useQuery","ApiError","getThirdwebBaseUrl","getClientFetch","toTokens","toUnits","useActiveWallet","usePaymentMethods","options","_payerWallet$getAccou","destinationToken","destinationAmount","client","payerWallet","supportedTokens","localWallet","wallet","query","enabled","queryFn","account","getAccount","Error","url","URL","concat","address","searchParams","set","chainId","toString","decimals","clientFetch","response","ok","errorJson","json","code","correlationId","undefined","message","statusText","statusCode","status","data","allValidOriginTokens","validTokenQuotes","map","s","balance","BigInt","originToken","token","type","quote","sufficientBalanceQuotes","filter","prices","USD","sort","a","b","Number","parseFloat","tokensToInclude","Object","keys","flatMap","c","_supportedTokens$Numb","_supportedTokens$Numb2","t","finalQuotes","q","find","toLowerCase","x","_objectSpread","action","queryKey","refetchOnWindowFocus","staleTime","error","isError","isLoading","isSuccess","refetch"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/react/core/hooks/usePaymentMethods.ts"],"sourcesContent":["import { useQuery } from \"@tanstack/react-query\";\nimport type { Quote } from \"../../../bridge/index.js\";\nimport { ApiError } from \"../../../bridge/types/Errors.js\";\nimport type { Token, TokenWithPrices } from \"../../../bridge/types/Token.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../../../utils/domains.js\";\nimport { getClientFetch } from \"../../../utils/fetch.js\";\nimport { toTokens, toUnits } from \"../../../utils/units.js\";\nimport type { Wallet } from \"../../../wallets/interfaces/wallet.js\";\nimport type { PaymentMethod } from \"../../web/ui/Bridge/types.js\";\nimport type { SupportedTokens } from \"../utils/defaultTokens.js\";\nimport { useActiveWallet } from \"./wallets/useActiveWallet.js\";\n\n/**\n * Hook that returns available payment methods for BridgeEmbed\n * Fetches real routes data based on the destination token\n *\n * @param options - Configuration options\n * @param options.destinationToken - The destination token to find routes for\n * @param options.client - ThirdwebClient for API calls\n * @returns Available payment methods with route data\n *\n * @example\n * ```tsx\n * const { data: paymentMethods, isLoading, error } = usePaymentMethods({\n *   destinationToken,\n *   client\n * });\n * ```\n */\nexport function usePaymentMethods(options: {\n  destinationToken: Token;\n  destinationAmount: string;\n  client: ThirdwebClient;\n  payerWallet?: Wallet;\n  supportedTokens?: SupportedTokens;\n}) {\n  const {\n    destinationToken,\n    destinationAmount,\n    client,\n    payerWallet,\n    supportedTokens,\n  } = options;\n  const localWallet = useActiveWallet(); // TODO (bridge): get all connected wallets\n  const wallet = payerWallet || localWallet;\n\n  const query = useQuery({\n    enabled: !!wallet,\n    queryFn: async (): Promise<PaymentMethod[]> => {\n      const account = wallet?.getAccount();\n      if (!wallet || !account) {\n        throw new Error(\"No wallet connected\");\n      }\n\n      const url = new URL(\n        `${getThirdwebBaseUrl(\"bridge\")}/v1/buy/quote/${account.address}`,\n      );\n      url.searchParams.set(\n        \"destinationChainId\",\n        destinationToken.chainId.toString(),\n      );\n      url.searchParams.set(\"destinationTokenAddress\", destinationToken.address);\n      url.searchParams.set(\n        \"amount\",\n        toUnits(destinationAmount, destinationToken.decimals).toString(),\n      );\n\n      const clientFetch = getClientFetch(client);\n      const response = await clientFetch(url.toString());\n      if (!response.ok) {\n        const errorJson = await response.json();\n        throw new ApiError({\n          code: errorJson.code || \"UNKNOWN_ERROR\",\n          correlationId: errorJson.correlationId || undefined,\n          message: errorJson.message || response.statusText,\n          statusCode: response.status,\n        });\n      }\n\n      const {\n        data: allValidOriginTokens,\n      }: { data: { quote: Quote; balance: string; token: TokenWithPrices }[] } =\n        await response.json();\n\n      // Sort by enough balance to pay THEN gross balance\n      const validTokenQuotes = allValidOriginTokens.map((s) => ({\n        balance: BigInt(s.balance),\n        originToken: s.token,\n        payerWallet: wallet,\n        type: \"wallet\" as const,\n        quote: s.quote,\n      }));\n\n      const sufficientBalanceQuotes = validTokenQuotes\n        .filter((s) => !!s.originToken.prices.USD)\n        .sort((a, b) => {\n          return (\n            Number.parseFloat(toTokens(b.balance, b.originToken.decimals)) *\n              (b.originToken.prices.USD || 1) -\n            Number.parseFloat(toTokens(a.balance, a.originToken.decimals)) *\n              (a.originToken.prices.USD || 1)\n          );\n        });\n\n      // Filter out quotes that are not included in the supportedTokens (if provided)\n      const tokensToInclude = supportedTokens\n        ? Object.keys(supportedTokens).flatMap(\n            (c: string) =>\n              supportedTokens[Number(c)]?.map((t) => ({\n                chainId: Number(c),\n                address: t.address,\n              })) ?? [],\n          )\n        : [];\n      const finalQuotes = supportedTokens\n        ? sufficientBalanceQuotes.filter((q) =>\n            tokensToInclude.find(\n              (t) =>\n                t.chainId === q.originToken.chainId &&\n                t.address.toLowerCase() === q.originToken.address.toLowerCase(),\n            ),\n          )\n        : sufficientBalanceQuotes;\n      return finalQuotes.map((x) => ({\n        ...x,\n        action: \"buy\",\n      }));\n    },\n    queryKey: [\n      \"payment-methods\",\n      destinationToken.chainId,\n      destinationToken.address,\n      destinationAmount,\n      payerWallet?.getAccount()?.address,\n      supportedTokens,\n    ], // 5 minutes\n    refetchOnWindowFocus: false,\n    staleTime: 5 * 60 * 1000,\n  });\n\n  return {\n    data: query.data || [],\n    error: query.error,\n    isError: query.isError,\n    isLoading: query.isLoading,\n    isSuccess: query.isSuccess,\n    refetch: query.refetch,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}