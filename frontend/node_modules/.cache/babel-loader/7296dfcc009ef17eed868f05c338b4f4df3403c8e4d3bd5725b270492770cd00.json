{"ast":null,"code":"import { maxUint256, padHex } from \"viem\";\nimport { isNativeTokenAddress, ZERO_ADDRESS } from \"../../../constants/addresses.js\";\nimport { getContractMetadata } from \"../../../extensions/common/read/getContractMetadata.js\";\nimport { isRecord } from \"../../type-guards.js\";\n/**\n * Get the claim parameters for a given drop\n * @param options - The options for getting the claim parameters\n * @returns The claim parameters\n * @example\n * ```ts\n * import { getClaimParams } from \"thirdweb/utils\";\n *\n * const claimParams = await getClaimParams({\n *  contract,\n *  to: \"0x...\",\n *  quantity: 1n,\n *  type: \"erc1155\",\n *  tokenId: 0n,\n * });\n * ```\n * @utils\n */\nexport async function getClaimParams(options) {\n  const cc = await (async () => {\n    if (options.type === \"erc1155\") {\n      // lazy-load the getActiveClaimCondition function\n      const {\n        getActiveClaimCondition\n      } = await import(\"../../../extensions/erc1155/drops/read/getActiveClaimCondition.js\");\n      return await getActiveClaimCondition({\n        contract: options.contract,\n        tokenId: options.tokenId\n      });\n    }\n    if (options.type === \"erc721\") {\n      // lazy-load the getActiveClaimCondition function\n      if (options.singlePhaseDrop) {\n        const {\n          claimCondition\n        } = await import(\"../../../extensions/erc721/__generated__/IDropSinglePhase/read/claimCondition.js\");\n        return await claimCondition({\n          contract: options.contract\n        });\n      }\n      const {\n        getActiveClaimCondition\n      } = await import(\"../../../extensions/erc721/drops/read/getActiveClaimCondition.js\");\n      return await getActiveClaimCondition({\n        contract: options.contract\n      });\n    }\n    // otherwise erc20 case!\n    // lazy-load the getActiveClaimCondition function\n    if (options.singlePhaseDrop) {\n      // same ABI as erc721\n      const {\n        claimCondition\n      } = await import(\"../../../extensions/erc721/__generated__/IDropSinglePhase/read/claimCondition.js\");\n      return await claimCondition({\n        contract: options.contract\n      });\n    }\n    const {\n      getActiveClaimCondition\n    } = await import(\"../../../extensions/erc20/drops/read/getActiveClaimCondition.js\");\n    return await getActiveClaimCondition({\n      contract: options.contract\n    });\n  })();\n  const tokenDecimals = options.type === \"erc20\" ? options.tokenDecimals : 0; // nfts have no decimals\n  // compute the allowListProof in an iife\n  const allowlistProof = await (async () => {\n    // early exit if no merkle root is set\n    if (!cc.merkleRoot || cc.merkleRoot === padHex(\"0x\", {\n      size: 32\n    })) {\n      return {\n        currency: ZERO_ADDRESS,\n        pricePerToken: maxUint256,\n        proof: [],\n        quantityLimitPerWallet: 0n\n      };\n    }\n    // lazy-load the fetchProofsForClaimer function if we need it\n    const {\n      fetchProofsForClaimer\n    } = await import(\"./fetch-proofs-for-claimers.js\");\n    // 1. fetch merkle data from contract URI\n    const metadata = await getContractMetadata({\n      contract: options.contract\n    });\n    const merkleData = isRecord(metadata.merkle) ? metadata.merkle : {};\n    const snapshotUri = merkleData[cc.merkleRoot];\n    if (!snapshotUri) {\n      return {\n        currency: ZERO_ADDRESS,\n        pricePerToken: maxUint256,\n        proof: [],\n        quantityLimitPerWallet: 0n\n      };\n    }\n    const allowListProof = await fetchProofsForClaimer({\n      claimer: options.from || options.to,\n      contract: options.contract,\n      // receiver and claimer can be different, always prioritize the claimer for allowlists\n      merkleTreeUri: snapshotUri,\n      tokenDecimals\n    });\n    // if no proof is found, we'll try the empty proof\n    if (!allowListProof) {\n      return {\n        currency: ZERO_ADDRESS,\n        pricePerToken: maxUint256,\n        proof: [],\n        quantityLimitPerWallet: 0n\n      };\n    }\n    // otherwise return the proof\n    return allowListProof;\n  })();\n  // currency and price need to match the allowlist proof if set\n  // if default values in the allowlist proof, fallback to the claim condition\n  const currency = allowlistProof.currency && allowlistProof.currency !== ZERO_ADDRESS ? allowlistProof.currency : cc.currency;\n  const pricePerToken = allowlistProof.pricePerToken !== undefined && allowlistProof.pricePerToken !== maxUint256 ? allowlistProof.pricePerToken : cc.pricePerToken;\n  const totalPrice = pricePerToken * options.quantity / BigInt(10 ** tokenDecimals);\n  const value = isNativeTokenAddress(currency) ? totalPrice : 0n;\n  const erc20Value = !isNativeTokenAddress(currency) && pricePerToken > 0n ? {\n    amountWei: totalPrice,\n    tokenAddress: currency\n  } : undefined;\n  return {\n    allowlistProof,\n    currency,\n    data: \"0x\",\n    overrides: {\n      erc20Value,\n      value\n    },\n    pricePerToken,\n    quantity: options.quantity,\n    receiver: options.to,\n    tokenId: options.type === \"erc1155\" ? options.tokenId : undefined\n  };\n}","map":{"version":3,"names":["maxUint256","padHex","isNativeTokenAddress","ZERO_ADDRESS","getContractMetadata","isRecord","getClaimParams","options","cc","type","getActiveClaimCondition","contract","tokenId","singlePhaseDrop","claimCondition","tokenDecimals","allowlistProof","merkleRoot","size","currency","pricePerToken","proof","quantityLimitPerWallet","fetchProofsForClaimer","metadata","merkleData","merkle","snapshotUri","allowListProof","claimer","from","to","merkleTreeUri","undefined","totalPrice","quantity","BigInt","value","erc20Value","amountWei","tokenAddress","data","overrides","receiver"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/utils/extensions/drops/get-claim-params.ts"],"sourcesContent":["import { maxUint256, padHex } from \"viem\";\nimport {\n  isNativeTokenAddress,\n  ZERO_ADDRESS,\n} from \"../../../constants/addresses.js\";\nimport type { ThirdwebContract } from \"../../../contract/contract.js\";\nimport { getContractMetadata } from \"../../../extensions/common/read/getContractMetadata.js\";\nimport type { Hex } from \"../../encoding/hex.js\";\nimport { isRecord } from \"../../type-guards.js\";\nimport type { ClaimCondition, OverrideProof } from \"./types.js\";\n\nexport type GetClaimParamsOptions = {\n  contract: ThirdwebContract;\n  to: string;\n  quantity: bigint;\n  from?: string;\n  singlePhaseDrop?: boolean;\n} & (\n  | {\n      type: \"erc721\";\n    }\n  | {\n      type: \"erc20\";\n      tokenDecimals: number;\n    }\n  | {\n      type: \"erc1155\";\n      tokenId: bigint;\n    }\n);\n\n/**\n * Get the claim parameters for a given drop\n * @param options - The options for getting the claim parameters\n * @returns The claim parameters\n * @example\n * ```ts\n * import { getClaimParams } from \"thirdweb/utils\";\n *\n * const claimParams = await getClaimParams({\n *  contract,\n *  to: \"0x...\",\n *  quantity: 1n,\n *  type: \"erc1155\",\n *  tokenId: 0n,\n * });\n * ```\n * @utils\n */\nexport async function getClaimParams(options: GetClaimParamsOptions) {\n  const cc: ClaimCondition = await (async () => {\n    if (options.type === \"erc1155\") {\n      // lazy-load the getActiveClaimCondition function\n      const { getActiveClaimCondition } = await import(\n        \"../../../extensions/erc1155/drops/read/getActiveClaimCondition.js\"\n      );\n      return await getActiveClaimCondition({\n        contract: options.contract,\n        tokenId: options.tokenId,\n      });\n    }\n    if (options.type === \"erc721\") {\n      // lazy-load the getActiveClaimCondition function\n      if (options.singlePhaseDrop) {\n        const { claimCondition } = await import(\n          \"../../../extensions/erc721/__generated__/IDropSinglePhase/read/claimCondition.js\"\n        );\n        return await claimCondition({\n          contract: options.contract,\n        });\n      }\n      const { getActiveClaimCondition } = await import(\n        \"../../../extensions/erc721/drops/read/getActiveClaimCondition.js\"\n      );\n      return await getActiveClaimCondition({\n        contract: options.contract,\n      });\n    }\n\n    // otherwise erc20 case!\n\n    // lazy-load the getActiveClaimCondition function\n    if (options.singlePhaseDrop) {\n      // same ABI as erc721\n      const { claimCondition } = await import(\n        \"../../../extensions/erc721/__generated__/IDropSinglePhase/read/claimCondition.js\"\n      );\n      return await claimCondition({\n        contract: options.contract,\n      });\n    }\n    const { getActiveClaimCondition } = await import(\n      \"../../../extensions/erc20/drops/read/getActiveClaimCondition.js\"\n    );\n    return await getActiveClaimCondition({\n      contract: options.contract,\n    });\n  })();\n\n  const tokenDecimals = options.type === \"erc20\" ? options.tokenDecimals : 0; // nfts have no decimals\n\n  // compute the allowListProof in an iife\n  const allowlistProof = await (async () => {\n    // early exit if no merkle root is set\n    if (!cc.merkleRoot || cc.merkleRoot === padHex(\"0x\", { size: 32 })) {\n      return {\n        currency: ZERO_ADDRESS,\n        pricePerToken: maxUint256,\n        proof: [],\n        quantityLimitPerWallet: 0n,\n      } satisfies OverrideProof;\n    }\n    // lazy-load the fetchProofsForClaimer function if we need it\n    const { fetchProofsForClaimer } = await import(\n      \"./fetch-proofs-for-claimers.js\"\n    );\n\n    // 1. fetch merkle data from contract URI\n    const metadata = await getContractMetadata({\n      contract: options.contract,\n    });\n\n    const merkleData = isRecord(metadata.merkle) ? metadata.merkle : {};\n    const snapshotUri = merkleData[cc.merkleRoot];\n\n    if (!snapshotUri) {\n      return {\n        currency: ZERO_ADDRESS,\n        pricePerToken: maxUint256,\n        proof: [],\n        quantityLimitPerWallet: 0n,\n      } satisfies OverrideProof;\n    }\n\n    const allowListProof = await fetchProofsForClaimer({\n      claimer: options.from || options.to,\n      contract: options.contract, // receiver and claimer can be different, always prioritize the claimer for allowlists\n      merkleTreeUri: snapshotUri,\n      tokenDecimals,\n    });\n    // if no proof is found, we'll try the empty proof\n    if (!allowListProof) {\n      return {\n        currency: ZERO_ADDRESS,\n        pricePerToken: maxUint256,\n        proof: [],\n        quantityLimitPerWallet: 0n,\n      } satisfies OverrideProof;\n    }\n    // otherwise return the proof\n    return allowListProof;\n  })();\n\n  // currency and price need to match the allowlist proof if set\n  // if default values in the allowlist proof, fallback to the claim condition\n  const currency =\n    allowlistProof.currency && allowlistProof.currency !== ZERO_ADDRESS\n      ? allowlistProof.currency\n      : cc.currency;\n  const pricePerToken =\n    allowlistProof.pricePerToken !== undefined &&\n    allowlistProof.pricePerToken !== maxUint256\n      ? allowlistProof.pricePerToken\n      : cc.pricePerToken;\n\n  const totalPrice =\n    (pricePerToken * options.quantity) / BigInt(10 ** tokenDecimals);\n  const value = isNativeTokenAddress(currency) ? totalPrice : 0n;\n  const erc20Value =\n    !isNativeTokenAddress(currency) && pricePerToken > 0n\n      ? {\n          amountWei: totalPrice,\n          tokenAddress: currency,\n        }\n      : undefined;\n\n  return {\n    allowlistProof,\n    currency,\n    data: \"0x\" as Hex,\n    overrides: {\n      erc20Value,\n      value,\n    },\n    pricePerToken,\n    quantity: options.quantity,\n    receiver: options.to,\n    tokenId: options.type === \"erc1155\" ? options.tokenId : undefined,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}