{"ast":null,"code":"import { fetchTokenMetadata } from \"../../../utils/nft/fetchTokenMetadata.js\";\nimport { parseNFT } from \"../../../utils/nft/parseNft.js\";\nimport { tokenURI } from \"../__generated__/IERC721A/read/tokenURI.js\";\nimport { tokenByIndex } from \"../__generated__/IERC721Enumerable/read/tokenByIndex.js\";\nexport { isTokenURISupported as isGetNFTSupported } from \"../__generated__/IERC721A/read/tokenURI.js\";\nimport { getNFT as getNFTInsight } from \"../../../insight/index.js\";\n/**\n * Retrieves information about a specific ERC721 non-fungible token (NFT).\n * @param options - The options for retrieving the NFT.\n * @returns A promise that resolves to the NFT object.\n * @extension ERC721\n * @example\n * ```ts\n * import { getNFT } from \"thirdweb/extensions/erc721\";\n * const nft = await getNFT({\n *  contract,\n *  tokenId: 1n,\n * });\n * ```\n *\n * * @example\n * ```ts\n * import { getNFT } from \"thirdweb/extensions/erc721\";\n *\n *\n * const nft = await getNFT({\n *  contract,\n *  tokenId: 1n,\n *  tokenByIndex: true // use this flag if the contract supports `tokenByIndex` and the above tokenId should be treated as an index.\n * });\n * ```\n */\nexport async function getNFT(options) {\n  const {\n    useIndexer = true\n  } = options;\n  if (useIndexer) {\n    try {\n      return await getNFTFromInsight(options);\n    } catch (_unused) {\n      return await getNFTFromRPC(options);\n    }\n  }\n  return await getNFTFromRPC(options);\n}\nasync function getNFTFromInsight(options) {\n  const nft = await getNFTInsight({\n    chain: options.contract.chain,\n    client: options.contract.client,\n    contractAddress: options.contract.address,\n    includeOwners: options.includeOwner,\n    tokenId: options.tokenId\n  });\n  if (!nft) {\n    // fresh contracts might be delayed in indexing, so we fallback to RPC\n    return getNFTFromRPC(options);\n  }\n  return nft;\n}\nasync function getNFTFromRPC(options) {\n  let tokenId = options.tokenId;\n  if (options.tokenByIndex) {\n    try {\n      tokenId = await tokenByIndex({\n        contract: options.contract,\n        index: options.tokenId\n      });\n    } catch (_unused2) {}\n  }\n  const [uri, owner] = await Promise.all([tokenURI({\n    contract: options.contract,\n    tokenId\n  }).catch(() => null), options.includeOwner ? import(\"../__generated__/IERC721A/read/ownerOf.js\").then(m => m.ownerOf({\n    contract: options.contract,\n    tokenId\n  })).catch(() => null) : null]);\n  if (!(uri !== null && uri !== void 0 && uri.trim())) {\n    return parseNFT({\n      id: tokenId,\n      type: \"ERC721\",\n      uri: \"\"\n    }, {\n      chainId: options.contract.chain.id,\n      owner,\n      tokenAddress: options.contract.address,\n      tokenId,\n      tokenUri: \"\",\n      type: \"ERC721\"\n    });\n  }\n  return parseNFT(await fetchTokenMetadata({\n    client: options.contract.client,\n    tokenId,\n    tokenUri: uri\n  }).then(metadata => {\n    // if the metadata is null-ish, return a default metadata object\n    if (!metadata) {\n      return {\n        id: tokenId,\n        type: \"ERC721\",\n        uri\n      };\n    }\n    return metadata;\n  }).catch(() => ({\n    id: tokenId,\n    type: \"ERC721\",\n    uri\n  })), {\n    chainId: options.contract.chain.id,\n    owner,\n    tokenAddress: options.contract.address,\n    tokenId: tokenId,\n    tokenUri: uri,\n    type: \"ERC721\"\n  });\n}","map":{"version":3,"names":["fetchTokenMetadata","parseNFT","tokenURI","tokenByIndex","isTokenURISupported","isGetNFTSupported","getNFT","getNFTInsight","options","useIndexer","getNFTFromInsight","_unused","getNFTFromRPC","nft","chain","contract","client","contractAddress","address","includeOwners","includeOwner","tokenId","index","_unused2","uri","owner","Promise","all","catch","then","m","ownerOf","trim","id","type","chainId","tokenAddress","tokenUri","metadata"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/extensions/erc721/read/getNFT.ts"],"sourcesContent":["import type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { fetchTokenMetadata } from \"../../../utils/nft/fetchTokenMetadata.js\";\nimport { type NFT, parseNFT } from \"../../../utils/nft/parseNft.js\";\nimport type { Prettify } from \"../../../utils/type-utils.js\";\nimport {\n  type TokenURIParams,\n  tokenURI,\n} from \"../__generated__/IERC721A/read/tokenURI.js\";\nimport { tokenByIndex } from \"../__generated__/IERC721Enumerable/read/tokenByIndex.js\";\n\nexport { isTokenURISupported as isGetNFTSupported } from \"../__generated__/IERC721A/read/tokenURI.js\";\n\nimport { getNFT as getNFTInsight } from \"../../../insight/index.js\";\n\n/**\n * Parameters for getting an NFT.\n * @extension ERC721\n */\nexport type GetNFTParams = Prettify<\n  TokenURIParams & {\n    /**\n     * Whether to include the owner of the NFT.\n     */\n    includeOwner?: boolean;\n    /**\n     * Whether to check and fetch tokenID by index, in case of non-sequential IDs.\n     *\n     * It should be set to true if it's an ERC721Enumerable contract, and has `tokenByIndex` function.\n     * In this case, the provided tokenId will be considered as token-index and actual tokenId will be fetched from the contract.\n     */\n    tokenByIndex?: boolean;\n    /**\n     * Whether to use the insight API to fetch the NFT.\n     * @default true\n     */\n    useIndexer?: boolean;\n  }\n>;\n\n/**\n * Retrieves information about a specific ERC721 non-fungible token (NFT).\n * @param options - The options for retrieving the NFT.\n * @returns A promise that resolves to the NFT object.\n * @extension ERC721\n * @example\n * ```ts\n * import { getNFT } from \"thirdweb/extensions/erc721\";\n * const nft = await getNFT({\n *  contract,\n *  tokenId: 1n,\n * });\n * ```\n *\n * * @example\n * ```ts\n * import { getNFT } from \"thirdweb/extensions/erc721\";\n *\n *\n * const nft = await getNFT({\n *  contract,\n *  tokenId: 1n,\n *  tokenByIndex: true // use this flag if the contract supports `tokenByIndex` and the above tokenId should be treated as an index.\n * });\n * ```\n */\nexport async function getNFT(\n  options: BaseTransactionOptions<GetNFTParams>,\n): Promise<NFT> {\n  const { useIndexer = true } = options;\n  if (useIndexer) {\n    try {\n      return await getNFTFromInsight(options);\n    } catch {\n      return await getNFTFromRPC(options);\n    }\n  }\n  return await getNFTFromRPC(options);\n}\n\nasync function getNFTFromInsight(\n  options: BaseTransactionOptions<GetNFTParams>,\n): Promise<NFT> {\n  const nft = await getNFTInsight({\n    chain: options.contract.chain,\n    client: options.contract.client,\n    contractAddress: options.contract.address,\n    includeOwners: options.includeOwner,\n    tokenId: options.tokenId,\n  });\n  if (!nft) {\n    // fresh contracts might be delayed in indexing, so we fallback to RPC\n    return getNFTFromRPC(options);\n  }\n  return nft;\n}\n\nasync function getNFTFromRPC(\n  options: BaseTransactionOptions<GetNFTParams>,\n): Promise<NFT> {\n  let tokenId = options.tokenId;\n  if (options.tokenByIndex) {\n    try {\n      tokenId = await tokenByIndex({\n        contract: options.contract,\n        index: options.tokenId,\n      });\n    } catch {}\n  }\n\n  const [uri, owner] = await Promise.all([\n    tokenURI({ contract: options.contract, tokenId }).catch(() => null),\n    options.includeOwner\n      ? import(\"../__generated__/IERC721A/read/ownerOf.js\")\n          .then((m) => m.ownerOf({ contract: options.contract, tokenId }))\n          .catch(() => null)\n      : null,\n  ]);\n\n  if (!uri?.trim()) {\n    return parseNFT(\n      {\n        id: tokenId,\n        type: \"ERC721\",\n        uri: \"\",\n      },\n      {\n        chainId: options.contract.chain.id,\n        owner,\n        tokenAddress: options.contract.address,\n        tokenId,\n        tokenUri: \"\",\n        type: \"ERC721\",\n      },\n    );\n  }\n\n  return parseNFT(\n    await fetchTokenMetadata({\n      client: options.contract.client,\n      tokenId,\n      tokenUri: uri,\n    })\n      .then((metadata) => {\n        // if the metadata is null-ish, return a default metadata object\n        if (!metadata) {\n          return {\n            id: tokenId,\n            type: \"ERC721\",\n            uri,\n          };\n        }\n        return metadata;\n      })\n      .catch(() => ({\n        id: tokenId,\n        type: \"ERC721\",\n        uri,\n      })),\n    {\n      chainId: options.contract.chain.id,\n      owner,\n      tokenAddress: options.contract.address,\n      tokenId: tokenId,\n      tokenUri: uri,\n      type: \"ERC721\",\n    },\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}