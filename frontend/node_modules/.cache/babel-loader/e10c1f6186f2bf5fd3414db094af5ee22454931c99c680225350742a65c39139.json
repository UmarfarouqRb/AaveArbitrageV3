{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\n// TODO(v3): Convert to sync.\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { isHex } from '../../utils/data/isHex.js';\nimport { hexToBytes } from '../../utils/encoding/toBytes.js';\nimport { numberToHex } from '../../utils/encoding/toHex.js';\nimport { serializeSignature } from '../../utils/signature/serializeSignature.js';\nlet extraEntropy = false;\n/**\n * Sets extra entropy for signing functions.\n */\nexport function setSignEntropy(entropy) {\n  if (!entropy) throw new Error('must be a `true` or a hex value.');\n  extraEntropy = entropy;\n}\n/**\n * @description Signs a hash with a given private key.\n *\n * @param hash The hash to sign.\n * @param privateKey The private key to sign with.\n *\n * @returns The signature.\n */\nexport async function sign(_ref) {\n  let {\n    hash,\n    privateKey,\n    to = 'object'\n  } = _ref;\n  const {\n    r,\n    s,\n    recovery\n  } = secp256k1.sign(hash.slice(2), privateKey.slice(2), {\n    lowS: true,\n    extraEntropy: isHex(extraEntropy, {\n      strict: false\n    }) ? hexToBytes(extraEntropy) : extraEntropy\n  });\n  const signature = {\n    r: numberToHex(r, {\n      size: 32\n    }),\n    s: numberToHex(s, {\n      size: 32\n    }),\n    v: recovery ? 28n : 27n,\n    yParity: recovery\n  };\n  return (() => {\n    if (to === 'bytes' || to === 'hex') return serializeSignature(_objectSpread(_objectSpread({}, signature), {}, {\n      to\n    }));\n    return signature;\n  })();\n}","map":{"version":3,"names":["secp256k1","isHex","hexToBytes","numberToHex","serializeSignature","extraEntropy","setSignEntropy","entropy","Error","sign","_ref","hash","privateKey","to","r","s","recovery","slice","lowS","strict","signature","size","v","yParity","_objectSpread"],"sources":["/home/user/Arbitrage/frontend/node_modules/viem/accounts/utils/sign.ts"],"sourcesContent":["// TODO(v3): Convert to sync.\n\nimport { secp256k1 } from '@noble/curves/secp256k1'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../../utils/data/isHex.js'\nimport {\n  type HexToBytesErrorType,\n  hexToBytes,\n} from '../../utils/encoding/toBytes.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport { serializeSignature } from '../../utils/signature/serializeSignature.js'\n\ntype To = 'object' | 'bytes' | 'hex'\n\nexport type SignParameters<to extends To = 'object'> = {\n  hash: Hex\n  privateKey: Hex\n  to?: to | To | undefined\n}\n\nexport type SignReturnType<to extends To = 'object'> =\n  | (to extends 'object' ? Signature : never)\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type SignErrorType =\n  | HexToBytesErrorType\n  | IsHexErrorType\n  | NumberToHexErrorType\n  | ErrorType\n\nlet extraEntropy: Hex | boolean = false\n\n/**\n * Sets extra entropy for signing functions.\n */\nexport function setSignEntropy(entropy: true | Hex) {\n  if (!entropy) throw new Error('must be a `true` or a hex value.')\n  extraEntropy = entropy\n}\n\n/**\n * @description Signs a hash with a given private key.\n *\n * @param hash The hash to sign.\n * @param privateKey The private key to sign with.\n *\n * @returns The signature.\n */\nexport async function sign<to extends To = 'object'>({\n  hash,\n  privateKey,\n  to = 'object',\n}: SignParameters<to>): Promise<SignReturnType<to>> {\n  const { r, s, recovery } = secp256k1.sign(\n    hash.slice(2),\n    privateKey.slice(2),\n    {\n      lowS: true,\n      extraEntropy: isHex(extraEntropy, { strict: false })\n        ? hexToBytes(extraEntropy)\n        : extraEntropy,\n    },\n  )\n  const signature = {\n    r: numberToHex(r, { size: 32 }),\n    s: numberToHex(s, { size: 32 }),\n    v: recovery ? 28n : 27n,\n    yParity: recovery,\n  }\n  return (() => {\n    if (to === 'bytes' || to === 'hex')\n      return serializeSignature({ ...signature, to })\n    return signature\n  })() as SignReturnType<to>\n}\n"],"mappings":";AAAA;AAEA,SAASA,SAAS,QAAQ,yBAAyB;AAInD,SAA8BC,KAAK,QAAQ,2BAA2B;AACtE,SAEEC,UAAU,QACL,iCAAiC;AACxC,SAEEC,WAAW,QACN,+BAA+B;AACtC,SAASC,kBAAkB,QAAQ,6CAA6C;AAqBhF,IAAIC,YAAY,GAAkB,KAAK;AAEvC;;;AAGA,OAAM,SAAUC,cAAcA,CAACC,OAAmB;EAChD,IAAI,CAACA,OAAO,EAAE,MAAM,IAAIC,KAAK,CAAC,kCAAkC,CAAC;EACjEH,YAAY,GAAGE,OAAO;AACxB;AAEA;;;;;;;;AAQA,OAAO,eAAeE,IAAIA,CAAAC,IAAA,EAIL;EAAA,IAJgC;IACnDC,IAAI;IACJC,UAAU;IACVC,EAAE,GAAG;EAAQ,CACM,GAAAH,IAAA;EACnB,MAAM;IAAEI,CAAC;IAAEC,CAAC;IAAEC;EAAQ,CAAE,GAAGhB,SAAS,CAACS,IAAI,CACvCE,IAAI,CAACM,KAAK,CAAC,CAAC,CAAC,EACbL,UAAU,CAACK,KAAK,CAAC,CAAC,CAAC,EACnB;IACEC,IAAI,EAAE,IAAI;IACVb,YAAY,EAAEJ,KAAK,CAACI,YAAY,EAAE;MAAEc,MAAM,EAAE;IAAK,CAAE,CAAC,GAChDjB,UAAU,CAACG,YAAY,CAAC,GACxBA;GACL,CACF;EACD,MAAMe,SAAS,GAAG;IAChBN,CAAC,EAAEX,WAAW,CAACW,CAAC,EAAE;MAAEO,IAAI,EAAE;IAAE,CAAE,CAAC;IAC/BN,CAAC,EAAEZ,WAAW,CAACY,CAAC,EAAE;MAAEM,IAAI,EAAE;IAAE,CAAE,CAAC;IAC/BC,CAAC,EAAEN,QAAQ,GAAG,GAAG,GAAG,GAAG;IACvBO,OAAO,EAAEP;GACV;EACD,OAAO,CAAC,MAAK;IACX,IAAIH,EAAE,KAAK,OAAO,IAAIA,EAAE,KAAK,KAAK,EAChC,OAAOT,kBAAkB,CAAAoB,aAAA,CAAAA,aAAA,KAAMJ,SAAS;MAAEP;IAAE,EAAE,CAAC;IACjD,OAAOO,SAAS;EAClB,CAAC,EAAC,CAAwB;AAC5B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}