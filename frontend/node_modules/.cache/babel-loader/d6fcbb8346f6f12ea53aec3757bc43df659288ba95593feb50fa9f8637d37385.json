{"ast":null,"code":"\"use client\";\n\nimport _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"loadingComponent\", \"fallbackComponent\", \"queryOptions\", \"mediaResolver\"];\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { getFunctionId } from \"../../../../../utils/function-id.js\";\nimport { MediaRenderer } from \"../../MediaRenderer/MediaRenderer.js\";\nimport { useNFTContext } from \"./provider.js\";\nimport { getNFTInfo } from \"./utils.js\";\n/**\n * This component fetches and displays an NFT's media. It uses thirdweb [`MediaRenderer`](https://portal.thirdweb.com/refernces/typescript/v5/MediaRenderer) under the hood\n * so you can style it just like how you would style a MediaRenderer.\n * @returns A MediaRenderer component\n *\n * @component\n *\n * @example\n * ### Basic usage\n * ```tsx\n * import { NFTProvider, NFTMedia } from \"thirdweb/react\";\n *\n * <NFTProvider>\n *   <NFTMedia />\n * </NFTProvider>\n * ```\n *\n * ### Show a loading sign while the media is being fetched\n * ```tsx\n * import { NFTProvider, NFTMedia } from \"thirdweb/react\";\n *\n * <NFTProvider>\n *   <NFTMedia loadingComponent={<YourLoadingSign />} />\n * </NFTProvider>\n * ```\n *\n * ### Show something in case the media failed to resolve\n * ```tsx\n * import { NFTProvider, NFTMedia } from \"thirdweb/react\";\n *\n * <NFTProvider>\n *   <NFTMedia fallbackComponent={<span>Failed to load media</span>} />\n * </NFTProvider>\n * ```\n *\n * ### Custom query options for useQuery (tanstack-query)\n * ```tsx\n * import { NFTProvider, NFTMedia } from \"thirdweb/react\";\n *\n * <NFTProvider>\n *   <NFTMedia queryOptions={{ retry: 3, enabled: false, }} />\n * </NFTProvider>\n * ```\n *\n * ### Basic stylings\n *\n * You can style NFTMedia with the `style` and `className` props.\n *\n * ```tsx\n * <NFTMedia style={{ borderRadius: \"8px\" }} className=\"mx-auto\" />\n * ```\n *\n * ### Override the media with the `mediaResolver` prop\n * If you already have the url, you can skip the network requests and pass it directly to the NFTMedia\n * ```tsx\n * <NFTMedia mediaResolver={{\n *   src: \"/cat_video.mp4\",\n *   // Poster is applicable to medias that are videos and audios\n *   poster: \"/cat-image.png\",\n * }} />\n * ```\n *\n * You can also pass in your own custom (async) function that retrieves the media url\n * ```tsx\n * const getMedia = async () => {\n *   const url = getNFTMedia(props);\n *   return url;\n * };\n *\n * <NFTMedia mediaResolver={getMedia} />\n * ```\n * @nft\n * @beta\n */\nexport function NFTMedia(_ref) {\n  let {\n      loadingComponent,\n      fallbackComponent,\n      queryOptions,\n      mediaResolver\n    } = _ref,\n    mediaRendererProps = _objectWithoutProperties(_ref, _excluded);\n  const {\n    contract,\n    tokenId\n  } = useNFTContext();\n  const mediaQuery = useQuery(_objectSpread({\n    queryFn: async () => fetchNftMedia({\n      contract,\n      mediaResolver,\n      tokenId\n    }),\n    queryKey: getQueryKey({\n      chainId: contract.chain.id,\n      contractAddress: contract.address,\n      mediaResolver,\n      tokenId\n    })\n  }, queryOptions));\n  if (mediaQuery.isLoading) {\n    return loadingComponent || null;\n  }\n  if (!mediaQuery.data) {\n    return fallbackComponent || null;\n  }\n  return _jsx(MediaRenderer, _objectSpread({\n    client: contract.client,\n    poster: mediaQuery.data.poster,\n    src: mediaQuery.data.src\n  }, mediaRendererProps));\n}\n/**\n * @internal\n */\nexport function getQueryKey(props) {\n  const {\n    chainId,\n    tokenId,\n    mediaResolver,\n    contractAddress\n  } = props;\n  return [\"_internal_nft_media_\", chainId, contractAddress, tokenId.toString(), {\n    resolver: typeof mediaResolver === \"object\" ? mediaResolver : typeof mediaResolver === \"function\" ? getFunctionId(mediaResolver) : undefined\n  }];\n}\n/**\n * @internal Exported for tests only\n */\nexport async function fetchNftMedia(props) {\n  const {\n    mediaResolver,\n    contract,\n    tokenId\n  } = props;\n  if (typeof mediaResolver === \"object\") {\n    return mediaResolver;\n  }\n  if (typeof mediaResolver === \"function\") {\n    return mediaResolver();\n  }\n  const nft = await getNFTInfo({\n    contract,\n    tokenId\n  }).catch(() => undefined);\n  if (!nft) {\n    throw new Error(\"Failed to resolve NFT info\");\n  }\n  const animation_url = nft.metadata.animation_url;\n  const image = nft.metadata.image || nft.metadata.image_url;\n  if (animation_url) {\n    return {\n      poster: image || undefined,\n      src: animation_url\n    };\n  }\n  if (image) {\n    return {\n      poster: undefined,\n      src: image\n    };\n  }\n  throw new Error(\"Failed to resolve NFT media\");\n}","map":{"version":3,"names":["_objectSpread","_objectWithoutProperties","_excluded","useQuery","getFunctionId","MediaRenderer","useNFTContext","getNFTInfo","NFTMedia","_ref","loadingComponent","fallbackComponent","queryOptions","mediaResolver","mediaRendererProps","contract","tokenId","mediaQuery","queryFn","fetchNftMedia","queryKey","getQueryKey","chainId","chain","id","contractAddress","address","isLoading","data","_jsx","client","poster","src","props","toString","resolver","undefined","nft","catch","Error","animation_url","metadata","image","image_url"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/react/web/ui/prebuilt/NFT/media.tsx"],"sourcesContent":["\"use client\";\n\nimport { type UseQueryOptions, useQuery } from \"@tanstack/react-query\";\nimport type { JSX } from \"react\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { getFunctionId } from \"../../../../../utils/function-id.js\";\nimport { MediaRenderer } from \"../../MediaRenderer/MediaRenderer.js\";\nimport type { MediaRendererProps } from \"../../MediaRenderer/types.js\";\nimport { useNFTContext } from \"./provider.js\";\nimport { getNFTInfo } from \"./utils.js\";\n\n/**\n * @component\n * @beta\n * @wallet\n */\nexport type NFTMediaInfo = {\n  src: string;\n  poster: string | undefined;\n};\n\n/**\n * @component\n * @beta\n * @wallet\n * The props for the <NFTMedia /> component\n * It is similar to the [`MediaRendererProps`](https://portal.thirdweb.com/references/typescript/v5/MediaRendererProps)\n * (excluding `src`, `poster` and `client`) that you can\n * use to style the NFTMedia\n */\nexport type NFTMediaProps = Omit<\n  MediaRendererProps,\n  \"src\" | \"poster\" | \"client\"\n> & {\n  loadingComponent?: JSX.Element;\n  fallbackComponent?: JSX.Element;\n  /**\n   * Optional `useQuery` params\n   */\n  queryOptions?: Omit<UseQueryOptions<NFTMediaInfo>, \"queryFn\" | \"queryKey\">;\n  /**\n   * This prop can be a string or a (async) function that resolves to a string, representing the media url of the NFT\n   * This is particularly useful if you already have a way to fetch the image.\n   * In case of function, the function must resolve to an object of type `NFTMediaInfo`\n   */\n  mediaResolver?:\n    | NFTMediaInfo\n    | (() => NFTMediaInfo)\n    | (() => Promise<NFTMediaInfo>);\n};\n\n/**\n * This component fetches and displays an NFT's media. It uses thirdweb [`MediaRenderer`](https://portal.thirdweb.com/refernces/typescript/v5/MediaRenderer) under the hood\n * so you can style it just like how you would style a MediaRenderer.\n * @returns A MediaRenderer component\n *\n * @component\n *\n * @example\n * ### Basic usage\n * ```tsx\n * import { NFTProvider, NFTMedia } from \"thirdweb/react\";\n *\n * <NFTProvider>\n *   <NFTMedia />\n * </NFTProvider>\n * ```\n *\n * ### Show a loading sign while the media is being fetched\n * ```tsx\n * import { NFTProvider, NFTMedia } from \"thirdweb/react\";\n *\n * <NFTProvider>\n *   <NFTMedia loadingComponent={<YourLoadingSign />} />\n * </NFTProvider>\n * ```\n *\n * ### Show something in case the media failed to resolve\n * ```tsx\n * import { NFTProvider, NFTMedia } from \"thirdweb/react\";\n *\n * <NFTProvider>\n *   <NFTMedia fallbackComponent={<span>Failed to load media</span>} />\n * </NFTProvider>\n * ```\n *\n * ### Custom query options for useQuery (tanstack-query)\n * ```tsx\n * import { NFTProvider, NFTMedia } from \"thirdweb/react\";\n *\n * <NFTProvider>\n *   <NFTMedia queryOptions={{ retry: 3, enabled: false, }} />\n * </NFTProvider>\n * ```\n *\n * ### Basic stylings\n *\n * You can style NFTMedia with the `style` and `className` props.\n *\n * ```tsx\n * <NFTMedia style={{ borderRadius: \"8px\" }} className=\"mx-auto\" />\n * ```\n *\n * ### Override the media with the `mediaResolver` prop\n * If you already have the url, you can skip the network requests and pass it directly to the NFTMedia\n * ```tsx\n * <NFTMedia mediaResolver={{\n *   src: \"/cat_video.mp4\",\n *   // Poster is applicable to medias that are videos and audios\n *   poster: \"/cat-image.png\",\n * }} />\n * ```\n *\n * You can also pass in your own custom (async) function that retrieves the media url\n * ```tsx\n * const getMedia = async () => {\n *   const url = getNFTMedia(props);\n *   return url;\n * };\n *\n * <NFTMedia mediaResolver={getMedia} />\n * ```\n * @nft\n * @beta\n */\nexport function NFTMedia({\n  loadingComponent,\n  fallbackComponent,\n  queryOptions,\n  mediaResolver,\n  ...mediaRendererProps\n}: NFTMediaProps) {\n  const { contract, tokenId } = useNFTContext();\n  const mediaQuery = useQuery({\n    queryFn: async (): Promise<NFTMediaInfo> =>\n      fetchNftMedia({ contract, mediaResolver, tokenId }),\n    queryKey: getQueryKey({\n      chainId: contract.chain.id,\n      contractAddress: contract.address,\n      mediaResolver,\n      tokenId,\n    }),\n    ...queryOptions,\n  });\n\n  if (mediaQuery.isLoading) {\n    return loadingComponent || null;\n  }\n\n  if (!mediaQuery.data) {\n    return fallbackComponent || null;\n  }\n\n  return (\n    <MediaRenderer\n      client={contract.client}\n      poster={mediaQuery.data.poster}\n      src={mediaQuery.data.src}\n      {...mediaRendererProps}\n    />\n  );\n}\n\n/**\n * @internal\n */\nexport function getQueryKey(props: {\n  contractAddress: string;\n  chainId: number;\n  tokenId: bigint;\n  mediaResolver?:\n    | NFTMediaInfo\n    | (() => NFTMediaInfo)\n    | (() => Promise<NFTMediaInfo>);\n}) {\n  const { chainId, tokenId, mediaResolver, contractAddress } = props;\n  return [\n    \"_internal_nft_media_\",\n    chainId,\n    contractAddress,\n    tokenId.toString(),\n    {\n      resolver:\n        typeof mediaResolver === \"object\"\n          ? mediaResolver\n          : typeof mediaResolver === \"function\"\n            ? getFunctionId(mediaResolver)\n            : undefined,\n    },\n  ] as const;\n}\n\n/**\n * @internal Exported for tests only\n */\nexport async function fetchNftMedia(props: {\n  mediaResolver?:\n    | NFTMediaInfo\n    | (() => NFTMediaInfo)\n    | (() => Promise<NFTMediaInfo>);\n  contract: ThirdwebContract;\n  tokenId: bigint;\n}): Promise<{ src: string; poster: string | undefined }> {\n  const { mediaResolver, contract, tokenId } = props;\n  if (typeof mediaResolver === \"object\") {\n    return mediaResolver;\n  }\n  if (typeof mediaResolver === \"function\") {\n    return mediaResolver();\n  }\n  const nft = await getNFTInfo({ contract, tokenId }).catch(() => undefined);\n  if (!nft) {\n    throw new Error(\"Failed to resolve NFT info\");\n  }\n  const animation_url = nft.metadata.animation_url;\n  const image = nft.metadata.image || nft.metadata.image_url;\n  if (animation_url) {\n    return {\n      poster: image || undefined,\n      src: animation_url,\n    };\n  }\n  if (image) {\n    return {\n      poster: undefined,\n      src: image,\n    };\n  }\n  throw new Error(\"Failed to resolve NFT media\");\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}