{"ast":null,"code":"import { base58Encode } from \"../base58/encode.js\";\nimport { hexToBytes } from \"../encoding/to-bytes.js\";\nimport { decode } from \"./cbor-decode.js\";\nimport { ensureBytecodePrefix } from \"./prefix.js\";\n/**\n * Extracts the IPFS URI from the given bytecode.\n * @param bytecode - The bytecode to extract the IPFS URI from.\n * @returns The IPFS URI if found, otherwise undefined.\n * @example\n * ```ts\n * import { extractIPFSUri } from \"thirdweb/utils/bytecode/extractIPFS\";\n * const bytecode = \"0x363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\";\n * const ipfsHash = extractIPFSUri(bytecode);\n * console.log(ipfsHash);\n * ```\n * @utils\n */\nexport function extractIPFSUri(bytecode) {\n  const numericBytecode = hexToBytes(ensureBytecodePrefix(bytecode));\n  const cborLength =\n  // @ts-expect-error - TS doesn't like this, but it's fine\n  numericBytecode[numericBytecode.length - 2] * 0x100 +\n  // @ts-expect-error - TS doesn't like this, but it's fine\n  numericBytecode[numericBytecode.length - 1];\n  const cborStart = numericBytecode.length - 2 - cborLength;\n  // if the cborStart is invalid, return undefined\n  if (cborStart < 0 || cborStart > numericBytecode.length) {\n    return undefined;\n  }\n  const bytecodeBuffer = numericBytecode.slice(cborStart, -2);\n  const cborData = decode(bytecodeBuffer);\n  if (\"ipfs\" in cborData) {\n    return \"ipfs://\".concat(base58Encode(cborData.ipfs));\n  }\n  return undefined;\n}","map":{"version":3,"names":["base58Encode","hexToBytes","decode","ensureBytecodePrefix","extractIPFSUri","bytecode","numericBytecode","cborLength","length","cborStart","undefined","bytecodeBuffer","slice","cborData","concat","ipfs"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/utils/bytecode/extractIPFS.ts"],"sourcesContent":["import { base58Encode } from \"../base58/encode.js\";\nimport { hexToBytes } from \"../encoding/to-bytes.js\";\nimport { decode } from \"./cbor-decode.js\";\nimport { ensureBytecodePrefix } from \"./prefix.js\";\n\n/**\n * Extracts the IPFS URI from the given bytecode.\n * @param bytecode - The bytecode to extract the IPFS URI from.\n * @returns The IPFS URI if found, otherwise undefined.\n * @example\n * ```ts\n * import { extractIPFSUri } from \"thirdweb/utils/bytecode/extractIPFS\";\n * const bytecode = \"0x363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\";\n * const ipfsHash = extractIPFSUri(bytecode);\n * console.log(ipfsHash);\n * ```\n * @utils\n */\nexport function extractIPFSUri(bytecode: string): string | undefined {\n  const numericBytecode = hexToBytes(ensureBytecodePrefix(bytecode));\n\n  const cborLength =\n    // @ts-expect-error - TS doesn't like this, but it's fine\n    numericBytecode[numericBytecode.length - 2] * 0x100 +\n    // @ts-expect-error - TS doesn't like this, but it's fine\n    numericBytecode[numericBytecode.length - 1];\n  const cborStart = numericBytecode.length - 2 - cborLength;\n  // if the cborStart is invalid, return undefined\n  if (cborStart < 0 || cborStart > numericBytecode.length) {\n    return undefined;\n  }\n  const bytecodeBuffer = numericBytecode.slice(cborStart, -2);\n\n  const cborData = decode(bytecodeBuffer);\n  if (\"ipfs\" in cborData) {\n    return `ipfs://${base58Encode(cborData.ipfs)}`;\n  }\n\n  return undefined;\n}\n"],"mappings":"AAAA,SAASA,YAAY,QAAQ,qBAAqB;AAClD,SAASC,UAAU,QAAQ,yBAAyB;AACpD,SAASC,MAAM,QAAQ,kBAAkB;AACzC,SAASC,oBAAoB,QAAQ,aAAa;AAElD;;;;;;;;;;;;;AAaA,OAAM,SAAUC,cAAcA,CAACC,QAAgB;EAC7C,MAAMC,eAAe,GAAGL,UAAU,CAACE,oBAAoB,CAACE,QAAQ,CAAC,CAAC;EAElE,MAAME,UAAU;EACd;EACAD,eAAe,CAACA,eAAe,CAACE,MAAM,GAAG,CAAC,CAAC,GAAG,KAAK;EACnD;EACAF,eAAe,CAACA,eAAe,CAACE,MAAM,GAAG,CAAC,CAAC;EAC7C,MAAMC,SAAS,GAAGH,eAAe,CAACE,MAAM,GAAG,CAAC,GAAGD,UAAU;EACzD;EACA,IAAIE,SAAS,GAAG,CAAC,IAAIA,SAAS,GAAGH,eAAe,CAACE,MAAM,EAAE;IACvD,OAAOE,SAAS;EAClB;EACA,MAAMC,cAAc,GAAGL,eAAe,CAACM,KAAK,CAACH,SAAS,EAAE,CAAC,CAAC,CAAC;EAE3D,MAAMI,QAAQ,GAAGX,MAAM,CAACS,cAAc,CAAC;EACvC,IAAI,MAAM,IAAIE,QAAQ,EAAE;IACtB,iBAAAC,MAAA,CAAiBd,YAAY,CAACa,QAAQ,CAACE,IAAI,CAAC;EAC9C;EAEA,OAAOL,SAAS;AAClB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}