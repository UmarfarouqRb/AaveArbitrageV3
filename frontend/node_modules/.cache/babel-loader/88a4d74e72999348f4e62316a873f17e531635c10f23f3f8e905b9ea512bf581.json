{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { getContract } from \"../../../contract/contract.js\";\nimport { toTokens } from \"../../../utils/units.js\";\nimport { getCurrencyMetadata } from \"../../erc20/read/getCurrencyMetadata.js\";\nimport { isERC721 } from \"../../erc721/read/isERC721.js\";\nimport { isERC1155 } from \"../../erc1155/read/isERC1155.js\";\nimport { computeStatus, getNFTAsset } from \"../utils.js\";\n/**\n * @internal\n */\nexport async function mapDirectListing(options) {\n  const {\n    latestBlock,\n    rawListing\n  } = options;\n  // process the listing\n  const status = computeStatus({\n    blockTimeStamp: latestBlock.timestamp,\n    endTimestamp: rawListing.endTimestamp,\n    listingStatus: rawListing.status,\n    startTimestamp: rawListing.startTimestamp\n  });\n  const currencyContract = getContract(_objectSpread(_objectSpread({}, options.contract), {}, {\n    address: rawListing.currency\n  }));\n  const [currencyValuePerToken, nftAsset] = await Promise.all([getCurrencyMetadata({\n    contract: currencyContract\n  }), getNFTAsset(_objectSpread(_objectSpread({}, options), {}, {\n    contract: getContract(_objectSpread(_objectSpread({}, options.contract), {}, {\n      address: rawListing.assetContract\n    })),\n    tokenId: rawListing.tokenId\n  }))]);\n  return {\n    asset: nftAsset,\n    assetContractAddress: rawListing.assetContract,\n    creatorAddress: rawListing.listingCreator,\n    currencyContractAddress: rawListing.currency,\n    currencyValuePerToken: _objectSpread(_objectSpread({}, currencyValuePerToken), {}, {\n      chainId: currencyContract.chain.id,\n      displayValue: toTokens(rawListing.pricePerToken, currencyValuePerToken.decimals),\n      tokenAddress: currencyContract.address,\n      value: rawListing.pricePerToken\n    }),\n    endTimeInSeconds: rawListing.endTimestamp,\n    id: rawListing.listingId,\n    isReservedListing: rawListing.reserved,\n    pricePerToken: rawListing.pricePerToken,\n    quantity: rawListing.quantity,\n    startTimeInSeconds: rawListing.startTimestamp,\n    status,\n    tokenId: rawListing.tokenId,\n    type: \"direct-listing\"\n  };\n}\nexport async function isListingValid(options) {\n  const assetContract = getContract(_objectSpread(_objectSpread({}, options.contract), {}, {\n    address: options.listing.assetContractAddress\n  }));\n  const [erc721, erc1155] = await Promise.all([isERC721({\n    contract: assetContract\n  }), isERC1155({\n    contract: assetContract\n  })]);\n  // if the asset is an erc721 token\n  if (erc721) {\n    const [{\n      isApprovedForAll\n    }, {\n      getApproved\n    }, {\n      ownerOf\n    }] = await Promise.all([import(\"../../erc721/__generated__/IERC721A/read/isApprovedForAll.js\"), import(\"../../erc721/__generated__/IERC721A/read/getApproved.js\"), import(\"../../erc721/__generated__/IERC721A/read/ownerOf.js\")]);\n    // check for token approval\n    const [approvedForAll, approvedOperator, tokenOwner] = await Promise.all([isApprovedForAll({\n      contract: assetContract,\n      // the marketplace contract address has to be approved to transfer the token\n      operator: options.contract.address,\n      owner: options.listing.creatorAddress\n    }), getApproved({\n      contract: assetContract,\n      tokenId: options.listing.tokenId\n    }).catch(() => \"\"), ownerOf({\n      contract: assetContract,\n      tokenId: options.listing.tokenId\n    })]);\n    // if the marketplace is not approved for all and the marketplace contract is not the approved operator for the token\n    // -> the listing is not valid\n    if (!approvedForAll && approvedOperator !== options.contract.address) {\n      return {\n        reason: \"Asset not approved for marketplace.\",\n        valid: false\n      };\n    }\n    // if the token owner is not the creator of the listing\n    // -> the listing is not valid\n    if (tokenOwner !== options.listing.creatorAddress) {\n      return {\n        reason: \"Listing creator no longer owns this token.\",\n        valid: false\n      };\n    }\n    // otherwise the listing is valid\n    return {\n      valid: true\n    };\n  }\n  // if the asset is an erc1155 token\n  if (erc1155) {\n    const [{\n      isApprovedForAll\n    }, {\n      balanceOf\n    }] = await Promise.all([import(\"../../erc1155/__generated__/IERC1155/read/isApprovedForAll.js\"), import(\"../../erc1155/__generated__/IERC1155/read/balanceOf.js\")]);\n    const [approvedForAll, balance] = await Promise.all([isApprovedForAll({\n      contract: assetContract,\n      // the marketplace contract address has to be approved to transfer the token\n      operator: options.contract.address,\n      owner: options.listing.creatorAddress\n    }), balanceOf({\n      contract: assetContract,\n      owner: options.listing.creatorAddress,\n      tokenId: options.listing.tokenId\n    })]);\n    // if the marketplace is not approved for all\n    // -> the listing is not valid\n    if (!approvedForAll) {\n      return {\n        reason: \"Asset not approved for marketplace.\",\n        valid: false\n      };\n    }\n    // if the balance is less than the quantity the user is trying to purchase or the listing quantity\n    // -> the listing is not valid\n    const quantityWanted = options.quantity || options.listing.quantity;\n    if (balance < quantityWanted) {\n      return {\n        reason: \"Seller does not have enough balance of token to fulfill order.\",\n        valid: false\n      };\n    }\n    return {\n      valid: true\n    };\n  }\n  // if the asset is neither ERC721 nor ERC1155\n  return {\n    reason: \"AssetContract must implement ERC 1155 or ERC 721.\",\n    valid: false\n  };\n}","map":{"version":3,"names":["getContract","toTokens","getCurrencyMetadata","isERC721","isERC1155","computeStatus","getNFTAsset","mapDirectListing","options","latestBlock","rawListing","status","blockTimeStamp","timestamp","endTimestamp","listingStatus","startTimestamp","currencyContract","_objectSpread","contract","address","currency","currencyValuePerToken","nftAsset","Promise","all","assetContract","tokenId","asset","assetContractAddress","creatorAddress","listingCreator","currencyContractAddress","chainId","chain","id","displayValue","pricePerToken","decimals","tokenAddress","value","endTimeInSeconds","listingId","isReservedListing","reserved","quantity","startTimeInSeconds","type","isListingValid","listing","erc721","erc1155","isApprovedForAll","getApproved","ownerOf","approvedForAll","approvedOperator","tokenOwner","operator","owner","catch","reason","valid","balanceOf","balance","quantityWanted"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/extensions/marketplace/direct-listings/utils.ts"],"sourcesContent":["import { getContract } from \"../../../contract/contract.js\";\nimport type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { toTokens } from \"../../../utils/units.js\";\nimport { getCurrencyMetadata } from \"../../erc20/read/getCurrencyMetadata.js\";\nimport { isERC721 } from \"../../erc721/read/isERC721.js\";\nimport { isERC1155 } from \"../../erc1155/read/isERC1155.js\";\nimport type { getListing } from \"../__generated__/IDirectListings/read/getListing.js\";\nimport { computeStatus, getNFTAsset } from \"../utils.js\";\nimport type { DirectListing } from \"./types.js\";\n\n/**\n * @internal\n */\nexport async function mapDirectListing(\n  options: BaseTransactionOptions<{\n    latestBlock: { timestamp: bigint };\n    rawListing: Awaited<ReturnType<typeof getListing>>;\n  }>,\n): Promise<DirectListing> {\n  const { latestBlock, rawListing } = options;\n  // process the listing\n  const status = computeStatus({\n    blockTimeStamp: latestBlock.timestamp,\n    endTimestamp: rawListing.endTimestamp,\n    listingStatus: rawListing.status,\n    startTimestamp: rawListing.startTimestamp,\n  });\n\n  const currencyContract = getContract({\n    ...options.contract,\n    address: rawListing.currency,\n  });\n  const [currencyValuePerToken, nftAsset] = await Promise.all([\n    getCurrencyMetadata({\n      contract: currencyContract,\n    }),\n    getNFTAsset({\n      ...options,\n      contract: getContract({\n        ...options.contract,\n        address: rawListing.assetContract,\n      }),\n      tokenId: rawListing.tokenId,\n    }),\n  ]);\n\n  return {\n    asset: nftAsset,\n    assetContractAddress: rawListing.assetContract,\n    creatorAddress: rawListing.listingCreator,\n    currencyContractAddress: rawListing.currency,\n    currencyValuePerToken: {\n      ...currencyValuePerToken,\n      chainId: currencyContract.chain.id,\n      displayValue: toTokens(\n        rawListing.pricePerToken,\n        currencyValuePerToken.decimals,\n      ),\n      tokenAddress: currencyContract.address,\n      value: rawListing.pricePerToken,\n    },\n    endTimeInSeconds: rawListing.endTimestamp,\n    id: rawListing.listingId,\n    isReservedListing: rawListing.reserved,\n    pricePerToken: rawListing.pricePerToken,\n    quantity: rawListing.quantity,\n    startTimeInSeconds: rawListing.startTimestamp,\n    status,\n    tokenId: rawListing.tokenId,\n    type: \"direct-listing\",\n  };\n}\n\ntype IsListingValidParams = {\n  listing: DirectListing;\n  quantity?: bigint;\n};\ntype ValidReturn = { valid: true } | { valid: false; reason: string };\n\nexport async function isListingValid(\n  options: BaseTransactionOptions<IsListingValidParams>,\n): Promise<ValidReturn> {\n  const assetContract = getContract({\n    ...options.contract,\n    address: options.listing.assetContractAddress,\n  });\n\n  const [erc721, erc1155] = await Promise.all([\n    isERC721({ contract: assetContract }),\n    isERC1155({ contract: assetContract }),\n  ]);\n\n  // if the asset is an erc721 token\n  if (erc721) {\n    const [{ isApprovedForAll }, { getApproved }, { ownerOf }] =\n      await Promise.all([\n        import(\"../../erc721/__generated__/IERC721A/read/isApprovedForAll.js\"),\n        import(\"../../erc721/__generated__/IERC721A/read/getApproved.js\"),\n        import(\"../../erc721/__generated__/IERC721A/read/ownerOf.js\"),\n      ]);\n    // check for token approval\n    const [approvedForAll, approvedOperator, tokenOwner] = await Promise.all([\n      isApprovedForAll({\n        contract: assetContract,\n        // the marketplace contract address has to be approved to transfer the token\n        operator: options.contract.address,\n        owner: options.listing.creatorAddress,\n      }),\n      getApproved({\n        contract: assetContract,\n        tokenId: options.listing.tokenId,\n      }).catch(() => \"\"),\n      ownerOf({\n        contract: assetContract,\n        tokenId: options.listing.tokenId,\n      }),\n    ]);\n    // if the marketplace is not approved for all and the marketplace contract is not the approved operator for the token\n    // -> the listing is not valid\n    if (!approvedForAll && approvedOperator !== options.contract.address) {\n      return { reason: \"Asset not approved for marketplace.\", valid: false };\n    }\n    // if the token owner is not the creator of the listing\n    // -> the listing is not valid\n    if (tokenOwner !== options.listing.creatorAddress) {\n      return {\n        reason: \"Listing creator no longer owns this token.\",\n        valid: false,\n      };\n    }\n    // otherwise the listing is valid\n    return {\n      valid: true,\n    };\n  }\n  // if the asset is an erc1155 token\n  if (erc1155) {\n    const [{ isApprovedForAll }, { balanceOf }] = await Promise.all([\n      import(\"../../erc1155/__generated__/IERC1155/read/isApprovedForAll.js\"),\n      import(\"../../erc1155/__generated__/IERC1155/read/balanceOf.js\"),\n    ]);\n\n    const [approvedForAll, balance] = await Promise.all([\n      isApprovedForAll({\n        contract: assetContract,\n        // the marketplace contract address has to be approved to transfer the token\n        operator: options.contract.address,\n        owner: options.listing.creatorAddress,\n      }),\n      balanceOf({\n        contract: assetContract,\n        owner: options.listing.creatorAddress,\n        tokenId: options.listing.tokenId,\n      }),\n    ]);\n\n    // if the marketplace is not approved for all\n    // -> the listing is not valid\n    if (!approvedForAll) {\n      return { reason: \"Asset not approved for marketplace.\", valid: false };\n    }\n    // if the balance is less than the quantity the user is trying to purchase or the listing quantity\n    // -> the listing is not valid\n    const quantityWanted = options.quantity || options.listing.quantity;\n    if (balance < quantityWanted) {\n      return {\n        reason:\n          \"Seller does not have enough balance of token to fulfill order.\",\n        valid: false,\n      };\n    }\n    return {\n      valid: true,\n    };\n  }\n  // if the asset is neither ERC721 nor ERC1155\n\n  return {\n    reason: \"AssetContract must implement ERC 1155 or ERC 721.\",\n    valid: false,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}