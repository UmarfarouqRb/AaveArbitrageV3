{"ast":null,"code":"import { getCachedChain } from \"../../chains/utils.js\";\nimport { getContract } from \"../../contract/contract.js\";\nimport { isAddress } from \"../address.js\";\n/**\n * Parses the NFT metadata and options to create an NFT object.\n * @param base - The base NFT metadata.\n * @param options - The options for parsing the NFT.\n * @returns The parsed NFT object.\n * @internal\n */\nexport function parseNFT(base, options) {\n  var _options$owner, _options$owner2;\n  switch (options.type) {\n    case \"ERC721\":\n      return {\n        chainId: options.chainId,\n        id: options.tokenId,\n        metadata: base,\n        owner: (_options$owner = options === null || options === void 0 ? void 0 : options.owner) !== null && _options$owner !== void 0 ? _options$owner : null,\n        tokenAddress: options.tokenAddress,\n        tokenURI: options.tokenUri,\n        type: options.type\n      };\n    case \"ERC1155\":\n      return {\n        chainId: options.chainId,\n        id: options.tokenId,\n        metadata: base,\n        owner: (_options$owner2 = options === null || options === void 0 ? void 0 : options.owner) !== null && _options$owner2 !== void 0 ? _options$owner2 : null,\n        supply: options.supply,\n        tokenAddress: options.tokenAddress,\n        tokenURI: options.tokenUri,\n        type: options.type\n      };\n    default:\n      throw new Error(\"Invalid NFT type\");\n  }\n}\n/**\n * Parses an NFT URI.\n * @param options - The options for parsing an NFT URI.\n * @param options.client - The Thirdweb client.\n * @param options.uri - The NFT URI to parse.\n * @returns A promise that resolves to the NFT URI, or null if the URI could not be parsed.\n *\n * @example\n * ```ts\n * import { parseNftUri } from \"thirdweb/utils/ens\";\n * const nftUri = await parseNftUri({\n *    client,\n *    uri: \"eip155:1/erc1155:0xb32979486938aa9694bfc898f35dbed459f44424/10063\",\n * });\n *\n * console.log(nftUri); // ipfs://bafybeiemxf5abjwjbikoz4mc3a3dla6ual3jsgpdr4cjr3oz3evfyavhwq/\n * ```\n *\n * @extension ENS\n *\n */\nexport async function parseNftUri(options) {\n  let uri = options.uri;\n  // parse valid nft spec (CAIP-22/CAIP-29)\n  // @see: https://github.com/ChainAgnostic/CAIPs/tree/master/CAIPs\n  if (uri.startsWith(\"did:nft:\")) {\n    // convert DID to CAIP\n    uri = uri.replace(\"did:nft:\", \"\").replace(/_/g, \"/\");\n  }\n  const [reference = \"\", asset_namespace = \"\", tokenID = \"\"] = uri.split(\"/\");\n  const [eip_namespace, chainID] = reference.split(\":\");\n  const [erc_namespace, contractAddress] = asset_namespace.split(\":\");\n  if (!eip_namespace || eip_namespace.toLowerCase() !== \"eip155\") {\n    throw new Error(\"Invalid EIP namespace, expected EIP155, got: \\\"\".concat(eip_namespace, \"\\\"\"));\n  }\n  if (!chainID) {\n    throw new Error(\"Chain ID not found\");\n  }\n  if (!contractAddress || !isAddress(contractAddress)) {\n    throw new Error(\"Contract address not found\");\n  }\n  if (!tokenID) {\n    throw new Error(\"Token ID not found\");\n  }\n  const chain = getCachedChain(Number(chainID));\n  const contract = getContract({\n    address: contractAddress,\n    chain,\n    client: options.client\n  });\n  switch (erc_namespace) {\n    case \"erc721\":\n      {\n        var _nft$metadata$image;\n        const {\n          getNFT\n        } = await import(\"../../extensions/erc721/read/getNFT.js\");\n        const nft = await getNFT({\n          contract,\n          tokenId: BigInt(tokenID)\n        });\n        return (_nft$metadata$image = nft.metadata.image) !== null && _nft$metadata$image !== void 0 ? _nft$metadata$image : null;\n      }\n    case \"erc1155\":\n      {\n        var _nft$metadata$image2;\n        const {\n          getNFT\n        } = await import(\"../../extensions/erc1155/read/getNFT.js\");\n        const nft = await getNFT({\n          contract,\n          tokenId: BigInt(tokenID)\n        });\n        return (_nft$metadata$image2 = nft.metadata.image) !== null && _nft$metadata$image2 !== void 0 ? _nft$metadata$image2 : null;\n      }\n    default:\n      {\n        throw new Error(\"Invalid ERC namespace, expected ERC721 or ERC1155, got: \\\"\".concat(erc_namespace, \"\\\"\"));\n      }\n  }\n}","map":{"version":3,"names":["getCachedChain","getContract","isAddress","parseNFT","base","options","_options$owner","_options$owner2","type","chainId","id","tokenId","metadata","owner","tokenAddress","tokenURI","tokenUri","supply","Error","parseNftUri","uri","startsWith","replace","reference","asset_namespace","tokenID","split","eip_namespace","chainID","erc_namespace","contractAddress","toLowerCase","concat","chain","Number","contract","address","client","_nft$metadata$image","getNFT","nft","BigInt","image","_nft$metadata$image2"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/utils/nft/parseNft.ts"],"sourcesContent":["import { getCachedChain } from \"../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { getContract } from \"../../contract/contract.js\";\nimport type { FileOrBufferOrString } from \"../../storage/upload/types.js\";\nimport { isAddress } from \"../address.js\";\nimport type { Prettify } from \"../type-utils.js\";\n\n/**\n * Represents the input data for creating an NFT (Non-Fungible Token).\n */\nexport type NFTInput = Prettify<\n  {\n    name?: string;\n    description?: string;\n    image?: FileOrBufferOrString;\n    animation_url?: FileOrBufferOrString;\n    external_url?: FileOrBufferOrString;\n    background_color?: string;\n    // TODO check if we truly need both of these?\n    properties?: Record<string, unknown> | Array<Record<string, unknown>>;\n  } & Record<string, unknown>\n>;\n\nexport type NFTMetadata = {\n  uri: string;\n  name?: string;\n  description?: string;\n  image?: string;\n  animation_url?: string;\n  external_url?: string;\n  background_color?: string;\n  properties?: Record<string, unknown> | Array<Record<string, unknown>>;\n  attributes?: Record<string, unknown> | Array<Record<string, unknown>>;\n  image_url?: string;\n} & Record<string, unknown>;\n\nexport type NFT =\n  | {\n      metadata: NFTMetadata;\n      owner: string | null;\n      id: bigint;\n      tokenURI: string;\n      type: \"ERC721\";\n      tokenAddress: string;\n      chainId: number;\n    }\n  | {\n      metadata: NFTMetadata;\n      owner: string | null;\n      id: bigint;\n      tokenURI: string;\n      type: \"ERC1155\";\n      supply: bigint;\n      tokenAddress: string;\n      chainId: number;\n    };\n\n/**\n * @internal\n */\nexport type ParseNFTOptions =\n  | {\n      tokenId: bigint;\n      tokenUri: string;\n      type: \"ERC721\";\n      owner?: string | null;\n      tokenAddress: string;\n      chainId: number;\n    }\n  | {\n      tokenId: bigint;\n      tokenUri: string;\n      type: \"ERC1155\";\n      owner?: string | null;\n      supply: bigint;\n      tokenAddress: string;\n      chainId: number;\n    };\n\n/**\n * Parses the NFT metadata and options to create an NFT object.\n * @param base - The base NFT metadata.\n * @param options - The options for parsing the NFT.\n * @returns The parsed NFT object.\n * @internal\n */\nexport function parseNFT(base: NFTMetadata, options: ParseNFTOptions): NFT {\n  switch (options.type) {\n    case \"ERC721\":\n      return {\n        chainId: options.chainId,\n        id: options.tokenId,\n        metadata: base,\n        owner: options?.owner ?? null,\n        tokenAddress: options.tokenAddress,\n        tokenURI: options.tokenUri,\n        type: options.type,\n      };\n    case \"ERC1155\":\n      return {\n        chainId: options.chainId,\n        id: options.tokenId,\n        metadata: base,\n        owner: options?.owner ?? null,\n        supply: options.supply,\n        tokenAddress: options.tokenAddress,\n        tokenURI: options.tokenUri,\n        type: options.type,\n      };\n    default:\n      throw new Error(\"Invalid NFT type\");\n  }\n}\n\n/**\n * Parses an NFT URI.\n * @param options - The options for parsing an NFT URI.\n * @param options.client - The Thirdweb client.\n * @param options.uri - The NFT URI to parse.\n * @returns A promise that resolves to the NFT URI, or null if the URI could not be parsed.\n *\n * @example\n * ```ts\n * import { parseNftUri } from \"thirdweb/utils/ens\";\n * const nftUri = await parseNftUri({\n *    client,\n *    uri: \"eip155:1/erc1155:0xb32979486938aa9694bfc898f35dbed459f44424/10063\",\n * });\n *\n * console.log(nftUri); // ipfs://bafybeiemxf5abjwjbikoz4mc3a3dla6ual3jsgpdr4cjr3oz3evfyavhwq/\n * ```\n *\n * @extension ENS\n *\n */\nexport async function parseNftUri(options: {\n  client: ThirdwebClient;\n  uri: string;\n}): Promise<string | null> {\n  let uri = options.uri;\n  // parse valid nft spec (CAIP-22/CAIP-29)\n  // @see: https://github.com/ChainAgnostic/CAIPs/tree/master/CAIPs\n  if (uri.startsWith(\"did:nft:\")) {\n    // convert DID to CAIP\n    uri = uri.replace(\"did:nft:\", \"\").replace(/_/g, \"/\");\n  }\n\n  const [reference = \"\", asset_namespace = \"\", tokenID = \"\"] = uri.split(\"/\");\n  const [eip_namespace, chainID] = reference.split(\":\");\n  const [erc_namespace, contractAddress] = asset_namespace.split(\":\");\n\n  if (!eip_namespace || eip_namespace.toLowerCase() !== \"eip155\") {\n    throw new Error(\n      `Invalid EIP namespace, expected EIP155, got: \"${eip_namespace}\"`,\n    );\n  }\n  if (!chainID) {\n    throw new Error(\"Chain ID not found\");\n  }\n  if (!contractAddress || !isAddress(contractAddress)) {\n    throw new Error(\"Contract address not found\");\n  }\n  if (!tokenID) {\n    throw new Error(\"Token ID not found\");\n  }\n  const chain = getCachedChain(Number(chainID));\n  const contract = getContract({\n    address: contractAddress,\n    chain,\n    client: options.client,\n  });\n  switch (erc_namespace) {\n    case \"erc721\": {\n      const { getNFT } = await import(\"../../extensions/erc721/read/getNFT.js\");\n      const nft = await getNFT({\n        contract,\n        tokenId: BigInt(tokenID),\n      });\n      return nft.metadata.image ?? null;\n    }\n    case \"erc1155\": {\n      const { getNFT } = await import(\n        \"../../extensions/erc1155/read/getNFT.js\"\n      );\n      const nft = await getNFT({\n        contract,\n        tokenId: BigInt(tokenID),\n      });\n      return nft.metadata.image ?? null;\n    }\n\n    default: {\n      throw new Error(\n        `Invalid ERC namespace, expected ERC721 or ERC1155, got: \"${erc_namespace}\"`,\n      );\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}