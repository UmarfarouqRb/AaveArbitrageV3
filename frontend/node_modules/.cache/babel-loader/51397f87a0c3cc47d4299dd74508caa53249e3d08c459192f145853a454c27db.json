{"ast":null,"code":"import { ethereum } from \"../../chains/chain-definitions/ethereum.js\";\nimport { getContract } from \"../../contract/contract.js\";\nimport { toHex } from \"../../utils/encoding/hex.js\";\nimport { packetToBytes } from \"../../utils/ens/packetToBytes.js\";\nimport { withCache } from \"../../utils/promise/withCache.js\";\nimport { reverse } from \"./__generated__/UniversalResolver/read/reverse.js\";\nimport { UNIVERSAL_RESOLVER_ADDRESS } from \"./constants.js\";\n/**\n * Resolves the primary name for a specified address.\n * @param options - The options for resolving an ENS address.\n * @example\n * ```ts\n * import { resolveName } from \"thirdweb/extensions/ens\";\n * const name = await resolveName({\n *    client,\n *    address: \"0x1234...\",\n * });\n * ```\n * @extension ENS\n * @returns A promise that resolves to the Ethereum address.\n */\nexport async function resolveName(options) {\n  const {\n    client,\n    address,\n    resolverAddress,\n    resolverChain\n  } = options;\n  return withCache(async () => {\n    const contract = getContract({\n      address: resolverAddress || UNIVERSAL_RESOLVER_ADDRESS,\n      chain: resolverChain || ethereum,\n      client\n    });\n    const reverseName = toHex(packetToBytes(\"\".concat(address.toLowerCase().substring(2), \".addr.reverse\")));\n    const [name, resolvedAddress] = await reverse({\n      contract,\n      reverseName\n    }).catch(e => {\n      if (\"data\" in e && e.data === \"0x7199966d\") {\n        return [null, address];\n      }\n      throw e;\n    });\n    if (address.toLowerCase() !== resolvedAddress.toLowerCase()) {\n      return null;\n    }\n    return name;\n  }, {\n    cacheKey: \"ens:name:\".concat((resolverChain === null || resolverChain === void 0 ? void 0 : resolverChain.id) || 1, \":\").concat(address),\n    // 1min cache\n    cacheTime: 60 * 1000\n  });\n}","map":{"version":3,"names":["ethereum","getContract","toHex","packetToBytes","withCache","reverse","UNIVERSAL_RESOLVER_ADDRESS","resolveName","options","client","address","resolverAddress","resolverChain","contract","chain","reverseName","concat","toLowerCase","substring","name","resolvedAddress","catch","e","data","cacheKey","id","cacheTime"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/extensions/ens/resolve-name.ts"],"sourcesContent":["import type { Address } from \"abitype\";\nimport { ethereum } from \"../../chains/chain-definitions/ethereum.js\";\nimport type { Chain } from \"../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { getContract } from \"../../contract/contract.js\";\nimport { toHex } from \"../../utils/encoding/hex.js\";\nimport { packetToBytes } from \"../../utils/ens/packetToBytes.js\";\nimport { withCache } from \"../../utils/promise/withCache.js\";\nimport { reverse } from \"./__generated__/UniversalResolver/read/reverse.js\";\nimport { UNIVERSAL_RESOLVER_ADDRESS } from \"./constants.js\";\n\n/**\n * @extension ENS\n */\nexport type ResolveNameOptions = {\n  client: ThirdwebClient;\n  address: Address;\n  resolverAddress?: string;\n  resolverChain?: Chain;\n};\n\n/**\n * Resolves the primary name for a specified address.\n * @param options - The options for resolving an ENS address.\n * @example\n * ```ts\n * import { resolveName } from \"thirdweb/extensions/ens\";\n * const name = await resolveName({\n *    client,\n *    address: \"0x1234...\",\n * });\n * ```\n * @extension ENS\n * @returns A promise that resolves to the Ethereum address.\n */\nexport async function resolveName(options: ResolveNameOptions) {\n  const { client, address, resolverAddress, resolverChain } = options;\n\n  return withCache(\n    async () => {\n      const contract = getContract({\n        address: resolverAddress || UNIVERSAL_RESOLVER_ADDRESS,\n        chain: resolverChain || ethereum,\n        client,\n      });\n\n      const reverseName = toHex(\n        packetToBytes(`${address.toLowerCase().substring(2)}.addr.reverse`),\n      );\n\n      const [name, resolvedAddress] = await reverse({\n        contract,\n        reverseName,\n      }).catch((e) => {\n        if (\"data\" in e && e.data === \"0x7199966d\") {\n          return [null, address] as const;\n        }\n        throw e;\n      });\n\n      if (address.toLowerCase() !== resolvedAddress.toLowerCase()) {\n        return null;\n      }\n\n      return name;\n    },\n    {\n      cacheKey: `ens:name:${resolverChain?.id || 1}:${address}`,\n      // 1min cache\n      cacheTime: 60 * 1000,\n    },\n  );\n}\n"],"mappings":"AACA,SAASA,QAAQ,QAAQ,4CAA4C;AAGrE,SAASC,WAAW,QAAQ,4BAA4B;AACxD,SAASC,KAAK,QAAQ,6BAA6B;AACnD,SAASC,aAAa,QAAQ,kCAAkC;AAChE,SAASC,SAAS,QAAQ,kCAAkC;AAC5D,SAASC,OAAO,QAAQ,mDAAmD;AAC3E,SAASC,0BAA0B,QAAQ,gBAAgB;AAY3D;;;;;;;;;;;;;;AAcA,OAAO,eAAeC,WAAWA,CAACC,OAA2B;EAC3D,MAAM;IAAEC,MAAM;IAAEC,OAAO;IAAEC,eAAe;IAAEC;EAAa,CAAE,GAAGJ,OAAO;EAEnE,OAAOJ,SAAS,CACd,YAAW;IACT,MAAMS,QAAQ,GAAGZ,WAAW,CAAC;MAC3BS,OAAO,EAAEC,eAAe,IAAIL,0BAA0B;MACtDQ,KAAK,EAAEF,aAAa,IAAIZ,QAAQ;MAChCS;KACD,CAAC;IAEF,MAAMM,WAAW,GAAGb,KAAK,CACvBC,aAAa,IAAAa,MAAA,CAAIN,OAAO,CAACO,WAAW,EAAE,CAACC,SAAS,CAAC,CAAC,CAAC,kBAAe,CAAC,CACpE;IAED,MAAM,CAACC,IAAI,EAAEC,eAAe,CAAC,GAAG,MAAMf,OAAO,CAAC;MAC5CQ,QAAQ;MACRE;KACD,CAAC,CAACM,KAAK,CAAEC,CAAC,IAAI;MACb,IAAI,MAAM,IAAIA,CAAC,IAAIA,CAAC,CAACC,IAAI,KAAK,YAAY,EAAE;QAC1C,OAAO,CAAC,IAAI,EAAEb,OAAO,CAAU;MACjC;MACA,MAAMY,CAAC;IACT,CAAC,CAAC;IAEF,IAAIZ,OAAO,CAACO,WAAW,EAAE,KAAKG,eAAe,CAACH,WAAW,EAAE,EAAE;MAC3D,OAAO,IAAI;IACb;IAEA,OAAOE,IAAI;EACb,CAAC,EACD;IACEK,QAAQ,cAAAR,MAAA,CAAc,CAAAJ,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAEa,EAAE,KAAI,CAAC,OAAAT,MAAA,CAAIN,OAAO,CAAE;IACzD;IACAgB,SAAS,EAAE,EAAE,GAAG;GACjB,CACF;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}