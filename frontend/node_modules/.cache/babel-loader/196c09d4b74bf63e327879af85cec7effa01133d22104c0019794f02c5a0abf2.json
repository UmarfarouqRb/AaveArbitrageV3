{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport * as ox__Hex from \"ox/Hex\";\nimport * as ox__TypedData from \"ox/TypedData\";\nimport { trackTransaction } from \"../../analytics/track/transaction.js\";\nimport { getCachedChain, getChainMetadata } from \"../../chains/utils.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { numberToHex, stringToHex, uint8ArrayToHex } from \"../../utils/encoding/hex.js\";\nimport { stringify } from \"../../utils/json.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parse-typed-data.js\";\nimport { COINBASE } from \"../constants.js\";\nimport { toGetCallsStatusResponse } from \"../eip5792/get-calls-status.js\";\nimport { toGetCapabilitiesResult } from \"../eip5792/get-capabilities.js\";\nimport { toProviderCallParams } from \"../eip5792/send-calls.js\";\nimport { getValidPublicRPCUrl } from \"../utils/chains.js\";\nimport { getDefaultAppMetadata } from \"../utils/defaultDappMetadata.js\";\nimport { normalizeChainId } from \"../utils/normalizeChainId.js\";\nimport { showCoinbasePopup } from \"./utils.js\";\n// Need to keep the provider around because it keeps a single popup window connection behind the scenes\n// this should be ok since all the creation options are provided at build time\nlet _provider;\n/**\n * @internal\n */\nexport async function getCoinbaseWebProvider(options) {\n  if (!_provider) {\n    var _options$appMetadata, _options$appMetadata2;\n    let CoinbaseWalletSDK = (await import(\"@coinbase/wallet-sdk\")).default;\n    // Workaround for Vite dev import errors\n    // https://github.com/vitejs/vite/issues/7112\n    if (typeof CoinbaseWalletSDK !== \"function\" && typeof CoinbaseWalletSDK.default === \"function\") {\n      CoinbaseWalletSDK = CoinbaseWalletSDK.default;\n    }\n    // @ts-expect-error This import error is not visible to TypeScript\n    const client = new CoinbaseWalletSDK({\n      appChainIds: options !== null && options !== void 0 && options.chains ? options.chains.map(c => c.id) : undefined,\n      appLogoUrl: (options === null || options === void 0 || (_options$appMetadata = options.appMetadata) === null || _options$appMetadata === void 0 ? void 0 : _options$appMetadata.logoUrl) || getDefaultAppMetadata().logoUrl,\n      appName: (options === null || options === void 0 || (_options$appMetadata2 = options.appMetadata) === null || _options$appMetadata2 === void 0 ? void 0 : _options$appMetadata2.name) || getDefaultAppMetadata().name\n    });\n    const provider = client.makeWeb3Provider(options === null || options === void 0 ? void 0 : options.walletConfig);\n    _provider = provider;\n    return provider;\n  }\n  return _provider;\n}\n/**\n * Checks if the provided wallet is a Coinbase SDK wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is a Coinbase SDK wallet, false otherwise.\n */\nexport function isCoinbaseSDKWallet(wallet) {\n  return wallet.id === COINBASE;\n}\nfunction createAccount(_ref) {\n  let {\n    provider,\n    address,\n    client\n  } = _ref;\n  const account = {\n    address: getAddress(address),\n    onTransactionRequested: async () => {\n      // make sure to show the coinbase popup BEFORE doing any transaction preprocessing\n      // otherwise the popup might get blocked in safari\n      // but only if using cb smart wallet (web based)\n      if (window.localStorage) {\n        // this is the local storage key for the signer type in the cb web sdk\n        // value can be \"scw\" (web) or \"walletlink\" (mobile wallet)\n        const signerType = window.localStorage.getItem(\"-CBWSDK:SignerConfigurator:SignerType\");\n        if (signerType === \"scw\") {\n          await showCoinbasePopup(provider);\n        }\n      }\n    },\n    async sendTransaction(tx) {\n      var _tx$to;\n      const transactionHash = await provider.request({\n        method: \"eth_sendTransaction\",\n        params: [{\n          accessList: tx.accessList,\n          data: tx.data,\n          from: getAddress(address),\n          gas: tx.gas ? numberToHex(tx.gas) : undefined,\n          to: tx.to,\n          value: tx.value ? numberToHex(tx.value) : undefined\n        }]\n      });\n      trackTransaction({\n        chainId: tx.chainId,\n        client: client,\n        contractAddress: (_tx$to = tx.to) !== null && _tx$to !== void 0 ? _tx$to : undefined,\n        gasPrice: tx.gasPrice,\n        transactionHash,\n        walletAddress: getAddress(address),\n        walletType: COINBASE\n      });\n      return {\n        transactionHash\n      };\n    },\n    async signMessage(_ref2) {\n      let {\n        message\n      } = _ref2;\n      if (!account.address) {\n        throw new Error(\"Provider not setup\");\n      }\n      const messageToSign = (() => {\n        if (typeof message === \"string\") {\n          return stringToHex(message);\n        }\n        if (message.raw instanceof Uint8Array) {\n          return uint8ArrayToHex(message.raw);\n        }\n        return message.raw;\n      })();\n      const res = await provider.request({\n        method: \"personal_sign\",\n        params: [messageToSign, account.address]\n      });\n      if (!ox__Hex.validate(res)) {\n        throw new Error(\"Invalid signature returned\");\n      }\n      return res;\n    },\n    async signTypedData(typedData) {\n      if (!account.address) {\n        throw new Error(\"Provider not setup\");\n      }\n      const {\n        domain,\n        message,\n        primaryType\n      } = parseTypedData(typedData);\n      const types = _objectSpread({\n        EIP712Domain: ox__TypedData.extractEip712DomainTypes(domain)\n      }, typedData.types);\n      // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n      // as we can't statically check this with TypeScript.\n      ox__TypedData.validate({\n        domain,\n        message,\n        primaryType,\n        types\n      });\n      const stringifiedData = ox__TypedData.serialize({\n        domain: domain !== null && domain !== void 0 ? domain : {},\n        message,\n        primaryType,\n        types\n      });\n      const res = await provider.request({\n        method: \"eth_signTypedData_v4\",\n        params: [account.address, stringifiedData]\n      });\n      if (!ox__Hex.validate(res)) {\n        throw new Error(\"Invalid signed payload returned\");\n      }\n      return res;\n    },\n    sendCalls: async options => {\n      try {\n        const {\n          callParams,\n          chain\n        } = await toProviderCallParams(options, account);\n        const callId = await provider.request({\n          method: \"wallet_sendCalls\",\n          params: callParams\n        });\n        if (callId && typeof callId === \"object\" && \"id\" in callId) {\n          return {\n            chain,\n            client,\n            id: callId.id\n          };\n        }\n        return {\n          chain,\n          client,\n          id: callId\n        };\n      } catch (error) {\n        if (/unsupport|not support/i.test(error.message)) {\n          throw new Error(\"\".concat(COINBASE, \" errored calling wallet_sendCalls, with error: \").concat(error instanceof Error ? error.message : stringify(error)));\n        }\n        throw error;\n      }\n    },\n    async getCallsStatus(options) {\n      try {\n        const rawResponse = await provider.request({\n          method: \"wallet_getCallsStatus\",\n          params: [options.id]\n        });\n        return toGetCallsStatusResponse(rawResponse);\n      } catch (error) {\n        if (/unsupport|not support/i.test(error.message)) {\n          throw new Error(\"\".concat(COINBASE, \" does not support wallet_getCallsStatus, reach out to them directly to request EIP-5792 support.\"));\n        }\n        throw error;\n      }\n    },\n    async getCapabilities(options) {\n      const chainId = options.chainId;\n      try {\n        const result = await provider.request({\n          method: \"wallet_getCapabilities\",\n          params: [getAddress(account.address)]\n        });\n        return toGetCapabilitiesResult(result, chainId);\n      } catch (error) {\n        if (/unsupport|not support|not available/i.test(error.message)) {\n          return {\n            message: \"\".concat(COINBASE, \" does not support wallet_getCapabilities, reach out to them directly to request EIP-5792 support.\")\n          };\n        }\n        throw error;\n      }\n    }\n  };\n  return account;\n}\nfunction onConnect(address, chain, provider, emitter, client) {\n  const account = createAccount({\n    address,\n    client,\n    provider\n  });\n  async function disconnect() {\n    provider.removeListener(\"accountsChanged\", onAccountsChanged);\n    provider.removeListener(\"chainChanged\", onChainChanged);\n    provider.removeListener(\"disconnect\", onDisconnect);\n    await provider.disconnect();\n  }\n  async function onDisconnect() {\n    disconnect();\n    emitter.emit(\"disconnect\", undefined);\n  }\n  function onAccountsChanged(accounts) {\n    if (accounts[0]) {\n      const newAccount = createAccount({\n        address: getAddress(accounts[0]),\n        client,\n        provider\n      });\n      emitter.emit(\"accountChanged\", newAccount);\n      emitter.emit(\"accountsChanged\", accounts);\n    } else {\n      onDisconnect();\n    }\n  }\n  function onChainChanged(newChainId) {\n    const newChain = getCachedChain(normalizeChainId(newChainId));\n    emitter.emit(\"chainChanged\", newChain);\n  }\n  // subscribe to events\n  provider.on(\"accountsChanged\", onAccountsChanged);\n  provider.on(\"chainChanged\", onChainChanged);\n  provider.on(\"disconnect\", onDisconnect);\n  return [account, chain, onDisconnect, newChain => switchChainCoinbaseWalletSDK(provider, newChain)];\n}\n/**\n * @internal\n */\nexport async function connectCoinbaseWalletSDK(options, emitter, provider) {\n  const accounts = await provider.request({\n    method: \"eth_requestAccounts\"\n  });\n  if (!accounts[0]) {\n    throw new Error(\"No accounts found\");\n  }\n  const address = getAddress(accounts[0]);\n  const connectedChainId = await provider.request({\n    method: \"eth_chainId\"\n  });\n  const chainId = normalizeChainId(connectedChainId);\n  let chain = options.chain && options.chain.id === chainId ? options.chain : getCachedChain(chainId);\n  // Switch to chain if provided\n  if (chainId && options !== null && options !== void 0 && options.chain && chainId !== (options === null || options === void 0 ? void 0 : options.chain.id)) {\n    await switchChainCoinbaseWalletSDK(provider, options.chain);\n    chain = options.chain;\n  }\n  return onConnect(address, chain, provider, emitter, options.client);\n}\n/**\n * @internal\n */\nexport async function autoConnectCoinbaseWalletSDK(options, emitter, provider) {\n  // connected accounts\n  const addresses = await provider.request({\n    method: \"eth_accounts\"\n  });\n  const address = addresses[0];\n  if (!address) {\n    throw new Error(\"No accounts found\");\n  }\n  const connectedChainId = await provider.request({\n    method: \"eth_chainId\"\n  });\n  const chainId = normalizeChainId(connectedChainId);\n  const chain = options.chain && options.chain.id === chainId ? options.chain : getCachedChain(chainId);\n  return onConnect(address, chain, provider, emitter, options.client);\n}\nasync function switchChainCoinbaseWalletSDK(provider, chain) {\n  const chainIdHex = numberToHex(chain.id);\n  try {\n    await provider.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{\n        chainId: chainIdHex\n      }]\n    });\n  } catch (error) {\n    const apiChain = await getChainMetadata(chain);\n    // Indicates chain is not added to provider\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n    if ((error === null || error === void 0 ? void 0 : error.code) === 4902) {\n      var _apiChain$explorers;\n      // try to add the chain\n      await provider.request({\n        method: \"wallet_addEthereumChain\",\n        params: [{\n          blockExplorerUrls: ((_apiChain$explorers = apiChain.explorers) === null || _apiChain$explorers === void 0 ? void 0 : _apiChain$explorers.map(x => x.url)) || [],\n          chainId: chainIdHex,\n          chainName: apiChain.name,\n          nativeCurrency: apiChain.nativeCurrency,\n          // no client id on purpose here\n          rpcUrls: getValidPublicRPCUrl(apiChain)\n        }]\n      });\n    }\n  }\n}","map":{"version":3,"names":["ox__Hex","ox__TypedData","trackTransaction","getCachedChain","getChainMetadata","getAddress","numberToHex","stringToHex","uint8ArrayToHex","stringify","parseTypedData","COINBASE","toGetCallsStatusResponse","toGetCapabilitiesResult","toProviderCallParams","getValidPublicRPCUrl","getDefaultAppMetadata","normalizeChainId","showCoinbasePopup","_provider","getCoinbaseWebProvider","options","_options$appMetadata","_options$appMetadata2","CoinbaseWalletSDK","default","client","appChainIds","chains","map","c","id","undefined","appLogoUrl","appMetadata","logoUrl","appName","name","provider","makeWeb3Provider","walletConfig","isCoinbaseSDKWallet","wallet","createAccount","_ref","address","account","onTransactionRequested","window","localStorage","signerType","getItem","sendTransaction","tx","_tx$to","transactionHash","request","method","params","accessList","data","from","gas","to","value","chainId","contractAddress","gasPrice","walletAddress","walletType","signMessage","_ref2","message","Error","messageToSign","raw","Uint8Array","res","validate","signTypedData","typedData","domain","primaryType","types","_objectSpread","EIP712Domain","extractEip712DomainTypes","stringifiedData","serialize","sendCalls","callParams","chain","callId","error","test","concat","getCallsStatus","rawResponse","getCapabilities","result","onConnect","emitter","disconnect","removeListener","onAccountsChanged","onChainChanged","onDisconnect","emit","accounts","newAccount","newChainId","newChain","on","switchChainCoinbaseWalletSDK","connectCoinbaseWalletSDK","connectedChainId","autoConnectCoinbaseWalletSDK","addresses","chainIdHex","apiChain","code","_apiChain$explorers","blockExplorerUrls","explorers","x","url","chainName","nativeCurrency","rpcUrls"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/wallets/coinbase/coinbase-web.ts"],"sourcesContent":["import type { ProviderInterface } from \"@coinbase/wallet-sdk\";\nimport type { Preference } from \"@coinbase/wallet-sdk/dist/core/provider/interface.js\";\nimport type { Address } from \"abitype\";\nimport * as ox__Hex from \"ox/Hex\";\nimport * as ox__TypedData from \"ox/TypedData\";\nimport { trackTransaction } from \"../../analytics/track/transaction.js\";\nimport type { Chain } from \"../../chains/types.js\";\nimport { getCachedChain, getChainMetadata } from \"../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport {\n  type Hex,\n  numberToHex,\n  stringToHex,\n  uint8ArrayToHex,\n} from \"../../utils/encoding/hex.js\";\nimport { stringify } from \"../../utils/json.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parse-typed-data.js\";\nimport { COINBASE } from \"../constants.js\";\nimport { toGetCallsStatusResponse } from \"../eip5792/get-calls-status.js\";\nimport { toGetCapabilitiesResult } from \"../eip5792/get-capabilities.js\";\nimport { toProviderCallParams } from \"../eip5792/send-calls.js\";\nimport type {\n  GetCallsStatusRawResponse,\n  WalletCapabilities,\n} from \"../eip5792/types.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n  Wallet,\n} from \"../interfaces/wallet.js\";\nimport type { AppMetadata, DisconnectFn, SwitchChainFn } from \"../types.js\";\nimport { getValidPublicRPCUrl } from \"../utils/chains.js\";\nimport { getDefaultAppMetadata } from \"../utils/defaultDappMetadata.js\";\nimport { normalizeChainId } from \"../utils/normalizeChainId.js\";\nimport type { WalletEmitter } from \"../wallet-emitter.js\";\nimport type {\n  CreateWalletArgs,\n  WalletConnectionOption,\n} from \"../wallet-types.js\";\nimport { showCoinbasePopup } from \"./utils.js\";\n\nexport type CoinbaseWalletCreationOptions =\n  | {\n      /**\n       * Metadata of the dApp that will be passed to connected wallet.\n       *\n       * Some wallets may display this information to the user.\n       *\n       * Setting this property is highly recommended. If this is not set, Below default metadata will be used:\n       *\n       * ```ts\n       * {\n       *   name: \"thirdweb powered dApp\",\n       *   url: \"https://thirdweb.com\",\n       *   description: \"thirdweb powered dApp\",\n       *   logoUrl: \"https://thirdweb.com/favicon.ico\",\n       * };\n       * ```\n       */\n      appMetadata?: AppMetadata;\n\n      /**\n       * Wallet configuration, choices are 'all' | 'smartWalletOnly' | 'eoaOnly'\n       * @default 'all'\n       * @example\n       * ```ts\n       * {\n       *  walletConfig: {\n       *   options: 'all',\n       *  }\n       * }\n       * ```\n       */\n      walletConfig?: Preference;\n\n      /**\n       * Chains that the wallet can switch chains to, will default to the first chain in this array on first connection.\n       * @default Ethereum mainnet\n       * @example\n       * ```ts\n       * {\n       *   chains: [base, optimisim]\n       * }\n       */\n      chains?: Chain[];\n\n      mobileConfig?: {\n        /**\n         * The univeral callback URL to redirect the user to after they have completed the wallet connection with the cb wallet app.\n         * This needs to be setup as a Universal link for iOS https://docs.cdp.coinbase.com/wallet-sdk/docs/ios-setup/\n         * and App link on Android https://docs.cdp.coinbase.com/wallet-sdk/docs/android-setup/\n         */\n        callbackURL?: string;\n      };\n    }\n  | undefined;\n\n/**\n * Options for connecting to the CoinbaseSDK Wallet\n */\nexport type CoinbaseSDKWalletConnectionOptions = {\n  /**\n   * The Thirdweb client object\n   */\n  client: ThirdwebClient;\n\n  /**\n   * If you want the wallet to be connected to a specific blockchain, you can pass a `Chain` object to the `connect` method.\n   * This will trigger a chain switch if the wallet provider is not already connected to the specified chain.\n   *\n   * You can create a `Chain` object using the [`defineChain`](https://portal.thirdweb.com/references/typescript/v5/defineChain) function.\n   * At minimum, you need to pass the `id` of the blockchain.\n   *\n   * ```ts\n   * import { defineChain } from \"thirdweb\";\n   * const myChain = defineChain(myChainId);\n   *\n   * const address = await wallet.connect({ chain: myChain })\n   */\n  chain?: Chain;\n};\n\n// Need to keep the provider around because it keeps a single popup window connection behind the scenes\n// this should be ok since all the creation options are provided at build time\nlet _provider: ProviderInterface | undefined;\n\n/**\n * @internal\n */\nexport async function getCoinbaseWebProvider(\n  options?: CreateWalletArgs<typeof COINBASE>[1],\n): Promise<ProviderInterface> {\n  if (!_provider) {\n    let CoinbaseWalletSDK: unknown = (await import(\"@coinbase/wallet-sdk\"))\n      .default;\n    // Workaround for Vite dev import errors\n    // https://github.com/vitejs/vite/issues/7112\n    if (\n      typeof CoinbaseWalletSDK !== \"function\" &&\n      typeof (CoinbaseWalletSDK as { default: unknown }).default === \"function\"\n    ) {\n      CoinbaseWalletSDK = (\n        CoinbaseWalletSDK as unknown as { default: typeof CoinbaseWalletSDK }\n      ).default;\n    }\n\n    // @ts-expect-error This import error is not visible to TypeScript\n    const client = new CoinbaseWalletSDK({\n      appChainIds: options?.chains\n        ? options.chains.map((c) => c.id)\n        : undefined,\n      appLogoUrl:\n        options?.appMetadata?.logoUrl || getDefaultAppMetadata().logoUrl,\n      appName: options?.appMetadata?.name || getDefaultAppMetadata().name,\n    });\n\n    const provider = client.makeWeb3Provider(options?.walletConfig);\n    _provider = provider;\n    return provider;\n  }\n  return _provider;\n}\n\n/**\n * Checks if the provided wallet is a Coinbase SDK wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is a Coinbase SDK wallet, false otherwise.\n */\nexport function isCoinbaseSDKWallet(\n  wallet: Wallet,\n): wallet is Wallet<typeof COINBASE> {\n  return wallet.id === COINBASE;\n}\n\nfunction createAccount({\n  provider,\n  address,\n  client,\n}: {\n  provider: ProviderInterface;\n  address: string;\n  client: ThirdwebClient;\n}) {\n  const account: Account = {\n    address: getAddress(address),\n    onTransactionRequested: async () => {\n      // make sure to show the coinbase popup BEFORE doing any transaction preprocessing\n      // otherwise the popup might get blocked in safari\n      // but only if using cb smart wallet (web based)\n      if (window.localStorage) {\n        // this is the local storage key for the signer type in the cb web sdk\n        // value can be \"scw\" (web) or \"walletlink\" (mobile wallet)\n        const signerType = window.localStorage.getItem(\n          \"-CBWSDK:SignerConfigurator:SignerType\",\n        );\n        if (signerType === \"scw\") {\n          await showCoinbasePopup(provider);\n        }\n      }\n    },\n    async sendTransaction(tx: SendTransactionOption) {\n      const transactionHash = (await provider.request({\n        method: \"eth_sendTransaction\",\n        params: [\n          {\n            accessList: tx.accessList,\n            data: tx.data,\n            from: getAddress(address),\n            gas: tx.gas ? numberToHex(tx.gas) : undefined,\n            to: tx.to as Address,\n            value: tx.value ? numberToHex(tx.value) : undefined,\n          },\n        ],\n      })) as Hex;\n\n      trackTransaction({\n        chainId: tx.chainId,\n        client: client,\n        contractAddress: tx.to ?? undefined,\n        gasPrice: tx.gasPrice,\n        transactionHash,\n        walletAddress: getAddress(address),\n        walletType: COINBASE,\n      });\n\n      return {\n        transactionHash,\n      };\n    },\n    async signMessage({ message }) {\n      if (!account.address) {\n        throw new Error(\"Provider not setup\");\n      }\n\n      const messageToSign = (() => {\n        if (typeof message === \"string\") {\n          return stringToHex(message);\n        }\n        if (message.raw instanceof Uint8Array) {\n          return uint8ArrayToHex(message.raw);\n        }\n        return message.raw;\n      })();\n\n      const res = await provider.request({\n        method: \"personal_sign\",\n        params: [messageToSign, account.address],\n      });\n      if (!ox__Hex.validate(res)) {\n        throw new Error(\"Invalid signature returned\");\n      }\n      return res;\n    },\n    async signTypedData(typedData) {\n      if (!account.address) {\n        throw new Error(\"Provider not setup\");\n      }\n\n      const { domain, message, primaryType } = parseTypedData(\n        typedData,\n      ) as ox__TypedData.Definition;\n\n      const types = {\n        EIP712Domain: ox__TypedData.extractEip712DomainTypes(domain),\n        ...typedData.types,\n      };\n\n      // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n      // as we can't statically check this with TypeScript.\n      ox__TypedData.validate({ domain, message, primaryType, types });\n\n      const stringifiedData = ox__TypedData.serialize({\n        domain: domain ?? {},\n        message,\n        primaryType,\n        types,\n      });\n\n      const res = await provider.request({\n        method: \"eth_signTypedData_v4\",\n        params: [account.address, stringifiedData],\n      });\n      if (!ox__Hex.validate(res)) {\n        throw new Error(\"Invalid signed payload returned\");\n      }\n      return res;\n    },\n    sendCalls: async (options) => {\n      try {\n        const { callParams, chain } = await toProviderCallParams(\n          options,\n          account,\n        );\n        const callId = await provider.request({\n          method: \"wallet_sendCalls\",\n          params: callParams,\n        });\n        if (callId && typeof callId === \"object\" && \"id\" in callId) {\n          return { chain, client, id: callId.id as string };\n        }\n        return { chain, client, id: callId as string };\n      } catch (error) {\n        if (/unsupport|not support/i.test((error as Error).message)) {\n          throw new Error(\n            `${COINBASE} errored calling wallet_sendCalls, with error: ${error instanceof Error ? error.message : stringify(error)}`,\n          );\n        }\n        throw error;\n      }\n    },\n    async getCallsStatus(options) {\n      try {\n        const rawResponse = (await provider.request({\n          method: \"wallet_getCallsStatus\",\n          params: [options.id],\n        })) as GetCallsStatusRawResponse;\n        return toGetCallsStatusResponse(rawResponse);\n      } catch (error) {\n        if (/unsupport|not support/i.test((error as Error).message)) {\n          throw new Error(\n            `${COINBASE} does not support wallet_getCallsStatus, reach out to them directly to request EIP-5792 support.`,\n          );\n        }\n        throw error;\n      }\n    },\n    async getCapabilities(options) {\n      const chainId = options.chainId;\n      try {\n        const result = (await provider.request({\n          method: \"wallet_getCapabilities\",\n          params: [getAddress(account.address)],\n        })) as Record<string, WalletCapabilities>;\n        return toGetCapabilitiesResult(result, chainId);\n      } catch (error: unknown) {\n        if (\n          /unsupport|not support|not available/i.test((error as Error).message)\n        ) {\n          return {\n            message: `${COINBASE} does not support wallet_getCapabilities, reach out to them directly to request EIP-5792 support.`,\n          };\n        }\n        throw error;\n      }\n    },\n  };\n\n  return account;\n}\n\nfunction onConnect(\n  address: string,\n  chain: Chain,\n  provider: ProviderInterface,\n  emitter: WalletEmitter<typeof COINBASE>,\n  client: ThirdwebClient,\n): [Account, Chain, DisconnectFn, SwitchChainFn] {\n  const account = createAccount({ address, client, provider });\n\n  async function disconnect() {\n    provider.removeListener(\"accountsChanged\", onAccountsChanged);\n    provider.removeListener(\"chainChanged\", onChainChanged);\n    provider.removeListener(\"disconnect\", onDisconnect);\n    await provider.disconnect();\n  }\n\n  async function onDisconnect() {\n    disconnect();\n    emitter.emit(\"disconnect\", undefined);\n  }\n\n  function onAccountsChanged(accounts: string[]) {\n    if (accounts[0]) {\n      const newAccount = createAccount({\n        address: getAddress(accounts[0]),\n        client,\n        provider,\n      });\n      emitter.emit(\"accountChanged\", newAccount);\n      emitter.emit(\"accountsChanged\", accounts);\n    } else {\n      onDisconnect();\n    }\n  }\n\n  function onChainChanged(newChainId: string) {\n    const newChain = getCachedChain(normalizeChainId(newChainId));\n    emitter.emit(\"chainChanged\", newChain);\n  }\n\n  // subscribe to events\n  provider.on(\"accountsChanged\", onAccountsChanged);\n  provider.on(\"chainChanged\", onChainChanged);\n  provider.on(\"disconnect\", onDisconnect);\n\n  return [\n    account,\n    chain,\n    onDisconnect,\n    (newChain) => switchChainCoinbaseWalletSDK(provider, newChain),\n  ];\n}\n\n/**\n * @internal\n */\nexport async function connectCoinbaseWalletSDK(\n  options: WalletConnectionOption<typeof COINBASE>,\n  emitter: WalletEmitter<typeof COINBASE>,\n  provider: ProviderInterface,\n): Promise<ReturnType<typeof onConnect>> {\n  const accounts = (await provider.request({\n    method: \"eth_requestAccounts\",\n  })) as string[];\n\n  if (!accounts[0]) {\n    throw new Error(\"No accounts found\");\n  }\n\n  const address = getAddress(accounts[0]);\n\n  const connectedChainId = (await provider.request({\n    method: \"eth_chainId\",\n  })) as string | number;\n\n  const chainId = normalizeChainId(connectedChainId);\n  let chain =\n    options.chain && options.chain.id === chainId\n      ? options.chain\n      : getCachedChain(chainId);\n  // Switch to chain if provided\n  if (chainId && options?.chain && chainId !== options?.chain.id) {\n    await switchChainCoinbaseWalletSDK(provider, options.chain);\n    chain = options.chain;\n  }\n\n  return onConnect(address, chain, provider, emitter, options.client);\n}\n\n/**\n * @internal\n */\nexport async function autoConnectCoinbaseWalletSDK(\n  options: WalletConnectionOption<typeof COINBASE>,\n  emitter: WalletEmitter<typeof COINBASE>,\n  provider: ProviderInterface,\n): Promise<ReturnType<typeof onConnect>> {\n  // connected accounts\n  const addresses = (await provider.request({\n    method: \"eth_accounts\",\n  })) as string[];\n\n  const address = addresses[0];\n\n  if (!address) {\n    throw new Error(\"No accounts found\");\n  }\n\n  const connectedChainId = (await provider.request({\n    method: \"eth_chainId\",\n  })) as string | number;\n  const chainId = normalizeChainId(connectedChainId);\n  const chain =\n    options.chain && options.chain.id === chainId\n      ? options.chain\n      : getCachedChain(chainId);\n\n  return onConnect(address, chain, provider, emitter, options.client);\n}\n\nasync function switchChainCoinbaseWalletSDK(\n  provider: ProviderInterface,\n  chain: Chain,\n) {\n  const chainIdHex = numberToHex(chain.id);\n\n  try {\n    await provider.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{ chainId: chainIdHex }],\n    });\n  } catch (error) {\n    const apiChain = await getChainMetadata(chain);\n\n    // Indicates chain is not added to provider\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n    if ((error as any)?.code === 4902) {\n      // try to add the chain\n      await provider.request({\n        method: \"wallet_addEthereumChain\",\n        params: [\n          {\n            blockExplorerUrls: apiChain.explorers?.map((x) => x.url) || [],\n            chainId: chainIdHex,\n            chainName: apiChain.name,\n            nativeCurrency: apiChain.nativeCurrency, // no client id on purpose here\n            rpcUrls: getValidPublicRPCUrl(apiChain),\n          },\n        ],\n      });\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}