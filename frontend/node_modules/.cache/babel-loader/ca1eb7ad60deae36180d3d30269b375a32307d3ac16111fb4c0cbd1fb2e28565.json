{"ast":null,"code":"const encodeWeakMap = new WeakMap();\n/**\n * Encodes a transaction object into a hexadecimal string representation of the encoded data.\n * @param transaction - The transaction object to encode.\n * @returns A promise that resolves to the encoded data as a hexadecimal string.\n * @transaction\n * @example\n * ```ts\n * import { encode } from \"thirdweb\";\n * const encodedData = await encode(transaction);\n * ```\n */\nexport async function encode(transaction) {\n  if (encodeWeakMap.has(transaction)) {\n    // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set\n    return encodeWeakMap.get(transaction);\n  }\n  const promise = (async () => {\n    const [data, extraData, {\n      concatHex\n    }] = await Promise.all([getDataFromTx(transaction), getExtraCallDataFromTx(transaction), import(\"../../utils/encoding/helpers/concat-hex.js\")]);\n    if (extraData) {\n      return concatHex([data, extraData]);\n    }\n    return data;\n  })();\n  encodeWeakMap.set(transaction, promise);\n  return promise;\n}\n/**\n * Get the transaction.data (from a PreparedTransaction)\n * If the transaction does not have `data`, we default to \"0x\"\n * @internal\n */\nexport async function getDataFromTx(transaction) {\n  if (transaction.data === undefined) {\n    return \"0x\";\n  }\n  if (typeof transaction.data === \"function\") {\n    const data = await transaction.data();\n    if (!data) {\n      return \"0x\";\n    }\n    return data;\n  }\n  return transaction.data;\n}\n/**\n * Get the extraCallData from a PreparedTransaction\n * @internal\n * If extraCallData is \"0x\", we will return `undefined`\n * to simplify the code, since concatenating \"0x\" doesn't do anything\n */\nexport async function getExtraCallDataFromTx(transaction) {\n  if (!transaction.extraCallData) {\n    return undefined;\n  }\n  if (typeof transaction.extraCallData === \"function\") {\n    const extraData = await transaction.extraCallData();\n    if (!extraData) return undefined;\n    if (!extraData.startsWith(\"0x\")) {\n      throw Error(\"Invalid extra calldata - must be a hex string\");\n    }\n    if (extraData === \"0x\") {\n      return undefined;\n    }\n    return extraData;\n  }\n  if (!transaction.extraCallData.startsWith(\"0x\")) {\n    throw Error(\"Invalid extra calldata - must be a hex string\");\n  }\n  return transaction.extraCallData;\n}","map":{"version":3,"names":["encodeWeakMap","WeakMap","encode","transaction","has","get","promise","data","extraData","concatHex","Promise","all","getDataFromTx","getExtraCallDataFromTx","set","undefined","extraCallData","startsWith","Error"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/transaction/actions/encode.ts"],"sourcesContent":["import type { Abi, AbiFunction } from \"abitype\";\nimport type { Hex } from \"../../utils/encoding/hex.js\";\nimport type { PreparedTransaction } from \"../prepare-transaction.js\";\n\nconst encodeWeakMap = new WeakMap<\n  PreparedTransaction<Abi, AbiFunction>,\n  Promise<Hex>\n>();\n\n/**\n * Encodes a transaction object into a hexadecimal string representation of the encoded data.\n * @param transaction - The transaction object to encode.\n * @returns A promise that resolves to the encoded data as a hexadecimal string.\n * @transaction\n * @example\n * ```ts\n * import { encode } from \"thirdweb\";\n * const encodedData = await encode(transaction);\n * ```\n */\nexport async function encode<abi extends Abi, abiFn extends AbiFunction>(\n  transaction: PreparedTransaction<abi, abiFn>,\n): Promise<Hex> {\n  if (encodeWeakMap.has(transaction)) {\n    // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set\n    return encodeWeakMap.get(transaction)!;\n  }\n  const promise = (async () => {\n    const [data, extraData, { concatHex }] = await Promise.all([\n      getDataFromTx(transaction),\n      getExtraCallDataFromTx(transaction),\n      import(\"../../utils/encoding/helpers/concat-hex.js\"),\n    ]);\n    if (extraData) {\n      return concatHex([data, extraData]);\n    }\n    return data;\n  })();\n  encodeWeakMap.set(transaction, promise);\n  return promise;\n}\n\n/**\n * Get the transaction.data (from a PreparedTransaction)\n * If the transaction does not have `data`, we default to \"0x\"\n * @internal\n */\nexport async function getDataFromTx<abi extends Abi, abiFn extends AbiFunction>(\n  transaction: PreparedTransaction<abi, abiFn>,\n): Promise<Hex> {\n  if (transaction.data === undefined) {\n    return \"0x\";\n  }\n  if (typeof transaction.data === \"function\") {\n    const data = await transaction.data();\n    if (!data) {\n      return \"0x\";\n    }\n    return data;\n  }\n  return transaction.data;\n}\n\n/**\n * Get the extraCallData from a PreparedTransaction\n * @internal\n * If extraCallData is \"0x\", we will return `undefined`\n * to simplify the code, since concatenating \"0x\" doesn't do anything\n */\nexport async function getExtraCallDataFromTx<\n  abi extends Abi,\n  abiFn extends AbiFunction,\n>(transaction: PreparedTransaction<abi, abiFn>): Promise<Hex | undefined> {\n  if (!transaction.extraCallData) {\n    return undefined;\n  }\n  if (typeof transaction.extraCallData === \"function\") {\n    const extraData = await transaction.extraCallData();\n    if (!extraData) return undefined;\n    if (!extraData.startsWith(\"0x\")) {\n      throw Error(\"Invalid extra calldata - must be a hex string\");\n    }\n    if (extraData === \"0x\") {\n      return undefined;\n    }\n    return extraData;\n  }\n  if (!transaction.extraCallData.startsWith(\"0x\")) {\n    throw Error(\"Invalid extra calldata - must be a hex string\");\n  }\n  return transaction.extraCallData;\n}\n"],"mappings":"AAIA,MAAMA,aAAa,GAAG,IAAIC,OAAO,EAG9B;AAEH;;;;;;;;;;;AAWA,OAAO,eAAeC,MAAMA,CAC1BC,WAA4C;EAE5C,IAAIH,aAAa,CAACI,GAAG,CAACD,WAAW,CAAC,EAAE;IAClC;IACA,OAAOH,aAAa,CAACK,GAAG,CAACF,WAAW,CAAE;EACxC;EACA,MAAMG,OAAO,GAAG,CAAC,YAAW;IAC1B,MAAM,CAACC,IAAI,EAAEC,SAAS,EAAE;MAAEC;IAAS,CAAE,CAAC,GAAG,MAAMC,OAAO,CAACC,GAAG,CAAC,CACzDC,aAAa,CAACT,WAAW,CAAC,EAC1BU,sBAAsB,CAACV,WAAW,CAAC,EACnC,MAAM,CAAC,4CAA4C,CAAC,CACrD,CAAC;IACF,IAAIK,SAAS,EAAE;MACb,OAAOC,SAAS,CAAC,CAACF,IAAI,EAAEC,SAAS,CAAC,CAAC;IACrC;IACA,OAAOD,IAAI;EACb,CAAC,EAAC,CAAE;EACJP,aAAa,CAACc,GAAG,CAACX,WAAW,EAAEG,OAAO,CAAC;EACvC,OAAOA,OAAO;AAChB;AAEA;;;;;AAKA,OAAO,eAAeM,aAAaA,CACjCT,WAA4C;EAE5C,IAAIA,WAAW,CAACI,IAAI,KAAKQ,SAAS,EAAE;IAClC,OAAO,IAAI;EACb;EACA,IAAI,OAAOZ,WAAW,CAACI,IAAI,KAAK,UAAU,EAAE;IAC1C,MAAMA,IAAI,GAAG,MAAMJ,WAAW,CAACI,IAAI,EAAE;IACrC,IAAI,CAACA,IAAI,EAAE;MACT,OAAO,IAAI;IACb;IACA,OAAOA,IAAI;EACb;EACA,OAAOJ,WAAW,CAACI,IAAI;AACzB;AAEA;;;;;;AAMA,OAAO,eAAeM,sBAAsBA,CAG1CV,WAA4C;EAC5C,IAAI,CAACA,WAAW,CAACa,aAAa,EAAE;IAC9B,OAAOD,SAAS;EAClB;EACA,IAAI,OAAOZ,WAAW,CAACa,aAAa,KAAK,UAAU,EAAE;IACnD,MAAMR,SAAS,GAAG,MAAML,WAAW,CAACa,aAAa,EAAE;IACnD,IAAI,CAACR,SAAS,EAAE,OAAOO,SAAS;IAChC,IAAI,CAACP,SAAS,CAACS,UAAU,CAAC,IAAI,CAAC,EAAE;MAC/B,MAAMC,KAAK,CAAC,+CAA+C,CAAC;IAC9D;IACA,IAAIV,SAAS,KAAK,IAAI,EAAE;MACtB,OAAOO,SAAS;IAClB;IACA,OAAOP,SAAS;EAClB;EACA,IAAI,CAACL,WAAW,CAACa,aAAa,CAACC,UAAU,CAAC,IAAI,CAAC,EAAE;IAC/C,MAAMC,KAAK,CAAC,+CAA+C,CAAC;EAC9D;EACA,OAAOf,WAAW,CAACa,aAAa;AAClC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}