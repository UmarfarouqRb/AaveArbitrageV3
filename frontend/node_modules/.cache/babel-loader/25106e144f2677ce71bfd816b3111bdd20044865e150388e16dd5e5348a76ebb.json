{"ast":null,"code":"import { getContract } from \"../../../contract/contract.js\";\nimport { prepareContractCall } from \"../../../transaction/prepare-contract-call.js\";\nimport { readContract } from \"../../../transaction/read-contract.js\";\nimport { isHex, stringToHex } from \"../../../utils/encoding/hex.js\";\nimport { withCache } from \"../../../utils/promise/withCache.js\";\nimport { DEFAULT_ACCOUNT_FACTORY_V0_6 } from \"./constants.js\";\n/**\n * Predict the address of a smart account.\n * @param args - The options for predicting the address of a smart account.\n * @returns The predicted address of the smart account.\n * @example\n * ```ts\n * import { predictSmartAccountAddress } from \"thirdweb/wallets/smart\";\n *\n * const predictedAddress = await predictSmartAccountAddress({\n *  client,\n *  chain,\n *  adminAddress,\n * });\n * ```\n * @walletUtils\n */\nexport async function predictSmartAccountAddress(args) {\n  var _args$factoryAddress;\n  return predictAddress({\n    accountSalt: args.accountSalt,\n    adminAddress: args.adminAddress,\n    factoryContract: getContract({\n      address: (_args$factoryAddress = args.factoryAddress) !== null && _args$factoryAddress !== void 0 ? _args$factoryAddress : DEFAULT_ACCOUNT_FACTORY_V0_6,\n      chain: args.chain,\n      client: args.client\n    })\n  });\n}\n/**\n * Predict the address of a smart account.\n * @param args - The options for predicting the address of a smart account.\n * @returns The predicted address of the smart account.\n * @example\n * ```ts\n * import { predictAddress } from \"thirdweb/wallets/smart\";\n *\n * const predictedAddress = await predictAddress({\n *  factoryContract,\n *  adminAddress,\n *  accountSalt,\n * });\n * ```\n * @walletUtils\n * @deprecated Use `predictSmartAccountAddress` instead.\n */\nexport async function predictAddress(args) {\n  const {\n    factoryContract,\n    predictAddressOverride: predictAddress,\n    adminAddress,\n    accountSalt,\n    accountAddress\n  } = args;\n  if (predictAddress) {\n    return predictAddress(factoryContract, adminAddress);\n  }\n  if (accountAddress) {\n    return accountAddress;\n  }\n  if (!adminAddress) {\n    throw new Error(\"Account address is required to predict the smart wallet address.\");\n  }\n  return withCache(async () => {\n    const saltHex = accountSalt && isHex(accountSalt) ? accountSalt : stringToHex(accountSalt !== null && accountSalt !== void 0 ? accountSalt : \"\");\n    let result;\n    let retries = 0;\n    const maxRetries = 3;\n    while (retries <= maxRetries) {\n      try {\n        result = await readContract({\n          contract: factoryContract,\n          method: \"function getAddress(address, bytes) returns (address)\",\n          params: [adminAddress, saltHex]\n        });\n        break;\n      } catch (error) {\n        if (retries === maxRetries) {\n          throw error;\n        }\n        // Exponential backoff: 2^(retries + 1) * 200ms (400ms, 800ms, 1600ms)\n        const delay = 2 ** (retries + 1) * 200;\n        await new Promise(resolve => setTimeout(resolve, delay));\n        retries++;\n      }\n    }\n    if (!result) {\n      throw new Error(\"No smart account address found for admin address \".concat(adminAddress, \" and salt \").concat(accountSalt));\n    }\n    return result;\n  }, {\n    cacheKey: \"\".concat(args.factoryContract.chain.id, \"-\").concat(args.factoryContract.address, \"-\").concat(args.adminAddress, \"-\").concat(args.accountSalt),\n    cacheTime: 1000 * 60 * 60 * 24 // 1 day\n  });\n}\n/**\n * @internal\n */\nexport function prepareCreateAccount(args) {\n  const {\n    adminAddress,\n    factoryContract,\n    createAccountOverride: createAccount,\n    accountSalt\n  } = args;\n  if (createAccount) {\n    return createAccount(factoryContract, adminAddress);\n  }\n  const saltHex = accountSalt && isHex(accountSalt) ? accountSalt : stringToHex(accountSalt !== null && accountSalt !== void 0 ? accountSalt : \"\");\n  return prepareContractCall({\n    contract: factoryContract,\n    method: \"function createAccount(address, bytes) returns (address)\",\n    params: [adminAddress, saltHex]\n  });\n}\n/**\n * @internal\n */\nexport function prepareExecute(args) {\n  const {\n    accountContract,\n    transaction,\n    executeOverride: execute\n  } = args;\n  if (execute) {\n    return execute(accountContract, transaction);\n  }\n  let value = transaction.value || 0n;\n  // special handling of hedera chains, decimals for native value is 8 instead of 18 when passed as contract params\n  if (transaction.chainId === 295 || transaction.chainId === 296) {\n    value = BigInt(value) / BigInt(10 ** 10);\n  }\n  return prepareContractCall({\n    contract: accountContract,\n    // if gas is specified for the inner tx, use that and add 21k for the execute call on the account contract\n    // this avoids another estimateGas call when bundling the userOp\n    // and also allows for passing custom gas limits for the inner tx\n    gas: transaction.gas ? transaction.gas + 21000n : undefined,\n    method: \"function execute(address, uint256, bytes)\",\n    params: [transaction.to || \"\", value, transaction.data || \"0x\"]\n  });\n}\n/**\n * @internal\n */\nexport function prepareBatchExecute(args) {\n  var _transactions$;\n  const {\n    accountContract,\n    transactions,\n    executeBatchOverride: executeBatch\n  } = args;\n  if (executeBatch) {\n    return executeBatch(accountContract, transactions);\n  }\n  let values = transactions.map(tx => tx.value || 0n);\n  const chainId = (_transactions$ = transactions[0]) === null || _transactions$ === void 0 ? void 0 : _transactions$.chainId;\n  // special handling of hedera chains, decimals for native value is 8 instead of 18 when passed as contract params\n  if (chainId === 295 || chainId === 296) {\n    values = values.map(value => BigInt(value) / BigInt(10 ** 10));\n  }\n  return prepareContractCall({\n    contract: accountContract,\n    method: \"function executeBatch(address[], uint256[], bytes[])\",\n    params: [transactions.map(tx => tx.to || \"\"), values, transactions.map(tx => tx.data || \"0x\")]\n  });\n}","map":{"version":3,"names":["getContract","prepareContractCall","readContract","isHex","stringToHex","withCache","DEFAULT_ACCOUNT_FACTORY_V0_6","predictSmartAccountAddress","args","_args$factoryAddress","predictAddress","accountSalt","adminAddress","factoryContract","address","factoryAddress","chain","client","predictAddressOverride","accountAddress","Error","saltHex","result","retries","maxRetries","contract","method","params","error","delay","Promise","resolve","setTimeout","concat","cacheKey","id","cacheTime","prepareCreateAccount","createAccountOverride","createAccount","prepareExecute","accountContract","transaction","executeOverride","execute","value","chainId","BigInt","gas","undefined","to","data","prepareBatchExecute","_transactions$","transactions","executeBatchOverride","executeBatch","values","map","tx"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/wallets/smart/lib/calls.ts"],"sourcesContent":["import type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport {\n  getContract,\n  type ThirdwebContract,\n} from \"../../../contract/contract.js\";\nimport { prepareContractCall } from \"../../../transaction/prepare-contract-call.js\";\nimport type { PreparedTransaction } from \"../../../transaction/prepare-transaction.js\";\nimport { readContract } from \"../../../transaction/read-contract.js\";\nimport { isHex, stringToHex } from \"../../../utils/encoding/hex.js\";\nimport { withCache } from \"../../../utils/promise/withCache.js\";\nimport type { SendTransactionOption } from \"../../interfaces/wallet.js\";\nimport { DEFAULT_ACCOUNT_FACTORY_V0_6 } from \"./constants.js\";\n\n/**\n * Predict the address of a smart account.\n * @param args - The options for predicting the address of a smart account.\n * @returns The predicted address of the smart account.\n * @example\n * ```ts\n * import { predictSmartAccountAddress } from \"thirdweb/wallets/smart\";\n *\n * const predictedAddress = await predictSmartAccountAddress({\n *  client,\n *  chain,\n *  adminAddress,\n * });\n * ```\n * @walletUtils\n */\nexport async function predictSmartAccountAddress(args: {\n  client: ThirdwebClient;\n  chain: Chain;\n  adminAddress: string;\n  factoryAddress?: string;\n  accountSalt?: string;\n}): Promise<string> {\n  return predictAddress({\n    accountSalt: args.accountSalt,\n    adminAddress: args.adminAddress,\n    factoryContract: getContract({\n      address: args.factoryAddress ?? DEFAULT_ACCOUNT_FACTORY_V0_6,\n      chain: args.chain,\n      client: args.client,\n    }),\n  });\n}\n\n/**\n * Predict the address of a smart account.\n * @param args - The options for predicting the address of a smart account.\n * @returns The predicted address of the smart account.\n * @example\n * ```ts\n * import { predictAddress } from \"thirdweb/wallets/smart\";\n *\n * const predictedAddress = await predictAddress({\n *  factoryContract,\n *  adminAddress,\n *  accountSalt,\n * });\n * ```\n * @walletUtils\n * @deprecated Use `predictSmartAccountAddress` instead.\n */\nexport async function predictAddress(args: {\n  factoryContract: ThirdwebContract;\n  predictAddressOverride?: (\n    factoryContract: ThirdwebContract,\n    admin: string,\n  ) => Promise<string>;\n  adminAddress: string;\n  accountSalt?: string;\n  accountAddress?: string;\n}): Promise<string> {\n  const {\n    factoryContract,\n    predictAddressOverride: predictAddress,\n    adminAddress,\n    accountSalt,\n    accountAddress,\n  } = args;\n  if (predictAddress) {\n    return predictAddress(factoryContract, adminAddress);\n  }\n  if (accountAddress) {\n    return accountAddress;\n  }\n  if (!adminAddress) {\n    throw new Error(\n      \"Account address is required to predict the smart wallet address.\",\n    );\n  }\n  return withCache(\n    async () => {\n      const saltHex =\n        accountSalt && isHex(accountSalt)\n          ? accountSalt\n          : stringToHex(accountSalt ?? \"\");\n      let result: string | undefined;\n      let retries = 0;\n      const maxRetries = 3;\n\n      while (retries <= maxRetries) {\n        try {\n          result = await readContract({\n            contract: factoryContract,\n            method: \"function getAddress(address, bytes) returns (address)\",\n            params: [adminAddress, saltHex],\n          });\n          break;\n        } catch (error) {\n          if (retries === maxRetries) {\n            throw error;\n          }\n\n          // Exponential backoff: 2^(retries + 1) * 200ms (400ms, 800ms, 1600ms)\n          const delay = 2 ** (retries + 1) * 200;\n          await new Promise((resolve) => setTimeout(resolve, delay));\n          retries++;\n        }\n      }\n      if (!result) {\n        throw new Error(\n          `No smart account address found for admin address ${adminAddress} and salt ${accountSalt}`,\n        );\n      }\n      return result;\n    },\n    {\n      cacheKey: `${args.factoryContract.chain.id}-${args.factoryContract.address}-${args.adminAddress}-${args.accountSalt}`,\n      cacheTime: 1000 * 60 * 60 * 24, // 1 day\n    },\n  );\n}\n\n/**\n * @internal\n */\nexport function prepareCreateAccount(args: {\n  factoryContract: ThirdwebContract;\n  adminAddress: string;\n  accountSalt?: string;\n  createAccountOverride?: (\n    factoryContract: ThirdwebContract,\n    admin: string,\n  ) => PreparedTransaction;\n}): PreparedTransaction {\n  const {\n    adminAddress,\n    factoryContract,\n    createAccountOverride: createAccount,\n    accountSalt,\n  } = args;\n  if (createAccount) {\n    return createAccount(factoryContract, adminAddress);\n  }\n  const saltHex =\n    accountSalt && isHex(accountSalt)\n      ? accountSalt\n      : stringToHex(accountSalt ?? \"\");\n  return prepareContractCall({\n    contract: factoryContract,\n    method: \"function createAccount(address, bytes) returns (address)\",\n    params: [adminAddress, saltHex],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareExecute(args: {\n  accountContract: ThirdwebContract;\n  transaction: SendTransactionOption;\n  executeOverride?: (\n    accountContract: ThirdwebContract,\n    transaction: SendTransactionOption,\n  ) => PreparedTransaction;\n}): PreparedTransaction {\n  const { accountContract, transaction, executeOverride: execute } = args;\n  if (execute) {\n    return execute(accountContract, transaction);\n  }\n  let value = transaction.value || 0n;\n  // special handling of hedera chains, decimals for native value is 8 instead of 18 when passed as contract params\n  if (transaction.chainId === 295 || transaction.chainId === 296) {\n    value = BigInt(value) / BigInt(10 ** 10);\n  }\n  return prepareContractCall({\n    contract: accountContract,\n    // if gas is specified for the inner tx, use that and add 21k for the execute call on the account contract\n    // this avoids another estimateGas call when bundling the userOp\n    // and also allows for passing custom gas limits for the inner tx\n    gas: transaction.gas ? transaction.gas + 21000n : undefined,\n    method: \"function execute(address, uint256, bytes)\",\n    params: [transaction.to || \"\", value, transaction.data || \"0x\"],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareBatchExecute(args: {\n  accountContract: ThirdwebContract;\n  transactions: SendTransactionOption[];\n  executeBatchOverride?: (\n    accountContract: ThirdwebContract,\n    transactions: SendTransactionOption[],\n  ) => PreparedTransaction;\n}): PreparedTransaction {\n  const {\n    accountContract,\n    transactions,\n    executeBatchOverride: executeBatch,\n  } = args;\n  if (executeBatch) {\n    return executeBatch(accountContract, transactions);\n  }\n  let values = transactions.map((tx) => tx.value || 0n);\n  const chainId = transactions[0]?.chainId;\n  // special handling of hedera chains, decimals for native value is 8 instead of 18 when passed as contract params\n  if (chainId === 295 || chainId === 296) {\n    values = values.map((value) => BigInt(value) / BigInt(10 ** 10));\n  }\n  return prepareContractCall({\n    contract: accountContract,\n    method: \"function executeBatch(address[], uint256[], bytes[])\",\n    params: [\n      transactions.map((tx) => tx.to || \"\"),\n      values,\n      transactions.map((tx) => tx.data || \"0x\"),\n    ],\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}