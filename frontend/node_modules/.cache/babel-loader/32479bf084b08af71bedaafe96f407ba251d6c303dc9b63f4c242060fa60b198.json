{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { defineChain } from \"../chains/utils.js\";\nimport { getThirdwebBaseUrl } from \"../utils/domains.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { stringify } from \"../utils/json.js\";\nimport { ApiError } from \"./types/Errors.js\";\n// export status within the Onramp module\nexport { status } from \"./OnrampStatus.js\";\n/**\n * Prepares an onramp transaction, returning a link from the specified provider to onramp to the specified token.\n *\n * @example\n * ```typescript\n * import { Bridge } from \"thirdweb\";\n * import { ethereum } from \"thirdweb/chains\";\n * import { NATIVE_TOKEN_ADDRESS, toWei } from \"thirdweb/utils\";\n *\n * const preparedOnramp = await Bridge.Onramp.prepare({\n *   client: thirdwebClient,\n *   onramp: \"stripe\",\n *   chainId: ethereum.id,\n *   tokenAddress: NATIVE_TOKEN_ADDRESS,\n *   receiver: \"0x...\", // receiver's address\n *   amount: toWei(\"10\"), // 10 of the destination token\n *   // Optional params:\n *   // sender: \"0x...\", // sender's address\n *   // onrampTokenAddress: NATIVE_TOKEN_ADDRESS, // token to initially onramp to\n *   // onrampChainId: 1, // chain to initially onramp to\n *   // currency: \"USD\",\n *   // maxSteps: 2,\n *   // purchaseData: { customId: \"123\" }\n * });\n *\n * console.log(preparedOnramp.link); // URL to redirect the user to\n * console.log(preparedOnramp.currencyAmount); // Amount in fiat the user will pay\n * ```\n *\n * This function returns a quote that might look like:\n * ```typescript\n * {\n *   id: \"123e4567-e89b-12d3-a456-426614174000\",\n *   link: \"https://onramp.example.com/session?id=...\",\n *   currency: \"USD\",\n *   currencyAmount: 10.52,\n *   destinationAmount: 10000000000000000000n, // 10 ETH if decimals 18\n *   timestamp: 1689812800,\n *   expiration: 1689842800,\n *   steps: [\n *     // ... further steps if any post-onramp swaps are needed\n *   ],\n *   intent: {\n *     onramp: \"stripe\",\n *     chainId: 1,\n *     tokenAddress: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *     receiver: \"0x...\",\n *     amount: \"10000000000000000000\"\n *   }\n * }\n * ```\n *\n * ### Global Support\n *\n * For the best user experience, specify the user's `country` code in your request. This will return an error if the user's country is not supported by the provider.\n *\n * ```typescript\n * const preparedOnramp = await Bridge.Onramp.prepare({\n *   client: thirdwebClient,\n *   onramp: \"stripe\",\n *   chainId: ethereum.id,\n *   tokenAddress: NATIVE_TOKEN_ADDRESS,\n *   receiver: \"0x...\", // receiver's address\n *   amount: toWei(\"10\"), // 10 of the destination token\n *   country: \"AU\" // User's country code\n * });\n * ```\n *\n * @param options - The options for preparing the onramp.\n * @param options.client - Your thirdweb client.\n * @param options.onramp - The onramp provider to use (e.g., \"stripe\", \"coinbase\", \"transak\").\n * @param options.chainId - The destination chain ID.\n * @param options.tokenAddress - The destination token address.\n * @param options.receiver - The address that will receive the output token.\n * @param [options.amount] - The desired token amount in wei.\n * @param [options.purchaseData] - Arbitrary purchase data.\n * @param [options.sender] - An optional address to associate as the onramp sender.\n * @param [options.onrampTokenAddress] - The token to initially onramp to if the destination token is not supported by the provider.\n * @param [options.onrampChainId] - The chain ID to initially onramp to if the destination chain is not supported.\n * @param [options.currency] - The currency for the onramp (e.g., \"USD\", \"GBP\"). Defaults to user's preferred or \"USD\".\n * @param [options.maxSteps] - Maximum number of post-onramp steps.\n * @param [options.excludeChainIds] - Chain IDs to exclude from the route (string or array of strings).\n * @param [options.country] - The user's country code (e.g. \"US\", \"JP\"). Defaults to \"US\". We highly recommend this be set (based on the user's IP address).\n *\n * @returns A promise that resolves to the prepared onramp details, including the link and quote.\n * @throws Will throw an error if there is an issue preparing the onramp.\n * @bridge Onramp\n * @beta\n */\nexport async function prepare(options) {\n  const {\n    client,\n    onramp,\n    chainId,\n    tokenAddress,\n    receiver,\n    amount,\n    purchaseData,\n    sender,\n    onrampTokenAddress,\n    onrampChainId,\n    currency,\n    maxSteps,\n    excludeChainIds,\n    paymentLinkId,\n    country\n  } = options;\n  const clientFetch = getClientFetch(client);\n  const url = \"\".concat(getThirdwebBaseUrl(\"bridge\"), \"/v1/onramp/prepare\");\n  const apiRequestBody = {\n    chainId: Number(chainId),\n    onramp,\n    receiver,\n    tokenAddress\n  };\n  if (amount !== undefined) {\n    apiRequestBody.amount = amount.toString();\n  }\n  if (purchaseData !== undefined) {\n    apiRequestBody.purchaseData = purchaseData;\n  }\n  if (sender !== undefined) {\n    apiRequestBody.sender = sender;\n  }\n  if (onrampTokenAddress !== undefined) {\n    apiRequestBody.onrampTokenAddress = onrampTokenAddress;\n  }\n  if (onrampChainId !== undefined) {\n    apiRequestBody.onrampChainId = Number(onrampChainId);\n  }\n  if (currency !== undefined) {\n    apiRequestBody.currency = currency;\n  }\n  if (maxSteps !== undefined) {\n    apiRequestBody.maxSteps = maxSteps;\n  }\n  if (excludeChainIds !== undefined) {\n    apiRequestBody.excludeChainIds = Array.isArray(excludeChainIds) ? excludeChainIds.join(\",\") : excludeChainIds;\n  }\n  if (paymentLinkId !== undefined) {\n    apiRequestBody.paymentLinkId = paymentLinkId;\n  }\n  if (country !== undefined) {\n    apiRequestBody.country = country;\n  }\n  const response = await clientFetch(url, {\n    body: stringify(apiRequestBody),\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    method: \"POST\"\n  });\n  if (!response.ok) {\n    const errorJson = await response.json();\n    throw new ApiError({\n      code: errorJson.code || \"UNKNOWN_ERROR\",\n      correlationId: errorJson.correlationId || undefined,\n      message: errorJson.message || response.statusText,\n      statusCode: response.status\n    });\n  }\n  const {\n    data\n  } = await response.json();\n  // Transform amounts from string to bigint where appropriate\n  const transformedSteps = data.steps.map(step => _objectSpread(_objectSpread({}, step), {}, {\n    destinationAmount: BigInt(step.destinationAmount),\n    originAmount: BigInt(step.originAmount),\n    transactions: step.transactions.map(tx => _objectSpread(_objectSpread({}, tx), {}, {\n      chain: defineChain(tx.chainId),\n      client,\n      value: tx.value ? BigInt(tx.value) : undefined\n    }))\n  }));\n  const intentFromResponse = _objectSpread(_objectSpread({}, data.intent), {}, {\n    amount: data.intent.amount ? data.intent.amount : undefined\n  });\n  return _objectSpread(_objectSpread({}, data), {}, {\n    destinationAmount: BigInt(data.destinationAmount),\n    intent: intentFromResponse,\n    steps: transformedSteps\n  });\n}","map":{"version":3,"names":["defineChain","getThirdwebBaseUrl","getClientFetch","stringify","ApiError","status","prepare","options","client","onramp","chainId","tokenAddress","receiver","amount","purchaseData","sender","onrampTokenAddress","onrampChainId","currency","maxSteps","excludeChainIds","paymentLinkId","country","clientFetch","url","concat","apiRequestBody","Number","undefined","toString","Array","isArray","join","response","body","headers","method","ok","errorJson","json","code","correlationId","message","statusText","statusCode","data","transformedSteps","steps","map","step","_objectSpread","destinationAmount","BigInt","originAmount","transactions","tx","chain","value","intentFromResponse","intent"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/bridge/Onramp.ts"],"sourcesContent":["import type { Address as ox__Address } from \"ox\";\nimport { defineChain } from \"../chains/utils.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport type { PurchaseData } from \"../pay/types.js\";\nimport { getThirdwebBaseUrl } from \"../utils/domains.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { stringify } from \"../utils/json.js\";\nimport { ApiError } from \"./types/Errors.js\";\nimport type { RouteStep } from \"./types/Route.js\";\nimport type { TokenWithPrices } from \"./types/Token.js\";\n\n// export status within the Onramp module\nexport { status } from \"./OnrampStatus.js\";\n\ntype OnrampIntent = {\n  onramp: \"stripe\" | \"coinbase\" | \"transak\";\n  chainId: number;\n  tokenAddress: ox__Address.Address;\n  receiver: ox__Address.Address;\n  amount?: string; // Corresponds to buyAmountWei in some other contexts\n  purchaseData?: PurchaseData;\n  sender?: ox__Address.Address;\n  onrampTokenAddress?: ox__Address.Address;\n  onrampChainId?: number;\n  currency?: string;\n  maxSteps?: number;\n  excludeChainIds?: string | string[];\n};\n\ntype OnrampPrepareQuoteResponseData = {\n  id: string;\n  link: string;\n  currency: string;\n  currencyAmount: number;\n  destinationAmount: bigint;\n  destinationToken: TokenWithPrices;\n  timestamp?: number;\n  expiration?: number;\n  steps: RouteStep[];\n  intent: OnrampIntent;\n};\n\n// Explicit type for the API request body\ninterface OnrampApiRequestBody {\n  onramp: \"stripe\" | \"coinbase\" | \"transak\";\n  chainId: number;\n  tokenAddress: ox__Address.Address;\n  receiver: ox__Address.Address;\n  amount?: string;\n  purchaseData?: PurchaseData;\n  sender?: ox__Address.Address;\n  onrampTokenAddress?: ox__Address.Address;\n  onrampChainId?: number;\n  currency?: string;\n  maxSteps?: number;\n  excludeChainIds?: string;\n  paymentLinkId?: string;\n  country?: string;\n}\n\n/**\n * Prepares an onramp transaction, returning a link from the specified provider to onramp to the specified token.\n *\n * @example\n * ```typescript\n * import { Bridge } from \"thirdweb\";\n * import { ethereum } from \"thirdweb/chains\";\n * import { NATIVE_TOKEN_ADDRESS, toWei } from \"thirdweb/utils\";\n *\n * const preparedOnramp = await Bridge.Onramp.prepare({\n *   client: thirdwebClient,\n *   onramp: \"stripe\",\n *   chainId: ethereum.id,\n *   tokenAddress: NATIVE_TOKEN_ADDRESS,\n *   receiver: \"0x...\", // receiver's address\n *   amount: toWei(\"10\"), // 10 of the destination token\n *   // Optional params:\n *   // sender: \"0x...\", // sender's address\n *   // onrampTokenAddress: NATIVE_TOKEN_ADDRESS, // token to initially onramp to\n *   // onrampChainId: 1, // chain to initially onramp to\n *   // currency: \"USD\",\n *   // maxSteps: 2,\n *   // purchaseData: { customId: \"123\" }\n * });\n *\n * console.log(preparedOnramp.link); // URL to redirect the user to\n * console.log(preparedOnramp.currencyAmount); // Amount in fiat the user will pay\n * ```\n *\n * This function returns a quote that might look like:\n * ```typescript\n * {\n *   id: \"123e4567-e89b-12d3-a456-426614174000\",\n *   link: \"https://onramp.example.com/session?id=...\",\n *   currency: \"USD\",\n *   currencyAmount: 10.52,\n *   destinationAmount: 10000000000000000000n, // 10 ETH if decimals 18\n *   timestamp: 1689812800,\n *   expiration: 1689842800,\n *   steps: [\n *     // ... further steps if any post-onramp swaps are needed\n *   ],\n *   intent: {\n *     onramp: \"stripe\",\n *     chainId: 1,\n *     tokenAddress: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *     receiver: \"0x...\",\n *     amount: \"10000000000000000000\"\n *   }\n * }\n * ```\n *\n * ### Global Support\n *\n * For the best user experience, specify the user's `country` code in your request. This will return an error if the user's country is not supported by the provider.\n *\n * ```typescript\n * const preparedOnramp = await Bridge.Onramp.prepare({\n *   client: thirdwebClient,\n *   onramp: \"stripe\",\n *   chainId: ethereum.id,\n *   tokenAddress: NATIVE_TOKEN_ADDRESS,\n *   receiver: \"0x...\", // receiver's address\n *   amount: toWei(\"10\"), // 10 of the destination token\n *   country: \"AU\" // User's country code\n * });\n * ```\n *\n * @param options - The options for preparing the onramp.\n * @param options.client - Your thirdweb client.\n * @param options.onramp - The onramp provider to use (e.g., \"stripe\", \"coinbase\", \"transak\").\n * @param options.chainId - The destination chain ID.\n * @param options.tokenAddress - The destination token address.\n * @param options.receiver - The address that will receive the output token.\n * @param [options.amount] - The desired token amount in wei.\n * @param [options.purchaseData] - Arbitrary purchase data.\n * @param [options.sender] - An optional address to associate as the onramp sender.\n * @param [options.onrampTokenAddress] - The token to initially onramp to if the destination token is not supported by the provider.\n * @param [options.onrampChainId] - The chain ID to initially onramp to if the destination chain is not supported.\n * @param [options.currency] - The currency for the onramp (e.g., \"USD\", \"GBP\"). Defaults to user's preferred or \"USD\".\n * @param [options.maxSteps] - Maximum number of post-onramp steps.\n * @param [options.excludeChainIds] - Chain IDs to exclude from the route (string or array of strings).\n * @param [options.country] - The user's country code (e.g. \"US\", \"JP\"). Defaults to \"US\". We highly recommend this be set (based on the user's IP address).\n *\n * @returns A promise that resolves to the prepared onramp details, including the link and quote.\n * @throws Will throw an error if there is an issue preparing the onramp.\n * @bridge Onramp\n * @beta\n */\nexport async function prepare(\n  options: prepare.Options,\n): Promise<prepare.Result> {\n  const {\n    client,\n    onramp,\n    chainId,\n    tokenAddress,\n    receiver,\n    amount,\n    purchaseData,\n    sender,\n    onrampTokenAddress,\n    onrampChainId,\n    currency,\n    maxSteps,\n    excludeChainIds,\n    paymentLinkId,\n    country,\n  } = options;\n\n  const clientFetch = getClientFetch(client);\n  const url = `${getThirdwebBaseUrl(\"bridge\")}/v1/onramp/prepare`;\n\n  const apiRequestBody: OnrampApiRequestBody = {\n    chainId: Number(chainId),\n    onramp,\n    receiver,\n    tokenAddress,\n  };\n\n  if (amount !== undefined) {\n    apiRequestBody.amount = amount.toString();\n  }\n  if (purchaseData !== undefined) {\n    apiRequestBody.purchaseData = purchaseData;\n  }\n  if (sender !== undefined) {\n    apiRequestBody.sender = sender;\n  }\n  if (onrampTokenAddress !== undefined) {\n    apiRequestBody.onrampTokenAddress = onrampTokenAddress;\n  }\n  if (onrampChainId !== undefined) {\n    apiRequestBody.onrampChainId = Number(onrampChainId);\n  }\n  if (currency !== undefined) {\n    apiRequestBody.currency = currency;\n  }\n  if (maxSteps !== undefined) {\n    apiRequestBody.maxSteps = maxSteps;\n  }\n  if (excludeChainIds !== undefined) {\n    apiRequestBody.excludeChainIds = Array.isArray(excludeChainIds)\n      ? excludeChainIds.join(\",\")\n      : excludeChainIds;\n  }\n  if (paymentLinkId !== undefined) {\n    apiRequestBody.paymentLinkId = paymentLinkId;\n  }\n  if (country !== undefined) {\n    apiRequestBody.country = country;\n  }\n\n  const response = await clientFetch(url, {\n    body: stringify(apiRequestBody),\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    method: \"POST\",\n  });\n\n  if (!response.ok) {\n    const errorJson = await response.json();\n    throw new ApiError({\n      code: errorJson.code || \"UNKNOWN_ERROR\",\n      correlationId: errorJson.correlationId || undefined,\n      message: errorJson.message || response.statusText,\n      statusCode: response.status,\n    });\n  }\n\n  const { data }: { data: OnrampPrepareQuoteResponseData } =\n    await response.json();\n\n  // Transform amounts from string to bigint where appropriate\n  const transformedSteps = data.steps.map((step) => ({\n    ...step,\n    destinationAmount: BigInt(step.destinationAmount),\n    originAmount: BigInt(step.originAmount),\n    transactions: step.transactions.map((tx) => ({\n      ...tx,\n      chain: defineChain(tx.chainId),\n      client,\n      value: tx.value ? BigInt(tx.value) : undefined,\n    })),\n  }));\n\n  const intentFromResponse = {\n    ...data.intent,\n    amount: data.intent.amount ? data.intent.amount : undefined,\n  };\n\n  return {\n    ...data,\n    destinationAmount: BigInt(data.destinationAmount),\n    intent: intentFromResponse,\n    steps: transformedSteps,\n  };\n}\n\n/**\n * Namespace containing types for the onramp prepare function.\n * @namespace prepare\n * @bridge Onramp\n */\nexport declare namespace prepare {\n  /**\n   * Options for preparing an onramp transaction.\n   * @interface Options\n   * @bridge Onramp\n   */\n  export type Options = {\n    /** Your thirdweb client */\n    client: ThirdwebClient;\n    /** The onramp provider to use (e.g., \"stripe\", \"coinbase\", \"transak\") */\n    onramp: \"stripe\" | \"coinbase\" | \"transak\";\n    /** The destination chain ID */\n    chainId: number;\n    /** The destination token address */\n    tokenAddress: ox__Address.Address;\n    /** The address that will receive the output token */\n    receiver: ox__Address.Address;\n    /** The desired token amount in wei */\n    amount?: bigint;\n    /** Arbitrary purchase data */\n    purchaseData?: PurchaseData;\n    /** An optional address to associate as the onramp sender */\n    sender?: ox__Address.Address;\n    /** The token to initially onramp to if the destination token is not supported by the provider */\n    onrampTokenAddress?: ox__Address.Address;\n    /** The chain ID to initially onramp to if the destination chain is not supported */\n    onrampChainId?: number;\n    /** The currency for the onramp (e.g., \"USD\", \"GBP\"). Defaults to user's preferred or \"USD\" */\n    currency?: string;\n    /** Maximum number of post-onramp steps */\n    maxSteps?: number;\n    /** Chain IDs to exclude from the route (string or array of strings) */\n    excludeChainIds?: string | string[];\n    /** The user's country code (e.g. \"US\", \"JP\"). Defaults to \"US\". We highly recommend this be set (based on the user's IP address) */\n    country?: string;\n    /**\n     * @hidden\n     */\n    paymentLinkId?: string;\n  };\n\n  /**\n   * Result returned from preparing an onramp transaction.\n   * Contains the onramp link, quote information, and routing steps.\n   * @interface Result\n   * @bridge Onramp\n   */\n  export type Result = OnrampPrepareQuoteResponseData;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}