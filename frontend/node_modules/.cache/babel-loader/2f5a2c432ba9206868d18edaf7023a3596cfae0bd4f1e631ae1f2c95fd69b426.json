{"ast":null,"code":"import { readContract } from '../../actions/public/readContract.js';\nimport { ChainNotFoundError } from '../../errors/chain.js';\nimport { l1SharedBridgeAbi } from '../constants/abis.js';\nimport { WithdrawalLogNotFoundError } from '../errors/bridge.js';\nimport { getWithdrawalL2ToL1Log } from '../utils/bridge/getWithdrawalL2ToL1Log.js';\nimport { getWithdrawalLog } from '../utils/bridge/getWithdrawalLog.js';\nimport { getDefaultBridgeAddresses } from './getDefaultBridgeAddresses.js';\nimport { getLogProof } from './getLogProof.js';\n/**\n * Returns whether the withdrawal transaction is finalized on the L1 network.\n *\n * @param client - Client to use\n * @param parameters - {@link IsWithdrawalFinalizedParameters}\n * @returns bool - Whether the withdrawal transaction is finalized on the L1 network. {@link IsWithdrawalFinalizedReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet, zksync } from 'viem/chains'\n * import { isWithdrawalFinalized } from 'viem/zksync'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const clientL2 = createPublicClient({\n *   chain: zksync,\n *   transport: http(),\n * })\n *\n * const hash = await isWithdrawalFinalized(client, {\n *     client: clientL2,\n *     hash: '0x...',\n * })\n */\nexport async function isWithdrawalFinalized(client, parameters) {\n  const {\n    client: l2Client,\n    hash,\n    index = 0\n  } = parameters;\n  if (!l2Client.chain) throw new ChainNotFoundError();\n  const {\n    log\n  } = await getWithdrawalLog(l2Client, {\n    hash,\n    index\n  });\n  const {\n    l2ToL1LogIndex\n  } = await getWithdrawalL2ToL1Log(l2Client, {\n    hash,\n    index\n  });\n  // `getLogProof` is called not to get proof but\n  // to get the index of the corresponding L2->L1 log,\n  // which is returned as `proof.id`.\n  const proof = await getLogProof(l2Client, {\n    txHash: hash,\n    index: l2ToL1LogIndex\n  });\n  if (!proof) throw new WithdrawalLogNotFoundError({\n    hash\n  });\n  const l1Bridge = (await getDefaultBridgeAddresses(l2Client)).sharedL1;\n  return await readContract(client, {\n    address: l1Bridge,\n    abi: l1SharedBridgeAbi,\n    functionName: 'isWithdrawalFinalized',\n    args: [BigInt(l2Client.chain.id), log.l1BatchNumber, BigInt(proof.id)]\n  });\n}","map":{"version":3,"names":["readContract","ChainNotFoundError","l1SharedBridgeAbi","WithdrawalLogNotFoundError","getWithdrawalL2ToL1Log","getWithdrawalLog","getDefaultBridgeAddresses","getLogProof","isWithdrawalFinalized","client","parameters","l2Client","hash","index","chain","log","l2ToL1LogIndex","proof","txHash","l1Bridge","sharedL1","address","abi","functionName","args","BigInt","id","l1BatchNumber"],"sources":["/home/user/Arbitrage/frontend/node_modules/viem/zksync/actions/isWithdrawalFinalized.ts"],"sourcesContent":["import type { Account } from '../../accounts/types.js'\nimport { readContract } from '../../actions/public/readContract.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  ChainNotFoundError,\n  type ChainNotFoundErrorType,\n} from '../../errors/chain.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport { l1SharedBridgeAbi } from '../constants/abis.js'\nimport {\n  WithdrawalLogNotFoundError,\n  type WithdrawalLogNotFoundErrorType,\n} from '../errors/bridge.js'\nimport type { ChainEIP712 } from '../types/chain.js'\nimport { getWithdrawalL2ToL1Log } from '../utils/bridge/getWithdrawalL2ToL1Log.js'\nimport { getWithdrawalLog } from '../utils/bridge/getWithdrawalLog.js'\nimport { getDefaultBridgeAddresses } from './getDefaultBridgeAddresses.js'\nimport { getLogProof } from './getLogProof.js'\n\nexport type IsWithdrawalFinalizedParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n> = {\n  /** L2 client */\n  client: Client<Transport, chain, account>\n  /** Hash of the L2 transaction where the withdrawal was initiated. */\n  hash: Hash\n  /** In case there were multiple withdrawals in one transaction, you may pass an index of the\n  withdrawal you want to finalize. */\n  index?: number | undefined\n}\n\nexport type IsWithdrawalFinalizedReturnType = boolean\n\nexport type IsWithdrawalFinalizedErrorType =\n  | WithdrawalLogNotFoundErrorType\n  | ChainNotFoundErrorType\n\n/**\n * Returns whether the withdrawal transaction is finalized on the L1 network.\n *\n * @param client - Client to use\n * @param parameters - {@link IsWithdrawalFinalizedParameters}\n * @returns bool - Whether the withdrawal transaction is finalized on the L1 network. {@link IsWithdrawalFinalizedReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet, zksync } from 'viem/chains'\n * import { isWithdrawalFinalized } from 'viem/zksync'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const clientL2 = createPublicClient({\n *   chain: zksync,\n *   transport: http(),\n * })\n *\n * const hash = await isWithdrawalFinalized(client, {\n *     client: clientL2,\n *     hash: '0x...',\n * })\n */\nexport async function isWithdrawalFinalized<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainL2 extends ChainEIP712 | undefined,\n  accountL2 extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: IsWithdrawalFinalizedParameters<chainL2, accountL2>,\n): Promise<IsWithdrawalFinalizedReturnType> {\n  const { client: l2Client, hash, index = 0 } = parameters\n\n  if (!l2Client.chain) throw new ChainNotFoundError()\n\n  const { log } = await getWithdrawalLog(l2Client, { hash, index })\n  const { l2ToL1LogIndex } = await getWithdrawalL2ToL1Log(l2Client, {\n    hash,\n    index,\n  })\n\n  // `getLogProof` is called not to get proof but\n  // to get the index of the corresponding L2->L1 log,\n  // which is returned as `proof.id`.\n  const proof = await getLogProof(l2Client, {\n    txHash: hash,\n    index: l2ToL1LogIndex!,\n  })\n  if (!proof) throw new WithdrawalLogNotFoundError({ hash })\n\n  const l1Bridge = (await getDefaultBridgeAddresses(l2Client)).sharedL1\n\n  return await readContract(client, {\n    address: l1Bridge,\n    abi: l1SharedBridgeAbi,\n    functionName: 'isWithdrawalFinalized',\n    args: [BigInt(l2Client.chain.id), log.l1BatchNumber!, BigInt(proof.id)],\n  })\n}\n"],"mappings":"AACA,SAASA,YAAY,QAAQ,sCAAsC;AAGnE,SACEC,kBAAkB,QAEb,uBAAuB;AAG9B,SAASC,iBAAiB,QAAQ,sBAAsB;AACxD,SACEC,0BAA0B,QAErB,qBAAqB;AAE5B,SAASC,sBAAsB,QAAQ,2CAA2C;AAClF,SAASC,gBAAgB,QAAQ,qCAAqC;AACtE,SAASC,yBAAyB,QAAQ,gCAAgC;AAC1E,SAASC,WAAW,QAAQ,kBAAkB;AAqB9C;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,OAAO,eAAeC,qBAAqBA,CAMzCC,MAAyC,EACzCC,UAA+D;EAE/D,MAAM;IAAED,MAAM,EAAEE,QAAQ;IAAEC,IAAI;IAAEC,KAAK,GAAG;EAAC,CAAE,GAAGH,UAAU;EAExD,IAAI,CAACC,QAAQ,CAACG,KAAK,EAAE,MAAM,IAAIb,kBAAkB,EAAE;EAEnD,MAAM;IAAEc;EAAG,CAAE,GAAG,MAAMV,gBAAgB,CAACM,QAAQ,EAAE;IAAEC,IAAI;IAAEC;EAAK,CAAE,CAAC;EACjE,MAAM;IAAEG;EAAc,CAAE,GAAG,MAAMZ,sBAAsB,CAACO,QAAQ,EAAE;IAChEC,IAAI;IACJC;GACD,CAAC;EAEF;EACA;EACA;EACA,MAAMI,KAAK,GAAG,MAAMV,WAAW,CAACI,QAAQ,EAAE;IACxCO,MAAM,EAAEN,IAAI;IACZC,KAAK,EAAEG;GACR,CAAC;EACF,IAAI,CAACC,KAAK,EAAE,MAAM,IAAId,0BAA0B,CAAC;IAAES;EAAI,CAAE,CAAC;EAE1D,MAAMO,QAAQ,GAAG,CAAC,MAAMb,yBAAyB,CAACK,QAAQ,CAAC,EAAES,QAAQ;EAErE,OAAO,MAAMpB,YAAY,CAACS,MAAM,EAAE;IAChCY,OAAO,EAAEF,QAAQ;IACjBG,GAAG,EAAEpB,iBAAiB;IACtBqB,YAAY,EAAE,uBAAuB;IACrCC,IAAI,EAAE,CAACC,MAAM,CAACd,QAAQ,CAACG,KAAK,CAACY,EAAE,CAAC,EAAEX,GAAG,CAACY,aAAc,EAAEF,MAAM,CAACR,KAAK,CAACS,EAAE,CAAC;GACvE,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}