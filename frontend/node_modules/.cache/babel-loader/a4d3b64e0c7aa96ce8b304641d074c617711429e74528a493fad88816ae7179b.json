{"ast":null,"code":"\"use client\";\n\nimport _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"iconResolver\", \"loadingComponent\", \"fallbackComponent\", \"queryOptions\"];\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { getChainMetadata } from \"../../../../../chains/utils.js\";\nimport { NATIVE_TOKEN_ADDRESS } from \"../../../../../constants/addresses.js\";\nimport { getContract } from \"../../../../../contract/contract.js\";\nimport { getContractMetadata } from \"../../../../../extensions/common/read/getContractMetadata.js\";\nimport { getToken } from \"../../../../../pay/convert/get-token.js\";\nimport { getFunctionId } from \"../../../../../utils/function-id.js\";\nimport { resolveScheme } from \"../../../../../utils/ipfs.js\";\nimport { useTokenContext } from \"./provider.js\";\n/**\n * This component tries to resolve the icon of a given token, then return an image.\n * @returns an <img /> with the src of the token icon\n *\n * @example\n * ### Basic usage\n * ```tsx\n * import { TokenProvider, TokenIcon } from \"thirdweb/react\";\n *\n * <TokenProvider address=\"0x-token-address\" chain={chain} client={client}>\n *   <TokenIcon />\n * </TokenProvider>\n * ```\n *\n * Result: An <img /> component with the src of the icon\n * ```html\n * <img src=\"token-icon.png\" />\n * ```\n *\n * ### Override the icon with the `iconResolver` prop\n * If you already have the icon url, you can skip the network requests and pass it directly to the TokenIcon\n * ```tsx\n * <TokenIcon iconResolver=\"/usdc.png\" />\n * ```\n *\n * You can also pass in your own custom (async) function that retrieves the icon url\n * ```tsx\n * const getIcon = async () => {\n *   const icon = getIconFromCoinMarketCap(tokenAddress, etc);\n *   return icon;\n * };\n *\n * <TokenIcon iconResolver={getIcon} />\n * ```\n *\n * ### Show a loading sign while the icon is being loaded\n * ```tsx\n * <TokenIcon loadingComponent={<Spinner />} />\n * ```\n *\n * ### Fallback to a dummy image if the token icon fails to resolve\n * ```tsx\n * <TokenIcon fallbackComponent={<img src=\"blank-image.png\" />} />\n * ```\n *\n * ### Usage with queryOptions\n * TokenIcon uses useQuery() from tanstack query internally.\n * It allows you to pass a custom queryOptions of your choice for more control of the internal fetching logic\n * ```tsx\n * <TokenIcon queryOptions={{ enabled: someLogic, retry: 3, }} />\n * ```\n *\n * @component\n * @token\n * @beta\n */\nexport function TokenIcon(_ref) {\n  let {\n      iconResolver,\n      loadingComponent,\n      fallbackComponent,\n      queryOptions\n    } = _ref,\n    restProps = _objectWithoutProperties(_ref, _excluded);\n  const {\n    address,\n    client,\n    chain\n  } = useTokenContext();\n  const iconQuery = useQuery(_objectSpread({\n    queryFn: async () => {\n      if (typeof iconResolver === \"string\") {\n        return iconResolver;\n      }\n      if (typeof iconResolver === \"function\") {\n        return iconResolver();\n      }\n      if (address.toLowerCase() === NATIVE_TOKEN_ADDRESS.toLowerCase()) {\n        const possibleUrl = await getChainMetadata(chain).then(data => {\n          var _data$icon;\n          return (_data$icon = data.icon) === null || _data$icon === void 0 ? void 0 : _data$icon.url;\n        });\n        if (!possibleUrl) {\n          throw new Error(\"Failed to resolve icon for native token\");\n        }\n        return resolveScheme({\n          client,\n          uri: possibleUrl\n        });\n      }\n      const bridgeToken = await getToken(client, address, chain.id).catch(() => null);\n      if (bridgeToken !== null && bridgeToken !== void 0 && bridgeToken.iconUri) {\n        return bridgeToken.iconUri;\n      }\n      // Try to get the icon from the contractURI\n      const contractMetadata = await getContractMetadata({\n        contract: getContract({\n          address,\n          chain,\n          client\n        })\n      });\n      if (!contractMetadata.image || typeof contractMetadata.image !== \"string\") {\n        throw new Error(\"Failed to resolve token icon from contract metadata\");\n      }\n      return resolveScheme({\n        client,\n        uri: contractMetadata.image\n      });\n    },\n    queryKey: [\"_internal_token_icon_\", chain.id, address, {\n      resolver: typeof iconResolver === \"string\" ? iconResolver : typeof iconResolver === \"function\" ? getFunctionId(iconResolver) : undefined\n    }]\n  }, queryOptions));\n  if (iconQuery.isLoading) {\n    return loadingComponent || null;\n  }\n  if (!iconQuery.data) {\n    return fallbackComponent || null;\n  }\n  return _jsx(\"img\", _objectSpread(_objectSpread({\n    src: iconQuery.data\n  }, restProps), {}, {\n    alt: restProps.alt\n  }));\n}","map":{"version":3,"names":["_objectSpread","_objectWithoutProperties","_excluded","useQuery","getChainMetadata","NATIVE_TOKEN_ADDRESS","getContract","getContractMetadata","getToken","getFunctionId","resolveScheme","useTokenContext","TokenIcon","_ref","iconResolver","loadingComponent","fallbackComponent","queryOptions","restProps","address","client","chain","iconQuery","queryFn","toLowerCase","possibleUrl","then","data","_data$icon","icon","url","Error","uri","bridgeToken","id","catch","iconUri","contractMetadata","contract","image","queryKey","resolver","undefined","isLoading","_jsx","src","alt"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/react/web/ui/prebuilt/Token/icon.tsx"],"sourcesContent":["\"use client\";\n\nimport { type UseQueryOptions, useQuery } from \"@tanstack/react-query\";\nimport type { JSX } from \"react\";\nimport { getChainMetadata } from \"../../../../../chains/utils.js\";\nimport { NATIVE_TOKEN_ADDRESS } from \"../../../../../constants/addresses.js\";\nimport { getContract } from \"../../../../../contract/contract.js\";\nimport { getContractMetadata } from \"../../../../../extensions/common/read/getContractMetadata.js\";\nimport { getToken } from \"../../../../../pay/convert/get-token.js\";\nimport { getFunctionId } from \"../../../../../utils/function-id.js\";\nimport { resolveScheme } from \"../../../../../utils/ipfs.js\";\nimport { useTokenContext } from \"./provider.js\";\n\n/**\n * Props for the TokenIcon component\n * @component\n * @token\n */\nexport interface TokenIconProps\n  extends Omit<React.ImgHTMLAttributes<HTMLImageElement>, \"src\"> {\n  /**\n   * This prop can be a string or a (async) function that resolves to a string, representing the icon url of the token\n   * This is particularly useful if you already have a way to fetch the token icon.\n   */\n  iconResolver?: string | (() => string) | (() => Promise<string>);\n  /**\n   * This component will be shown while the avatar of the icon is being fetched\n   * If not passed, the component will return `null`.\n   *\n   * You can pass a loading sign or spinner to this prop.\n   * @example\n   * ```tsx\n   * <TokenIcon loadingComponent={<Spinner />} />\n   * ```\n   */\n  loadingComponent?: JSX.Element;\n  /**\n   * This component will be shown if the request for fetching the avatar is done\n   * but could not retreive any result.\n   * You can pass a dummy avatar/image to this prop.\n   *\n   * If not passed, the component will return `null`\n   *\n   * @example\n   * ```tsx\n   * <TokenIcon fallbackComponent={<DummyImage />} />\n   * ```\n   */\n  fallbackComponent?: JSX.Element;\n\n  /**\n   * Optional query options for `useQuery`\n   */\n  queryOptions?: Omit<UseQueryOptions<string>, \"queryFn\" | \"queryKey\">;\n}\n\n/**\n * This component tries to resolve the icon of a given token, then return an image.\n * @returns an <img /> with the src of the token icon\n *\n * @example\n * ### Basic usage\n * ```tsx\n * import { TokenProvider, TokenIcon } from \"thirdweb/react\";\n *\n * <TokenProvider address=\"0x-token-address\" chain={chain} client={client}>\n *   <TokenIcon />\n * </TokenProvider>\n * ```\n *\n * Result: An <img /> component with the src of the icon\n * ```html\n * <img src=\"token-icon.png\" />\n * ```\n *\n * ### Override the icon with the `iconResolver` prop\n * If you already have the icon url, you can skip the network requests and pass it directly to the TokenIcon\n * ```tsx\n * <TokenIcon iconResolver=\"/usdc.png\" />\n * ```\n *\n * You can also pass in your own custom (async) function that retrieves the icon url\n * ```tsx\n * const getIcon = async () => {\n *   const icon = getIconFromCoinMarketCap(tokenAddress, etc);\n *   return icon;\n * };\n *\n * <TokenIcon iconResolver={getIcon} />\n * ```\n *\n * ### Show a loading sign while the icon is being loaded\n * ```tsx\n * <TokenIcon loadingComponent={<Spinner />} />\n * ```\n *\n * ### Fallback to a dummy image if the token icon fails to resolve\n * ```tsx\n * <TokenIcon fallbackComponent={<img src=\"blank-image.png\" />} />\n * ```\n *\n * ### Usage with queryOptions\n * TokenIcon uses useQuery() from tanstack query internally.\n * It allows you to pass a custom queryOptions of your choice for more control of the internal fetching logic\n * ```tsx\n * <TokenIcon queryOptions={{ enabled: someLogic, retry: 3, }} />\n * ```\n *\n * @component\n * @token\n * @beta\n */\nexport function TokenIcon({\n  iconResolver,\n  loadingComponent,\n  fallbackComponent,\n  queryOptions,\n  ...restProps\n}: TokenIconProps) {\n  const { address, client, chain } = useTokenContext();\n  const iconQuery = useQuery({\n    queryFn: async () => {\n      if (typeof iconResolver === \"string\") {\n        return iconResolver;\n      }\n      if (typeof iconResolver === \"function\") {\n        return iconResolver();\n      }\n      if (address.toLowerCase() === NATIVE_TOKEN_ADDRESS.toLowerCase()) {\n        const possibleUrl = await getChainMetadata(chain).then(\n          (data) => data.icon?.url,\n        );\n        if (!possibleUrl) {\n          throw new Error(\"Failed to resolve icon for native token\");\n        }\n        return resolveScheme({ client, uri: possibleUrl });\n      }\n\n      const bridgeToken = await getToken(client, address, chain.id).catch(\n        () => null,\n      );\n\n      if (bridgeToken?.iconUri) {\n        return bridgeToken.iconUri;\n      }\n\n      // Try to get the icon from the contractURI\n      const contractMetadata = await getContractMetadata({\n        contract: getContract({\n          address,\n          chain,\n          client,\n        }),\n      });\n\n      if (\n        !contractMetadata.image ||\n        typeof contractMetadata.image !== \"string\"\n      ) {\n        throw new Error(\"Failed to resolve token icon from contract metadata\");\n      }\n\n      return resolveScheme({\n        client,\n        uri: contractMetadata.image,\n      });\n    },\n    queryKey: [\n      \"_internal_token_icon_\",\n      chain.id,\n      address,\n      {\n        resolver:\n          typeof iconResolver === \"string\"\n            ? iconResolver\n            : typeof iconResolver === \"function\"\n              ? getFunctionId(iconResolver)\n              : undefined,\n      },\n    ] as const,\n    ...queryOptions,\n  });\n\n  if (iconQuery.isLoading) {\n    return loadingComponent || null;\n  }\n\n  if (!iconQuery.data) {\n    return fallbackComponent || null;\n  }\n\n  return <img src={iconQuery.data} {...restProps} alt={restProps.alt} />;\n}\n"],"mappings":"AAAA,YAAY;;AAAC,OAAAA,aAAA;AAAA,OAAAC,wBAAA;AAAA,MAAAC,SAAA;;AAEb,SAA+BC,QAAQ,QAAQ,uBAAuB;AAEtE,SAASC,gBAAgB,QAAQ,gCAAgC;AACjE,SAASC,oBAAoB,QAAQ,uCAAuC;AAC5E,SAASC,WAAW,QAAQ,qCAAqC;AACjE,SAASC,mBAAmB,QAAQ,8DAA8D;AAClG,SAASC,QAAQ,QAAQ,yCAAyC;AAClE,SAASC,aAAa,QAAQ,qCAAqC;AACnE,SAASC,aAAa,QAAQ,8BAA8B;AAC5D,SAASC,eAAe,QAAQ,eAAe;AA6C/C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwDA,OAAM,SAAUC,SAASA,CAAAC,IAAA,EAMR;EAAA,IANS;MACxBC,YAAY;MACZC,gBAAgB;MAChBC,iBAAiB;MACjBC;IACY,CACG,GAAAJ,IAAA;IADZK,SAAS,GAAAjB,wBAAA,CAAAY,IAAA,EAAAX,SAAA;EAEZ,MAAM;IAAEiB,OAAO;IAAEC,MAAM;IAAEC;EAAK,CAAE,GAAGV,eAAe,EAAE;EACpD,MAAMW,SAAS,GAAGnB,QAAQ,CAAAH,aAAA;IACxBuB,OAAO,EAAE,MAAAA,CAAA,KAAW;MAClB,IAAI,OAAOT,YAAY,KAAK,QAAQ,EAAE;QACpC,OAAOA,YAAY;MACrB;MACA,IAAI,OAAOA,YAAY,KAAK,UAAU,EAAE;QACtC,OAAOA,YAAY,EAAE;MACvB;MACA,IAAIK,OAAO,CAACK,WAAW,EAAE,KAAKnB,oBAAoB,CAACmB,WAAW,EAAE,EAAE;QAChE,MAAMC,WAAW,GAAG,MAAMrB,gBAAgB,CAACiB,KAAK,CAAC,CAACK,IAAI,CACnDC,IAAI;UAAA,IAAAC,UAAA;UAAA,QAAAA,UAAA,GAAKD,IAAI,CAACE,IAAI,cAAAD,UAAA,uBAATA,UAAA,CAAWE,GAAG;QAAA,EACzB;QACD,IAAI,CAACL,WAAW,EAAE;UAChB,MAAM,IAAIM,KAAK,CAAC,yCAAyC,CAAC;QAC5D;QACA,OAAOrB,aAAa,CAAC;UAAEU,MAAM;UAAEY,GAAG,EAAEP;QAAW,CAAE,CAAC;MACpD;MAEA,MAAMQ,WAAW,GAAG,MAAMzB,QAAQ,CAACY,MAAM,EAAED,OAAO,EAAEE,KAAK,CAACa,EAAE,CAAC,CAACC,KAAK,CACjE,MAAM,IAAI,CACX;MAED,IAAIF,WAAW,aAAXA,WAAW,eAAXA,WAAW,CAAEG,OAAO,EAAE;QACxB,OAAOH,WAAW,CAACG,OAAO;MAC5B;MAEA;MACA,MAAMC,gBAAgB,GAAG,MAAM9B,mBAAmB,CAAC;QACjD+B,QAAQ,EAAEhC,WAAW,CAAC;UACpBa,OAAO;UACPE,KAAK;UACLD;SACD;OACF,CAAC;MAEF,IACE,CAACiB,gBAAgB,CAACE,KAAK,IACvB,OAAOF,gBAAgB,CAACE,KAAK,KAAK,QAAQ,EAC1C;QACA,MAAM,IAAIR,KAAK,CAAC,qDAAqD,CAAC;MACxE;MAEA,OAAOrB,aAAa,CAAC;QACnBU,MAAM;QACNY,GAAG,EAAEK,gBAAgB,CAACE;OACvB,CAAC;IACJ,CAAC;IACDC,QAAQ,EAAE,CACR,uBAAuB,EACvBnB,KAAK,CAACa,EAAE,EACRf,OAAO,EACP;MACEsB,QAAQ,EACN,OAAO3B,YAAY,KAAK,QAAQ,GAC5BA,YAAY,GACZ,OAAOA,YAAY,KAAK,UAAU,GAChCL,aAAa,CAACK,YAAY,CAAC,GAC3B4B;KACT;EACO,GACPzB,YAAY,CAChB,CAAC;EAEF,IAAIK,SAAS,CAACqB,SAAS,EAAE;IACvB,OAAO5B,gBAAgB,IAAI,IAAI;EACjC;EAEA,IAAI,CAACO,SAAS,CAACK,IAAI,EAAE;IACnB,OAAOX,iBAAiB,IAAI,IAAI;EAClC;EAEA,OAAO4B,IAAA,QAAA5C,aAAA,CAAAA,aAAA;IAAK6C,GAAG,EAAEvB,SAAS,CAACK;EAAI,GAAMT,SAAS;IAAE4B,GAAG,EAAE5B,SAAS,CAAC4B;EAAG,GAAI;AACxE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}