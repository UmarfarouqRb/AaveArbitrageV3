{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport * as ox__Bytes from \"ox/Bytes\";\nimport * as ox__TypedData from \"ox/TypedData\";\nimport { encodeAbiParameters } from \"../abi/encodeAbiParameters.js\";\nimport { toHex } from \"../encoding/hex.js\";\nimport { keccak256 } from \"./keccak256.js\";\n/**\n * @internal\n */\nexport function hashTypedData(parameters) {\n  const {\n    domain = {},\n    message,\n    primaryType\n  } = parameters;\n  const types = _objectSpread({\n    EIP712Domain: ox__TypedData.extractEip712DomainTypes(domain)\n  }, parameters.types);\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  ox__TypedData.validate({\n    domain,\n    message,\n    primaryType,\n    types\n  });\n  const parts = [\"0x1901\"];\n  if (domain) parts.push(ox__TypedData.hashDomain({\n    domain,\n    types: types\n  }));\n  if (primaryType !== \"EIP712Domain\") {\n    const hashedStruct = (() => {\n      const encoded = encodeData({\n        data: message,\n        primaryType,\n        types: types\n      });\n      return keccak256(encoded);\n    })();\n    parts.push(hashedStruct);\n  }\n  return keccak256(ox__Bytes.concat(...parts.map(p => ox__Bytes.fromHex(p))));\n}\nfunction encodeData(_ref) {\n  let {\n    data,\n    primaryType,\n    types\n  } = _ref;\n  const encodedTypes = [{\n    type: \"bytes32\"\n  }];\n  const encodedValues = [hashType({\n    primaryType,\n    types\n  })];\n  if (!types[primaryType]) throw new Error(\"Invalid types\");\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      name: field.name,\n      type: field.type,\n      types,\n      value: data[field.name]\n    });\n    encodedTypes.push(type);\n    encodedValues.push(value);\n  }\n  return encodeAbiParameters(encodedTypes, encodedValues);\n}\nfunction hashType(_ref2) {\n  let {\n    primaryType,\n    types\n  } = _ref2;\n  const encodedHashType = toHex(encodeType({\n    primaryType,\n    types\n  }));\n  return keccak256(encodedHashType);\n}\nfunction encodeType(_ref3) {\n  let {\n    primaryType,\n    types\n  } = _ref3;\n  let result = \"\";\n  const unsortedDeps = findTypeDependencies({\n    primaryType,\n    types\n  });\n  unsortedDeps.delete(primaryType);\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];\n  for (const type of deps) {\n    if (!types[type]) throw new Error(\"Invalid types\");\n    result += \"\".concat(type, \"(\").concat(types[type].map(_ref4 => {\n      let {\n        name,\n        type: t\n      } = _ref4;\n      return \"\".concat(t, \" \").concat(name);\n    }).join(\",\"), \")\");\n  }\n  return result;\n}\nfunction findTypeDependencies(_ref5) {\n  let {\n    primaryType: primaryType_,\n    types\n  } = _ref5;\n  let results = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n  const match = primaryType_.match(/^[0-9A-Z_a-z]*/);\n  const primaryType = match === null || match === void 0 ? void 0 : match[0];\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results;\n  }\n  results.add(primaryType);\n  for (const field of types[primaryType]) {\n    findTypeDependencies({\n      primaryType: field.type,\n      types\n    }, results);\n  }\n  return results;\n}\nfunction encodeField(_ref6) {\n  let {\n    types,\n    name,\n    type,\n    value\n  } = _ref6;\n  if (types[type] !== undefined) {\n    return [{\n      type: \"bytes32\"\n    }, keccak256(encodeData({\n      data: value,\n      primaryType: type,\n      types\n    }))];\n  }\n  if (type === \"bytes\") {\n    const prepend = value.length % 2 ? \"0\" : \"\";\n    value = \"0x\".concat(prepend + value.slice(2));\n    return [{\n      type: \"bytes32\"\n    }, keccak256(value)];\n  }\n  if (type === \"string\") return [{\n    type: \"bytes32\"\n  }, keccak256(toHex(value))];\n  if (type.lastIndexOf(\"]\") === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf(\"[\"));\n    const typeValuePairs =\n    // biome-ignore lint/suspicious/noExplicitAny: Can't anticipate types of nested values\n    value.map(item => encodeField({\n      name,\n      type: parsedType,\n      types,\n      value: item\n    }));\n    return [{\n      type: \"bytes32\"\n    }, keccak256(encodeAbiParameters(typeValuePairs.map(_ref7 => {\n      let [t] = _ref7;\n      return t;\n    }), typeValuePairs.map(_ref8 => {\n      let [, v] = _ref8;\n      return v;\n    })))];\n  }\n  return [{\n    type\n  }, value];\n}","map":{"version":3,"names":["ox__Bytes","ox__TypedData","encodeAbiParameters","toHex","keccak256","hashTypedData","parameters","domain","message","primaryType","types","_objectSpread","EIP712Domain","extractEip712DomainTypes","validate","parts","push","hashDomain","hashedStruct","encoded","encodeData","data","concat","map","p","fromHex","_ref","encodedTypes","type","encodedValues","hashType","Error","field","value","encodeField","name","_ref2","encodedHashType","encodeType","_ref3","result","unsortedDeps","findTypeDependencies","delete","deps","Array","from","sort","_ref4","t","join","_ref5","primaryType_","results","arguments","length","undefined","Set","match","has","add","_ref6","prepend","slice","lastIndexOf","parsedType","typeValuePairs","item","_ref7","_ref8","v"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/utils/hashing/hashTypedData.ts"],"sourcesContent":["import type * as ox__AbiParameters from \"ox/AbiParameters\";\nimport * as ox__Bytes from \"ox/Bytes\";\nimport * as ox__TypedData from \"ox/TypedData\";\nimport { encodeAbiParameters } from \"../abi/encodeAbiParameters.js\";\nimport { type Hex, toHex } from \"../encoding/hex.js\";\nimport { keccak256 } from \"./keccak256.js\";\n\ntype MessageTypeProperty = {\n  name: string;\n  type: string;\n};\n\nexport type HashTypedDataParams<\n  typedData extends\n    | ox__TypedData.TypedData\n    | Record<string, unknown> = ox__TypedData.TypedData,\n  primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n> = ox__TypedData.Definition<typedData, primaryType>;\n\n/**\n * @internal\n */\nexport function hashTypedData<\n  const typedData extends ox__TypedData.TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | \"EIP712Domain\",\n>(parameters: HashTypedDataParams<typedData, primaryType>): Hex {\n  const {\n    domain = {},\n    message,\n    primaryType,\n  } = parameters as HashTypedDataParams;\n  const types = {\n    EIP712Domain: ox__TypedData.extractEip712DomainTypes(domain),\n    ...parameters.types,\n  };\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  ox__TypedData.validate({\n    domain,\n    message,\n    primaryType,\n    types,\n  });\n\n  const parts: Hex[] = [\"0x1901\"];\n  if (domain)\n    parts.push(\n      ox__TypedData.hashDomain({\n        domain,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    );\n\n  if (primaryType !== \"EIP712Domain\") {\n    const hashedStruct = (() => {\n      const encoded = encodeData({\n        data: message,\n        primaryType,\n        types: types as Record<string, MessageTypeProperty[]>,\n      });\n      return keccak256(encoded);\n    })();\n\n    parts.push(hashedStruct);\n  }\n\n  return keccak256(ox__Bytes.concat(...parts.map((p) => ox__Bytes.fromHex(p))));\n}\n\nfunction encodeData({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>;\n  primaryType: string;\n  types: Record<string, MessageTypeProperty[]>;\n}) {\n  const encodedTypes: ox__AbiParameters.Parameter[] = [{ type: \"bytes32\" }];\n  const encodedValues: unknown[] = [hashType({ primaryType, types })];\n\n  if (!types[primaryType]) throw new Error(\"Invalid types\");\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      name: field.name,\n      type: field.type,\n      types,\n      value: data[field.name],\n    });\n    encodedTypes.push(type);\n    encodedValues.push(value);\n  }\n\n  return encodeAbiParameters(encodedTypes, encodedValues);\n}\n\nfunction hashType({\n  primaryType,\n  types,\n}: {\n  primaryType: string;\n  types: Record<string, MessageTypeProperty[]>;\n}) {\n  const encodedHashType = toHex(encodeType({ primaryType, types }));\n  return keccak256(encodedHashType);\n}\n\nfunction encodeType({\n  primaryType,\n  types,\n}: {\n  primaryType: string;\n  types: Record<string, MessageTypeProperty[]>;\n}) {\n  let result = \"\";\n  const unsortedDeps = findTypeDependencies({ primaryType, types });\n  unsortedDeps.delete(primaryType);\n\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];\n  for (const type of deps) {\n    if (!types[type]) throw new Error(\"Invalid types\");\n    result += `${type}(${types[type]\n      .map(({ name, type: t }) => `${t} ${name}`)\n      .join(\",\")})`;\n  }\n\n  return result;\n}\n\nfunction findTypeDependencies(\n  {\n    primaryType: primaryType_,\n    types,\n  }: {\n    primaryType: string;\n    types: Record<string, MessageTypeProperty[]>;\n  },\n  results: Set<string> = new Set(),\n): Set<string> {\n  const match = primaryType_.match(/^\\w*/u);\n  const primaryType = match?.[0] as string;\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results;\n  }\n\n  results.add(primaryType);\n\n  for (const field of types[primaryType]) {\n    findTypeDependencies({ primaryType: field.type, types }, results);\n  }\n  return results;\n}\n\nfunction encodeField({\n  types,\n  name,\n  type,\n  value,\n}: {\n  types: Record<string, MessageTypeProperty[]>;\n  name: string;\n  type: string;\n  // biome-ignore lint/suspicious/noExplicitAny: Can't anticipate types of nested values\n  value: any;\n  // biome-ignore lint/suspicious/noExplicitAny: Can't anticipate types of nested values\n}): [type: ox__AbiParameters.Parameter, value: any] {\n  if (types[type] !== undefined) {\n    return [\n      { type: \"bytes32\" },\n      keccak256(encodeData({ data: value, primaryType: type, types })),\n    ];\n  }\n\n  if (type === \"bytes\") {\n    const prepend = value.length % 2 ? \"0\" : \"\";\n    value = `0x${prepend + value.slice(2)}`;\n    return [{ type: \"bytes32\" }, keccak256(value)];\n  }\n\n  if (type === \"string\") return [{ type: \"bytes32\" }, keccak256(toHex(value))];\n\n  if (type.lastIndexOf(\"]\") === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf(\"[\"));\n    const typeValuePairs =\n      // biome-ignore lint/suspicious/noExplicitAny: Can't anticipate types of nested values\n      (value as [ox__AbiParameters.Parameter, any][]).map((item) =>\n        encodeField({\n          name,\n          type: parsedType,\n          types,\n          value: item,\n        }),\n      );\n    return [\n      { type: \"bytes32\" },\n      keccak256(\n        encodeAbiParameters(\n          typeValuePairs.map(([t]) => t),\n          typeValuePairs.map(([, v]) => v),\n        ),\n      ),\n    ];\n  }\n\n  return [{ type }, value];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}