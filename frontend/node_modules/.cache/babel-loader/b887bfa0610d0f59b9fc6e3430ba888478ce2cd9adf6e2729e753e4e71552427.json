{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport { inMemoryStorage } from \"../../../../utils/storage/inMemoryStorage.js\";\nimport { webLocalStorage } from \"../../../../utils/storage/webStorage.js\";\nimport { getUserStatus } from \"../../core/actions/get-enclave-user-status.js\";\nimport { authEndpoint } from \"../../core/authentication/authEndpoint.js\";\nimport { backendAuthenticate } from \"../../core/authentication/backend.js\";\nimport { ClientScopedStorage } from \"../../core/authentication/client-scoped-storage.js\";\nimport { guestAuthenticate } from \"../../core/authentication/guest.js\";\nimport { customJwt } from \"../../core/authentication/jwt.js\";\nimport { getLinkedProfilesInternal, linkAccount, unlinkAccount } from \"../../core/authentication/linkAccount.js\";\nimport { loginWithPasskey, registerPasskey } from \"../../core/authentication/passkeys.js\";\nimport { siweAuthenticate } from \"../../core/authentication/siwe.js\";\nimport { EnclaveWallet } from \"../../core/wallet/enclave-wallet.js\";\nimport { InAppWalletIframeCommunicator } from \"../utils/iFrameCommunication/InAppWalletIframeCommunicator.js\";\nimport { Auth } from \"./auth/iframe-auth.js\";\nimport { loginWithOauth, loginWithOauthRedirect } from \"./auth/oauth.js\";\nimport { sendOtp, verifyOtp } from \"./auth/otp.js\";\nimport { IFrameWallet } from \"./iframe-wallet.js\";\n/**\n * @internal\n */\nexport class InAppWebConnector {\n  isClientIdLegacyPaper(clientId) {\n    if (clientId.indexOf(\"-\") > 0 && clientId.length === 36) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * @example\n   * `const thirdwebInAppWallet = new InAppWalletSdk({ clientId: \"\", chain: \"Goerli\" });`\n   * @internal\n   */\n  constructor(_ref) {\n    let {\n      client,\n      onAuthSuccess,\n      ecosystem,\n      passkeyDomain,\n      storage\n    } = _ref;\n    Object.defineProperty(this, \"client\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"ecosystem\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"querier\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"storage\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"wallet\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\n     * Used to manage the Auth state of the user.\n     */\n    Object.defineProperty(this, \"auth\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"passkeyDomain\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    if (this.isClientIdLegacyPaper(client.clientId)) {\n      throw new Error(\"You are using a legacy clientId. Please use the clientId found on the thirdweb dashboard settings page\");\n    }\n    const baseUrl = getThirdwebBaseUrl(\"inAppWallet\");\n    this.client = client;\n    this.ecosystem = ecosystem;\n    this.passkeyDomain = passkeyDomain;\n    this.storage = new ClientScopedStorage({\n      clientId: client.clientId,\n      ecosystem: ecosystem,\n      storage: storage !== null && storage !== void 0 ? storage : getDefaultStorage()\n    });\n    this.querier = new InAppWalletIframeCommunicator({\n      baseUrl,\n      clientId: client.clientId,\n      ecosystem\n    });\n    this.auth = new Auth({\n      baseUrl,\n      client,\n      ecosystem,\n      localStorage: this.storage,\n      onAuthSuccess: async authResult => {\n        onAuthSuccess === null || onAuthSuccess === void 0 || onAuthSuccess(authResult);\n        if (authResult.storedToken.authDetails.walletType === \"sharded\") {\n          // If this is an existing sharded ecosystem wallet, we'll need to migrate\n          const result = await this.querier.call({\n            params: {\n              storedToken: authResult.storedToken\n            },\n            procedureName: \"migrateFromShardToEnclave\"\n          });\n          if (!result) {\n            console.warn(\"Failed to migrate from sharded to enclave wallet, continuing with sharded wallet\");\n          }\n        }\n        this.wallet = await this.initializeWallet(authResult.storedToken.cookieString);\n        if (!this.wallet) {\n          throw new Error(\"Failed to initialize wallet\");\n        }\n        const deviceShareStored = \"deviceShareStored\" in authResult.walletDetails ? authResult.walletDetails.deviceShareStored : undefined;\n        await this.wallet.postWalletSetUp({\n          deviceShareStored,\n          storedToken: authResult.storedToken\n        });\n        if (this.wallet instanceof IFrameWallet) {\n          await this.querier.call({\n            params: {\n              authCookie: authResult.storedToken.cookieString,\n              clientId: this.client.clientId,\n              // For enclave wallets we won't have a device share\n              deviceShareStored: \"deviceShareStored\" in authResult.walletDetails ? authResult.walletDetails.deviceShareStored : null,\n              ecosystemId: ecosystem === null || ecosystem === void 0 ? void 0 : ecosystem.id,\n              partnerId: ecosystem === null || ecosystem === void 0 ? void 0 : ecosystem.partnerId,\n              walletUserId: authResult.storedToken.authDetails.userWalletId\n            },\n            procedureName: \"initIframe\"\n          });\n        }\n        return {\n          user: {\n            account: await this.wallet.getAccount(),\n            authDetails: authResult.storedToken.authDetails,\n            status: \"Logged In, Wallet Initialized\",\n            walletAddress: authResult.walletDetails.walletAddress\n          }\n        };\n      },\n      querier: this.querier\n    });\n  }\n  async initializeWallet(authToken) {\n    var _user$wallets$;\n    const storedAuthToken = await this.storage.getAuthCookie();\n    if (!authToken && storedAuthToken === null) {\n      throw new Error(\"No auth token provided and no stored auth token found to initialize the wallet\");\n    }\n    const user = await getUserStatus({\n      authToken: authToken || storedAuthToken,\n      client: this.client,\n      ecosystem: this.ecosystem\n    });\n    if (!user) {\n      throw new Error(\"Cannot initialize wallet, no user logged in\");\n    }\n    if (user.wallets.length === 0) {\n      throw new Error(\"Cannot initialize wallet, this user does not have a wallet generated yet\");\n    }\n    if (((_user$wallets$ = user.wallets[0]) === null || _user$wallets$ === void 0 ? void 0 : _user$wallets$.type) === \"enclave\") {\n      return new EnclaveWallet({\n        address: user.wallets[0].address,\n        client: this.client,\n        ecosystem: this.ecosystem,\n        storage: this.storage\n      });\n    }\n    return new IFrameWallet({\n      client: this.client,\n      ecosystem: this.ecosystem,\n      localStorage: this.storage,\n      querier: this.querier\n    });\n  }\n  /**\n   * Gets the user if they're logged in\n   * @example\n   * ```js\n   *  const user = await thirdwebInAppWallet.getUser();\n   *  switch (user.status) {\n   *     case UserWalletStatus.LOGGED_OUT: {\n   *       // User is logged out, call one of the auth methods on thirdwebInAppWallet.auth to authenticate the user\n   *       break;\n   *     }\n   *     case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {\n   *       // user is logged in and wallet is all set up.\n   *       // You have access to:\n   *       user.status;\n   *       user.authDetails;\n   *       user.walletAddress;\n   *       user.wallet;\n   *       break;\n   *     }\n   * }\n   * ```\n   * @returns GetUser - an object to containing various information on the user statuses\n   */\n  async getUser() {\n    // If we don't have a wallet yet we'll create one\n    if (!this.wallet) {\n      const localAuthToken = await this.storage.getAuthCookie();\n      if (!localAuthToken) {\n        return {\n          status: \"Logged Out\"\n        };\n      }\n      this.wallet = await this.initializeWallet(localAuthToken);\n    }\n    if (!this.wallet) {\n      throw new Error(\"Wallet not initialized\");\n    }\n    return await this.wallet.getUserWalletStatus();\n  }\n  getAccount() {\n    if (!this.wallet) {\n      throw new Error(\"Wallet not initialized\");\n    }\n    return this.wallet.getAccount();\n  }\n  async preAuthenticate(args) {\n    return sendOtp(_objectSpread(_objectSpread({}, args), {}, {\n      client: this.client,\n      ecosystem: this.ecosystem\n    }));\n  }\n  async authenticateWithRedirect(strategy, mode, redirectUrl) {\n    return loginWithOauthRedirect({\n      authOption: strategy,\n      client: this.client,\n      ecosystem: this.ecosystem,\n      mode,\n      redirectUrl\n    });\n  }\n  async loginWithAuthToken(authResult, recoveryCode) {\n    return this.auth.loginWithAuthToken(authResult, recoveryCode);\n  }\n  /**\n   * Authenticates the user and returns the auth token, but does not instantiate their wallet\n   */\n  async authenticate(args) {\n    const strategy = args.strategy;\n    switch (strategy) {\n      case \"email\":\n        return verifyOtp(_objectSpread(_objectSpread({}, args), {}, {\n          client: this.client,\n          ecosystem: this.ecosystem\n        }));\n      case \"phone\":\n        return verifyOtp(_objectSpread(_objectSpread({}, args), {}, {\n          client: this.client,\n          ecosystem: this.ecosystem\n        }));\n      case \"auth_endpoint\":\n        {\n          return authEndpoint({\n            client: this.client,\n            ecosystem: this.ecosystem,\n            payload: args.payload\n          });\n        }\n      case \"jwt\":\n        return customJwt({\n          client: this.client,\n          ecosystem: this.ecosystem,\n          jwt: args.jwt\n        });\n      case \"passkey\":\n        {\n          return this.passkeyAuth(args);\n        }\n      case \"iframe_email_verification\":\n        {\n          return this.auth.authenticateWithIframe({\n            email: args.email\n          });\n        }\n      case \"iframe\":\n        {\n          return this.auth.authenticateWithModal();\n        }\n      case \"apple\":\n      case \"facebook\":\n      case \"google\":\n      case \"telegram\":\n      case \"github\":\n      case \"twitch\":\n      case \"farcaster\":\n      case \"line\":\n      case \"x\":\n      case \"tiktok\":\n      case \"steam\":\n      case \"coinbase\":\n      case \"discord\":\n        {\n          return loginWithOauth({\n            authOption: strategy,\n            client: this.client,\n            closeOpenedWindow: args.closeOpenedWindow,\n            ecosystem: this.ecosystem,\n            openedWindow: args.openedWindow\n          });\n        }\n      case \"guest\":\n        {\n          return guestAuthenticate({\n            client: this.client,\n            ecosystem: this.ecosystem,\n            storage: this.storage\n          });\n        }\n      case \"backend\":\n        {\n          return backendAuthenticate({\n            client: this.client,\n            ecosystem: this.ecosystem,\n            walletSecret: args.walletSecret\n          });\n        }\n      case \"wallet\":\n        {\n          return siweAuthenticate({\n            client: this.client,\n            ecosystem: this.ecosystem,\n            wallet: args.wallet\n          });\n        }\n    }\n  }\n  /**\n   * Authenticates the user then instantiates their wallet using the resulting auth token\n   */\n  async connect(args) {\n    const strategy = args.strategy;\n    switch (strategy) {\n      case \"auth_endpoint\":\n      case \"jwt\":\n        {\n          const authToken = await this.authenticate(args);\n          return await this.loginWithAuthToken(authToken, args.encryptionKey);\n        }\n      case \"iframe_email_verification\":\n        {\n          return this.auth.loginWithIframe({\n            email: args.email\n          });\n        }\n      case \"iframe\":\n        {\n          return this.auth.loginWithModal();\n        }\n      case \"passkey\":\n        {\n          const authToken = await this.passkeyAuth(args);\n          return this.loginWithAuthToken(authToken);\n        }\n      case \"backend\":\n      case \"phone\":\n      case \"email\":\n      case \"wallet\":\n      case \"apple\":\n      case \"facebook\":\n      case \"google\":\n      case \"farcaster\":\n      case \"telegram\":\n      case \"github\":\n      case \"line\":\n      case \"x\":\n      case \"tiktok\":\n      case \"guest\":\n      case \"coinbase\":\n      case \"twitch\":\n      case \"steam\":\n      case \"discord\":\n        {\n          const authToken = await this.authenticate(args);\n          return await this.auth.loginWithAuthToken(authToken);\n        }\n      default:\n        assertUnreachable(strategy);\n    }\n  }\n  async logout() {\n    return await this.auth.logout();\n  }\n  async passkeyAuth(args) {\n    var _this$passkeyDomain3, _this$passkeyDomain4;\n    const {\n      PasskeyWebClient\n    } = await import(\"./auth/passkeys.js\");\n    const {\n      passkeyName,\n      storeLastUsedPasskey = true\n    } = args;\n    const passkeyClient = new PasskeyWebClient();\n    const storage = this.storage;\n    if (args.type === \"sign-up\") {\n      var _this$passkeyDomain, _this$passkeyDomain2;\n      return registerPasskey({\n        client: this.client,\n        ecosystem: this.ecosystem,\n        passkeyClient,\n        rp: {\n          id: (_this$passkeyDomain = this.passkeyDomain) !== null && _this$passkeyDomain !== void 0 ? _this$passkeyDomain : window.location.hostname,\n          name: (_this$passkeyDomain2 = this.passkeyDomain) !== null && _this$passkeyDomain2 !== void 0 ? _this$passkeyDomain2 : window.document.title\n        },\n        storage: storeLastUsedPasskey ? storage : undefined,\n        username: passkeyName\n      });\n    }\n    return loginWithPasskey({\n      client: this.client,\n      ecosystem: this.ecosystem,\n      passkeyClient,\n      rp: {\n        id: (_this$passkeyDomain3 = this.passkeyDomain) !== null && _this$passkeyDomain3 !== void 0 ? _this$passkeyDomain3 : window.location.hostname,\n        name: (_this$passkeyDomain4 = this.passkeyDomain) !== null && _this$passkeyDomain4 !== void 0 ? _this$passkeyDomain4 : window.document.title\n      },\n      storage: storeLastUsedPasskey ? storage : undefined\n    });\n  }\n  async linkProfile(args) {\n    const {\n      storedToken\n    } = await this.authenticate(args);\n    return await linkAccount({\n      client: args.client,\n      ecosystem: args.ecosystem || this.ecosystem,\n      storage: this.storage,\n      tokenToLink: storedToken.cookieString\n    });\n  }\n  async unlinkProfile(profile, allowAccountDeletion) {\n    return await unlinkAccount({\n      allowAccountDeletion,\n      client: this.client,\n      ecosystem: this.ecosystem,\n      profileToUnlink: profile,\n      storage: this.storage\n    });\n  }\n  async getProfiles() {\n    return getLinkedProfilesInternal({\n      client: this.client,\n      ecosystem: this.ecosystem,\n      storage: this.storage\n    });\n  }\n}\nfunction assertUnreachable(x, message) {\n  throw new Error(message !== null && message !== void 0 ? message : \"Invalid param: \".concat(x));\n}\nfunction getDefaultStorage() {\n  if (typeof window !== \"undefined\" && window.localStorage) {\n    return webLocalStorage;\n  }\n  // default to in-memory storage if we're not in the browser\n  return inMemoryStorage;\n}","map":{"version":3,"names":["getThirdwebBaseUrl","inMemoryStorage","webLocalStorage","getUserStatus","authEndpoint","backendAuthenticate","ClientScopedStorage","guestAuthenticate","customJwt","getLinkedProfilesInternal","linkAccount","unlinkAccount","loginWithPasskey","registerPasskey","siweAuthenticate","EnclaveWallet","InAppWalletIframeCommunicator","Auth","loginWithOauth","loginWithOauthRedirect","sendOtp","verifyOtp","IFrameWallet","InAppWebConnector","isClientIdLegacyPaper","clientId","indexOf","length","constructor","_ref","client","onAuthSuccess","ecosystem","passkeyDomain","storage","Object","defineProperty","Error","baseUrl","getDefaultStorage","querier","auth","localStorage","authResult","storedToken","authDetails","walletType","result","call","params","procedureName","console","warn","wallet","initializeWallet","cookieString","deviceShareStored","walletDetails","undefined","postWalletSetUp","authCookie","ecosystemId","id","partnerId","walletUserId","userWalletId","user","account","getAccount","status","walletAddress","authToken","_user$wallets$","storedAuthToken","getAuthCookie","wallets","type","address","getUser","localAuthToken","getUserWalletStatus","preAuthenticate","args","_objectSpread","authenticateWithRedirect","strategy","mode","redirectUrl","authOption","loginWithAuthToken","recoveryCode","authenticate","payload","jwt","passkeyAuth","authenticateWithIframe","email","authenticateWithModal","closeOpenedWindow","openedWindow","walletSecret","connect","encryptionKey","loginWithIframe","loginWithModal","assertUnreachable","logout","_this$passkeyDomain3","_this$passkeyDomain4","PasskeyWebClient","passkeyName","storeLastUsedPasskey","passkeyClient","_this$passkeyDomain","_this$passkeyDomain2","rp","window","location","hostname","name","document","title","username","linkProfile","tokenToLink","unlinkProfile","profile","allowAccountDeletion","profileToUnlink","getProfiles","x","message","concat"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/wallets/in-app/web/lib/web-connector.ts"],"sourcesContent":["import type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport type { AsyncStorage } from \"../../../../utils/storage/AsyncStorage.js\";\nimport { inMemoryStorage } from \"../../../../utils/storage/inMemoryStorage.js\";\nimport { webLocalStorage } from \"../../../../utils/storage/webStorage.js\";\nimport type { SocialAuthOption } from \"../../../../wallets/types.js\";\nimport type { Account } from \"../../../interfaces/wallet.js\";\nimport { getUserStatus } from \"../../core/actions/get-enclave-user-status.js\";\nimport { authEndpoint } from \"../../core/authentication/authEndpoint.js\";\nimport { backendAuthenticate } from \"../../core/authentication/backend.js\";\nimport { ClientScopedStorage } from \"../../core/authentication/client-scoped-storage.js\";\nimport { guestAuthenticate } from \"../../core/authentication/guest.js\";\nimport { customJwt } from \"../../core/authentication/jwt.js\";\nimport {\n  getLinkedProfilesInternal,\n  linkAccount,\n  unlinkAccount,\n} from \"../../core/authentication/linkAccount.js\";\nimport {\n  loginWithPasskey,\n  registerPasskey,\n} from \"../../core/authentication/passkeys.js\";\nimport { siweAuthenticate } from \"../../core/authentication/siwe.js\";\nimport type {\n  AuthArgsType,\n  AuthLoginReturnType,\n  AuthStoredTokenWithCookieReturnType,\n  GetUser,\n  LogoutReturnType,\n  MultiStepAuthArgsType,\n  MultiStepAuthProviderType,\n  Profile,\n  SingleStepAuthArgsType,\n} from \"../../core/authentication/types.js\";\nimport type { InAppConnector } from \"../../core/interfaces/connector.js\";\nimport { EnclaveWallet } from \"../../core/wallet/enclave-wallet.js\";\nimport type { Ecosystem } from \"../../core/wallet/types.js\";\nimport type { IWebWallet } from \"../../core/wallet/web-wallet.js\";\nimport type { InAppWalletConstructorType } from \"../types.js\";\nimport { InAppWalletIframeCommunicator } from \"../utils/iFrameCommunication/InAppWalletIframeCommunicator.js\";\nimport { Auth, type AuthQuerierTypes } from \"./auth/iframe-auth.js\";\nimport { loginWithOauth, loginWithOauthRedirect } from \"./auth/oauth.js\";\nimport { sendOtp, verifyOtp } from \"./auth/otp.js\";\nimport { IFrameWallet } from \"./iframe-wallet.js\";\n\n/**\n * @internal\n */\nexport class InAppWebConnector implements InAppConnector {\n  private client: ThirdwebClient;\n  private ecosystem?: Ecosystem;\n  private querier: InAppWalletIframeCommunicator<AuthQuerierTypes>;\n  public storage: ClientScopedStorage;\n\n  private wallet?: IWebWallet;\n  /**\n   * Used to manage the Auth state of the user.\n   */\n  auth: Auth;\n  private passkeyDomain?: string;\n\n  private isClientIdLegacyPaper(clientId: string): boolean {\n    if (clientId.indexOf(\"-\") > 0 && clientId.length === 36) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @example\n   * `const thirdwebInAppWallet = new InAppWalletSdk({ clientId: \"\", chain: \"Goerli\" });`\n   * @internal\n   */\n  constructor({\n    client,\n    onAuthSuccess,\n    ecosystem,\n    passkeyDomain,\n    storage,\n  }: InAppWalletConstructorType) {\n    if (this.isClientIdLegacyPaper(client.clientId)) {\n      throw new Error(\n        \"You are using a legacy clientId. Please use the clientId found on the thirdweb dashboard settings page\",\n      );\n    }\n    const baseUrl = getThirdwebBaseUrl(\"inAppWallet\");\n    this.client = client;\n    this.ecosystem = ecosystem;\n    this.passkeyDomain = passkeyDomain;\n    this.storage = new ClientScopedStorage({\n      clientId: client.clientId,\n      ecosystem: ecosystem,\n      storage: storage ?? getDefaultStorage(),\n    });\n    this.querier = new InAppWalletIframeCommunicator({\n      baseUrl,\n      clientId: client.clientId,\n      ecosystem,\n    });\n\n    this.auth = new Auth({\n      baseUrl,\n      client,\n      ecosystem,\n      localStorage: this.storage,\n      onAuthSuccess: async (authResult) => {\n        onAuthSuccess?.(authResult);\n\n        if (authResult.storedToken.authDetails.walletType === \"sharded\") {\n          // If this is an existing sharded ecosystem wallet, we'll need to migrate\n          const result = await this.querier.call<boolean>({\n            params: {\n              storedToken: authResult.storedToken,\n            },\n            procedureName: \"migrateFromShardToEnclave\",\n          });\n          if (!result) {\n            console.warn(\n              \"Failed to migrate from sharded to enclave wallet, continuing with sharded wallet\",\n            );\n          }\n        }\n\n        this.wallet = await this.initializeWallet(\n          authResult.storedToken.cookieString,\n        );\n\n        if (!this.wallet) {\n          throw new Error(\"Failed to initialize wallet\");\n        }\n\n        const deviceShareStored =\n          \"deviceShareStored\" in authResult.walletDetails\n            ? authResult.walletDetails.deviceShareStored\n            : undefined;\n\n        await this.wallet.postWalletSetUp({\n          deviceShareStored,\n          storedToken: authResult.storedToken,\n        });\n\n        if (this.wallet instanceof IFrameWallet) {\n          await this.querier.call({\n            params: {\n              authCookie: authResult.storedToken.cookieString,\n              clientId: this.client.clientId,\n              // For enclave wallets we won't have a device share\n              deviceShareStored:\n                \"deviceShareStored\" in authResult.walletDetails\n                  ? authResult.walletDetails.deviceShareStored\n                  : null,\n              ecosystemId: ecosystem?.id,\n              partnerId: ecosystem?.partnerId,\n              walletUserId: authResult.storedToken.authDetails.userWalletId,\n            },\n            procedureName: \"initIframe\",\n          });\n        }\n\n        return {\n          user: {\n            account: await this.wallet.getAccount(),\n            authDetails: authResult.storedToken.authDetails,\n            status: \"Logged In, Wallet Initialized\",\n            walletAddress: authResult.walletDetails.walletAddress,\n          },\n        };\n      },\n      querier: this.querier,\n    });\n  }\n\n  async initializeWallet(authToken?: string): Promise<IWebWallet> {\n    const storedAuthToken = await this.storage.getAuthCookie();\n    if (!authToken && storedAuthToken === null) {\n      throw new Error(\n        \"No auth token provided and no stored auth token found to initialize the wallet\",\n      );\n    }\n\n    const user = await getUserStatus({\n      authToken: authToken || (storedAuthToken as string),\n      client: this.client,\n      ecosystem: this.ecosystem,\n    });\n\n    if (!user) {\n      throw new Error(\"Cannot initialize wallet, no user logged in\");\n    }\n    if (user.wallets.length === 0) {\n      throw new Error(\n        \"Cannot initialize wallet, this user does not have a wallet generated yet\",\n      );\n    }\n\n    if (user.wallets[0]?.type === \"enclave\") {\n      return new EnclaveWallet({\n        address: user.wallets[0].address,\n        client: this.client,\n        ecosystem: this.ecosystem,\n        storage: this.storage,\n      });\n    }\n\n    return new IFrameWallet({\n      client: this.client,\n      ecosystem: this.ecosystem,\n      localStorage: this.storage,\n      querier: this.querier,\n    });\n  }\n\n  /**\n   * Gets the user if they're logged in\n   * @example\n   * ```js\n   *  const user = await thirdwebInAppWallet.getUser();\n   *  switch (user.status) {\n   *     case UserWalletStatus.LOGGED_OUT: {\n   *       // User is logged out, call one of the auth methods on thirdwebInAppWallet.auth to authenticate the user\n   *       break;\n   *     }\n   *     case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {\n   *       // user is logged in and wallet is all set up.\n   *       // You have access to:\n   *       user.status;\n   *       user.authDetails;\n   *       user.walletAddress;\n   *       user.wallet;\n   *       break;\n   *     }\n   * }\n   * ```\n   * @returns GetUser - an object to containing various information on the user statuses\n   */\n  async getUser(): Promise<GetUser> {\n    // If we don't have a wallet yet we'll create one\n    if (!this.wallet) {\n      const localAuthToken = await this.storage.getAuthCookie();\n      if (!localAuthToken) {\n        return { status: \"Logged Out\" };\n      }\n      this.wallet = await this.initializeWallet(localAuthToken);\n    }\n    if (!this.wallet) {\n      throw new Error(\"Wallet not initialized\");\n    }\n    return await this.wallet.getUserWalletStatus();\n  }\n\n  getAccount(): Promise<Account> {\n    if (!this.wallet) {\n      throw new Error(\"Wallet not initialized\");\n    }\n    return this.wallet.getAccount();\n  }\n\n  async preAuthenticate(args: MultiStepAuthProviderType): Promise<void> {\n    return sendOtp({\n      ...args,\n      client: this.client,\n      ecosystem: this.ecosystem,\n    });\n  }\n\n  async authenticateWithRedirect(\n    strategy: SocialAuthOption,\n    mode?: \"redirect\" | \"popup\" | \"window\",\n    redirectUrl?: string,\n  ): Promise<void> {\n    return loginWithOauthRedirect({\n      authOption: strategy,\n      client: this.client,\n      ecosystem: this.ecosystem,\n      mode,\n      redirectUrl,\n    });\n  }\n\n  async loginWithAuthToken(\n    authResult: AuthStoredTokenWithCookieReturnType,\n    recoveryCode?: string,\n  ) {\n    return this.auth.loginWithAuthToken(authResult, recoveryCode);\n  }\n\n  /**\n   * Authenticates the user and returns the auth token, but does not instantiate their wallet\n   */\n  async authenticate(\n    args: MultiStepAuthArgsType | SingleStepAuthArgsType,\n  ): Promise<AuthStoredTokenWithCookieReturnType> {\n    const strategy = args.strategy;\n    switch (strategy) {\n      case \"email\":\n        return verifyOtp({\n          ...args,\n          client: this.client,\n          ecosystem: this.ecosystem,\n        });\n      case \"phone\":\n        return verifyOtp({\n          ...args,\n          client: this.client,\n          ecosystem: this.ecosystem,\n        });\n      case \"auth_endpoint\": {\n        return authEndpoint({\n          client: this.client,\n          ecosystem: this.ecosystem,\n          payload: args.payload,\n        });\n      }\n      case \"jwt\":\n        return customJwt({\n          client: this.client,\n          ecosystem: this.ecosystem,\n          jwt: args.jwt,\n        });\n      case \"passkey\": {\n        return this.passkeyAuth(args);\n      }\n      case \"iframe_email_verification\": {\n        return this.auth.authenticateWithIframe({\n          email: args.email,\n        });\n      }\n      case \"iframe\": {\n        return this.auth.authenticateWithModal();\n      }\n      case \"apple\":\n      case \"facebook\":\n      case \"google\":\n      case \"telegram\":\n      case \"github\":\n      case \"twitch\":\n      case \"farcaster\":\n      case \"line\":\n      case \"x\":\n      case \"tiktok\":\n      case \"steam\":\n      case \"coinbase\":\n      case \"discord\": {\n        return loginWithOauth({\n          authOption: strategy,\n          client: this.client,\n          closeOpenedWindow: args.closeOpenedWindow,\n          ecosystem: this.ecosystem,\n          openedWindow: args.openedWindow,\n        });\n      }\n      case \"guest\": {\n        return guestAuthenticate({\n          client: this.client,\n          ecosystem: this.ecosystem,\n          storage: this.storage,\n        });\n      }\n      case \"backend\": {\n        return backendAuthenticate({\n          client: this.client,\n          ecosystem: this.ecosystem,\n          walletSecret: args.walletSecret,\n        });\n      }\n      case \"wallet\": {\n        return siweAuthenticate({\n          client: this.client,\n          ecosystem: this.ecosystem,\n          wallet: args.wallet,\n        });\n      }\n    }\n  }\n\n  /**\n   * Authenticates the user then instantiates their wallet using the resulting auth token\n   */\n  async connect(\n    args: MultiStepAuthArgsType | SingleStepAuthArgsType,\n  ): Promise<AuthLoginReturnType> {\n    const strategy = args.strategy;\n    switch (strategy) {\n      case \"auth_endpoint\":\n      case \"jwt\": {\n        const authToken = await this.authenticate(args);\n        return await this.loginWithAuthToken(authToken, args.encryptionKey);\n      }\n      case \"iframe_email_verification\": {\n        return this.auth.loginWithIframe({\n          email: args.email,\n        });\n      }\n      case \"iframe\": {\n        return this.auth.loginWithModal();\n      }\n      case \"passkey\": {\n        const authToken = await this.passkeyAuth(args);\n        return this.loginWithAuthToken(authToken);\n      }\n      case \"backend\":\n      case \"phone\":\n      case \"email\":\n      case \"wallet\":\n      case \"apple\":\n      case \"facebook\":\n      case \"google\":\n      case \"farcaster\":\n      case \"telegram\":\n      case \"github\":\n      case \"line\":\n      case \"x\":\n      case \"tiktok\":\n      case \"guest\":\n      case \"coinbase\":\n      case \"twitch\":\n      case \"steam\":\n      case \"discord\": {\n        const authToken = await this.authenticate(args);\n        return await this.auth.loginWithAuthToken(authToken);\n      }\n\n      default:\n        assertUnreachable(strategy);\n    }\n  }\n\n  async logout(): Promise<LogoutReturnType> {\n    return await this.auth.logout();\n  }\n\n  private async passkeyAuth(\n    args: Extract<SingleStepAuthArgsType, { strategy: \"passkey\" }>,\n  ) {\n    const { PasskeyWebClient } = await import(\"./auth/passkeys.js\");\n    const { passkeyName, storeLastUsedPasskey = true } = args;\n    const passkeyClient = new PasskeyWebClient();\n    const storage = this.storage;\n    if (args.type === \"sign-up\") {\n      return registerPasskey({\n        client: this.client,\n        ecosystem: this.ecosystem,\n        passkeyClient,\n        rp: {\n          id: this.passkeyDomain ?? window.location.hostname,\n          name: this.passkeyDomain ?? window.document.title,\n        },\n        storage: storeLastUsedPasskey ? storage : undefined,\n        username: passkeyName,\n      });\n    }\n    return loginWithPasskey({\n      client: this.client,\n      ecosystem: this.ecosystem,\n      passkeyClient,\n      rp: {\n        id: this.passkeyDomain ?? window.location.hostname,\n        name: this.passkeyDomain ?? window.document.title,\n      },\n      storage: storeLastUsedPasskey ? storage : undefined,\n    });\n  }\n\n  async linkProfile(args: AuthArgsType) {\n    const { storedToken } = await this.authenticate(args);\n    return await linkAccount({\n      client: args.client,\n      ecosystem: args.ecosystem || this.ecosystem,\n      storage: this.storage,\n      tokenToLink: storedToken.cookieString,\n    });\n  }\n\n  async unlinkProfile(profile: Profile, allowAccountDeletion?: boolean) {\n    return await unlinkAccount({\n      allowAccountDeletion,\n      client: this.client,\n      ecosystem: this.ecosystem,\n      profileToUnlink: profile,\n      storage: this.storage,\n    });\n  }\n\n  async getProfiles() {\n    return getLinkedProfilesInternal({\n      client: this.client,\n      ecosystem: this.ecosystem,\n      storage: this.storage,\n    });\n  }\n}\n\nfunction assertUnreachable(x: never, message?: string): never {\n  throw new Error(message ?? `Invalid param: ${x}`);\n}\n\nfunction getDefaultStorage(): AsyncStorage {\n  if (typeof window !== \"undefined\" && window.localStorage) {\n    return webLocalStorage;\n  }\n  // default to in-memory storage if we're not in the browser\n  return inMemoryStorage;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}