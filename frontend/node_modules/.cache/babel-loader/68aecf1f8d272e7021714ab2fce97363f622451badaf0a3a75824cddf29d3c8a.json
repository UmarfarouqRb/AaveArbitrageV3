{"ast":null,"code":"import { parseAbiItem } from \"abitype\";\nimport { decodeAbiParameters } from \"viem\";\nimport { eth_call } from \"../rpc/actions/eth_call.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport { encodeAbiParameters } from \"../utils/abi/encodeAbiParameters.js\";\nimport { prepareMethod } from \"../utils/abi/prepare-method.js\";\nimport { getAddress } from \"../utils/address.js\";\nimport { isAbiFunction } from \"./utils.js\";\n/**\n * ### Reads state from a deployed smart contract.\n *\n * Use this for raw read calls from a contract, but you can also use read [extensions](https://portal.thirdweb.com/typescript/v5/extensions/use) for predefined methods for common standards.\n *\n * @param options - The transaction options.\n * @returns A promise that resolves with the result of the read call.\n * @transaction\n * @example\n *\n * ### Raw contract call (recommended)\n *\n * You can read from any contract by using the solidity signature of the function you want to call.\n *\n * ```ts\n * import { getContract } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { useReadContract } from \"thirdweb/react\";\n *\n * const contract = getContract({\n *   client,\n *   address: \"0x...\",\n *   chain: sepolia,\n * });\n *\n * const { data, isLoading } = useReadContract({\n *   contract,\n *   method: \"function tokenURI(uint256 tokenId) returns (string)\",\n *   params: [1n],\n * });\n * ```\n *\n * Note that this is type safe, the params types will be enforced based on the signature.\n *\n * ### Raw contract call with `resolveMethod`\n *\n * If you don't have the solidity signature of the function you want to call, you can use the `resolveMethod` helper to resolve the method from any deployed contract.\n *\n * Note that this is not type safe, and will also have a 1 time overhead of resolving the contract ABI.\n *\n * ```ts\n * import { getContract, resolveMethod } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { useReadContract } from \"thirdweb/react\";\n *\n * const contract = getContract({\n *   client,\n *   address: \"0x...\",\n *   chain: sepolia,\n * });\n *\n * const { data, isLoading } = useReadContract({\n *   contract,\n *   method: resolveMethod(\"tokenURI\"),\n *   params: [1n],\n * });\n * ```\n */\nexport async function readContract(options) {\n  const {\n    contract,\n    method,\n    params\n  } = options;\n  const resolvePreparedMethod = async () => {\n    var _contract$abi;\n    if (Array.isArray(method)) {\n      return method;\n    }\n    if (isAbiFunction(method)) {\n      return prepareMethod(method);\n    }\n    if (typeof method === \"function\") {\n      return prepareMethod(\n      // @ts-expect-error - we're sure it's a function\n      await method(contract));\n    }\n    // if the method starts with the string `function ` we always will want to try to parse it\n    if (typeof method === \"string\" && method.startsWith(\"function \")) {\n      // @ts-expect-error - method *is* string in this case\n      const abiItem = parseAbiItem(method);\n      if (abiItem.type === \"function\") {\n        return prepareMethod(abiItem);\n      }\n      throw new Error(\"\\\"method\\\" passed is not of type \\\"function\\\"\");\n    }\n    // check if we have a \"abi\" on the contract\n    if (contract.abi && ((_contract$abi = contract.abi) === null || _contract$abi === void 0 ? void 0 : _contract$abi.length) > 0) {\n      var _contract$abi2;\n      // extract the abiFunction from it\n      const abiFunction = (_contract$abi2 = contract.abi) === null || _contract$abi2 === void 0 ? void 0 : _contract$abi2.find(item => item.type === \"function\" && item.name === method);\n      // if we were able to find it -> return it\n      if (abiFunction) {\n        return prepareMethod(abiFunction);\n      }\n    }\n    throw new Error(\"Could not resolve method \\\"\".concat(method, \"\\\".\"));\n  };\n  // resolve in parallel\n  const [resolvedPreparedMethod, resolvedParams] = await Promise.all([resolvePreparedMethod(), typeof params === \"function\" ? params() : params]);\n  let encodedData;\n  // if we have no inputs, we know it's just the signature\n  if (resolvedPreparedMethod[1].length === 0) {\n    encodedData = resolvedPreparedMethod[0];\n  } else {\n    // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n    // we can do this because we know the specific formats of the values\n    encodedData = resolvedPreparedMethod[0] + encodeAbiParameters(resolvedPreparedMethod[1],\n    // @ts-expect-error - TODO: fix this type issue\n    resolvedParams).slice(2);\n  }\n  const rpcRequest = getRpcClient({\n    chain: contract.chain,\n    client: contract.client\n  });\n  const result = await eth_call(rpcRequest, {\n    data: encodedData,\n    from: options.from ? getAddress(options.from) : undefined,\n    to: contract.address\n  });\n  // use the prepared method to decode the result\n  const decoded = decodeAbiParameters(resolvedPreparedMethod[2], result);\n  if (Array.isArray(decoded) && decoded.length === 1) {\n    return decoded[0];\n  }\n  return decoded;\n}","map":{"version":3,"names":["parseAbiItem","decodeAbiParameters","eth_call","getRpcClient","encodeAbiParameters","prepareMethod","getAddress","isAbiFunction","readContract","options","contract","method","params","resolvePreparedMethod","_contract$abi","Array","isArray","startsWith","abiItem","type","Error","abi","length","_contract$abi2","abiFunction","find","item","name","concat","resolvedPreparedMethod","resolvedParams","Promise","all","encodedData","slice","rpcRequest","chain","client","result","data","from","undefined","to","address","decoded"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/transaction/read-contract.ts"],"sourcesContent":["import {\n  type Abi,\n  type AbiFunction,\n  type AbiParameter,\n  type AbiParametersToPrimitiveTypes,\n  type ExtractAbiFunctionNames,\n  parseAbiItem,\n} from \"abitype\";\nimport { decodeAbiParameters, type TransactionRequest } from \"viem\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\nimport { eth_call } from \"../rpc/actions/eth_call.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport { encodeAbiParameters } from \"../utils/abi/encodeAbiParameters.js\";\nimport {\n  type PreparedMethod,\n  prepareMethod,\n} from \"../utils/abi/prepare-method.js\";\nimport { getAddress } from \"../utils/address.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\nimport type { PrepareTransactionOptions } from \"./prepare-transaction.js\";\nimport type {\n  BaseTransactionOptions,\n  ParamsOption,\n  ParseMethod,\n} from \"./types.js\";\nimport { isAbiFunction } from \"./utils.js\";\n\nexport type ReadContractResult<outputs extends readonly AbiParameter[]> = // if the outputs are 0 length, return never, invalid case\n  outputs extends { length: 0 }\n    ? never\n    : outputs extends { length: 1 }\n      ? // if the outputs are 1 length, we'll always return the first element\n        AbiParametersToPrimitiveTypes<outputs>[0]\n      : // otherwise we'll return the array\n        AbiParametersToPrimitiveTypes<outputs>;\n\nexport type ReadContractOptions<\n  TAbi extends Abi = [],\n  TMethod extends\n    | AbiFunction\n    | string\n    | ((\n        contract: ThirdwebContract<TAbi>,\n      ) => Promise<AbiFunction>) = TAbi extends { length: 0 }\n    ? AbiFunction | string\n    : ExtractAbiFunctionNames<TAbi>,\n  TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n> = BaseTransactionOptions<\n  Omit<\n    TransactionRequest,\n    | \"from\"\n    | \"to\"\n    | \"data\"\n    | \"value\"\n    | \"accessList\"\n    | \"gas\"\n    | \"gasPrice\"\n    | \"maxFeePerGas\"\n    | \"maxPriorityFeePerGas\"\n    | \"nonce\"\n  > & {\n    method: TMethod | TPreparedMethod;\n    from?: string;\n  } & ParamsOption<TPreparedMethod[1]> &\n    Omit<PrepareTransactionOptions, \"to\" | \"data\" | \"chain\" | \"client\">,\n  TAbi\n>;\n\n/**\n * ### Reads state from a deployed smart contract.\n *\n * Use this for raw read calls from a contract, but you can also use read [extensions](https://portal.thirdweb.com/typescript/v5/extensions/use) for predefined methods for common standards.\n *\n * @param options - The transaction options.\n * @returns A promise that resolves with the result of the read call.\n * @transaction\n * @example\n *\n * ### Raw contract call (recommended)\n *\n * You can read from any contract by using the solidity signature of the function you want to call.\n *\n * ```ts\n * import { getContract } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { useReadContract } from \"thirdweb/react\";\n *\n * const contract = getContract({\n *   client,\n *   address: \"0x...\",\n *   chain: sepolia,\n * });\n *\n * const { data, isLoading } = useReadContract({\n *   contract,\n *   method: \"function tokenURI(uint256 tokenId) returns (string)\",\n *   params: [1n],\n * });\n * ```\n *\n * Note that this is type safe, the params types will be enforced based on the signature.\n *\n * ### Raw contract call with `resolveMethod`\n *\n * If you don't have the solidity signature of the function you want to call, you can use the `resolveMethod` helper to resolve the method from any deployed contract.\n *\n * Note that this is not type safe, and will also have a 1 time overhead of resolving the contract ABI.\n *\n * ```ts\n * import { getContract, resolveMethod } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { useReadContract } from \"thirdweb/react\";\n *\n * const contract = getContract({\n *   client,\n *   address: \"0x...\",\n *   chain: sepolia,\n * });\n *\n * const { data, isLoading } = useReadContract({\n *   contract,\n *   method: resolveMethod(\"tokenURI\"),\n *   params: [1n],\n * });\n * ```\n */\nexport async function readContract<\n  const TAbi extends Abi,\n  const TMethod extends TAbi extends {\n    length: 0;\n  }\n    ?\n        | AbiFunction\n        | `function ${string}`\n        | ((contract: ThirdwebContract<TAbi>) => Promise<AbiFunction>)\n    : ExtractAbiFunctionNames<TAbi>,\n  const TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n>(\n  options: ReadContractOptions<TAbi, TMethod, TPreparedMethod>,\n): Promise<ReadContractResult<TPreparedMethod[2]>> {\n  type ParsedMethod_ = ParseMethod<TAbi, TMethod>;\n  type PreparedMethod_ = PreparedMethod<ParsedMethod_>;\n  const { contract, method, params } = options;\n\n  const resolvePreparedMethod = async () => {\n    if (Array.isArray(method)) {\n      return method as PreparedMethod_;\n    }\n    if (isAbiFunction(method)) {\n      return prepareMethod(method as ParsedMethod_) as PreparedMethod_;\n    }\n\n    if (typeof method === \"function\") {\n      return prepareMethod(\n        // @ts-expect-error - we're sure it's a function\n        (await method(contract)) as ParsedMethod_,\n      ) as PreparedMethod_;\n    }\n    // if the method starts with the string `function ` we always will want to try to parse it\n    if (typeof method === \"string\" && method.startsWith(\"function \")) {\n      // @ts-expect-error - method *is* string in this case\n      const abiItem = parseAbiItem(method);\n      if (abiItem.type === \"function\") {\n        return prepareMethod(abiItem as ParsedMethod_) as PreparedMethod_;\n      }\n      throw new Error(`\"method\" passed is not of type \"function\"`);\n    }\n    // check if we have a \"abi\" on the contract\n    if (contract.abi && contract.abi?.length > 0) {\n      // extract the abiFunction from it\n      const abiFunction = contract.abi?.find(\n        (item) => item.type === \"function\" && item.name === method,\n      );\n      // if we were able to find it -> return it\n      if (abiFunction) {\n        return prepareMethod(abiFunction as ParsedMethod_) as PreparedMethod_;\n      }\n    }\n    throw new Error(`Could not resolve method \"${method}\".`);\n  };\n\n  // resolve in parallel\n  const [resolvedPreparedMethod, resolvedParams] = await Promise.all([\n    resolvePreparedMethod(),\n    typeof params === \"function\" ? params() : params,\n  ]);\n\n  let encodedData: Hex;\n\n  // if we have no inputs, we know it's just the signature\n  if (resolvedPreparedMethod[1].length === 0) {\n    encodedData = resolvedPreparedMethod[0];\n  } else {\n    // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n    // we can do this because we know the specific formats of the values\n    encodedData = (resolvedPreparedMethod[0] +\n      encodeAbiParameters(\n        resolvedPreparedMethod[1],\n        // @ts-expect-error - TODO: fix this type issue\n        resolvedParams,\n      ).slice(2)) as `${(typeof resolvedPreparedMethod)[0]}${string}`;\n  }\n\n  const rpcRequest = getRpcClient({\n    chain: contract.chain,\n    client: contract.client,\n  });\n\n  const result = await eth_call(rpcRequest, {\n    data: encodedData,\n    from: options.from ? getAddress(options.from) : undefined,\n    to: contract.address,\n  });\n  // use the prepared method to decode the result\n  const decoded = decodeAbiParameters(resolvedPreparedMethod[2], result);\n  if (Array.isArray(decoded) && decoded.length === 1) {\n    return decoded[0];\n  }\n\n  return decoded as ReadContractResult<TPreparedMethod[2]>;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}