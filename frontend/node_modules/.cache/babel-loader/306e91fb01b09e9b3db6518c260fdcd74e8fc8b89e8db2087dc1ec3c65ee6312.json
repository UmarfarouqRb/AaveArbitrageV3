{"ast":null,"code":"/**\n * Converts a given number of units to a string representation with a specified number of decimal places.\n * @param units - The number of units to convert.\n * @param decimals - The number of decimal places to include in the string representation.\n * @returns The string representation of the converted units.\n * @example\n * ```ts\n * import { toTokens } from \"thirdweb/utils\";\n * toTokens(1000000000000000000n, 18)\n * // '1'\n * ```\n * @utils\n */\nexport function toTokens(units, decimals) {\n  // Convert to string once and handle negativity.\n  const stringValue = units.toString();\n  const prefix = stringValue[0] === \"-\" ? \"-\" : \"\";\n  // Abusing that string \"-\" is truthy\n  const absStringValue = prefix ? stringValue.slice(1) : stringValue;\n  // Ensure we have enough digits for the fractional part.\n  const paddedValue = absStringValue.padStart(decimals + 1, \"0\");\n  const splitIndex = paddedValue.length - decimals;\n  // Extract integer and fraction parts directly.\n  const integerPart = paddedValue.slice(0, splitIndex) || \"0\";\n  let fractionPart = paddedValue.slice(splitIndex);\n  // Manually trim trailing zeros from the fraction part.\n  for (let i = fractionPart.length - 1; i >= 0; i--) {\n    if (fractionPart[i] !== \"0\") {\n      fractionPart = fractionPart.slice(0, i + 1);\n      break;\n    }\n    // check if the next digit is a zero also\n    // If all zeros, make fraction part empty\n    if (i === 0) {\n      fractionPart = \"\";\n    }\n  }\n  // Construct and return the formatted string.\n  return \"\".concat(prefix).concat(integerPart).concat(fractionPart ? \".\".concat(fractionPart) : \"\");\n}\n/**\n * Converts a value from wei to ether.\n * @param wei The value in wei to be converted.\n * @returns The converted value in ether.\n * @example\n * ```ts\n * import { toEther } from \"thirdweb/utils\";\n * toEther(1000000000000000000n)\n * // '1'\n * ```\n * @utils\n */\nexport function toEther(wei) {\n  return toTokens(wei, 18);\n}\n/**\n * Converts a string representation of a number with decimal places to a BigInt representation.\n * @param tokens - The string representation of the number, including the integer and fraction parts.\n * @param decimals - The number of decimal places to include in the BigInt representation.\n * @returns The BigInt representation of the number.\n * @example\n * ```ts\n * import { toUnits } from \"thirdweb/utils\";\n * toUnits('1', 18)\n * // 1000000000000000000n\n * ```\n * @utils\n */\nexport function toUnits(tokens, decimals) {\n  if (tokens.includes(\"e\")) {\n    tokens = Number(tokens).toFixed(decimals);\n  }\n  let [integerPart, fractionPart = \"\"] = tokens.split(\".\");\n  const prefix = integerPart.startsWith(\"-\") ? \"-\" : \"\";\n  if (prefix) {\n    integerPart = integerPart.slice(1);\n  }\n  fractionPart = fractionPart.padEnd(decimals, \"0\"); // Ensure fraction part is at least 'decimals' long.\n  if (decimals === 0) {\n    // Check if there's any fraction part that would necessitate rounding up the integer part.\n    if (fractionPart[0] && Number.parseInt(fractionPart[0]) >= 5) {\n      integerPart = (BigInt(integerPart) + 1n).toString();\n    }\n    fractionPart = \"\"; // No fraction part is needed when decimals === 0.\n  } else {\n    // When decimals > 0, handle potential rounding based on the digit right after the specified decimal places.\n    if (fractionPart.length > decimals) {\n      const roundingDigit = fractionPart[decimals];\n      if (roundingDigit && Number.parseInt(roundingDigit, 10) >= 5) {\n        // If rounding is needed, add 1 to the last included digit of the fraction part.\n        const roundedFraction = BigInt(fractionPart.substring(0, decimals)) + 1n;\n        fractionPart = roundedFraction.toString().padStart(decimals, \"0\");\n        if (fractionPart.length > decimals) {\n          // If rounding the fraction results in a length increase (e.g., .999 -> 1.000), increment the integer part.\n          integerPart = (BigInt(integerPart) + 1n).toString();\n          // Adjust the fraction part if it's longer than the specified decimals due to rounding up.\n          fractionPart = fractionPart.substring(fractionPart.length - decimals);\n        }\n      } else {\n        // If no rounding is necessary, just truncate the fraction part to the specified number of decimals.\n        fractionPart = fractionPart.substring(0, decimals);\n      }\n    }\n    // If the fraction part is shorter than the specified decimals, it's already handled by padEnd() above.\n  }\n  // Combine the integer and fraction parts into the final BigInt representation.\n  return BigInt(\"\".concat(prefix).concat(integerPart).concat(fractionPart));\n}\n/**\n * Converts the specified number of tokens to Wei.\n * @param tokens The number of tokens to convert.\n * @returns The converted value in Wei.\n * @example\n * ```ts\n * import { toWei } from \"thirdweb/utils\";\n * toWei('1')\n * // 1000000000000000000n\n * ```\n * @utils\n */\nexport function toWei(tokens) {\n  return toUnits(tokens, 18);\n}\n/**\n * Converts the specified number from gwei to wei.\n * @param gwei The number of gwei to convert.\n * @returns The converted value in wei.\n * @example\n * ```ts\n * import { fromGwei } from \"thirdweb/utils\";\n * fromGwei('1')\n * // 1000000000n\n * ```\n * @utils\n */\nexport function fromGwei(gwei) {\n  return toUnits(gwei, 9);\n}","map":{"version":3,"names":["toTokens","units","decimals","stringValue","toString","prefix","absStringValue","slice","paddedValue","padStart","splitIndex","length","integerPart","fractionPart","i","concat","toEther","wei","toUnits","tokens","includes","Number","toFixed","split","startsWith","padEnd","parseInt","BigInt","roundingDigit","roundedFraction","substring","toWei","fromGwei","gwei"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/utils/units.ts"],"sourcesContent":["/**\n * Converts a given number of units to a string representation with a specified number of decimal places.\n * @param units - The number of units to convert.\n * @param decimals - The number of decimal places to include in the string representation.\n * @returns The string representation of the converted units.\n * @example\n * ```ts\n * import { toTokens } from \"thirdweb/utils\";\n * toTokens(1000000000000000000n, 18)\n * // '1'\n * ```\n * @utils\n */\nexport function toTokens(units: bigint, decimals: number): string {\n  // Convert to string once and handle negativity.\n  const stringValue = units.toString();\n  const prefix = stringValue[0] === \"-\" ? \"-\" : \"\";\n  // Abusing that string \"-\" is truthy\n  const absStringValue = prefix ? stringValue.slice(1) : stringValue;\n\n  // Ensure we have enough digits for the fractional part.\n  const paddedValue = absStringValue.padStart(decimals + 1, \"0\");\n  const splitIndex = paddedValue.length - decimals;\n\n  // Extract integer and fraction parts directly.\n  const integerPart = paddedValue.slice(0, splitIndex) || \"0\";\n  let fractionPart = paddedValue.slice(splitIndex);\n\n  // Manually trim trailing zeros from the fraction part.\n  for (let i = fractionPart.length - 1; i >= 0; i--) {\n    if (fractionPart[i] !== \"0\") {\n      fractionPart = fractionPart.slice(0, i + 1);\n      break;\n    }\n    // check if the next digit is a zero also\n    // If all zeros, make fraction part empty\n    if (i === 0) {\n      fractionPart = \"\";\n    }\n  }\n\n  // Construct and return the formatted string.\n  return `${prefix}${integerPart}${fractionPart ? `.${fractionPart}` : \"\"}`;\n}\n\n/**\n * Converts a value from wei to ether.\n * @param wei The value in wei to be converted.\n * @returns The converted value in ether.\n * @example\n * ```ts\n * import { toEther } from \"thirdweb/utils\";\n * toEther(1000000000000000000n)\n * // '1'\n * ```\n * @utils\n */\nexport function toEther(wei: bigint) {\n  return toTokens(wei, 18);\n}\n\n/**\n * Converts a string representation of a number with decimal places to a BigInt representation.\n * @param tokens - The string representation of the number, including the integer and fraction parts.\n * @param decimals - The number of decimal places to include in the BigInt representation.\n * @returns The BigInt representation of the number.\n * @example\n * ```ts\n * import { toUnits } from \"thirdweb/utils\";\n * toUnits('1', 18)\n * // 1000000000000000000n\n * ```\n * @utils\n */\nexport function toUnits(tokens: string, decimals: number): bigint {\n  if (tokens.includes(\"e\")) {\n    tokens = Number(tokens).toFixed(decimals);\n  }\n\n  let [integerPart, fractionPart = \"\"] = tokens.split(\".\") as [string, string];\n  const prefix = integerPart.startsWith(\"-\") ? \"-\" : \"\";\n  if (prefix) {\n    integerPart = integerPart.slice(1);\n  }\n\n  fractionPart = fractionPart.padEnd(decimals, \"0\"); // Ensure fraction part is at least 'decimals' long.\n\n  if (decimals === 0) {\n    // Check if there's any fraction part that would necessitate rounding up the integer part.\n    if (fractionPart[0] && Number.parseInt(fractionPart[0]) >= 5) {\n      integerPart = (BigInt(integerPart) + 1n).toString();\n    }\n    fractionPart = \"\"; // No fraction part is needed when decimals === 0.\n  } else {\n    // When decimals > 0, handle potential rounding based on the digit right after the specified decimal places.\n    if (fractionPart.length > decimals) {\n      const roundingDigit = fractionPart[decimals];\n      if (roundingDigit && Number.parseInt(roundingDigit, 10) >= 5) {\n        // If rounding is needed, add 1 to the last included digit of the fraction part.\n        const roundedFraction =\n          BigInt(fractionPart.substring(0, decimals)) + 1n;\n        fractionPart = roundedFraction.toString().padStart(decimals, \"0\");\n\n        if (fractionPart.length > decimals) {\n          // If rounding the fraction results in a length increase (e.g., .999 -> 1.000), increment the integer part.\n          integerPart = (BigInt(integerPart) + 1n).toString();\n          // Adjust the fraction part if it's longer than the specified decimals due to rounding up.\n          fractionPart = fractionPart.substring(fractionPart.length - decimals);\n        }\n      } else {\n        // If no rounding is necessary, just truncate the fraction part to the specified number of decimals.\n        fractionPart = fractionPart.substring(0, decimals);\n      }\n    }\n    // If the fraction part is shorter than the specified decimals, it's already handled by padEnd() above.\n  }\n\n  // Combine the integer and fraction parts into the final BigInt representation.\n  return BigInt(`${prefix}${integerPart}${fractionPart}`);\n}\n\n/**\n * Converts the specified number of tokens to Wei.\n * @param tokens The number of tokens to convert.\n * @returns The converted value in Wei.\n * @example\n * ```ts\n * import { toWei } from \"thirdweb/utils\";\n * toWei('1')\n * // 1000000000000000000n\n * ```\n * @utils\n */\nexport function toWei(tokens: string) {\n  return toUnits(tokens, 18);\n}\n\n/**\n * Converts the specified number from gwei to wei.\n * @param gwei The number of gwei to convert.\n * @returns The converted value in wei.\n * @example\n * ```ts\n * import { fromGwei } from \"thirdweb/utils\";\n * fromGwei('1')\n * // 1000000000n\n * ```\n * @utils\n */\nexport function fromGwei(gwei: string) {\n  return toUnits(gwei, 9);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}