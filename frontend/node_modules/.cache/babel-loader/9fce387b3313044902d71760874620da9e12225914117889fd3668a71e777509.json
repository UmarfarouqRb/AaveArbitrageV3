{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { getGasOverridesForTransaction } from \"../../gas/fee-data.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { isZkSyncChain } from \"../../utils/any-evm/zksync/isZkSyncChain.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport { encode } from \"./encode.js\";\nimport { estimateGas } from \"./estimate-gas.js\";\n/**\n * Converts a prepared transaction to a transaction with populated options.\n * @param options - The transaction and additional options for conversion\n * @returns A serializable transaction for inspection or submission to an account.\n *\n *  For easier transaction sending, {@see sendTransaction}\n * @example\n * ```ts\n * import { prepareTransaction, toSerializableTransaction } from \"thirdweb\";\n *\n * const transaction = await prepareTransaction({\n *   transaction: {\n *     to: \"0x...\",\n *     value: 100,\n *   },\n * });\n * const finalTx = await toSerializableTransaction({\n *   transaction,\n * });\n *\n * account.sendTransaction(finalTx);\n * ```\n * @transaction\n */\nexport async function toSerializableTransaction(options) {\n  // zk chains require a different rpc method for gas estimation and gas fees\n  const isZkSync = await isZkSyncChain(options.transaction.chain);\n  if (isZkSync) {\n    const {\n      getZkGasFees\n    } = await import(\"./zksync/send-eip712-transaction.js\");\n    const {\n      gas,\n      maxFeePerGas,\n      maxPriorityFeePerGas\n    } = await getZkGasFees({\n      from: typeof options.from === \"string\" // Is this just an address?\n      ? getAddress(options.from) : options.from !== undefined // Is this an account?\n      ? getAddress(options.from.address) : undefined,\n      transaction: options.transaction\n    });\n    // passing these values here will avoid re-fetching them below\n    options.transaction = _objectSpread(_objectSpread({}, options.transaction), {}, {\n      gas,\n      maxFeePerGas,\n      maxPriorityFeePerGas\n    });\n  }\n  const rpcRequest = getRpcClient(options.transaction);\n  const chainId = options.transaction.chain.id;\n  const from = options.from;\n  let [data, nonce, gas, feeData, to, accessList, value, authorizationList, type] = await Promise.all([encode(options.transaction), (async () => {\n    // if the user has specified a nonce, use that\n    const resolvedNonce = await resolvePromisedValue(options.transaction.nonce);\n    if (resolvedNonce !== undefined) {\n      return resolvedNonce;\n    }\n    return from // otherwise get the next nonce (import the method to do so)\n    ? await import(\"../../rpc/actions/eth_getTransactionCount.js\").then(_ref => {\n      let {\n        eth_getTransactionCount\n      } = _ref;\n      return eth_getTransactionCount(rpcRequest, {\n        address: typeof from === \"string\" ? getAddress(from) : getAddress(from.address),\n        blockTag: \"pending\"\n      });\n    }) : undefined;\n  })(),\n  // takes the same options as the sendTransaction function thankfully!\n  estimateGas(_objectSpread(_objectSpread({}, options), {}, {\n    from: options.from\n  })), getGasOverridesForTransaction(options.transaction), resolvePromisedValue(options.transaction.to), resolvePromisedValue(options.transaction.accessList), resolvePromisedValue(options.transaction.value), resolvePromisedValue(options.transaction.authorizationList), resolvePromisedValue(options.transaction.type)]);\n  const extraGas = await resolvePromisedValue(options.transaction.extraGas);\n  if (extraGas) {\n    gas += extraGas;\n  }\n  return _objectSpread({\n    accessList,\n    authorizationList,\n    chainId,\n    data,\n    gas,\n    nonce,\n    to,\n    type,\n    value\n  }, feeData);\n}","map":{"version":3,"names":["getGasOverridesForTransaction","getRpcClient","getAddress","isZkSyncChain","resolvePromisedValue","encode","estimateGas","toSerializableTransaction","options","isZkSync","transaction","chain","getZkGasFees","gas","maxFeePerGas","maxPriorityFeePerGas","from","undefined","address","_objectSpread","rpcRequest","chainId","id","data","nonce","feeData","to","accessList","value","authorizationList","type","Promise","all","resolvedNonce","then","_ref","eth_getTransactionCount","blockTag","extraGas"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/transaction/actions/to-serializable-transaction.ts"],"sourcesContent":["import { getGasOverridesForTransaction } from \"../../gas/fee-data.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { isZkSyncChain } from \"../../utils/any-evm/zksync/isZkSyncChain.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport type { Account } from \"../../wallets/interfaces/wallet.js\";\nimport type { PreparedTransaction } from \"../prepare-transaction.js\";\nimport type { SerializableTransaction } from \"../serialize-transaction.js\";\nimport { encode } from \"./encode.js\";\nimport { estimateGas } from \"./estimate-gas.js\";\n\nexport type ToSerializableTransactionOptions = {\n  /**\n   * The transaction to convert to a serializable transaction.\n   */\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n  transaction: PreparedTransaction<any>;\n  /**\n   * The from address or account to use for gas estimation and authorization signing.\n   */\n  from?: string | Account;\n};\n\n/**\n * Converts a prepared transaction to a transaction with populated options.\n * @param options - The transaction and additional options for conversion\n * @returns A serializable transaction for inspection or submission to an account.\n *\n *  For easier transaction sending, {@see sendTransaction}\n * @example\n * ```ts\n * import { prepareTransaction, toSerializableTransaction } from \"thirdweb\";\n *\n * const transaction = await prepareTransaction({\n *   transaction: {\n *     to: \"0x...\",\n *     value: 100,\n *   },\n * });\n * const finalTx = await toSerializableTransaction({\n *   transaction,\n * });\n *\n * account.sendTransaction(finalTx);\n * ```\n * @transaction\n */\nexport async function toSerializableTransaction(\n  options: ToSerializableTransactionOptions,\n) {\n  // zk chains require a different rpc method for gas estimation and gas fees\n  const isZkSync = await isZkSyncChain(options.transaction.chain);\n  if (isZkSync) {\n    const { getZkGasFees } = await import(\n      \"./zksync/send-eip712-transaction.js\"\n    );\n    const { gas, maxFeePerGas, maxPriorityFeePerGas } = await getZkGasFees({\n      from:\n        typeof options.from === \"string\" // Is this just an address?\n          ? getAddress(options.from)\n          : options.from !== undefined // Is this an account?\n            ? getAddress(options.from.address)\n            : undefined,\n      transaction: options.transaction,\n    });\n    // passing these values here will avoid re-fetching them below\n    options.transaction = {\n      ...options.transaction,\n      gas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    };\n  }\n\n  const rpcRequest = getRpcClient(options.transaction);\n  const chainId = options.transaction.chain.id;\n  const from = options.from;\n  let [\n    data,\n    nonce,\n    gas,\n    feeData,\n    to,\n    accessList,\n    value,\n    authorizationList,\n    type,\n  ] = await Promise.all([\n    encode(options.transaction),\n    (async () => {\n      // if the user has specified a nonce, use that\n      const resolvedNonce = await resolvePromisedValue(\n        options.transaction.nonce,\n      );\n      if (resolvedNonce !== undefined) {\n        return resolvedNonce;\n      }\n\n      return from // otherwise get the next nonce (import the method to do so)\n        ? await import(\"../../rpc/actions/eth_getTransactionCount.js\").then(\n            ({ eth_getTransactionCount }) =>\n              eth_getTransactionCount(rpcRequest, {\n                address:\n                  typeof from === \"string\"\n                    ? getAddress(from)\n                    : getAddress(from.address),\n                blockTag: \"pending\",\n              }),\n          )\n        : undefined;\n    })(),\n    // takes the same options as the sendTransaction function thankfully!\n    estimateGas({\n      ...options,\n      from: options.from,\n    }),\n    getGasOverridesForTransaction(options.transaction),\n    resolvePromisedValue(options.transaction.to),\n    resolvePromisedValue(options.transaction.accessList),\n    resolvePromisedValue(options.transaction.value),\n    resolvePromisedValue(options.transaction.authorizationList),\n    resolvePromisedValue(options.transaction.type),\n  ]);\n\n  const extraGas = await resolvePromisedValue(options.transaction.extraGas);\n  if (extraGas) {\n    gas += extraGas;\n  }\n\n  return {\n    accessList,\n    authorizationList,\n    chainId,\n    data,\n    gas,\n    nonce,\n    to,\n    type,\n    value,\n    ...feeData,\n  } satisfies SerializableTransaction;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}