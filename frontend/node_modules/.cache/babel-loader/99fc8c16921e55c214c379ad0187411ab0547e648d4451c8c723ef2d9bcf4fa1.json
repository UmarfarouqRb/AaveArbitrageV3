{"ast":null,"code":"import { getNFT as getNFTInsight } from \"../../../insight/get-nfts.js\";\nimport { fetchTokenMetadata } from \"../../../utils/nft/fetchTokenMetadata.js\";\nimport { parseNFT } from \"../../../utils/nft/parseNft.js\";\nimport { totalSupply } from \"../__generated__/IERC1155/read/totalSupply.js\";\nimport { uri } from \"../__generated__/IERC1155/read/uri.js\";\nexport { isUriSupported as isGetNFTSupported } from \"../__generated__/IERC1155/read/uri.js\";\n/**\n * Retrieves information about a specific ERC1155 non-fungible token (NFT).\n * @param options - The options for retrieving the NFT.\n * @returns A promise that resolves to the NFT object.\n * @extension ERC1155\n * @example\n * ```ts\n * import { getNFT } from \"thirdweb/extensions/erc1155\";\n * const nft = await getNFT({\n *  contract,\n *  tokenId: 1n,\n * });\n * ```\n */\nexport async function getNFT(options) {\n  const {\n    useIndexer = true\n  } = options;\n  if (useIndexer) {\n    try {\n      return await getNFTFromInsight(options);\n    } catch (_unused) {\n      return await getNFTFromRPC(options);\n    }\n  }\n  return await getNFTFromRPC(options);\n}\nasync function getNFTFromInsight(options) {\n  const nft = await getNFTInsight({\n    chain: options.contract.chain,\n    client: options.contract.client,\n    contractAddress: options.contract.address,\n    tokenId: options.tokenId\n  });\n  if (!nft) {\n    // fresh contracts might be delayed in indexing, so we fallback to RPC\n    return getNFTFromRPC(options);\n  }\n  return nft;\n}\nasync function getNFTFromRPC(options) {\n  const [tokenUri, supply] = await Promise.all([uri({\n    contract: options.contract,\n    tokenId: options.tokenId\n  }), totalSupply({\n    contract: options.contract,\n    id: options.tokenId\n    // in cases where the supply is not available -> fall back to 0\n  }).catch(() => 0n)]);\n  return parseNFT(await fetchTokenMetadata({\n    client: options.contract.client,\n    tokenId: options.tokenId,\n    tokenUri\n  }).then(metadata => {\n    // if the metadata is null-ish, return a default metadata object\n    if (!metadata) {\n      return {\n        id: options.tokenId,\n        type: \"ERC1155\",\n        uri: tokenUri\n      };\n    }\n    return metadata;\n  }).catch(() => ({\n    id: options.tokenId,\n    type: \"ERC1155\",\n    uri: tokenUri\n  })), {\n    chainId: options.contract.chain.id,\n    owner: null,\n    supply,\n    tokenAddress: options.contract.address,\n    tokenId: options.tokenId,\n    tokenUri,\n    type: \"ERC1155\"\n  });\n}","map":{"version":3,"names":["getNFT","getNFTInsight","fetchTokenMetadata","parseNFT","totalSupply","uri","isUriSupported","isGetNFTSupported","options","useIndexer","getNFTFromInsight","_unused","getNFTFromRPC","nft","chain","contract","client","contractAddress","address","tokenId","tokenUri","supply","Promise","all","id","catch","then","metadata","type","chainId","owner","tokenAddress"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/extensions/erc1155/read/getNFT.ts"],"sourcesContent":["import { getNFT as getNFTInsight } from \"../../../insight/get-nfts.js\";\nimport type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { fetchTokenMetadata } from \"../../../utils/nft/fetchTokenMetadata.js\";\nimport { type NFT, parseNFT } from \"../../../utils/nft/parseNft.js\";\nimport { totalSupply } from \"../__generated__/IERC1155/read/totalSupply.js\";\nimport { uri } from \"../__generated__/IERC1155/read/uri.js\";\n\nexport { isUriSupported as isGetNFTSupported } from \"../__generated__/IERC1155/read/uri.js\";\n\n/**\n * Parameters for getting an NFT.\n * @extension ERC1155\n */\nexport type GetNFTParams = {\n  tokenId: bigint;\n  /**\n   * Whether to use the insight API to fetch the NFT.\n   * @default true\n   */\n  useIndexer?: boolean;\n};\n\n/**\n * Retrieves information about a specific ERC1155 non-fungible token (NFT).\n * @param options - The options for retrieving the NFT.\n * @returns A promise that resolves to the NFT object.\n * @extension ERC1155\n * @example\n * ```ts\n * import { getNFT } from \"thirdweb/extensions/erc1155\";\n * const nft = await getNFT({\n *  contract,\n *  tokenId: 1n,\n * });\n * ```\n */\nexport async function getNFT(\n  options: BaseTransactionOptions<GetNFTParams>,\n): Promise<NFT> {\n  const { useIndexer = true } = options;\n  if (useIndexer) {\n    try {\n      return await getNFTFromInsight(options);\n    } catch {\n      return await getNFTFromRPC(options);\n    }\n  }\n  return await getNFTFromRPC(options);\n}\n\nasync function getNFTFromInsight(\n  options: BaseTransactionOptions<GetNFTParams>,\n): Promise<NFT> {\n  const nft = await getNFTInsight({\n    chain: options.contract.chain,\n    client: options.contract.client,\n    contractAddress: options.contract.address,\n    tokenId: options.tokenId,\n  });\n  if (!nft) {\n    // fresh contracts might be delayed in indexing, so we fallback to RPC\n    return getNFTFromRPC(options);\n  }\n  return nft;\n}\n\nasync function getNFTFromRPC(\n  options: BaseTransactionOptions<GetNFTParams>,\n): Promise<NFT> {\n  const [tokenUri, supply] = await Promise.all([\n    uri({\n      contract: options.contract,\n      tokenId: options.tokenId,\n    }),\n    totalSupply({\n      contract: options.contract,\n      id: options.tokenId,\n      // in cases where the supply is not available -> fall back to 0\n    }).catch(() => 0n),\n  ]);\n  return parseNFT(\n    await fetchTokenMetadata({\n      client: options.contract.client,\n      tokenId: options.tokenId,\n      tokenUri,\n    })\n      .then((metadata) => {\n        // if the metadata is null-ish, return a default metadata object\n        if (!metadata) {\n          return {\n            id: options.tokenId,\n            type: \"ERC1155\",\n            uri: tokenUri,\n          };\n        }\n        return metadata;\n      })\n      .catch(() => ({\n        id: options.tokenId,\n        type: \"ERC1155\",\n        uri: tokenUri,\n      })),\n    {\n      chainId: options.contract.chain.id,\n      owner: null,\n      supply,\n      tokenAddress: options.contract.address,\n      tokenId: options.tokenId,\n      tokenUri,\n      type: \"ERC1155\",\n    },\n  );\n}\n"],"mappings":"AAAA,SAASA,MAAM,IAAIC,aAAa,QAAQ,8BAA8B;AAEtE,SAASC,kBAAkB,QAAQ,0CAA0C;AAC7E,SAAmBC,QAAQ,QAAQ,gCAAgC;AACnE,SAASC,WAAW,QAAQ,+CAA+C;AAC3E,SAASC,GAAG,QAAQ,uCAAuC;AAE3D,SAASC,cAAc,IAAIC,iBAAiB,QAAQ,uCAAuC;AAe3F;;;;;;;;;;;;;;AAcA,OAAO,eAAeP,MAAMA,CAC1BQ,OAA6C;EAE7C,MAAM;IAAEC,UAAU,GAAG;EAAI,CAAE,GAAGD,OAAO;EACrC,IAAIC,UAAU,EAAE;IACd,IAAI;MACF,OAAO,MAAMC,iBAAiB,CAACF,OAAO,CAAC;IACzC,CAAC,CAAC,OAAAG,OAAA,EAAM;MACN,OAAO,MAAMC,aAAa,CAACJ,OAAO,CAAC;IACrC;EACF;EACA,OAAO,MAAMI,aAAa,CAACJ,OAAO,CAAC;AACrC;AAEA,eAAeE,iBAAiBA,CAC9BF,OAA6C;EAE7C,MAAMK,GAAG,GAAG,MAAMZ,aAAa,CAAC;IAC9Ba,KAAK,EAAEN,OAAO,CAACO,QAAQ,CAACD,KAAK;IAC7BE,MAAM,EAAER,OAAO,CAACO,QAAQ,CAACC,MAAM;IAC/BC,eAAe,EAAET,OAAO,CAACO,QAAQ,CAACG,OAAO;IACzCC,OAAO,EAAEX,OAAO,CAACW;GAClB,CAAC;EACF,IAAI,CAACN,GAAG,EAAE;IACR;IACA,OAAOD,aAAa,CAACJ,OAAO,CAAC;EAC/B;EACA,OAAOK,GAAG;AACZ;AAEA,eAAeD,aAAaA,CAC1BJ,OAA6C;EAE7C,MAAM,CAACY,QAAQ,EAAEC,MAAM,CAAC,GAAG,MAAMC,OAAO,CAACC,GAAG,CAAC,CAC3ClB,GAAG,CAAC;IACFU,QAAQ,EAAEP,OAAO,CAACO,QAAQ;IAC1BI,OAAO,EAAEX,OAAO,CAACW;GAClB,CAAC,EACFf,WAAW,CAAC;IACVW,QAAQ,EAAEP,OAAO,CAACO,QAAQ;IAC1BS,EAAE,EAAEhB,OAAO,CAACW;IACZ;GACD,CAAC,CAACM,KAAK,CAAC,MAAM,EAAE,CAAC,CACnB,CAAC;EACF,OAAOtB,QAAQ,CACb,MAAMD,kBAAkB,CAAC;IACvBc,MAAM,EAAER,OAAO,CAACO,QAAQ,CAACC,MAAM;IAC/BG,OAAO,EAAEX,OAAO,CAACW,OAAO;IACxBC;GACD,CAAC,CACCM,IAAI,CAAEC,QAAQ,IAAI;IACjB;IACA,IAAI,CAACA,QAAQ,EAAE;MACb,OAAO;QACLH,EAAE,EAAEhB,OAAO,CAACW,OAAO;QACnBS,IAAI,EAAE,SAAS;QACfvB,GAAG,EAAEe;OACN;IACH;IACA,OAAOO,QAAQ;EACjB,CAAC,CAAC,CACDF,KAAK,CAAC,OAAO;IACZD,EAAE,EAAEhB,OAAO,CAACW,OAAO;IACnBS,IAAI,EAAE,SAAS;IACfvB,GAAG,EAAEe;GACN,CAAC,CAAC,EACL;IACES,OAAO,EAAErB,OAAO,CAACO,QAAQ,CAACD,KAAK,CAACU,EAAE;IAClCM,KAAK,EAAE,IAAI;IACXT,MAAM;IACNU,YAAY,EAAEvB,OAAO,CAACO,QAAQ,CAACG,OAAO;IACtCC,OAAO,EAAEX,OAAO,CAACW,OAAO;IACxBC,QAAQ;IACRQ,IAAI,EAAE;GACP,CACF;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}