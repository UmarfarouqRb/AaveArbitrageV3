{"ast":null,"code":"import { getThirdwebBaseUrl } from \"../utils/domains.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { ApiError } from \"./types/Errors.js\";\n/**\n * Retrieves supported Bridge tokens based on the provided filters.\n *\n * When multiple filters are specified, a token must satisfy all filters to be included (it acts as an AND operator).\n *\n * @example\n * ```typescript\n * import { Bridge } from \"thirdweb\";\n *\n * const tokens = await Bridge.tokens({\n *   client: thirdwebClient,\n *   chainId: 1,\n * });\n * ```\n *\n * Returned tokens might look something like:\n * ```typescript\n * [\n *   {\n *     chainId: 1,\n *     address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *     decimals: 18,\n *     symbol: \"ETH\",\n *     name: \"Ethereum\",\n *     iconUri: \"https://assets.relay.link/icons/1/light.png\",\n *     priceUsd: 2000.50,\n *     prices: {\n *       USD: 2000.50,\n *       EUR: 1800.00,\n *       GBP: 1500.00,\n *       JPY: 10000.00\n *     }\n *   },\n *   {\n *     chainId: 1,\n *     address: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n *     decimals: 6,\n *     symbol: \"USDC\",\n *     name: \"USD Coin\",\n *     iconUri: \"https://assets.coingecko.com/coins/images/6319/large/USD_Coin_icon.png\",\n *     priceUsd: 1.00,\n *     prices: {\n *       USD: 1.00,\n *       EUR: 0.84,\n *       GBP: 0.73,\n *       JPY: 120.00\n *     }\n *   }\n * ]\n * ```\n *\n * You can filter for specific chains or tokens:\n * ```typescript\n * import { Bridge } from \"thirdweb\";\n *\n * // Get all tokens on Ethereum mainnet\n * const ethTokens = await Bridge.tokens({\n *   chainId: 1,\n *   client: thirdwebClient,\n * });\n * ```\n *\n * You can search for tokens by symbol or name:\n * ```typescript\n * import { Bridge } from \"thirdweb\";\n *\n * // Search for USDC tokens\n * const usdcTokens = await Bridge.tokens({\n *   symbol: \"USDC\",\n *   client: thirdwebClient,\n * });\n *\n * // Search for tokens by name\n * const ethereumTokens = await Bridge.tokens({\n *   name: \"Ethereum\",\n *   client: thirdwebClient,\n * });\n * ```\n *\n * You can filter by a specific token address:\n * ```typescript\n * import { Bridge } from \"thirdweb\";\n *\n * // Get a specific token\n * const token = await Bridge.tokens({\n *   tokenAddress: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n *   client: thirdwebClient,\n * });\n * ```\n *\n * The returned tokens will be limited based on the API. You can paginate through the results using the `limit` and `offset` parameters:\n * ```typescript\n * import { Bridge } from \"thirdweb\";\n *\n * // Get the first 50 tokens\n * const tokens = await Bridge.tokens({\n *   limit: 50,\n *   offset: 0,\n *   client: thirdwebClient,\n * });\n *\n * // Get the next 50 tokens\n * const nextTokens = await Bridge.tokens({\n *   limit: 50,\n *   offset: 50,\n *   client: thirdwebClient,\n * });\n * ```\n *\n * @param options - The options for retrieving tokens.\n * @param options.client - Your thirdweb client.\n * @param options.chainId - Filter by a specific chain ID.\n * @param options.tokenAddress - Filter by a specific token address.\n * @param options.symbol - Filter by token symbol.\n * @param options.name - Filter by token name.\n * @param options.limit - Number of tokens to return (min: 1, default: 100).\n * @param options.offset - Number of tokens to skip (min: 0, default: 0).\n *\n * @returns A promise that resolves to an array of tokens.\n *\n * @throws Will throw an error if there is an issue fetching the tokens.\n * @bridge\n * @beta\n */\nexport async function tokens(options) {\n  const {\n    client,\n    chainId,\n    tokenAddress,\n    symbol,\n    name,\n    limit,\n    offset,\n    includePrices,\n    sortBy,\n    query\n  } = options;\n  const clientFetch = getClientFetch(client);\n  const url = new URL(\"\".concat(getThirdwebBaseUrl(\"bridge\"), \"/v1/tokens\"));\n  if (chainId !== null && chainId !== undefined) {\n    url.searchParams.set(\"chainId\", chainId.toString());\n  }\n  if (tokenAddress) {\n    url.searchParams.set(\"tokenAddress\", tokenAddress);\n  }\n  if (symbol) {\n    url.searchParams.set(\"symbol\", symbol);\n  }\n  if (name) {\n    url.searchParams.set(\"name\", name);\n  }\n  if (limit !== undefined) {\n    url.searchParams.set(\"limit\", limit.toString());\n  }\n  if (offset !== null && offset !== undefined) {\n    url.searchParams.set(\"offset\", offset.toString());\n  }\n  if (includePrices !== undefined) {\n    url.searchParams.set(\"includePrices\", includePrices.toString());\n  }\n  if (sortBy !== undefined) {\n    url.searchParams.set(\"sortBy\", sortBy);\n  }\n  if (query !== undefined) {\n    url.searchParams.set(\"query\", query);\n  }\n  const response = await clientFetch(url.toString());\n  if (!response.ok) {\n    const errorJson = await response.json();\n    throw new ApiError({\n      code: errorJson.code || \"UNKNOWN_ERROR\",\n      correlationId: errorJson.correlationId || undefined,\n      message: errorJson.message || response.statusText,\n      statusCode: response.status\n    });\n  }\n  const {\n    data\n  } = await response.json();\n  return data;\n}\n/**\n * Adds a token to the Bridge for indexing.\n *\n * This function requests the Bridge to index a specific token on a given chain.\n * Once indexed, the token will be available for cross-chain operations.\n *\n * @example\n * ```typescript\n * import { Bridge } from \"thirdweb\";\n *\n * // Add a token for indexing\n * const result = await Bridge.add({\n *   client: thirdwebClient,\n *   chainId: 1,\n *   tokenAddress: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\", // USDC\n * });\n * ```\n *\n * @param options - The options for adding a token.\n * @param options.client - Your thirdweb client.\n * @param options.chainId - The chain ID where the token is deployed.\n * @param options.tokenAddress - The contract address of the token to add.\n *\n * @returns A promise that resolves when the token has been successfully submitted for indexing.\n *\n * @throws Will throw an error if there is an issue adding the token.\n * @bridge\n * @beta\n */\nexport async function add(options) {\n  const {\n    client,\n    chainId,\n    tokenAddress\n  } = options;\n  const clientFetch = getClientFetch(client);\n  const url = \"\".concat(getThirdwebBaseUrl(\"bridge\"), \"/v1/tokens\");\n  const requestBody = {\n    chainId,\n    tokenAddress\n  };\n  const response = await clientFetch(url, {\n    body: JSON.stringify(requestBody),\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    method: \"POST\"\n  });\n  if (!response.ok) {\n    const errorJson = await response.json();\n    throw new ApiError({\n      code: errorJson.code || \"UNKNOWN_ERROR\",\n      correlationId: errorJson.correlationId || undefined,\n      message: errorJson.message || response.statusText,\n      statusCode: response.status\n    });\n  }\n  const {\n    data\n  } = await response.json();\n  return data;\n}","map":{"version":3,"names":["getThirdwebBaseUrl","getClientFetch","ApiError","tokens","options","client","chainId","tokenAddress","symbol","name","limit","offset","includePrices","sortBy","query","clientFetch","url","URL","concat","undefined","searchParams","set","toString","response","ok","errorJson","json","code","correlationId","message","statusText","statusCode","status","data","add","requestBody","body","JSON","stringify","headers","method"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/bridge/Token.ts"],"sourcesContent":["import type { ThirdwebClient } from \"../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../utils/domains.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { ApiError } from \"./types/Errors.js\";\nimport type { Token, TokenWithPrices } from \"./types/Token.js\";\n\n/**\n * Retrieves supported Bridge tokens based on the provided filters.\n *\n * When multiple filters are specified, a token must satisfy all filters to be included (it acts as an AND operator).\n *\n * @example\n * ```typescript\n * import { Bridge } from \"thirdweb\";\n *\n * const tokens = await Bridge.tokens({\n *   client: thirdwebClient,\n *   chainId: 1,\n * });\n * ```\n *\n * Returned tokens might look something like:\n * ```typescript\n * [\n *   {\n *     chainId: 1,\n *     address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *     decimals: 18,\n *     symbol: \"ETH\",\n *     name: \"Ethereum\",\n *     iconUri: \"https://assets.relay.link/icons/1/light.png\",\n *     priceUsd: 2000.50,\n *     prices: {\n *       USD: 2000.50,\n *       EUR: 1800.00,\n *       GBP: 1500.00,\n *       JPY: 10000.00\n *     }\n *   },\n *   {\n *     chainId: 1,\n *     address: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n *     decimals: 6,\n *     symbol: \"USDC\",\n *     name: \"USD Coin\",\n *     iconUri: \"https://assets.coingecko.com/coins/images/6319/large/USD_Coin_icon.png\",\n *     priceUsd: 1.00,\n *     prices: {\n *       USD: 1.00,\n *       EUR: 0.84,\n *       GBP: 0.73,\n *       JPY: 120.00\n *     }\n *   }\n * ]\n * ```\n *\n * You can filter for specific chains or tokens:\n * ```typescript\n * import { Bridge } from \"thirdweb\";\n *\n * // Get all tokens on Ethereum mainnet\n * const ethTokens = await Bridge.tokens({\n *   chainId: 1,\n *   client: thirdwebClient,\n * });\n * ```\n *\n * You can search for tokens by symbol or name:\n * ```typescript\n * import { Bridge } from \"thirdweb\";\n *\n * // Search for USDC tokens\n * const usdcTokens = await Bridge.tokens({\n *   symbol: \"USDC\",\n *   client: thirdwebClient,\n * });\n *\n * // Search for tokens by name\n * const ethereumTokens = await Bridge.tokens({\n *   name: \"Ethereum\",\n *   client: thirdwebClient,\n * });\n * ```\n *\n * You can filter by a specific token address:\n * ```typescript\n * import { Bridge } from \"thirdweb\";\n *\n * // Get a specific token\n * const token = await Bridge.tokens({\n *   tokenAddress: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n *   client: thirdwebClient,\n * });\n * ```\n *\n * The returned tokens will be limited based on the API. You can paginate through the results using the `limit` and `offset` parameters:\n * ```typescript\n * import { Bridge } from \"thirdweb\";\n *\n * // Get the first 50 tokens\n * const tokens = await Bridge.tokens({\n *   limit: 50,\n *   offset: 0,\n *   client: thirdwebClient,\n * });\n *\n * // Get the next 50 tokens\n * const nextTokens = await Bridge.tokens({\n *   limit: 50,\n *   offset: 50,\n *   client: thirdwebClient,\n * });\n * ```\n *\n * @param options - The options for retrieving tokens.\n * @param options.client - Your thirdweb client.\n * @param options.chainId - Filter by a specific chain ID.\n * @param options.tokenAddress - Filter by a specific token address.\n * @param options.symbol - Filter by token symbol.\n * @param options.name - Filter by token name.\n * @param options.limit - Number of tokens to return (min: 1, default: 100).\n * @param options.offset - Number of tokens to skip (min: 0, default: 0).\n *\n * @returns A promise that resolves to an array of tokens.\n *\n * @throws Will throw an error if there is an issue fetching the tokens.\n * @bridge\n * @beta\n */\nexport async function tokens<\n  IncludePrices extends boolean = true,\n  R extends Token | TokenWithPrices = TokenWithPrices,\n>(options: tokens.Options<IncludePrices>): Promise<R[]> {\n  const {\n    client,\n    chainId,\n    tokenAddress,\n    symbol,\n    name,\n    limit,\n    offset,\n    includePrices,\n    sortBy,\n    query,\n  } = options;\n\n  const clientFetch = getClientFetch(client);\n  const url = new URL(`${getThirdwebBaseUrl(\"bridge\")}/v1/tokens`);\n\n  if (chainId !== null && chainId !== undefined) {\n    url.searchParams.set(\"chainId\", chainId.toString());\n  }\n  if (tokenAddress) {\n    url.searchParams.set(\"tokenAddress\", tokenAddress);\n  }\n  if (symbol) {\n    url.searchParams.set(\"symbol\", symbol);\n  }\n  if (name) {\n    url.searchParams.set(\"name\", name);\n  }\n  if (limit !== undefined) {\n    url.searchParams.set(\"limit\", limit.toString());\n  }\n  if (offset !== null && offset !== undefined) {\n    url.searchParams.set(\"offset\", offset.toString());\n  }\n  if (includePrices !== undefined) {\n    url.searchParams.set(\"includePrices\", includePrices.toString());\n  }\n  if (sortBy !== undefined) {\n    url.searchParams.set(\"sortBy\", sortBy);\n  }\n\n  if (query !== undefined) {\n    url.searchParams.set(\"query\", query);\n  }\n\n  const response = await clientFetch(url.toString());\n  if (!response.ok) {\n    const errorJson = await response.json();\n    throw new ApiError({\n      code: errorJson.code || \"UNKNOWN_ERROR\",\n      correlationId: errorJson.correlationId || undefined,\n      message: errorJson.message || response.statusText,\n      statusCode: response.status,\n    });\n  }\n\n  const { data }: { data: R[] } = await response.json();\n  return data;\n}\n\nexport declare namespace tokens {\n  /**\n   * Input parameters for {@link tokens}.\n   */\n  type Options<IncludePrices extends boolean> = {\n    /** Your {@link ThirdwebClient} instance. */\n    client: ThirdwebClient;\n    /** Filter by a specific chain ID. */\n    chainId?: number | null;\n    /** Filter by a specific token address. */\n    tokenAddress?: string;\n    /** Filter by token symbol. */\n    symbol?: string;\n    /** Filter by token name. */\n    name?: string;\n    /** Number of tokens to return (min: 1, default: 100). */\n    limit?: number;\n    /** Number of tokens to skip (min: 0, default: 0). */\n    offset?: number | null;\n    /** Whether or not to include prices for the tokens. Setting this to false will speed up the request. */\n    includePrices?: IncludePrices;\n    /** Sort by a specific field. */\n    sortBy?: \"newest\" | \"oldest\" | \"volume\" | \"market_cap\";\n    /** search for tokens by token name or symbol */\n    query?: string;\n  };\n\n  /**\n   * The result returned from {@link Bridge.tokens}.\n   */\n  type Result<T extends Token | TokenWithPrices> = T[];\n}\n\n/**\n * Adds a token to the Bridge for indexing.\n *\n * This function requests the Bridge to index a specific token on a given chain.\n * Once indexed, the token will be available for cross-chain operations.\n *\n * @example\n * ```typescript\n * import { Bridge } from \"thirdweb\";\n *\n * // Add a token for indexing\n * const result = await Bridge.add({\n *   client: thirdwebClient,\n *   chainId: 1,\n *   tokenAddress: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\", // USDC\n * });\n * ```\n *\n * @param options - The options for adding a token.\n * @param options.client - Your thirdweb client.\n * @param options.chainId - The chain ID where the token is deployed.\n * @param options.tokenAddress - The contract address of the token to add.\n *\n * @returns A promise that resolves when the token has been successfully submitted for indexing.\n *\n * @throws Will throw an error if there is an issue adding the token.\n * @bridge\n * @beta\n */\nexport async function add(options: add.Options): Promise<add.Result> {\n  const { client, chainId, tokenAddress } = options;\n\n  const clientFetch = getClientFetch(client);\n  const url = `${getThirdwebBaseUrl(\"bridge\")}/v1/tokens`;\n\n  const requestBody = {\n    chainId,\n    tokenAddress,\n  };\n\n  const response = await clientFetch(url, {\n    body: JSON.stringify(requestBody),\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    method: \"POST\",\n  });\n\n  if (!response.ok) {\n    const errorJson = await response.json();\n    throw new ApiError({\n      code: errorJson.code || \"UNKNOWN_ERROR\",\n      correlationId: errorJson.correlationId || undefined,\n      message: errorJson.message || response.statusText,\n      statusCode: response.status,\n    });\n  }\n\n  const { data }: { data: TokenWithPrices } = await response.json();\n  return data;\n}\n\nexport declare namespace add {\n  /**\n   * Input parameters for {@link add}.\n   */\n  type Options = {\n    /** Your {@link ThirdwebClient} instance. */\n    client: ThirdwebClient;\n    /** The chain ID where the token is deployed. */\n    chainId: number;\n    /** The contract address of the token to add. */\n    tokenAddress: string;\n  };\n\n  /**\n   * The result returned from {@link Bridge.add}.\n   */\n  type Result = TokenWithPrices;\n}\n"],"mappings":"AACA,SAASA,kBAAkB,QAAQ,qBAAqB;AACxD,SAASC,cAAc,QAAQ,mBAAmB;AAClD,SAASC,QAAQ,QAAQ,mBAAmB;AAG5C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4HA,OAAO,eAAeC,MAAMA,CAG1BC,OAAsC;EACtC,MAAM;IACJC,MAAM;IACNC,OAAO;IACPC,YAAY;IACZC,MAAM;IACNC,IAAI;IACJC,KAAK;IACLC,MAAM;IACNC,aAAa;IACbC,MAAM;IACNC;EAAK,CACN,GAAGV,OAAO;EAEX,MAAMW,WAAW,GAAGd,cAAc,CAACI,MAAM,CAAC;EAC1C,MAAMW,GAAG,GAAG,IAAIC,GAAG,IAAAC,MAAA,CAAIlB,kBAAkB,CAAC,QAAQ,CAAC,eAAY,CAAC;EAEhE,IAAIM,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAKa,SAAS,EAAE;IAC7CH,GAAG,CAACI,YAAY,CAACC,GAAG,CAAC,SAAS,EAAEf,OAAO,CAACgB,QAAQ,EAAE,CAAC;EACrD;EACA,IAAIf,YAAY,EAAE;IAChBS,GAAG,CAACI,YAAY,CAACC,GAAG,CAAC,cAAc,EAAEd,YAAY,CAAC;EACpD;EACA,IAAIC,MAAM,EAAE;IACVQ,GAAG,CAACI,YAAY,CAACC,GAAG,CAAC,QAAQ,EAAEb,MAAM,CAAC;EACxC;EACA,IAAIC,IAAI,EAAE;IACRO,GAAG,CAACI,YAAY,CAACC,GAAG,CAAC,MAAM,EAAEZ,IAAI,CAAC;EACpC;EACA,IAAIC,KAAK,KAAKS,SAAS,EAAE;IACvBH,GAAG,CAACI,YAAY,CAACC,GAAG,CAAC,OAAO,EAAEX,KAAK,CAACY,QAAQ,EAAE,CAAC;EACjD;EACA,IAAIX,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAKQ,SAAS,EAAE;IAC3CH,GAAG,CAACI,YAAY,CAACC,GAAG,CAAC,QAAQ,EAAEV,MAAM,CAACW,QAAQ,EAAE,CAAC;EACnD;EACA,IAAIV,aAAa,KAAKO,SAAS,EAAE;IAC/BH,GAAG,CAACI,YAAY,CAACC,GAAG,CAAC,eAAe,EAAET,aAAa,CAACU,QAAQ,EAAE,CAAC;EACjE;EACA,IAAIT,MAAM,KAAKM,SAAS,EAAE;IACxBH,GAAG,CAACI,YAAY,CAACC,GAAG,CAAC,QAAQ,EAAER,MAAM,CAAC;EACxC;EAEA,IAAIC,KAAK,KAAKK,SAAS,EAAE;IACvBH,GAAG,CAACI,YAAY,CAACC,GAAG,CAAC,OAAO,EAAEP,KAAK,CAAC;EACtC;EAEA,MAAMS,QAAQ,GAAG,MAAMR,WAAW,CAACC,GAAG,CAACM,QAAQ,EAAE,CAAC;EAClD,IAAI,CAACC,QAAQ,CAACC,EAAE,EAAE;IAChB,MAAMC,SAAS,GAAG,MAAMF,QAAQ,CAACG,IAAI,EAAE;IACvC,MAAM,IAAIxB,QAAQ,CAAC;MACjByB,IAAI,EAAEF,SAAS,CAACE,IAAI,IAAI,eAAe;MACvCC,aAAa,EAAEH,SAAS,CAACG,aAAa,IAAIT,SAAS;MACnDU,OAAO,EAAEJ,SAAS,CAACI,OAAO,IAAIN,QAAQ,CAACO,UAAU;MACjDC,UAAU,EAAER,QAAQ,CAACS;KACtB,CAAC;EACJ;EAEA,MAAM;IAAEC;EAAI,CAAE,GAAkB,MAAMV,QAAQ,CAACG,IAAI,EAAE;EACrD,OAAOO,IAAI;AACb;AAmCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA,OAAO,eAAeC,GAAGA,CAAC9B,OAAoB;EAC5C,MAAM;IAAEC,MAAM;IAAEC,OAAO;IAAEC;EAAY,CAAE,GAAGH,OAAO;EAEjD,MAAMW,WAAW,GAAGd,cAAc,CAACI,MAAM,CAAC;EAC1C,MAAMW,GAAG,MAAAE,MAAA,CAAMlB,kBAAkB,CAAC,QAAQ,CAAC,eAAY;EAEvD,MAAMmC,WAAW,GAAG;IAClB7B,OAAO;IACPC;GACD;EAED,MAAMgB,QAAQ,GAAG,MAAMR,WAAW,CAACC,GAAG,EAAE;IACtCoB,IAAI,EAAEC,IAAI,CAACC,SAAS,CAACH,WAAW,CAAC;IACjCI,OAAO,EAAE;MACP,cAAc,EAAE;KACjB;IACDC,MAAM,EAAE;GACT,CAAC;EAEF,IAAI,CAACjB,QAAQ,CAACC,EAAE,EAAE;IAChB,MAAMC,SAAS,GAAG,MAAMF,QAAQ,CAACG,IAAI,EAAE;IACvC,MAAM,IAAIxB,QAAQ,CAAC;MACjByB,IAAI,EAAEF,SAAS,CAACE,IAAI,IAAI,eAAe;MACvCC,aAAa,EAAEH,SAAS,CAACG,aAAa,IAAIT,SAAS;MACnDU,OAAO,EAAEJ,SAAS,CAACI,OAAO,IAAIN,QAAQ,CAACO,UAAU;MACjDC,UAAU,EAAER,QAAQ,CAACS;KACtB,CAAC;EACJ;EAEA,MAAM;IAAEC;EAAI,CAAE,GAA8B,MAAMV,QAAQ,CAACG,IAAI,EAAE;EACjE,OAAOO,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}