{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { fetchContractMetadata } from \"../../../utils/contract/fetchContractMetadata.js\";\nimport { contractURI } from \"../__generated__/IContractMetadata/read/contractURI.js\";\nimport { name } from \"./name.js\";\nimport { symbol } from \"./symbol.js\";\nexport { isContractURISupported as isGetContractMetadataSupported } from \"../__generated__/IContractMetadata/read/contractURI.js\";\n/**\n * Retrieves the contract metadata including name and symbol.\n * @param options The transaction options.\n * @returns A promise that resolves to an object containing the resolved metadata, name, and symbol.\n * @extension COMMON\n * @example\n * ```ts\n * import { getContractMetadata } from \"thirdweb/extensions/common\";\n * const metadata = await getContractMetadata({ contract });\n * ```\n */\nexport async function getContractMetadata(options) {\n  const [resolvedMetadata, resolvedName, resolvedSymbol] = await Promise.all([contractURI(options).then(uri => {\n    if (uri) {\n      return fetchContractMetadata({\n        client: options.contract.client,\n        uri\n      });\n    }\n    return null;\n  }).catch(() => null), name(options).catch(() => null), symbol(options).catch(() => null)]);\n  // TODO: basic parsing?\n  return _objectSpread(_objectSpread({}, resolvedMetadata !== null && resolvedMetadata !== void 0 ? resolvedMetadata : {}), {}, {\n    name: resolvedMetadata !== null && resolvedMetadata !== void 0 && resolvedMetadata.name && typeof resolvedMetadata.name === \"string\" ? resolvedMetadata.name : resolvedName,\n    symbol: resolvedMetadata !== null && resolvedMetadata !== void 0 && resolvedMetadata.symbol && typeof resolvedMetadata.symbol === \"string\" ? resolvedMetadata.symbol : resolvedSymbol\n  });\n}","map":{"version":3,"names":["fetchContractMetadata","contractURI","name","symbol","isContractURISupported","isGetContractMetadataSupported","getContractMetadata","options","resolvedMetadata","resolvedName","resolvedSymbol","Promise","all","then","uri","client","contract","catch","_objectSpread"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/extensions/common/read/getContractMetadata.ts"],"sourcesContent":["import type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { fetchContractMetadata } from \"../../../utils/contract/fetchContractMetadata.js\";\nimport { contractURI } from \"../__generated__/IContractMetadata/read/contractURI.js\";\nimport { name } from \"./name.js\";\nimport { symbol } from \"./symbol.js\";\n\nexport { isContractURISupported as isGetContractMetadataSupported } from \"../__generated__/IContractMetadata/read/contractURI.js\";\n\n/**\n * Retrieves the contract metadata including name and symbol.\n * @param options The transaction options.\n * @returns A promise that resolves to an object containing the resolved metadata, name, and symbol.\n * @extension COMMON\n * @example\n * ```ts\n * import { getContractMetadata } from \"thirdweb/extensions/common\";\n * const metadata = await getContractMetadata({ contract });\n * ```\n */\nexport async function getContractMetadata(\n  options: BaseTransactionOptions,\n): Promise<{\n  name: string | null;\n  symbol: string | null;\n  [key: string]: unknown;\n}> {\n  const [resolvedMetadata, resolvedName, resolvedSymbol] = await Promise.all([\n    contractURI(options)\n      .then((uri) => {\n        if (uri) {\n          return fetchContractMetadata({\n            client: options.contract.client,\n            uri,\n          });\n        }\n        return null;\n      })\n      .catch(() => null),\n    name(options).catch(() => null),\n    symbol(options).catch(() => null),\n  ]);\n\n  // TODO: basic parsing?\n  return {\n    ...(resolvedMetadata ?? {}),\n    name:\n      resolvedMetadata?.name && typeof resolvedMetadata.name === \"string\"\n        ? resolvedMetadata.name\n        : resolvedName,\n    symbol:\n      resolvedMetadata?.symbol && typeof resolvedMetadata.symbol === \"string\"\n        ? resolvedMetadata.symbol\n        : resolvedSymbol,\n  };\n}\n"],"mappings":";AACA,SAASA,qBAAqB,QAAQ,kDAAkD;AACxF,SAASC,WAAW,QAAQ,wDAAwD;AACpF,SAASC,IAAI,QAAQ,WAAW;AAChC,SAASC,MAAM,QAAQ,aAAa;AAEpC,SAASC,sBAAsB,IAAIC,8BAA8B,QAAQ,wDAAwD;AAEjI;;;;;;;;;;;AAWA,OAAO,eAAeC,mBAAmBA,CACvCC,OAA+B;EAM/B,MAAM,CAACC,gBAAgB,EAAEC,YAAY,EAAEC,cAAc,CAAC,GAAG,MAAMC,OAAO,CAACC,GAAG,CAAC,CACzEX,WAAW,CAACM,OAAO,CAAC,CACjBM,IAAI,CAAEC,GAAG,IAAI;IACZ,IAAIA,GAAG,EAAE;MACP,OAAOd,qBAAqB,CAAC;QAC3Be,MAAM,EAAER,OAAO,CAACS,QAAQ,CAACD,MAAM;QAC/BD;OACD,CAAC;IACJ;IACA,OAAO,IAAI;EACb,CAAC,CAAC,CACDG,KAAK,CAAC,MAAM,IAAI,CAAC,EACpBf,IAAI,CAACK,OAAO,CAAC,CAACU,KAAK,CAAC,MAAM,IAAI,CAAC,EAC/Bd,MAAM,CAACI,OAAO,CAAC,CAACU,KAAK,CAAC,MAAM,IAAI,CAAC,CAClC,CAAC;EAEF;EACA,OAAAC,aAAA,CAAAA,aAAA,KACMV,gBAAgB,aAAhBA,gBAAgB,cAAhBA,gBAAgB,GAAI,EAAE;IAC1BN,IAAI,EACFM,gBAAgB,aAAhBA,gBAAgB,eAAhBA,gBAAgB,CAAEN,IAAI,IAAI,OAAOM,gBAAgB,CAACN,IAAI,KAAK,QAAQ,GAC/DM,gBAAgB,CAACN,IAAI,GACrBO,YAAY;IAClBN,MAAM,EACJK,gBAAgB,aAAhBA,gBAAgB,eAAhBA,gBAAgB,CAAEL,MAAM,IAAI,OAAOK,gBAAgB,CAACL,MAAM,KAAK,QAAQ,GACnEK,gBAAgB,CAACL,MAAM,GACvBO;EAAc;AAExB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}