{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { bytesToHex } from \"viem\";\nimport { trackTransaction } from \"../../../../analytics/track/transaction.js\";\nimport { getCachedChain } from \"../../../../chains/utils.js\";\nimport { eth_sendRawTransaction } from \"../../../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../../../rpc/rpc.js\";\nimport { getAddress } from \"../../../../utils/address.js\";\nimport { isHex, toHex } from \"../../../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../../../utils/signatures/helpers/parse-typed-data.js\";\nimport { getUserStatus } from \"../actions/get-enclave-user-status.js\";\nimport { signAuthorization as signEnclaveAuthorization } from \"../actions/sign-authorization.enclave.js\";\nimport { signMessage as signEnclaveMessage } from \"../actions/sign-message.enclave.js\";\nimport { signTransaction as signEnclaveTransaction } from \"../actions/sign-transaction.enclave.js\";\nimport { signTypedData as signEnclaveTypedData } from \"../actions/sign-typed-data.enclave.js\";\nexport class EnclaveWallet {\n  constructor(_ref) {\n    let {\n      client,\n      ecosystem,\n      address,\n      storage\n    } = _ref;\n    Object.defineProperty(this, \"client\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"ecosystem\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"address\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"localStorage\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.client = client;\n    this.ecosystem = ecosystem;\n    this.address = address;\n    this.localStorage = storage;\n  }\n  /**\n   * Store the auth token for use\n   * @returns `{walletAddress: string }` The user's wallet details\n   * @internal\n   */\n  async postWalletSetUp(authResult) {\n    await this.localStorage.saveAuthCookie(authResult.storedToken.cookieString);\n  }\n  /**\n   * Gets the current user's details\n   * @internal\n   */\n  async getUserWalletStatus() {\n    var _userStatus$linkedAcc, _userStatus$linkedAcc2;\n    const token = await this.localStorage.getAuthCookie();\n    if (!token) {\n      return {\n        status: \"Logged Out\"\n      };\n    }\n    const userStatus = await getUserStatus({\n      authToken: token,\n      client: this.client,\n      ecosystem: this.ecosystem\n    });\n    if (!userStatus) {\n      return {\n        status: \"Logged Out\"\n      };\n    }\n    const wallet = userStatus.wallets[0];\n    const authDetails = {\n      email: (_userStatus$linkedAcc = userStatus.linkedAccounts.find(account => account.details.email !== undefined)) === null || _userStatus$linkedAcc === void 0 ? void 0 : _userStatus$linkedAcc.details.email,\n      phoneNumber: (_userStatus$linkedAcc2 = userStatus.linkedAccounts.find(account => account.details.phone !== undefined)) === null || _userStatus$linkedAcc2 === void 0 ? void 0 : _userStatus$linkedAcc2.details.phone,\n      recoveryShareManagement: \"ENCLAVE\",\n      userWalletId: userStatus.id || \"\"\n    };\n    if (!wallet) {\n      return {\n        authDetails,\n        status: \"Logged In, Wallet Uninitialized\"\n      };\n    }\n    return {\n      account: await this.getAccount(),\n      authDetails,\n      status: \"Logged In, Wallet Initialized\",\n      walletAddress: wallet.address\n    };\n  }\n  /**\n   * Returns an account to perform wallet operations\n   * @internal\n   */\n  async getAccount() {\n    const client = this.client;\n    const storage = this.localStorage;\n    const address = this.address;\n    const ecosystem = this.ecosystem;\n    const _signTransaction = async tx => {\n      const rpcRequest = getRpcClient({\n        chain: getCachedChain(tx.chainId),\n        client\n      });\n      const transaction = {\n        chainId: toHex(tx.chainId),\n        data: tx.data,\n        gas: hexlify(tx.gas),\n        nonce: hexlify(tx.nonce) || toHex(await import(\"../../../../rpc/actions/eth_getTransactionCount.js\").then(_ref2 => {\n          let {\n            eth_getTransactionCount\n          } = _ref2;\n          return eth_getTransactionCount(rpcRequest, {\n            address: getAddress(this.address),\n            blockTag: \"pending\"\n          });\n        })),\n        to: tx.to ? getAddress(tx.to) : undefined,\n        value: hexlify(tx.value)\n      };\n      if (tx.authorizationList && tx.authorizationList.length > 0) {\n        transaction.type = 4;\n        transaction.authorizationList = tx.authorizationList;\n        transaction.maxFeePerGas = hexlify(tx.maxFeePerGas);\n        transaction.maxPriorityFeePerGas = hexlify(tx.maxPriorityFeePerGas);\n      } else if (hexlify(tx.maxFeePerGas)) {\n        transaction.maxFeePerGas = hexlify(tx.maxFeePerGas);\n        transaction.maxPriorityFeePerGas = hexlify(tx.maxPriorityFeePerGas);\n        transaction.type = 2;\n      } else {\n        transaction.gasPrice = hexlify(tx.gasPrice);\n        transaction.type = 0;\n      }\n      return signEnclaveTransaction({\n        client,\n        payload: transaction,\n        storage\n      });\n    };\n    const account = {\n      address: getAddress(address),\n      async sendTransaction(tx) {\n        var _tx$to;\n        const rpcRequest = getRpcClient({\n          chain: getCachedChain(tx.chainId),\n          client\n        });\n        const signedTx = await _signTransaction(tx);\n        const transactionHash = await eth_sendRawTransaction(rpcRequest, signedTx);\n        trackTransaction({\n          chainId: tx.chainId,\n          client,\n          contractAddress: (_tx$to = tx.to) !== null && _tx$to !== void 0 ? _tx$to : undefined,\n          ecosystem,\n          gasPrice: tx.gasPrice,\n          transactionHash,\n          walletAddress: address,\n          walletType: \"inApp\"\n        });\n        return {\n          transactionHash\n        };\n      },\n      async signAuthorization(payload) {\n        const authorization = await signEnclaveAuthorization({\n          client,\n          payload,\n          storage\n        });\n        return {\n          address: getAddress(authorization.address),\n          chainId: Number.parseInt(authorization.chainId),\n          nonce: BigInt(authorization.nonce),\n          r: BigInt(authorization.r),\n          s: BigInt(authorization.s),\n          yParity: Number.parseInt(authorization.yParity)\n        };\n      },\n      async signMessage(_ref3) {\n        let {\n          message,\n          originalMessage,\n          chainId\n        } = _ref3;\n        const messagePayload = (() => {\n          if (typeof message === \"string\") {\n            return {\n              chainId,\n              isRaw: false,\n              message,\n              originalMessage\n            };\n          }\n          return {\n            chainId,\n            isRaw: true,\n            message: typeof message.raw === \"string\" ? message.raw : bytesToHex(message.raw),\n            originalMessage\n          };\n        })();\n        const {\n          signature\n        } = await signEnclaveMessage({\n          client,\n          payload: messagePayload,\n          storage\n        });\n        return signature;\n      },\n      async signTransaction(tx) {\n        if (!tx.chainId) {\n          throw new Error(\"chainId required in tx to sign\");\n        }\n        return _signTransaction(_objectSpread({\n          chainId: tx.chainId\n        }, tx));\n      },\n      async signTypedData(_typedData) {\n        const parsedTypedData = parseTypedData(_typedData);\n        const {\n          signature\n        } = await signEnclaveTypedData({\n          client,\n          payload: parsedTypedData,\n          storage\n        });\n        return signature;\n      },\n      sendCalls: async options => {\n        const {\n          inAppWalletSendCalls\n        } = await import(\"../eip5792/in-app-wallet-calls.js\");\n        const firstCall = options.calls[0];\n        if (!firstCall) {\n          throw new Error(\"No calls to send\");\n        }\n        const client = firstCall.client;\n        const chain = firstCall.chain || options.chain;\n        const id = await inAppWalletSendCalls({\n          account: account,\n          calls: options.calls,\n          chain\n        });\n        return {\n          chain,\n          client,\n          id\n        };\n      },\n      getCallsStatus: async options => {\n        const {\n          inAppWalletGetCallsStatus\n        } = await import(\"../eip5792/in-app-wallet-calls.js\");\n        return inAppWalletGetCallsStatus(options);\n      },\n      getCapabilities: async options => {\n        var _options$chainId;\n        return {\n          [(_options$chainId = options.chainId) !== null && _options$chainId !== void 0 ? _options$chainId : 1]: {\n            atomic: {\n              status: \"unsupported\"\n            },\n            paymasterService: {\n              supported: false\n            }\n          }\n        };\n      }\n    };\n    return account;\n  }\n}\nfunction hexlify(value) {\n  return value === undefined || isHex(value) ? value : toHex(value);\n}","map":{"version":3,"names":["bytesToHex","trackTransaction","getCachedChain","eth_sendRawTransaction","getRpcClient","getAddress","isHex","toHex","parseTypedData","getUserStatus","signAuthorization","signEnclaveAuthorization","signMessage","signEnclaveMessage","signTransaction","signEnclaveTransaction","signTypedData","signEnclaveTypedData","EnclaveWallet","constructor","_ref","client","ecosystem","address","storage","Object","defineProperty","localStorage","postWalletSetUp","authResult","saveAuthCookie","storedToken","cookieString","getUserWalletStatus","_userStatus$linkedAcc","_userStatus$linkedAcc2","token","getAuthCookie","status","userStatus","authToken","wallet","wallets","authDetails","email","linkedAccounts","find","account","details","undefined","phoneNumber","phone","recoveryShareManagement","userWalletId","id","getAccount","walletAddress","_signTransaction","tx","rpcRequest","chain","chainId","transaction","data","gas","hexlify","nonce","then","_ref2","eth_getTransactionCount","blockTag","to","value","authorizationList","length","type","maxFeePerGas","maxPriorityFeePerGas","gasPrice","payload","sendTransaction","_tx$to","signedTx","transactionHash","contractAddress","walletType","authorization","Number","parseInt","BigInt","r","s","yParity","_ref3","message","originalMessage","messagePayload","isRaw","raw","signature","Error","_objectSpread","_typedData","parsedTypedData","sendCalls","options","inAppWalletSendCalls","firstCall","calls","getCallsStatus","inAppWalletGetCallsStatus","getCapabilities","_options$chainId","atomic","paymasterService","supported"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/wallets/in-app/core/wallet/enclave-wallet.ts"],"sourcesContent":["import { bytesToHex } from \"viem\";\nimport { trackTransaction } from \"../../../../analytics/track/transaction.js\";\nimport { getCachedChain } from \"../../../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { eth_sendRawTransaction } from \"../../../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../../../rpc/rpc.js\";\nimport { getAddress } from \"../../../../utils/address.js\";\nimport { type Hex, isHex, toHex } from \"../../../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../../../utils/signatures/helpers/parse-typed-data.js\";\nimport type { Prettify } from \"../../../../utils/type-utils.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n} from \"../../../interfaces/wallet.js\";\nimport { getUserStatus } from \"../actions/get-enclave-user-status.js\";\nimport { signAuthorization as signEnclaveAuthorization } from \"../actions/sign-authorization.enclave.js\";\nimport { signMessage as signEnclaveMessage } from \"../actions/sign-message.enclave.js\";\nimport { signTransaction as signEnclaveTransaction } from \"../actions/sign-transaction.enclave.js\";\nimport { signTypedData as signEnclaveTypedData } from \"../actions/sign-typed-data.enclave.js\";\nimport type { ClientScopedStorage } from \"../authentication/client-scoped-storage.js\";\nimport type {\n  AuthDetails,\n  AuthResultAndRecoveryCode,\n  GetUser,\n} from \"../authentication/types.js\";\nimport type { Ecosystem } from \"./types.js\";\nimport type { IWebWallet } from \"./web-wallet.js\";\n\nexport type UserStatus = {\n  linkedAccounts: {\n    type: string;\n    details:\n      | { email: string; [key: string]: string }\n      | { phone: string; [key: string]: string }\n      | { address: string; [key: string]: string }\n      | { id: string; [key: string]: string };\n  }[];\n  wallets: UserWallet[];\n  id: string;\n};\n\nexport type UserWallet = {\n  address: string;\n  createdAt: string;\n  type: \"sharded\" | \"enclave\";\n};\n\nexport class EnclaveWallet implements IWebWallet {\n  private client: ThirdwebClient;\n  private ecosystem?: Ecosystem;\n  private address: string;\n  private localStorage: ClientScopedStorage;\n\n  constructor({\n    client,\n    ecosystem,\n    address,\n    storage,\n  }: Prettify<{\n    client: ThirdwebClient;\n    ecosystem?: Ecosystem;\n    address: string;\n    storage: ClientScopedStorage;\n  }>) {\n    this.client = client;\n    this.ecosystem = ecosystem;\n    this.address = address;\n    this.localStorage = storage;\n  }\n\n  /**\n   * Store the auth token for use\n   * @returns `{walletAddress: string }` The user's wallet details\n   * @internal\n   */\n  async postWalletSetUp(authResult: AuthResultAndRecoveryCode): Promise<void> {\n    await this.localStorage.saveAuthCookie(authResult.storedToken.cookieString);\n  }\n\n  /**\n   * Gets the current user's details\n   * @internal\n   */\n  async getUserWalletStatus(): Promise<GetUser> {\n    const token = await this.localStorage.getAuthCookie();\n    if (!token) {\n      return { status: \"Logged Out\" };\n    }\n\n    const userStatus = await getUserStatus({\n      authToken: token,\n      client: this.client,\n      ecosystem: this.ecosystem,\n    });\n\n    if (!userStatus) {\n      return { status: \"Logged Out\" };\n    }\n    const wallet = userStatus.wallets[0];\n\n    const authDetails: AuthDetails = {\n      email: userStatus.linkedAccounts.find(\n        (account) => account.details.email !== undefined,\n      )?.details.email,\n      phoneNumber: userStatus.linkedAccounts.find(\n        (account) => account.details.phone !== undefined,\n      )?.details.phone,\n      recoveryShareManagement: \"ENCLAVE\",\n      userWalletId: userStatus.id || \"\",\n    };\n\n    if (!wallet) {\n      return {\n        authDetails,\n        status: \"Logged In, Wallet Uninitialized\",\n      };\n    }\n\n    return {\n      account: await this.getAccount(),\n      authDetails,\n      status: \"Logged In, Wallet Initialized\",\n      walletAddress: wallet.address,\n    };\n  }\n\n  /**\n   * Returns an account to perform wallet operations\n   * @internal\n   */\n  async getAccount(): Promise<Account> {\n    const client = this.client;\n    const storage = this.localStorage;\n    const address = this.address;\n    const ecosystem = this.ecosystem;\n\n    const _signTransaction = async (tx: SendTransactionOption) => {\n      const rpcRequest = getRpcClient({\n        chain: getCachedChain(tx.chainId),\n        client,\n      });\n      const transaction: Record<string, unknown> = {\n        chainId: toHex(tx.chainId),\n        data: tx.data,\n        gas: hexlify(tx.gas),\n        nonce:\n          hexlify(tx.nonce) ||\n          toHex(\n            await import(\n              \"../../../../rpc/actions/eth_getTransactionCount.js\"\n            ).then(({ eth_getTransactionCount }) =>\n              eth_getTransactionCount(rpcRequest, {\n                address: getAddress(this.address),\n                blockTag: \"pending\",\n              }),\n            ),\n          ),\n        to: tx.to ? getAddress(tx.to) : undefined,\n        value: hexlify(tx.value),\n      };\n\n      if (tx.authorizationList && tx.authorizationList.length > 0) {\n        transaction.type = 4;\n        transaction.authorizationList = tx.authorizationList;\n        transaction.maxFeePerGas = hexlify(tx.maxFeePerGas);\n        transaction.maxPriorityFeePerGas = hexlify(tx.maxPriorityFeePerGas);\n      } else if (hexlify(tx.maxFeePerGas)) {\n        transaction.maxFeePerGas = hexlify(tx.maxFeePerGas);\n        transaction.maxPriorityFeePerGas = hexlify(tx.maxPriorityFeePerGas);\n        transaction.type = 2;\n      } else {\n        transaction.gasPrice = hexlify(tx.gasPrice);\n        transaction.type = 0;\n      }\n\n      return signEnclaveTransaction({\n        client,\n        payload: transaction,\n        storage,\n      });\n    };\n    const account: Account = {\n      address: getAddress(address),\n      async sendTransaction(tx) {\n        const rpcRequest = getRpcClient({\n          chain: getCachedChain(tx.chainId),\n          client,\n        });\n        const signedTx = await _signTransaction(tx);\n\n        const transactionHash = await eth_sendRawTransaction(\n          rpcRequest,\n          signedTx,\n        );\n\n        trackTransaction({\n          chainId: tx.chainId,\n          client,\n          contractAddress: tx.to ?? undefined,\n          ecosystem,\n          gasPrice: tx.gasPrice,\n          transactionHash,\n          walletAddress: address,\n          walletType: \"inApp\",\n        });\n\n        return { transactionHash };\n      },\n      async signAuthorization(payload) {\n        const authorization = await signEnclaveAuthorization({\n          client,\n          payload,\n          storage,\n        });\n        return {\n          address: getAddress(authorization.address),\n          chainId: Number.parseInt(authorization.chainId),\n          nonce: BigInt(authorization.nonce),\n          r: BigInt(authorization.r),\n          s: BigInt(authorization.s),\n          yParity: Number.parseInt(authorization.yParity),\n        };\n      },\n      async signMessage({ message, originalMessage, chainId }) {\n        const messagePayload = (() => {\n          if (typeof message === \"string\") {\n            return { chainId, isRaw: false, message, originalMessage };\n          }\n          return {\n            chainId,\n            isRaw: true,\n            message:\n              typeof message.raw === \"string\"\n                ? message.raw\n                : bytesToHex(message.raw),\n            originalMessage,\n          };\n        })();\n\n        const { signature } = await signEnclaveMessage({\n          client,\n          payload: messagePayload,\n          storage,\n        });\n        return signature as Hex;\n      },\n      async signTransaction(tx) {\n        if (!tx.chainId) {\n          throw new Error(\"chainId required in tx to sign\");\n        }\n\n        return _signTransaction({\n          chainId: tx.chainId,\n          ...tx,\n        });\n      },\n      async signTypedData(_typedData) {\n        const parsedTypedData = parseTypedData(_typedData);\n        const { signature } = await signEnclaveTypedData({\n          client,\n          payload: parsedTypedData,\n          storage,\n        });\n\n        return signature as Hex;\n      },\n      sendCalls: async (options) => {\n        const { inAppWalletSendCalls } = await import(\n          \"../eip5792/in-app-wallet-calls.js\"\n        );\n        const firstCall = options.calls[0];\n        if (!firstCall) {\n          throw new Error(\"No calls to send\");\n        }\n        const client = firstCall.client;\n        const chain = firstCall.chain || options.chain;\n        const id = await inAppWalletSendCalls({\n          account: account,\n          calls: options.calls,\n          chain,\n        });\n        return { chain, client, id };\n      },\n      getCallsStatus: async (options) => {\n        const { inAppWalletGetCallsStatus } = await import(\n          \"../eip5792/in-app-wallet-calls.js\"\n        );\n        return inAppWalletGetCallsStatus(options);\n      },\n      getCapabilities: async (options) => {\n        return {\n          [options.chainId ?? 1]: {\n            atomic: {\n              status: \"unsupported\",\n            },\n            paymasterService: {\n              supported: false,\n            },\n          },\n        };\n      },\n    };\n    return account;\n  }\n}\n\nfunction hexlify(value: string | number | bigint | undefined) {\n  return value === undefined || isHex(value) ? value : toHex(value);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}