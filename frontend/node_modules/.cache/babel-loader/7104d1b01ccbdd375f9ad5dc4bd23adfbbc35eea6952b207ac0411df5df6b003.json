{"ast":null,"code":"import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { getCachedChain } from \"../../../../chains/utils.js\";\n/**\n * @internal\n */\nexport function useSiweAuth(activeWallet, activeAccount, authOptions) {\n  const requiresAuth = !!authOptions;\n  const queryClient = useQueryClient();\n  const isLoggedInQuery = useQuery({\n    enabled: requiresAuth && !!(activeAccount !== null && activeAccount !== void 0 && activeAccount.address),\n    gcTime: 0,\n    placeholderData: false,\n    queryFn: () => {\n      // these cases should never be hit but just in case...\n      if (!authOptions || !(activeAccount !== null && activeAccount !== void 0 && activeAccount.address)) {\n        return false;\n      }\n      return authOptions.isLoggedIn(activeAccount.address);\n    },\n    queryKey: [\"siwe_auth\", \"isLoggedIn\", activeAccount === null || activeAccount === void 0 ? void 0 : activeAccount.address],\n    refetchOnWindowFocus: false\n  });\n  const loginMutation = useMutation({\n    mutationFn: async () => {\n      if (!authOptions) {\n        throw new Error(\"No auth options provided\");\n      }\n      if (!activeWallet) {\n        throw new Error(\"No active wallet\");\n      }\n      const chain = activeWallet.getChain();\n      if (!chain) {\n        throw new Error(\"No active chain\");\n      }\n      if (!activeAccount) {\n        throw new Error(\"No active account\");\n      }\n      const [payload, {\n        signLoginPayload\n      }] = await Promise.all([authOptions.getLoginPayload({\n        address: activeAccount.address,\n        chainId: chain.id\n      }),\n      // we lazy-load this because it's only needed when logging in\n      import(\"../../../../auth/core/sign-login-payload.js\")]);\n      if (payload.chain_id && Number(payload.chain_id) !== chain.id) {\n        await activeWallet.switchChain(getCachedChain(Number(payload.chain_id)));\n      }\n      const signedPayload = await signLoginPayload({\n        account: activeAccount,\n        payload\n      });\n      return await authOptions.doLogin(signedPayload);\n    },\n    mutationKey: [\"siwe_auth\", \"login\", activeAccount === null || activeAccount === void 0 ? void 0 : activeAccount.address],\n    onSuccess: () => {\n      return queryClient.invalidateQueries({\n        queryKey: [\"siwe_auth\", \"isLoggedIn\"]\n      });\n    }\n  });\n  const logoutMutation = useMutation({\n    mutationFn: async () => {\n      if (!authOptions) {\n        throw new Error(\"No auth options provided\");\n      }\n      return await authOptions.doLogout();\n    },\n    mutationKey: [\"siwe_auth\", \"logout\", activeAccount === null || activeAccount === void 0 ? void 0 : activeAccount.address],\n    onSuccess: () => {\n      return queryClient.invalidateQueries({\n        queryKey: [\"siwe_auth\", \"isLoggedIn\"]\n      });\n    }\n  });\n  return {\n    // login\n    doLogin: loginMutation.mutateAsync,\n    // logout\n    doLogout: logoutMutation.mutateAsync,\n    isLoading: isLoggedInQuery.isFetching,\n    // checking if logged in\n    isLoggedIn: isLoggedInQuery.data,\n    isLoggingIn: loginMutation.isPending,\n    isLoggingOut: logoutMutation.isPending,\n    isPending: isLoggedInQuery.isPending,\n    // is auth even enabled\n    requiresAuth\n  };\n}","map":{"version":3,"names":["useMutation","useQuery","useQueryClient","getCachedChain","useSiweAuth","activeWallet","activeAccount","authOptions","requiresAuth","queryClient","isLoggedInQuery","enabled","address","gcTime","placeholderData","queryFn","isLoggedIn","queryKey","refetchOnWindowFocus","loginMutation","mutationFn","Error","chain","getChain","payload","signLoginPayload","Promise","all","getLoginPayload","chainId","id","chain_id","Number","switchChain","signedPayload","account","doLogin","mutationKey","onSuccess","invalidateQueries","logoutMutation","doLogout","mutateAsync","isLoading","isFetching","data","isLoggingIn","isPending","isLoggingOut"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/react/core/hooks/auth/useSiweAuth.ts"],"sourcesContent":["import { useMutation, useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport type { LoginPayload } from \"../../../../auth/core/types.js\";\nimport type { VerifyLoginPayloadParams } from \"../../../../auth/core/verify-login-payload.js\";\nimport { getCachedChain } from \"../../../../chains/utils.js\";\nimport type { Account, Wallet } from \"../../../../wallets/interfaces/wallet.js\";\n\n/**\n * Options for Setting up SIWE (Sign in with Ethereum) Authentication\n * @auth\n */\nexport type SiweAuthOptions = {\n  // we pass address and chainId and retrieve a login payload (we do not care how)\n\n  /**\n   * Method to get the login payload for given address and chainId\n   * @param params - The parameters to get the login payload for.\n   */\n  getLoginPayload: (params: {\n    address: string;\n    chainId: number;\n  }) => Promise<LoginPayload>;\n\n  // we pass the login payload and signature and the developer passes this to the auth server however they want\n\n  /**\n   * Method to login with the signed login payload\n   * @param params\n   */\n  doLogin: (params: VerifyLoginPayloadParams) => Promise<void>;\n\n  // we call this internally when a user explicitly disconnects their wallet\n\n  /**\n   * Method to logout the user\n   */\n  doLogout: () => Promise<void>;\n\n  // the developer specifies how to check if the user is logged in, this is called internally by the component\n\n  /**\n   * Method to check if the user is logged in or not\n   * @param address\n   */\n  isLoggedIn: (address: string) => Promise<boolean>;\n};\n\n/**\n * @internal\n */\nexport function useSiweAuth(\n  activeWallet?: Wallet,\n  activeAccount?: Account,\n  authOptions?: SiweAuthOptions,\n) {\n  const requiresAuth = !!authOptions;\n\n  const queryClient = useQueryClient();\n\n  const isLoggedInQuery = useQuery({\n    enabled: requiresAuth && !!activeAccount?.address,\n    gcTime: 0,\n    placeholderData: false,\n    queryFn: () => {\n      // these cases should never be hit but just in case...\n      if (!authOptions || !activeAccount?.address) {\n        return false;\n      }\n      return authOptions.isLoggedIn(activeAccount.address);\n    },\n    queryKey: [\"siwe_auth\", \"isLoggedIn\", activeAccount?.address],\n    refetchOnWindowFocus: false,\n  });\n\n  const loginMutation = useMutation({\n    mutationFn: async () => {\n      if (!authOptions) {\n        throw new Error(\"No auth options provided\");\n      }\n\n      if (!activeWallet) {\n        throw new Error(\"No active wallet\");\n      }\n      const chain = activeWallet.getChain();\n      if (!chain) {\n        throw new Error(\"No active chain\");\n      }\n      if (!activeAccount) {\n        throw new Error(\"No active account\");\n      }\n      const [payload, { signLoginPayload }] = await Promise.all([\n        authOptions.getLoginPayload({\n          address: activeAccount.address,\n          chainId: chain.id,\n        }),\n        // we lazy-load this because it's only needed when logging in\n        import(\"../../../../auth/core/sign-login-payload.js\"),\n      ]);\n\n      if (payload.chain_id && Number(payload.chain_id) !== chain.id) {\n        await activeWallet.switchChain(\n          getCachedChain(Number(payload.chain_id)),\n        );\n      }\n\n      const signedPayload = await signLoginPayload({\n        account: activeAccount,\n        payload,\n      });\n\n      return await authOptions.doLogin(signedPayload);\n    },\n    mutationKey: [\"siwe_auth\", \"login\", activeAccount?.address],\n    onSuccess: () => {\n      return queryClient.invalidateQueries({\n        queryKey: [\"siwe_auth\", \"isLoggedIn\"],\n      });\n    },\n  });\n\n  const logoutMutation = useMutation({\n    mutationFn: async () => {\n      if (!authOptions) {\n        throw new Error(\"No auth options provided\");\n      }\n\n      return await authOptions.doLogout();\n    },\n    mutationKey: [\"siwe_auth\", \"logout\", activeAccount?.address],\n    onSuccess: () => {\n      return queryClient.invalidateQueries({\n        queryKey: [\"siwe_auth\", \"isLoggedIn\"],\n      });\n    },\n  });\n\n  return {\n    // login\n    doLogin: loginMutation.mutateAsync,\n\n    // logout\n    doLogout: logoutMutation.mutateAsync,\n    isLoading: isLoggedInQuery.isFetching,\n\n    // checking if logged in\n    isLoggedIn: isLoggedInQuery.data,\n    isLoggingIn: loginMutation.isPending,\n    isLoggingOut: logoutMutation.isPending,\n    isPending: isLoggedInQuery.isPending,\n    // is auth even enabled\n    requiresAuth,\n  };\n}\n"],"mappings":"AAAA,SAASA,WAAW,EAAEC,QAAQ,EAAEC,cAAc,QAAQ,uBAAuB;AAG7E,SAASC,cAAc,QAAQ,6BAA6B;AA2C5D;;;AAGA,OAAM,SAAUC,WAAWA,CACzBC,YAAqB,EACrBC,aAAuB,EACvBC,WAA6B;EAE7B,MAAMC,YAAY,GAAG,CAAC,CAACD,WAAW;EAElC,MAAME,WAAW,GAAGP,cAAc,EAAE;EAEpC,MAAMQ,eAAe,GAAGT,QAAQ,CAAC;IAC/BU,OAAO,EAAEH,YAAY,IAAI,CAAC,EAACF,aAAa,aAAbA,aAAa,eAAbA,aAAa,CAAEM,OAAO;IACjDC,MAAM,EAAE,CAAC;IACTC,eAAe,EAAE,KAAK;IACtBC,OAAO,EAAEA,CAAA,KAAK;MACZ;MACA,IAAI,CAACR,WAAW,IAAI,EAACD,aAAa,aAAbA,aAAa,eAAbA,aAAa,CAAEM,OAAO,GAAE;QAC3C,OAAO,KAAK;MACd;MACA,OAAOL,WAAW,CAACS,UAAU,CAACV,aAAa,CAACM,OAAO,CAAC;IACtD,CAAC;IACDK,QAAQ,EAAE,CAAC,WAAW,EAAE,YAAY,EAAEX,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAEM,OAAO,CAAC;IAC7DM,oBAAoB,EAAE;GACvB,CAAC;EAEF,MAAMC,aAAa,GAAGnB,WAAW,CAAC;IAChCoB,UAAU,EAAE,MAAAA,CAAA,KAAW;MACrB,IAAI,CAACb,WAAW,EAAE;QAChB,MAAM,IAAIc,KAAK,CAAC,0BAA0B,CAAC;MAC7C;MAEA,IAAI,CAAChB,YAAY,EAAE;QACjB,MAAM,IAAIgB,KAAK,CAAC,kBAAkB,CAAC;MACrC;MACA,MAAMC,KAAK,GAAGjB,YAAY,CAACkB,QAAQ,EAAE;MACrC,IAAI,CAACD,KAAK,EAAE;QACV,MAAM,IAAID,KAAK,CAAC,iBAAiB,CAAC;MACpC;MACA,IAAI,CAACf,aAAa,EAAE;QAClB,MAAM,IAAIe,KAAK,CAAC,mBAAmB,CAAC;MACtC;MACA,MAAM,CAACG,OAAO,EAAE;QAAEC;MAAgB,CAAE,CAAC,GAAG,MAAMC,OAAO,CAACC,GAAG,CAAC,CACxDpB,WAAW,CAACqB,eAAe,CAAC;QAC1BhB,OAAO,EAAEN,aAAa,CAACM,OAAO;QAC9BiB,OAAO,EAAEP,KAAK,CAACQ;OAChB,CAAC;MACF;MACA,MAAM,CAAC,6CAA6C,CAAC,CACtD,CAAC;MAEF,IAAIN,OAAO,CAACO,QAAQ,IAAIC,MAAM,CAACR,OAAO,CAACO,QAAQ,CAAC,KAAKT,KAAK,CAACQ,EAAE,EAAE;QAC7D,MAAMzB,YAAY,CAAC4B,WAAW,CAC5B9B,cAAc,CAAC6B,MAAM,CAACR,OAAO,CAACO,QAAQ,CAAC,CAAC,CACzC;MACH;MAEA,MAAMG,aAAa,GAAG,MAAMT,gBAAgB,CAAC;QAC3CU,OAAO,EAAE7B,aAAa;QACtBkB;OACD,CAAC;MAEF,OAAO,MAAMjB,WAAW,CAAC6B,OAAO,CAACF,aAAa,CAAC;IACjD,CAAC;IACDG,WAAW,EAAE,CAAC,WAAW,EAAE,OAAO,EAAE/B,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAEM,OAAO,CAAC;IAC3D0B,SAAS,EAAEA,CAAA,KAAK;MACd,OAAO7B,WAAW,CAAC8B,iBAAiB,CAAC;QACnCtB,QAAQ,EAAE,CAAC,WAAW,EAAE,YAAY;OACrC,CAAC;IACJ;GACD,CAAC;EAEF,MAAMuB,cAAc,GAAGxC,WAAW,CAAC;IACjCoB,UAAU,EAAE,MAAAA,CAAA,KAAW;MACrB,IAAI,CAACb,WAAW,EAAE;QAChB,MAAM,IAAIc,KAAK,CAAC,0BAA0B,CAAC;MAC7C;MAEA,OAAO,MAAMd,WAAW,CAACkC,QAAQ,EAAE;IACrC,CAAC;IACDJ,WAAW,EAAE,CAAC,WAAW,EAAE,QAAQ,EAAE/B,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAEM,OAAO,CAAC;IAC5D0B,SAAS,EAAEA,CAAA,KAAK;MACd,OAAO7B,WAAW,CAAC8B,iBAAiB,CAAC;QACnCtB,QAAQ,EAAE,CAAC,WAAW,EAAE,YAAY;OACrC,CAAC;IACJ;GACD,CAAC;EAEF,OAAO;IACL;IACAmB,OAAO,EAAEjB,aAAa,CAACuB,WAAW;IAElC;IACAD,QAAQ,EAAED,cAAc,CAACE,WAAW;IACpCC,SAAS,EAAEjC,eAAe,CAACkC,UAAU;IAErC;IACA5B,UAAU,EAAEN,eAAe,CAACmC,IAAI;IAChCC,WAAW,EAAE3B,aAAa,CAAC4B,SAAS;IACpCC,YAAY,EAAER,cAAc,CAACO,SAAS;IACtCA,SAAS,EAAErC,eAAe,CAACqC,SAAS;IACpC;IACAvC;GACD;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}