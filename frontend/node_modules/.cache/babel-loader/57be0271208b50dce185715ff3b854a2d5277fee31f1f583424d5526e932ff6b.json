{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport * as ox__Hex from \"ox/Hex\";\nimport { formatTransactionRequest } from \"viem\";\nimport { roundUpGas } from \"../../gas/op-gas-fee-reducer.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport { extractError } from \"../extract-error.js\";\nconst cache = new WeakMap();\n/**\n * Estimates the gas required to execute a transaction. The gas is returned as a `bigint` and in gwei units.\n * @param options - The options for estimating gas.\n * @returns A promise that resolves to the estimated gas as a bigint.\n * @transaction\n * @example\n * ```ts\n * import { estimateGas } from \"thirdweb\";\n * const gas = await estimateGas({\n *  transaction,\n *  from: \"0x...\",\n * });\n * ```\n */\nexport async function estimateGas(options) {\n  var _options$from, _options$from$address, _options$from2, _options$account;\n  // from is:\n  // 1. the user specified from address\n  // 2. the passed in account address\n  // 3. the passed in wallet's account address\n  const fromAddress = typeof options.from === \"string\" ? (_options$from = options.from) !== null && _options$from !== void 0 ? _options$from : undefined : (_options$from$address = (_options$from2 = options.from) === null || _options$from2 === void 0 ? void 0 : _options$from2.address) !== null && _options$from$address !== void 0 ? _options$from$address : (_options$account = options.account) === null || _options$account === void 0 ? void 0 : _options$account.address;\n  const txWithFrom = _objectSpread(_objectSpread({}, options.transaction), {}, {\n    from: fromAddress\n  });\n  if (cache.has(txWithFrom)) {\n    // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set\n    return cache.get(txWithFrom);\n  }\n  const {\n    account\n  } = options;\n  const promise = (async () => {\n    const predefinedGas = await resolvePromisedValue(options.transaction.gas);\n    // if we have a predefined gas value in the TX -> always use that\n    if (predefinedGas !== undefined) {\n      return predefinedGas;\n    }\n    // if the wallet itself overrides the estimateGas function, use that\n    if (account !== null && account !== void 0 && account.estimateGas) {\n      try {\n        var _options$transaction$;\n        let gas = await account.estimateGas(options.transaction);\n        if ((_options$transaction$ = options.transaction.chain.experimental) !== null && _options$transaction$ !== void 0 && _options$transaction$.increaseZeroByteCount) {\n          gas = roundUpGas(gas);\n        }\n        return gas;\n      } catch (error) {\n        throw await extractError({\n          contract: options.transaction.__contract,\n          error,\n          fromAddress\n        });\n      }\n    }\n    // load up encode function if we need it\n    const {\n      encode\n    } = await import(\"./encode.js\");\n    const [encodedData, toAddress, value, authorizationList] = await Promise.all([encode(options.transaction), resolvePromisedValue(options.transaction.to), resolvePromisedValue(options.transaction.value), resolvePromisedValue(options.transaction.authorizationList)]);\n    // load up the rpc client and the estimateGas function if we need it\n    const [{\n      getRpcClient\n    }, {\n      eth_estimateGas\n    }] = await Promise.all([import(\"../../rpc/rpc.js\"), import(\"../../rpc/actions/eth_estimateGas.js\")]);\n    const rpcRequest = getRpcClient(options.transaction);\n    try {\n      var _options$transaction$2;\n      const formattedTx = formatTransactionRequest({\n        authorizationList: authorizationList === null || authorizationList === void 0 ? void 0 : authorizationList.map(auth => _objectSpread(_objectSpread({}, auth), {}, {\n          address: getAddress(auth.address),\n          nonce: Number(auth.nonce),\n          r: ox__Hex.fromNumber(auth.r),\n          s: ox__Hex.fromNumber(auth.s)\n        })),\n        data: encodedData,\n        from: fromAddress ? getAddress(fromAddress) : undefined,\n        to: toAddress ? getAddress(toAddress) : undefined,\n        value\n      });\n      let gas = await eth_estimateGas(rpcRequest, formattedTx);\n      if ((_options$transaction$2 = options.transaction.chain.experimental) !== null && _options$transaction$2 !== void 0 && _options$transaction$2.increaseZeroByteCount) {\n        gas = roundUpGas(gas);\n      }\n      return gas;\n    } catch (error) {\n      throw await extractError({\n        contract: options.transaction.__contract,\n        error,\n        fromAddress\n      });\n    }\n  })();\n  cache.set(txWithFrom, promise);\n  return promise;\n}","map":{"version":3,"names":["ox__Hex","formatTransactionRequest","roundUpGas","getAddress","resolvePromisedValue","extractError","cache","WeakMap","estimateGas","options","_options$from","_options$from$address","_options$from2","_options$account","fromAddress","from","undefined","address","account","txWithFrom","_objectSpread","transaction","has","get","promise","predefinedGas","gas","_options$transaction$","chain","experimental","increaseZeroByteCount","error","contract","__contract","encode","encodedData","toAddress","value","authorizationList","Promise","all","to","getRpcClient","eth_estimateGas","rpcRequest","_options$transaction$2","formattedTx","map","auth","nonce","Number","r","fromNumber","s","data","set"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/transaction/actions/estimate-gas.ts"],"sourcesContent":["import * as ox__Hex from \"ox/Hex\";\nimport { formatTransactionRequest } from \"viem\";\nimport { roundUpGas } from \"../../gas/op-gas-fee-reducer.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport type { Prettify } from \"../../utils/type-utils.js\";\nimport type { Account } from \"../../wallets/interfaces/wallet.js\";\nimport { extractError } from \"../extract-error.js\";\nimport type { PreparedTransaction } from \"../prepare-transaction.js\";\n\nexport type EstimateGasOptions = Prettify<\n  {\n    /**\n     * The prepared transaction to estimate the gas for.\n     */\n    // TODO: update this to `Transaction<\"prepared\">` once the type is available to ensure only prepared transactions are accepted\n    // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any prepared transaction type\n    transaction: PreparedTransaction<any>;\n  } & (\n    | {\n        /**\n         * The account the transaction would be sent from.\n         *\n         * @deprecated Use `from` instead\n         */\n        account: Account;\n        from?: never;\n      }\n    | {\n        account?: never;\n        /**\n         * The address the transaction would be sent from.\n         */\n        from?: string | Account;\n      }\n  )\n>;\n\nexport type EstimateGasResult = bigint;\n\nconst cache = new WeakMap<\n  PreparedTransaction & { from: string | undefined },\n  Promise<EstimateGasResult>\n>();\n\n/**\n * Estimates the gas required to execute a transaction. The gas is returned as a `bigint` and in gwei units.\n * @param options - The options for estimating gas.\n * @returns A promise that resolves to the estimated gas as a bigint.\n * @transaction\n * @example\n * ```ts\n * import { estimateGas } from \"thirdweb\";\n * const gas = await estimateGas({\n *  transaction,\n *  from: \"0x...\",\n * });\n * ```\n */\nexport async function estimateGas(\n  options: EstimateGasOptions,\n): Promise<EstimateGasResult> {\n  // from is:\n  // 1. the user specified from address\n  // 2. the passed in account address\n  // 3. the passed in wallet's account address\n  const fromAddress =\n    typeof options.from === \"string\"\n      ? (options.from ?? undefined)\n      : (options.from?.address ?? options.account?.address);\n  const txWithFrom = { ...options.transaction, from: fromAddress };\n  if (cache.has(txWithFrom)) {\n    // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set\n    return cache.get(txWithFrom)!;\n  }\n  const { account } = options;\n  const promise = (async () => {\n    const predefinedGas = await resolvePromisedValue(options.transaction.gas);\n    // if we have a predefined gas value in the TX -> always use that\n    if (predefinedGas !== undefined) {\n      return predefinedGas;\n    }\n\n    // if the wallet itself overrides the estimateGas function, use that\n    if (account?.estimateGas) {\n      try {\n        let gas = await account.estimateGas(options.transaction);\n        if (options.transaction.chain.experimental?.increaseZeroByteCount) {\n          gas = roundUpGas(gas);\n        }\n        return gas;\n      } catch (error) {\n        throw await extractError({\n          contract: options.transaction.__contract,\n          error,\n          fromAddress,\n        });\n      }\n    }\n\n    // load up encode function if we need it\n    const { encode } = await import(\"./encode.js\");\n    const [encodedData, toAddress, value, authorizationList] =\n      await Promise.all([\n        encode(options.transaction),\n        resolvePromisedValue(options.transaction.to),\n        resolvePromisedValue(options.transaction.value),\n        resolvePromisedValue(options.transaction.authorizationList),\n      ]);\n\n    // load up the rpc client and the estimateGas function if we need it\n    const [{ getRpcClient }, { eth_estimateGas }] = await Promise.all([\n      import(\"../../rpc/rpc.js\"),\n      import(\"../../rpc/actions/eth_estimateGas.js\"),\n    ]);\n\n    const rpcRequest = getRpcClient(options.transaction);\n    try {\n      const formattedTx = formatTransactionRequest({\n        authorizationList: authorizationList?.map((auth) => ({\n          ...auth,\n          address: getAddress(auth.address),\n          nonce: Number(auth.nonce),\n          r: ox__Hex.fromNumber(auth.r),\n          s: ox__Hex.fromNumber(auth.s),\n        })),\n        data: encodedData,\n        from: fromAddress ? getAddress(fromAddress) : undefined,\n        to: toAddress ? getAddress(toAddress) : undefined,\n        value,\n      });\n      let gas = await eth_estimateGas(rpcRequest, formattedTx);\n\n      if (options.transaction.chain.experimental?.increaseZeroByteCount) {\n        gas = roundUpGas(gas);\n      }\n      return gas;\n    } catch (error) {\n      throw await extractError({\n        contract: options.transaction.__contract,\n        error,\n        fromAddress,\n      });\n    }\n  })();\n  cache.set(txWithFrom, promise);\n  return promise;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}