{"ast":null,"code":"import { eth_getTransactionReceipt } from \"../../rpc/actions/eth_getTransactionReceipt.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { watchBlockNumber } from \"../../rpc/watchBlockNumber.js\";\nconst DEFAULT_MAX_BLOCKS_WAIT_TIME = 100;\nconst map = new Map();\n/**\n * Waits for the transaction receipt of a given transaction hash on a specific contract.\n * @param options - The options for waiting for the receipt.\n * By default, it's 100 blocks.\n * @returns A promise that resolves with the transaction receipt.\n * @transaction\n * @example\n * ```ts\n * import { waitForReceipt } from \"thirdweb\";\n * const receipt = await waitForReceipt({\n *   client,\n *   chain,\n *   transactionHash: \"0x123...\",\n * });\n * ```\n */\nexport function waitForReceipt(options) {\n  var _options$maxBlocksWai;\n  const {\n    transactionHash,\n    chain,\n    client\n  } = options;\n  const chainId = chain.id;\n  const key = \"\".concat(chainId, \":tx_\").concat(transactionHash);\n  const maxBlocksWaitTime = (_options$maxBlocksWai = options.maxBlocksWaitTime) !== null && _options$maxBlocksWai !== void 0 ? _options$maxBlocksWai : DEFAULT_MAX_BLOCKS_WAIT_TIME;\n  if (map.has(key)) {\n    // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set\n    return map.get(key);\n  }\n  const promise = new Promise((resolve, reject) => {\n    if (!transactionHash) {\n      reject(new Error(\"Transaction has no transactionHash to wait for, did you execute it?\"));\n    }\n    const request = getRpcClient({\n      chain,\n      client\n    });\n    // start at -1 because the first block doesn't count\n    let blocksWaited = -1;\n    const unwatch = watchBlockNumber({\n      chain: chain,\n      client: client,\n      onNewBlockNumber: async () => {\n        blocksWaited++;\n        if (blocksWaited >= maxBlocksWaitTime) {\n          unwatch();\n          reject(new Error(\"Transaction receipt for \".concat(transactionHash, \" not found after \").concat(maxBlocksWaitTime, \" blocks\")));\n          return;\n        }\n        try {\n          const receipt = await eth_getTransactionReceipt(request, {\n            hash: transactionHash\n          });\n          // stop the polling\n          unwatch();\n          // resolve the top level promise with the receipt\n          resolve(receipt);\n        } catch (_unused) {\n          // noop, we'll try again on the next blocks\n        }\n      }\n    });\n    // remove the promise from the map when it's done (one way or the other)\n  }).finally(() => {\n    map.delete(key);\n  });\n  map.set(key, promise);\n  return promise;\n}","map":{"version":3,"names":["eth_getTransactionReceipt","getRpcClient","watchBlockNumber","DEFAULT_MAX_BLOCKS_WAIT_TIME","map","Map","waitForReceipt","options","_options$maxBlocksWai","transactionHash","chain","client","chainId","id","key","concat","maxBlocksWaitTime","has","get","promise","Promise","resolve","reject","Error","request","blocksWaited","unwatch","onNewBlockNumber","receipt","hash","_unused","finally","delete","set"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/transaction/actions/wait-for-tx-receipt.ts"],"sourcesContent":["import type { Hex } from \"viem\";\nimport type { Chain } from \"../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { eth_getTransactionReceipt } from \"../../rpc/actions/eth_getTransactionReceipt.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { watchBlockNumber } from \"../../rpc/watchBlockNumber.js\";\nimport type { Prettify } from \"../../utils/type-utils.js\";\nimport type { SendTransactionResult, TransactionReceipt } from \"../types.js\";\n\nconst DEFAULT_MAX_BLOCKS_WAIT_TIME = 100;\n\nconst map = new Map<string, Promise<TransactionReceipt>>();\n\nexport type WaitForReceiptOptions = Prettify<\n  SendTransactionResult & {\n    client: ThirdwebClient;\n    chain: Chain;\n    maxBlocksWaitTime?: number;\n  }\n>;\n\n/**\n * Waits for the transaction receipt of a given transaction hash on a specific contract.\n * @param options - The options for waiting for the receipt.\n * By default, it's 100 blocks.\n * @returns A promise that resolves with the transaction receipt.\n * @transaction\n * @example\n * ```ts\n * import { waitForReceipt } from \"thirdweb\";\n * const receipt = await waitForReceipt({\n *   client,\n *   chain,\n *   transactionHash: \"0x123...\",\n * });\n * ```\n */\nexport function waitForReceipt(\n  options: WaitForReceiptOptions,\n): Promise<TransactionReceipt> {\n  const { transactionHash, chain, client } = options;\n\n  const chainId = chain.id;\n  const key = `${chainId}:tx_${transactionHash}`;\n  const maxBlocksWaitTime =\n    options.maxBlocksWaitTime ?? DEFAULT_MAX_BLOCKS_WAIT_TIME;\n\n  if (map.has(key)) {\n    // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set\n    return map.get(key)!;\n  }\n  const promise = new Promise<TransactionReceipt>((resolve, reject) => {\n    if (!transactionHash) {\n      reject(\n        new Error(\n          \"Transaction has no transactionHash to wait for, did you execute it?\",\n        ),\n      );\n    }\n\n    const request = getRpcClient({ chain, client });\n\n    // start at -1 because the first block doesn't count\n    let blocksWaited = -1;\n\n    const unwatch = watchBlockNumber({\n      chain: chain,\n      client: client,\n      onNewBlockNumber: async () => {\n        blocksWaited++;\n        if (blocksWaited >= maxBlocksWaitTime) {\n          unwatch();\n          reject(\n            new Error(\n              `Transaction receipt for ${transactionHash} not found after ${maxBlocksWaitTime} blocks`,\n            ),\n          );\n          return;\n        }\n        try {\n          const receipt = await eth_getTransactionReceipt(request, {\n            hash: transactionHash as Hex,\n          });\n\n          // stop the polling\n          unwatch();\n          // resolve the top level promise with the receipt\n          resolve(receipt);\n        } catch {\n          // noop, we'll try again on the next blocks\n        }\n      },\n    });\n    // remove the promise from the map when it's done (one way or the other)\n  }).finally(() => {\n    map.delete(key);\n  });\n\n  map.set(key, promise);\n  return promise;\n}\n"],"mappings":"AAGA,SAASA,yBAAyB,QAAQ,gDAAgD;AAC1F,SAASC,YAAY,QAAQ,kBAAkB;AAC/C,SAASC,gBAAgB,QAAQ,+BAA+B;AAIhE,MAAMC,4BAA4B,GAAG,GAAG;AAExC,MAAMC,GAAG,GAAG,IAAIC,GAAG,EAAuC;AAU1D;;;;;;;;;;;;;;;;AAgBA,OAAM,SAAUC,cAAcA,CAC5BC,OAA8B;EAAA,IAAAC,qBAAA;EAE9B,MAAM;IAAEC,eAAe;IAAEC,KAAK;IAAEC;EAAM,CAAE,GAAGJ,OAAO;EAElD,MAAMK,OAAO,GAAGF,KAAK,CAACG,EAAE;EACxB,MAAMC,GAAG,MAAAC,MAAA,CAAMH,OAAO,UAAAG,MAAA,CAAON,eAAe,CAAE;EAC9C,MAAMO,iBAAiB,IAAAR,qBAAA,GACrBD,OAAO,CAACS,iBAAiB,cAAAR,qBAAA,cAAAA,qBAAA,GAAIL,4BAA4B;EAE3D,IAAIC,GAAG,CAACa,GAAG,CAACH,GAAG,CAAC,EAAE;IAChB;IACA,OAAOV,GAAG,CAACc,GAAG,CAACJ,GAAG,CAAE;EACtB;EACA,MAAMK,OAAO,GAAG,IAAIC,OAAO,CAAqB,CAACC,OAAO,EAAEC,MAAM,KAAI;IAClE,IAAI,CAACb,eAAe,EAAE;MACpBa,MAAM,CACJ,IAAIC,KAAK,CACP,qEAAqE,CACtE,CACF;IACH;IAEA,MAAMC,OAAO,GAAGvB,YAAY,CAAC;MAAES,KAAK;MAAEC;IAAM,CAAE,CAAC;IAE/C;IACA,IAAIc,YAAY,GAAG,CAAC,CAAC;IAErB,MAAMC,OAAO,GAAGxB,gBAAgB,CAAC;MAC/BQ,KAAK,EAAEA,KAAK;MACZC,MAAM,EAAEA,MAAM;MACdgB,gBAAgB,EAAE,MAAAA,CAAA,KAAW;QAC3BF,YAAY,EAAE;QACd,IAAIA,YAAY,IAAIT,iBAAiB,EAAE;UACrCU,OAAO,EAAE;UACTJ,MAAM,CACJ,IAAIC,KAAK,4BAAAR,MAAA,CACoBN,eAAe,uBAAAM,MAAA,CAAoBC,iBAAiB,YAAS,CACzF,CACF;UACD;QACF;QACA,IAAI;UACF,MAAMY,OAAO,GAAG,MAAM5B,yBAAyB,CAACwB,OAAO,EAAE;YACvDK,IAAI,EAAEpB;WACP,CAAC;UAEF;UACAiB,OAAO,EAAE;UACT;UACAL,OAAO,CAACO,OAAO,CAAC;QAClB,CAAC,CAAC,OAAAE,OAAA,EAAM;UACN;QAAA;MAEJ;KACD,CAAC;IACF;EACF,CAAC,CAAC,CAACC,OAAO,CAAC,MAAK;IACd3B,GAAG,CAAC4B,MAAM,CAAClB,GAAG,CAAC;EACjB,CAAC,CAAC;EAEFV,GAAG,CAAC6B,GAAG,CAACnB,GAAG,EAAEK,OAAO,CAAC;EACrB,OAAOA,OAAO;AAChB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}