{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { detectPlatform } from \"../utils/detect-platform.js\";\nimport { stringify } from \"../utils/json.js\";\nimport { buildFormData, extractObjectFiles, isFileOrUint8Array, replaceObjectFilesWithUris, replaceObjectGatewayUrlsWithSchemes } from \"./upload/helpers.js\";\n/**\n * Uploads files based on the provided options.\n * @param options - The upload options.\n * @returns A promise that resolves to the uploaded file URI or URIs (when passing multiple files).\n * @throws An error if the upload fails.\n * @example\n *\n * ### Uploading JSON objects\n *\n * ```ts\n * import { upload } from \"thirdweb/storage\";\n * const uri = await upload({\n *  client,\n *  files: [\n *    {\n *      name: \"something\",\n *      data: {\n *        hello: \"world\",\n *      },\n *    },\n *  ],\n * });\n * ```\n *\n * ### Uploading files\n *\n * ```ts\n * import { upload } from \"thirdweb/storage\";\n * const uri = await upload({\n *  client,\n *  files: [\n *    new File([\"hello world\"], \"hello.txt\"),\n *  ],\n * });\n * ```\n * @storage\n */\nexport async function upload(options) {\n  // deal with the different file types\n  // if there are no files, return an empty array immediately\n  if (options.files.length === 0) {\n    return null;\n  }\n  // handle file arrays\n  const isFileArray = options.files.map(item => isFileOrUint8Array(item) || typeof item === \"string\").every(item => !!item);\n  let uris;\n  if (isFileArray) {\n    // if we already have an array of files, we can just pass it through\n    uris = options.files;\n  } else {\n    // otherwise we have to process them first\n    let cleaned = options.files;\n    // Replace any gateway URLs with their hashes\n    cleaned = replaceObjectGatewayUrlsWithSchemes(cleaned);\n    // Recurse through data and extract files to upload\n    const files = extractObjectFiles(cleaned);\n    if (files.length) {\n      // Upload all files that came from the object\n      const uris_ = await upload(_objectSpread(_objectSpread({}, options), {}, {\n        files\n      }));\n      // Recurse through data and replace files with hashes\n      cleaned = replaceObjectFilesWithUris(cleaned,\n      // always pass an array even if the underlying upload returns a single uri\n      Array.isArray(uris_) ? uris_ : [uris_]);\n    }\n    uris = cleaned.map(item => {\n      if (typeof item === \"string\") {\n        return item;\n      }\n      return stringify(item);\n    });\n  }\n  // end deal with the different file types\n  const form_ = new FormData();\n  const {\n    fileNames,\n    form\n  } = buildFormData(form_, uris, options);\n  const platform = detectPlatform();\n  if (platform === \"browser\" || platform === \"node\") {\n    const {\n      uploadBatch\n    } = await import(\"./upload/web-node.js\");\n    const uris = await uploadBatch(options.client, form, fileNames, options);\n    // if we only passed a single file, return its URI directly\n    if (options.files.length === 1) {\n      return uris[0];\n    }\n    return uris;\n  }\n  throw new Error(\"Please, use the uploadMobile function in mobile environments.\");\n}","map":{"version":3,"names":["detectPlatform","stringify","buildFormData","extractObjectFiles","isFileOrUint8Array","replaceObjectFilesWithUris","replaceObjectGatewayUrlsWithSchemes","upload","options","files","length","isFileArray","map","item","every","uris","cleaned","uris_","_objectSpread","Array","isArray","form_","FormData","fileNames","form","platform","uploadBatch","client","Error"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/storage/upload.ts"],"sourcesContent":["import type { ThirdwebClient } from \"../client/client.js\";\nimport { detectPlatform } from \"../utils/detect-platform.js\";\nimport { stringify } from \"../utils/json.js\";\nimport {\n  buildFormData,\n  extractObjectFiles,\n  isFileOrUint8Array,\n  replaceObjectFilesWithUris,\n  replaceObjectGatewayUrlsWithSchemes,\n} from \"./upload/helpers.js\";\nimport type {\n  FileOrBufferOrString,\n  UploadOptions as InternalUploadOptions,\n  UploadableFile,\n} from \"./upload/types.js\";\n\nexport type UploadOptions<TFiles extends UploadableFile[]> =\n  InternalUploadOptions<TFiles> & {\n    client: ThirdwebClient;\n  };\n\ntype UploadReturnType<TFiles extends UploadableFile[]> = TFiles extends {\n  length: 0;\n}\n  ? null\n  : TFiles extends { length: 1 }\n    ? string\n    : string[];\n\n/**\n * Uploads files based on the provided options.\n * @param options - The upload options.\n * @returns A promise that resolves to the uploaded file URI or URIs (when passing multiple files).\n * @throws An error if the upload fails.\n * @example\n *\n * ### Uploading JSON objects\n *\n * ```ts\n * import { upload } from \"thirdweb/storage\";\n * const uri = await upload({\n *  client,\n *  files: [\n *    {\n *      name: \"something\",\n *      data: {\n *        hello: \"world\",\n *      },\n *    },\n *  ],\n * });\n * ```\n *\n * ### Uploading files\n *\n * ```ts\n * import { upload } from \"thirdweb/storage\";\n * const uri = await upload({\n *  client,\n *  files: [\n *    new File([\"hello world\"], \"hello.txt\"),\n *  ],\n * });\n * ```\n * @storage\n */\nexport async function upload<const TFiles extends UploadableFile[]>(\n  options: UploadOptions<TFiles>,\n): Promise<UploadReturnType<TFiles>> {\n  // deal with the different file types\n\n  // if there are no files, return an empty array immediately\n  if (options.files.length === 0) {\n    return null as UploadReturnType<TFiles>;\n  }\n  // handle file arrays\n  const isFileArray = options.files\n    .map((item) => isFileOrUint8Array(item) || typeof item === \"string\")\n    .every((item) => !!item);\n\n  let uris: FileOrBufferOrString[];\n\n  if (isFileArray) {\n    // if we already have an array of files, we can just pass it through\n    uris = options.files as FileOrBufferOrString[];\n  } else {\n    // otherwise we have to process them first\n    let cleaned = options.files as unknown[];\n\n    // Replace any gateway URLs with their hashes\n    cleaned = replaceObjectGatewayUrlsWithSchemes(cleaned);\n\n    // Recurse through data and extract files to upload\n    const files = extractObjectFiles(cleaned);\n    if (files.length) {\n      // Upload all files that came from the object\n      const uris_ = await upload({ ...options, files });\n\n      // Recurse through data and replace files with hashes\n      cleaned = replaceObjectFilesWithUris(\n        cleaned,\n        // always pass an array even if the underlying upload returns a single uri\n        Array.isArray(uris_) ? uris_ : [uris_],\n      ) as unknown[];\n    }\n\n    uris = cleaned.map((item) => {\n      if (typeof item === \"string\") {\n        return item;\n      }\n      return stringify(item);\n    });\n  }\n\n  // end deal with the different file types\n  const form_ = new FormData();\n\n  const { fileNames, form } = buildFormData(form_, uris, options);\n\n  const platform = detectPlatform();\n  if (platform === \"browser\" || platform === \"node\") {\n    const { uploadBatch } = await import(\"./upload/web-node.js\");\n    const uris = await uploadBatch(options.client, form, fileNames, options);\n    // if we only passed a single file, return its URI directly\n    if (options.files.length === 1) {\n      return uris[0] as UploadReturnType<TFiles>;\n    }\n    return uris as UploadReturnType<TFiles>;\n  }\n  throw new Error(\n    \"Please, use the uploadMobile function in mobile environments.\",\n  );\n}\n"],"mappings":";AACA,SAASA,cAAc,QAAQ,6BAA6B;AAC5D,SAASC,SAAS,QAAQ,kBAAkB;AAC5C,SACEC,aAAa,EACbC,kBAAkB,EAClBC,kBAAkB,EAClBC,0BAA0B,EAC1BC,mCAAmC,QAC9B,qBAAqB;AAoB5B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCA,OAAO,eAAeC,MAAMA,CAC1BC,OAA8B;EAE9B;EAEA;EACA,IAAIA,OAAO,CAACC,KAAK,CAACC,MAAM,KAAK,CAAC,EAAE;IAC9B,OAAO,IAAgC;EACzC;EACA;EACA,MAAMC,WAAW,GAAGH,OAAO,CAACC,KAAK,CAC9BG,GAAG,CAAEC,IAAI,IAAKT,kBAAkB,CAACS,IAAI,CAAC,IAAI,OAAOA,IAAI,KAAK,QAAQ,CAAC,CACnEC,KAAK,CAAED,IAAI,IAAK,CAAC,CAACA,IAAI,CAAC;EAE1B,IAAIE,IAA4B;EAEhC,IAAIJ,WAAW,EAAE;IACf;IACAI,IAAI,GAAGP,OAAO,CAACC,KAA+B;EAChD,CAAC,MAAM;IACL;IACA,IAAIO,OAAO,GAAGR,OAAO,CAACC,KAAkB;IAExC;IACAO,OAAO,GAAGV,mCAAmC,CAACU,OAAO,CAAC;IAEtD;IACA,MAAMP,KAAK,GAAGN,kBAAkB,CAACa,OAAO,CAAC;IACzC,IAAIP,KAAK,CAACC,MAAM,EAAE;MAChB;MACA,MAAMO,KAAK,GAAG,MAAMV,MAAM,CAAAW,aAAA,CAAAA,aAAA,KAAMV,OAAO;QAAEC;MAAK,EAAE,CAAC;MAEjD;MACAO,OAAO,GAAGX,0BAA0B,CAClCW,OAAO;MACP;MACAG,KAAK,CAACC,OAAO,CAACH,KAAK,CAAC,GAAGA,KAAK,GAAG,CAACA,KAAK,CAAC,CAC1B;IAChB;IAEAF,IAAI,GAAGC,OAAO,CAACJ,GAAG,CAAEC,IAAI,IAAI;MAC1B,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;QAC5B,OAAOA,IAAI;MACb;MACA,OAAOZ,SAAS,CAACY,IAAI,CAAC;IACxB,CAAC,CAAC;EACJ;EAEA;EACA,MAAMQ,KAAK,GAAG,IAAIC,QAAQ,EAAE;EAE5B,MAAM;IAAEC,SAAS;IAAEC;EAAI,CAAE,GAAGtB,aAAa,CAACmB,KAAK,EAAEN,IAAI,EAAEP,OAAO,CAAC;EAE/D,MAAMiB,QAAQ,GAAGzB,cAAc,EAAE;EACjC,IAAIyB,QAAQ,KAAK,SAAS,IAAIA,QAAQ,KAAK,MAAM,EAAE;IACjD,MAAM;MAAEC;IAAW,CAAE,GAAG,MAAM,MAAM,CAAC,sBAAsB,CAAC;IAC5D,MAAMX,IAAI,GAAG,MAAMW,WAAW,CAAClB,OAAO,CAACmB,MAAM,EAAEH,IAAI,EAAED,SAAS,EAAEf,OAAO,CAAC;IACxE;IACA,IAAIA,OAAO,CAACC,KAAK,CAACC,MAAM,KAAK,CAAC,EAAE;MAC9B,OAAOK,IAAI,CAAC,CAAC,CAA6B;IAC5C;IACA,OAAOA,IAAgC;EACzC;EACA,MAAM,IAAIa,KAAK,CACb,+DAA+D,CAChE;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}