{"ast":null,"code":"import { prepare as prepareOnramp } from \"../../bridge/Onramp.js\";\nimport { getCachedChain } from \"../../chains/utils.js\";\nimport { NATIVE_TOKEN_ADDRESS } from \"../../constants/addresses.js\";\nimport { getContract } from \"../../contract/contract.js\";\nimport { decimals } from \"../../extensions/erc20/read/decimals.js\";\nimport { toTokens, toUnits } from \"../../utils/units.js\";\n/**\n * Get a quote of type [`BuyWithFiatQuote`](https://portal.thirdweb.com/references/typescript/v5/BuyWithFiatQuote) to buy given token with fiat currency.\n * This quote contains the information about the swap such as token amounts, processing fees, estimated time etc.\n *\n * ### Rendering the On-Ramp provider UI\n * Once you have the `quote`, you can open the `quote.onRampLink` in a new tab - This will prompt the user to buy the token with fiat currency\n *\n * ### Determining the steps required\n * If `quote.onRampToken.token` is same as `quote.toToken` ( same chain + same token address ) - This means that the token can be directly bought from the on-ramp provider.\n * But if they are different, On-ramp provider will send the `quote.onRampToken` to the user's wallet address and a swap is required to swap it to the desired token onchain.\n *\n * You can use the [`isSwapRequiredPostOnramp`](https://portal.thirdweb.com/references/typescript/v5/isSwapRequiredPostOnramp) utility function to check if a swap is required after the on-ramp is done.\n *\n * ### Polling for the status\n * Once you open the `quote.onRampLink` in a new tab, you can start polling for the status using [`getBuyWithFiatStatus`](https://portal.thirdweb.com/references/typescript/v5/getBuyWithFiatStatus) to get the status of the transaction.\n *\n * `getBuyWithFiatStatus` returns a status object of type [`BuyWithFiatStatus`](https://portal.thirdweb.com/references/typescript/v5/BuyWithFiatStatus).\n *\n * - If no swap is required - the status will become `\"ON_RAMP_TRANSFER_COMPLETED\"` once the on-ramp provider has sent the desired token to the user's wallet address. Once you receive this status, the process is complete.\n * - If a swap is required - the status will become `\"CRYPTO_SWAP_REQUIRED\"` once the on-ramp provider has sent the tokens to the user's wallet address. Once you receive this status, you need to start the swap process.\n *\n * ### Swap Process\n * On receiving the `\"CRYPTO_SWAP_REQUIRED\"` status, you can use the [`getPostOnRampQuote`](https://portal.thirdweb.com/references/typescript/v5/getPostOnRampQuote) function to get the quote for the swap of type [`BuyWithCryptoQuote`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoQuote).\n *\n * Once you have this quote - You can follow the same steps as mentioned in the [`getBuyWithCryptoQuote`](https://portal.thirdweb.com/references/typescript/v5/getBuyWithCryptoQuote) documentation to perform the swap.\n *\n * @param params - object of type [`GetBuyWithFiatQuoteParams`](https://portal.thirdweb.com/references/typescript/v5/GetBuyWithFiatQuoteParams)\n * @returns Object of type [`BuyWithFiatQuote`](https://portal.thirdweb.com/references/typescript/v5/BuyWithFiatQuote) which contains the information about the quote such as processing fees, estimated time, converted token amounts, etc.\n * @example\n * Get a quote for buying 10 USDC on polygon chain (chainId: 137) with USD fiat currency:\n *\n * ```ts\n * import { getBuyWithFiatQuote } from \"thirdweb/pay\";\n *\n * const quote = await getBuyWithFiatQuote({\n *  client: client, // thirdweb client\n *  fromCurrencySymbol: \"USD\", // fiat currency symbol\n *  toChainId: 137, // polygon chain id\n *  toAmount: \"10\", // amount of USDC to buy\n *  toTokenAddress: \"0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359\" // USDC token address in polygon chain\n *  toAddress: \"0x...\", // user's wallet address\n *  isTestMode: false, // whether to use onramp in test mode for testing purpose (defaults to false)\n * });\n *\n * window.open(quote.onRampLink, \"_blank\");\n * ```\n * @deprecated\n * @buyCrypto\n */\nexport async function getBuyWithFiatQuote(params) {\n  try {\n    var _params$maxSlippageBP, _params$preferredProv;\n    // map preferred provider (FiatProvider) → onramp string expected by Onramp.prepare\n    const mapProviderToOnramp = provider => {\n      switch (provider) {\n        case \"stripe\":\n          return \"stripe\";\n        case \"transak\":\n          return \"transak\";\n        default:\n          // default to coinbase when undefined or any other value\n          return \"coinbase\";\n      }\n    };\n    // Choose provider or default to STRIPE\n    const onrampProvider = mapProviderToOnramp(params.preferredProvider);\n    const d = params.toTokenAddress !== NATIVE_TOKEN_ADDRESS ? await decimals({\n      contract: getContract({\n        address: params.toTokenAddress,\n        chain: getCachedChain(params.toChainId),\n        client: params.client\n      })\n    }) : 18;\n    // Prepare amount in wei if provided\n    const amountWei = params.toAmount ? toUnits(params.toAmount, d) : undefined;\n    // Call new Onramp.prepare to get the quote & link\n    const prepared = await prepareOnramp({\n      amount: amountWei,\n      chainId: params.toChainId,\n      client: params.client,\n      currency: params.fromCurrencySymbol,\n      maxSteps: 2,\n      onramp: onrampProvider,\n      onrampChainId: params.onrampChainId,\n      onrampTokenAddress: params.onrampTokenAddress,\n      paymentLinkId: params.paymentLinkId,\n      purchaseData: params.purchaseData,\n      receiver: params.toAddress,\n      // force onramp to native token to avoid missing gas issues\n      sender: params.fromAddress,\n      tokenAddress: params.toTokenAddress\n    });\n    // Determine tokens based on steps rules\n    const hasSteps = prepared.steps.length > 0;\n    const firstStep = hasSteps ? prepared.steps[0] : undefined;\n    // Estimated duration in seconds – sum of all step durations\n    const estimatedDurationSeconds = Math.max(120, Math.ceil(prepared.steps.reduce((acc, s) => acc + s.estimatedExecutionTimeMs, 0) / 1000));\n    const estimatedToAmountMinWeiBigInt = prepared.destinationAmount;\n    const maxSlippageBPS = (_params$maxSlippageBP = params.maxSlippageBPS) !== null && _params$maxSlippageBP !== void 0 ? _params$maxSlippageBP : 0;\n    const slippageWei = estimatedToAmountMinWeiBigInt * BigInt(maxSlippageBPS) / 10000n;\n    const toAmountMinWeiBigInt = estimatedToAmountMinWeiBigInt - slippageWei;\n    const estimatedToAmountMin = toTokens(estimatedToAmountMinWeiBigInt, d);\n    const toAmountMin = toTokens(toAmountMinWeiBigInt, d);\n    // Helper to convert a Token → PayTokenInfo\n    const tokenToPayTokenInfo = token => ({\n      chainId: token.chainId,\n      decimals: token.decimals,\n      name: token.name,\n      priceUSDCents: Math.round((token.prices.USD || 0) * 100),\n      symbol: token.symbol,\n      tokenAddress: token.address\n    });\n    // Determine the raw token objects using new simplified rules\n    // 1. toToken is always the destination token\n    const toTokenRaw = prepared.destinationToken;\n    // 2. onRampToken: if exactly one step -> originToken of that step, else toTokenRaw\n    const onRampTokenRaw = prepared.steps.length > 0 && firstStep ? firstStep.originToken : toTokenRaw;\n    // 3. routingToken: if exactly two steps -> originToken of second step, else undefined\n    const routingTokenRaw = prepared.steps.length > 1 ? prepared.steps[1].originToken : undefined;\n    // Amounts for onRampToken/raw\n    const onRampTokenAmountWei = prepared.steps.length > 0 && firstStep ? firstStep.originAmount : prepared.destinationAmount;\n    const onRampTokenAmount = toTokens(onRampTokenAmountWei, onRampTokenRaw.decimals);\n    // Build info objects\n    const onRampTokenObject = {\n      amount: onRampTokenAmount,\n      amountUSDCents: Math.round(Number(onRampTokenAmount) * (onRampTokenRaw.prices.USD || 0) * 100),\n      amountWei: onRampTokenAmountWei.toString(),\n      token: tokenToPayTokenInfo(onRampTokenRaw)\n    };\n    let routingTokenObject;\n    if (routingTokenRaw) {\n      const routingAmountWei = prepared.steps[1].originAmount;\n      const routingAmount = toTokens(routingAmountWei, routingTokenRaw.decimals);\n      routingTokenObject = {\n        amount: routingAmount,\n        amountUSDCents: Math.round(Number(routingAmount) * (routingTokenRaw.prices.USD || 0) * 100),\n        amountWei: routingAmountWei.toString(),\n        token: tokenToPayTokenInfo(routingTokenRaw)\n      };\n    }\n    const buyWithFiatQuote = {\n      estimatedDurationSeconds,\n      estimatedToAmountMin: estimatedToAmountMin,\n      estimatedToAmountMinWei: estimatedToAmountMinWeiBigInt.toString(),\n      fromAddress: params.fromAddress,\n      fromCurrency: {\n        amount: prepared.currencyAmount.toString(),\n        amountUnits: Number(prepared.currencyAmount).toFixed(2),\n        currencySymbol: prepared.currency,\n        decimals: 2\n      },\n      fromCurrencyWithFees: {\n        amount: prepared.currencyAmount.toString(),\n        amountUnits: Number(prepared.currencyAmount).toFixed(2),\n        currencySymbol: prepared.currency,\n        decimals: 2\n      },\n      intentId: prepared.id,\n      maxSlippageBPS: maxSlippageBPS,\n      onRampLink: prepared.link,\n      onRampToken: onRampTokenObject,\n      processingFees: [],\n      provider: (_params$preferredProv = params.preferredProvider) !== null && _params$preferredProv !== void 0 ? _params$preferredProv : \"COINBASE\",\n      routingToken: routingTokenObject,\n      toAddress: params.toAddress,\n      toAmountMin: toAmountMin,\n      toAmountMinWei: toAmountMinWeiBigInt.toString(),\n      toToken: tokenToPayTokenInfo(toTokenRaw)\n    };\n    return buyWithFiatQuote;\n  } catch (error) {\n    console.error(\"Error getting buy with fiat quote\", error);\n    throw error;\n  }\n}","map":{"version":3,"names":["prepare","prepareOnramp","getCachedChain","NATIVE_TOKEN_ADDRESS","getContract","decimals","toTokens","toUnits","getBuyWithFiatQuote","params","_params$maxSlippageBP","_params$preferredProv","mapProviderToOnramp","provider","onrampProvider","preferredProvider","d","toTokenAddress","contract","address","chain","toChainId","client","amountWei","toAmount","undefined","prepared","amount","chainId","currency","fromCurrencySymbol","maxSteps","onramp","onrampChainId","onrampTokenAddress","paymentLinkId","purchaseData","receiver","toAddress","sender","fromAddress","tokenAddress","hasSteps","steps","length","firstStep","estimatedDurationSeconds","Math","max","ceil","reduce","acc","s","estimatedExecutionTimeMs","estimatedToAmountMinWeiBigInt","destinationAmount","maxSlippageBPS","slippageWei","BigInt","toAmountMinWeiBigInt","estimatedToAmountMin","toAmountMin","tokenToPayTokenInfo","token","name","priceUSDCents","round","prices","USD","symbol","toTokenRaw","destinationToken","onRampTokenRaw","originToken","routingTokenRaw","onRampTokenAmountWei","originAmount","onRampTokenAmount","onRampTokenObject","amountUSDCents","Number","toString","routingTokenObject","routingAmountWei","routingAmount","buyWithFiatQuote","estimatedToAmountMinWei","fromCurrency","currencyAmount","amountUnits","toFixed","currencySymbol","fromCurrencyWithFees","intentId","id","onRampLink","link","onRampToken","processingFees","routingToken","toAmountMinWei","toToken","error","console"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/pay/buyWithFiat/getQuote.ts"],"sourcesContent":["import { prepare as prepareOnramp } from \"../../bridge/Onramp.js\";\nimport { getCachedChain } from \"../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { NATIVE_TOKEN_ADDRESS } from \"../../constants/addresses.js\";\nimport { getContract } from \"../../contract/contract.js\";\nimport { decimals } from \"../../extensions/erc20/read/decimals.js\";\nimport type { CurrencyMeta } from \"../../react/web/ui/ConnectWallet/screens/Buy/fiat/currencies.js\";\nimport { toTokens, toUnits } from \"../../utils/units.js\";\nimport type { PurchaseData } from \"../types.js\";\nimport type { FiatProvider, PayTokenInfo } from \"../utils/commonTypes.js\";\n/**\n * Parameters for [`getBuyWithFiatQuote`](https://portal.thirdweb.com/references/typescript/v5/getBuyWithFiatQuote) function\n * @deprecated\n * @buyCrypto\n */\nexport type GetBuyWithFiatQuoteParams = {\n  /**\n   * A client is the entry point to the thirdweb SDK. It is required for all other actions.\n   *\n   * You can create a client using the `createThirdwebClient` function.\n   * Refer to the [Creating a Client](https://portal.thirdweb.com/typescript/v5/client) documentation for more information.\n   */\n  client: ThirdwebClient;\n\n  /**\n   * The address of the wallet where the tokens will be sent.\n   */\n  toAddress: string;\n\n  /**\n   * The address of the wallet which will be used to buy the token.\n   */\n  fromAddress: string;\n\n  /**\n   * Chain id of the token to buy.\n   */\n  toChainId: number;\n\n  /**\n   * Token address of the token to buy.\n   */\n  toTokenAddress: string;\n\n  /**\n   * Symbol of the fiat currency to buy the token with.\n   */\n  fromCurrencySymbol: CurrencyMeta[\"shorthand\"];\n\n  /**\n   * The maximum slippage in basis points (bps) allowed for the transaction.\n   * For example, if you want to allow a maximum slippage of 0.5%, you should specify `50` bps.\n   */\n  maxSlippageBPS?: number;\n\n  /**\n   * The amount of fiat currency to spend to buy the token.\n   * This is useful if you want to buy whatever amount of token you can get for a certain amount of fiat currency.\n   *\n   * If you want a certain amount of token, you can provide `toAmount` instead of `fromAmount`.\n   */\n  fromAmount?: string;\n\n  /**\n   * The amount of token to buy\n   * This is useful if you want to get a certain amount of token.\n   *\n   * If you want to buy however much token you can get for a certain amount of fiat currency, you can provide `fromAmount` instead of `toAmount`.\n   */\n  toAmount?: string;\n\n  /**\n   * Whether to use on-ramp provider in test mode for testing purpose or not.\n   *\n   * Defaults to `false`\n   */\n  isTestMode?: boolean;\n\n  /**\n   * Extra details to store with the purchase.\n   *\n   * This details will be stored with the purchase and can be retrieved later via the status API or Webhook\n   */\n  purchaseData?: PurchaseData;\n\n  /**\n   * Optional parameter to onramp gas with the purchase\n   * If native token, will onramp extra native token amount\n   * If erc20, will onramp native token + erc20\n   */\n  toGasAmountWei?: string;\n\n  /**\n   * Optional parameter to specify the preferred onramp provider.\n   *\n   * By default, we choose a recommended provider based on the location of the user, KYC status, and currency.\n   */\n  preferredProvider?: FiatProvider;\n\n  /**\n   * @hidden\n   */\n  paymentLinkId?: string;\n\n  onrampChainId?: number;\n  onrampTokenAddress?: string;\n};\n\n/**\n * The response object returned by the [`getBuyWithFiatQuote`](https://portal.thirdweb.com/references/typescript/v5/getBuyWithFiatQuote) function.\n *\n * This includes various information for buying a token using a fiat currency:\n * - on-ramp provider UI link\n * - The estimated time for the transaction to complete.\n * - The on-ramp and destination token information.\n * - Processing fees\n *\n * @deprecated\n * @buyCrypto\n */\nexport type BuyWithFiatQuote = {\n  /**\n   * Estimated time for the transaction to complete in seconds.\n   */\n  estimatedDurationSeconds: number;\n  /**\n   * Minimum amount of token that is expected to be received in units.\n   */\n  estimatedToAmountMin: string;\n  /**\n   * Minimum amount of token that is expected to be received in wei.\n   */\n  estimatedToAmountMinWei: string;\n  /**\n   * Amount of token that is expected to be received in units.\n   *\n   * (estimatedToAmountMinWei - maxSlippageWei)\n   */\n  toAmountMinWei: string;\n  /**\n   * Amount of token that is expected to be received in wei.\n   *\n   * (estimatedToAmountMin - maxSlippageWei)\n   */\n  toAmountMin: string;\n  /**\n   * fiat currency used to buy the token - excluding the fees.\n   */\n  fromCurrency: {\n    amount: string;\n    amountUnits: string;\n    decimals: number;\n    currencySymbol: string;\n  };\n  /**\n   * Fiat currency used to buy the token - including the fees.\n   */\n  fromCurrencyWithFees: {\n    amount: string;\n    amountUnits: string;\n    decimals: number;\n    currencySymbol: string;\n  };\n  /**\n   * Token information for the desired token. (token the user wants to buy)\n   */\n  toToken: PayTokenInfo;\n  /**\n   * Address of the wallet to which the tokens will be sent.\n   */\n  toAddress: string;\n  /**\n   * Address of the wallet used for buying the token.\n   */\n  fromAddress: string;\n  /**\n   * The maximum slippage in basis points (bps) allowed for the transaction.\n   */\n  maxSlippageBPS: number;\n  /**\n   * Id of transaction\n   */\n  intentId: string;\n  /**\n   * Array of processing fees for the transaction.\n   *\n   * This includes the processing fees for on-ramp and swap (if required).\n   */\n  processingFees: {\n    amount: string;\n    amountUnits: string;\n    decimals: number;\n    currencySymbol: string;\n    feeType: \"ON_RAMP\" | \"NETWORK\";\n  }[];\n  /**\n   * Token that will be sent to the user's wallet address by the on-ramp provider.\n   *\n   * If the token is same as `toToken` - the user can directly buy the token from the on-ramp provider.\n   * If not, the user will receive this token and a swap is required to convert it `toToken`.\n   */\n  onRampToken: {\n    amount: string;\n    amountWei: string;\n    amountUSDCents: number;\n    token: PayTokenInfo;\n  };\n\n  /**\n   * Routing token that will be swapped from the on-ramp token, so that it can be bridged to the destination token.\n   */\n  routingToken?: {\n    amount: string;\n    amountWei: string;\n    amountUSDCents: number;\n    token: PayTokenInfo;\n  };\n\n  /**\n   * Link to the on-ramp provider UI that will prompt the user to buy the token with fiat currency.\n   *\n   * This link should be opened in a new tab.\n   * @example\n   * ```ts\n   * window.open(quote.onRampLink, \"_blank\");\n   * ```\n   *\n   */\n  onRampLink: string;\n\n  /**\n   * The provider that was used to get the quote.\n   */\n  provider: FiatProvider;\n};\n\n/**\n * Get a quote of type [`BuyWithFiatQuote`](https://portal.thirdweb.com/references/typescript/v5/BuyWithFiatQuote) to buy given token with fiat currency.\n * This quote contains the information about the swap such as token amounts, processing fees, estimated time etc.\n *\n * ### Rendering the On-Ramp provider UI\n * Once you have the `quote`, you can open the `quote.onRampLink` in a new tab - This will prompt the user to buy the token with fiat currency\n *\n * ### Determining the steps required\n * If `quote.onRampToken.token` is same as `quote.toToken` ( same chain + same token address ) - This means that the token can be directly bought from the on-ramp provider.\n * But if they are different, On-ramp provider will send the `quote.onRampToken` to the user's wallet address and a swap is required to swap it to the desired token onchain.\n *\n * You can use the [`isSwapRequiredPostOnramp`](https://portal.thirdweb.com/references/typescript/v5/isSwapRequiredPostOnramp) utility function to check if a swap is required after the on-ramp is done.\n *\n * ### Polling for the status\n * Once you open the `quote.onRampLink` in a new tab, you can start polling for the status using [`getBuyWithFiatStatus`](https://portal.thirdweb.com/references/typescript/v5/getBuyWithFiatStatus) to get the status of the transaction.\n *\n * `getBuyWithFiatStatus` returns a status object of type [`BuyWithFiatStatus`](https://portal.thirdweb.com/references/typescript/v5/BuyWithFiatStatus).\n *\n * - If no swap is required - the status will become `\"ON_RAMP_TRANSFER_COMPLETED\"` once the on-ramp provider has sent the desired token to the user's wallet address. Once you receive this status, the process is complete.\n * - If a swap is required - the status will become `\"CRYPTO_SWAP_REQUIRED\"` once the on-ramp provider has sent the tokens to the user's wallet address. Once you receive this status, you need to start the swap process.\n *\n * ### Swap Process\n * On receiving the `\"CRYPTO_SWAP_REQUIRED\"` status, you can use the [`getPostOnRampQuote`](https://portal.thirdweb.com/references/typescript/v5/getPostOnRampQuote) function to get the quote for the swap of type [`BuyWithCryptoQuote`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoQuote).\n *\n * Once you have this quote - You can follow the same steps as mentioned in the [`getBuyWithCryptoQuote`](https://portal.thirdweb.com/references/typescript/v5/getBuyWithCryptoQuote) documentation to perform the swap.\n *\n * @param params - object of type [`GetBuyWithFiatQuoteParams`](https://portal.thirdweb.com/references/typescript/v5/GetBuyWithFiatQuoteParams)\n * @returns Object of type [`BuyWithFiatQuote`](https://portal.thirdweb.com/references/typescript/v5/BuyWithFiatQuote) which contains the information about the quote such as processing fees, estimated time, converted token amounts, etc.\n * @example\n * Get a quote for buying 10 USDC on polygon chain (chainId: 137) with USD fiat currency:\n *\n * ```ts\n * import { getBuyWithFiatQuote } from \"thirdweb/pay\";\n *\n * const quote = await getBuyWithFiatQuote({\n *  client: client, // thirdweb client\n *  fromCurrencySymbol: \"USD\", // fiat currency symbol\n *  toChainId: 137, // polygon chain id\n *  toAmount: \"10\", // amount of USDC to buy\n *  toTokenAddress: \"0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359\" // USDC token address in polygon chain\n *  toAddress: \"0x...\", // user's wallet address\n *  isTestMode: false, // whether to use onramp in test mode for testing purpose (defaults to false)\n * });\n *\n * window.open(quote.onRampLink, \"_blank\");\n * ```\n * @deprecated\n * @buyCrypto\n */\nexport async function getBuyWithFiatQuote(\n  params: GetBuyWithFiatQuoteParams,\n): Promise<BuyWithFiatQuote> {\n  try {\n    // map preferred provider (FiatProvider) → onramp string expected by Onramp.prepare\n    const mapProviderToOnramp = (\n      provider?: FiatProvider,\n    ): \"stripe\" | \"coinbase\" | \"transak\" => {\n      switch (provider) {\n        case \"stripe\":\n          return \"stripe\";\n        case \"transak\":\n          return \"transak\";\n        default: // default to coinbase when undefined or any other value\n          return \"coinbase\";\n      }\n    };\n\n    // Choose provider or default to STRIPE\n    const onrampProvider = mapProviderToOnramp(params.preferredProvider);\n\n    const d =\n      params.toTokenAddress !== NATIVE_TOKEN_ADDRESS\n        ? await decimals({\n            contract: getContract({\n              address: params.toTokenAddress,\n              chain: getCachedChain(params.toChainId),\n              client: params.client,\n            }),\n          })\n        : 18;\n\n    // Prepare amount in wei if provided\n    const amountWei = params.toAmount ? toUnits(params.toAmount, d) : undefined;\n\n    // Call new Onramp.prepare to get the quote & link\n    const prepared = await prepareOnramp({\n      amount: amountWei,\n      chainId: params.toChainId,\n      client: params.client,\n      currency: params.fromCurrencySymbol,\n      maxSteps: 2,\n      onramp: onrampProvider,\n      onrampChainId: params.onrampChainId,\n      onrampTokenAddress: params.onrampTokenAddress,\n      paymentLinkId: params.paymentLinkId,\n      purchaseData: params.purchaseData,\n      receiver: params.toAddress, // force onramp to native token to avoid missing gas issues\n      sender: params.fromAddress,\n      tokenAddress: params.toTokenAddress,\n    });\n\n    // Determine tokens based on steps rules\n    const hasSteps = prepared.steps.length > 0;\n    const firstStep = hasSteps\n      ? (prepared.steps[0] as (typeof prepared.steps)[number])\n      : undefined;\n\n    // Estimated duration in seconds – sum of all step durations\n    const estimatedDurationSeconds = Math.max(\n      120,\n      Math.ceil(\n        prepared.steps.reduce((acc, s) => acc + s.estimatedExecutionTimeMs, 0) /\n          1000,\n      ),\n    );\n\n    const estimatedToAmountMinWeiBigInt = prepared.destinationAmount;\n\n    const maxSlippageBPS = params.maxSlippageBPS ?? 0;\n    const slippageWei =\n      (estimatedToAmountMinWeiBigInt * BigInt(maxSlippageBPS)) / 10000n;\n    const toAmountMinWeiBigInt = estimatedToAmountMinWeiBigInt - slippageWei;\n\n    const estimatedToAmountMin = toTokens(estimatedToAmountMinWeiBigInt, d);\n    const toAmountMin = toTokens(toAmountMinWeiBigInt, d);\n\n    // Helper to convert a Token → PayTokenInfo\n    const tokenToPayTokenInfo = (token: {\n      chainId: number;\n      address: string;\n      decimals: number;\n      symbol: string;\n      name: string;\n      prices: Record<string, number>;\n    }): PayTokenInfo => ({\n      chainId: token.chainId,\n      decimals: token.decimals,\n      name: token.name,\n      priceUSDCents: Math.round((token.prices.USD || 0) * 100),\n      symbol: token.symbol,\n      tokenAddress: token.address,\n    });\n\n    // Determine the raw token objects using new simplified rules\n    // 1. toToken is always the destination token\n    const toTokenRaw = prepared.destinationToken;\n\n    // 2. onRampToken: if exactly one step -> originToken of that step, else toTokenRaw\n    const onRampTokenRaw =\n      prepared.steps.length > 0 && firstStep\n        ? firstStep.originToken\n        : toTokenRaw;\n\n    // 3. routingToken: if exactly two steps -> originToken of second step, else undefined\n    const routingTokenRaw =\n      prepared.steps.length > 1\n        ? (prepared.steps[1] as (typeof prepared.steps)[number]).originToken\n        : undefined;\n\n    // Amounts for onRampToken/raw\n    const onRampTokenAmountWei: bigint =\n      prepared.steps.length > 0 && firstStep\n        ? firstStep.originAmount\n        : prepared.destinationAmount;\n\n    const onRampTokenAmount = toTokens(\n      onRampTokenAmountWei,\n      onRampTokenRaw.decimals,\n    );\n\n    // Build info objects\n    const onRampTokenObject = {\n      amount: onRampTokenAmount,\n      amountUSDCents: Math.round(\n        Number(onRampTokenAmount) * (onRampTokenRaw.prices.USD || 0) * 100,\n      ),\n      amountWei: onRampTokenAmountWei.toString(),\n      token: tokenToPayTokenInfo(onRampTokenRaw),\n    };\n\n    let routingTokenObject:\n      | {\n          amount: string;\n          amountWei: string;\n          amountUSDCents: number;\n          token: PayTokenInfo;\n        }\n      | undefined;\n\n    if (routingTokenRaw) {\n      const routingAmountWei = (\n        prepared.steps[1] as (typeof prepared.steps)[number]\n      ).originAmount;\n      const routingAmount = toTokens(\n        routingAmountWei,\n        routingTokenRaw.decimals,\n      );\n      routingTokenObject = {\n        amount: routingAmount,\n        amountUSDCents: Math.round(\n          Number(routingAmount) * (routingTokenRaw.prices.USD || 0) * 100,\n        ),\n        amountWei: routingAmountWei.toString(),\n        token: tokenToPayTokenInfo(routingTokenRaw),\n      };\n    }\n\n    const buyWithFiatQuote: BuyWithFiatQuote = {\n      estimatedDurationSeconds,\n      estimatedToAmountMin: estimatedToAmountMin,\n      estimatedToAmountMinWei: estimatedToAmountMinWeiBigInt.toString(),\n      fromAddress: params.fromAddress,\n      fromCurrency: {\n        amount: prepared.currencyAmount.toString(),\n        amountUnits: Number(prepared.currencyAmount).toFixed(2),\n        currencySymbol: prepared.currency,\n        decimals: 2,\n      },\n      fromCurrencyWithFees: {\n        amount: prepared.currencyAmount.toString(),\n        amountUnits: Number(prepared.currencyAmount).toFixed(2),\n        currencySymbol: prepared.currency,\n        decimals: 2,\n      },\n      intentId: prepared.id,\n      maxSlippageBPS: maxSlippageBPS,\n      onRampLink: prepared.link,\n      onRampToken: onRampTokenObject,\n      processingFees: [],\n      provider: (params.preferredProvider ?? \"COINBASE\") as FiatProvider,\n      routingToken: routingTokenObject,\n      toAddress: params.toAddress,\n      toAmountMin: toAmountMin,\n      toAmountMinWei: toAmountMinWeiBigInt.toString(),\n      toToken: tokenToPayTokenInfo(toTokenRaw),\n    };\n\n    return buyWithFiatQuote;\n  } catch (error) {\n    console.error(\"Error getting buy with fiat quote\", error);\n    throw error;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}