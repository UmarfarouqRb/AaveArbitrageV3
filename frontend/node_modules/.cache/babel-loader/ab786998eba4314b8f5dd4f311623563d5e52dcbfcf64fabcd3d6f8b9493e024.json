{"ast":null,"code":"import { useMutation } from \"@tanstack/react-query\";\nimport { isInsufficientFundsError } from \"../../../../analytics/track/helpers.js\";\nimport { trackPayEvent } from \"../../../../analytics/track/pay.js\";\nimport { trackInsufficientFundsError } from \"../../../../analytics/track/transaction.js\";\nimport * as Bridge from \"../../../../bridge/index.js\";\nimport { sendTransaction } from \"../../../../transaction/actions/send-transaction.js\";\nimport { getTransactionGasCost } from \"../../../../transaction/utils.js\";\nimport { resolvePromisedValue } from \"../../../../utils/promise/resolve-promised-value.js\";\nimport { hasSponsoredTransactionsEnabled } from \"../../../../wallets/smart/is-smart-wallet.js\";\nimport { getTokenBalance } from \"../../../../wallets/utils/getTokenBalance.js\";\nimport { getWalletBalance } from \"../../../../wallets/utils/getWalletBalance.js\";\n/**\n * A hook to send a transaction.\n * @returns A mutation object to send a transaction.\n * @example\n * ```jsx\n * import { useSendTransaction } from \"thirdweb/react\";\n * const { mutate: sendTx, data: transactionResult } = useSendTransaction();\n *\n * // later\n * sendTx(tx);\n * ```\n * @internal\n */\nexport function useSendTransactionCore(args) {\n  const {\n    showPayModal,\n    gasless,\n    wallet,\n    switchChain\n  } = args;\n  let _account = wallet === null || wallet === void 0 ? void 0 : wallet.getAccount();\n  return useMutation({\n    mutationFn: async tx => {\n      var _wallet$getChain;\n      // switch chain if needed\n      if (wallet && tx.chain.id !== ((_wallet$getChain = wallet.getChain()) === null || _wallet$getChain === void 0 ? void 0 : _wallet$getChain.id)) {\n        var _wallet$getChain2;\n        await switchChain(tx.chain);\n        // in smart wallet case, account may change after chain switch\n        _account = wallet.getAccount();\n        // ensure that the account has switched to the correct chain\n        if (((_wallet$getChain2 = wallet.getChain()) === null || _wallet$getChain2 === void 0 ? void 0 : _wallet$getChain2.id) !== tx.chain.id) {\n          throw new Error(\"Could not switch to chain \".concat(tx.chain.id));\n        }\n      }\n      const account = _account;\n      if (!account) {\n        throw new Error(\"No active account\");\n      }\n      if (!showPayModal) {\n        trackPayEvent({\n          chainId: tx.chain.id,\n          client: tx.client,\n          event: \"pay_transaction_modal_disabled\",\n          walletAddress: account.address,\n          walletType: wallet === null || wallet === void 0 ? void 0 : wallet.id\n        });\n        return sendTransaction({\n          account,\n          gasless,\n          transaction: tx\n        });\n      }\n      return new Promise((resolve, reject) => {\n        const sendTx = async () => {\n          try {\n            const res = await sendTransaction({\n              account,\n              gasless,\n              transaction: tx\n            });\n            resolve(res);\n          } catch (e) {\n            // Track insufficient funds errors specifically\n            if (isInsufficientFundsError(e)) {\n              var _tx$to;\n              trackInsufficientFundsError({\n                chainId: tx.chain.id,\n                client: tx.client,\n                contractAddress: await resolvePromisedValue((_tx$to = tx.to) !== null && _tx$to !== void 0 ? _tx$to : undefined),\n                error: e,\n                transactionValue: await resolvePromisedValue(tx.value),\n                walletAddress: account.address\n              });\n            }\n            reject(e);\n          }\n        };\n        (async () => {\n          try {\n            const [_nativeValue, _erc20Value] = await Promise.all([resolvePromisedValue(tx.value), resolvePromisedValue(tx.erc20Value)]);\n            const nativeValue = _nativeValue || 0n;\n            const erc20Value = (_erc20Value === null || _erc20Value === void 0 ? void 0 : _erc20Value.amountWei) || 0n;\n            const [nativeBalance, erc20Balance, gasCost] = await Promise.all([getWalletBalance({\n              address: account.address,\n              chain: tx.chain,\n              client: tx.client\n            }), _erc20Value !== null && _erc20Value !== void 0 && _erc20Value.tokenAddress ? getTokenBalance({\n              account,\n              chain: tx.chain,\n              client: tx.client,\n              tokenAddress: _erc20Value.tokenAddress\n            }) : undefined, getTransactionGasCost(tx, account.address)]);\n            const gasSponsored = hasSponsoredTransactionsEnabled(wallet);\n            const txGasCost = gasSponsored ? 0n : gasCost;\n            const nativeCost = nativeValue + txGasCost;\n            const shouldShowModal = erc20Value > 0n && erc20Balance && erc20Balance.value < erc20Value || nativeCost > 0n && nativeBalance.value < nativeCost;\n            if (shouldShowModal) {\n              const tokens = await Bridge.tokens({\n                client: tx.client,\n                chainId: tx.chain.id,\n                tokenAddress: _erc20Value === null || _erc20Value === void 0 ? void 0 : _erc20Value.tokenAddress\n              }).catch(err => {\n                trackPayEvent({\n                  client: tx.client,\n                  error: err === null || err === void 0 ? void 0 : err.message,\n                  event: \"pay_transaction_modal_pay_api_error\",\n                  toChainId: tx.chain.id,\n                  walletAddress: account.address,\n                  walletType: wallet === null || wallet === void 0 ? void 0 : wallet.id\n                });\n                return null;\n              });\n              if (!tokens || tokens.length === 0) {\n                // not a supported token -> show deposit screen\n                trackPayEvent({\n                  client: tx.client,\n                  error: JSON.stringify({\n                    chain: tx.chain.id,\n                    message: \"chain/token not supported\",\n                    token: _erc20Value === null || _erc20Value === void 0 ? void 0 : _erc20Value.tokenAddress\n                  }),\n                  event: \"pay_transaction_modal_chain_token_not_supported\",\n                  toChainId: tx.chain.id,\n                  toToken: (_erc20Value === null || _erc20Value === void 0 ? void 0 : _erc20Value.tokenAddress) || undefined,\n                  walletAddress: account.address,\n                  walletType: wallet === null || wallet === void 0 ? void 0 : wallet.id\n                });\n                showPayModal({\n                  mode: \"deposit\",\n                  rejectTx: reject,\n                  resolveTx: resolve,\n                  sendTx,\n                  tx\n                });\n                return;\n              }\n              // chain is supported, show buy mode\n              showPayModal({\n                mode: \"buy\",\n                rejectTx: reject,\n                resolveTx: resolve,\n                sendTx,\n                tx\n              });\n            } else {\n              trackPayEvent({\n                client: tx.client,\n                event: \"pay_transaction_modal_has_enough_funds\",\n                toChainId: tx.chain.id,\n                toToken: (_erc20Value === null || _erc20Value === void 0 ? void 0 : _erc20Value.tokenAddress) || undefined,\n                walletAddress: account.address,\n                walletType: wallet === null || wallet === void 0 ? void 0 : wallet.id\n              });\n              sendTx();\n            }\n          } catch (e) {\n            console.error(\"Failed to estimate cost\", e);\n            // send it anyway?\n            sendTx();\n          }\n        })();\n      });\n    }\n  });\n}","map":{"version":3,"names":["useMutation","isInsufficientFundsError","trackPayEvent","trackInsufficientFundsError","Bridge","sendTransaction","getTransactionGasCost","resolvePromisedValue","hasSponsoredTransactionsEnabled","getTokenBalance","getWalletBalance","useSendTransactionCore","args","showPayModal","gasless","wallet","switchChain","_account","getAccount","mutationFn","tx","_wallet$getChain","chain","id","getChain","_wallet$getChain2","Error","concat","account","chainId","client","event","walletAddress","address","walletType","transaction","Promise","resolve","reject","sendTx","res","e","_tx$to","contractAddress","to","undefined","error","transactionValue","value","_nativeValue","_erc20Value","all","erc20Value","nativeValue","amountWei","nativeBalance","erc20Balance","gasCost","tokenAddress","gasSponsored","txGasCost","nativeCost","shouldShowModal","tokens","catch","err","message","toChainId","length","JSON","stringify","token","toToken","mode","rejectTx","resolveTx","console"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/react/core/hooks/transaction/useSendTransaction.ts"],"sourcesContent":["import { type UseMutationResult, useMutation } from \"@tanstack/react-query\";\nimport { isInsufficientFundsError } from \"../../../../analytics/track/helpers.js\";\nimport { trackPayEvent } from \"../../../../analytics/track/pay.js\";\nimport { trackInsufficientFundsError } from \"../../../../analytics/track/transaction.js\";\nimport * as Bridge from \"../../../../bridge/index.js\";\nimport type { Chain } from \"../../../../chains/types.js\";\nimport type { BuyWithCryptoStatus } from \"../../../../pay/buyWithCrypto/getStatus.js\";\nimport type { BuyWithFiatStatus } from \"../../../../pay/buyWithFiat/getStatus.js\";\nimport type { SupportedFiatCurrency } from \"../../../../pay/convert/type.js\";\nimport type { PurchaseData } from \"../../../../pay/types.js\";\nimport type { FiatProvider } from \"../../../../pay/utils/commonTypes.js\";\nimport type { GaslessOptions } from \"../../../../transaction/actions/gasless/types.js\";\nimport {\n  type SendTransactionOptions,\n  sendTransaction,\n} from \"../../../../transaction/actions/send-transaction.js\";\nimport type { WaitForReceiptOptions } from \"../../../../transaction/actions/wait-for-tx-receipt.js\";\nimport type { PreparedTransaction } from \"../../../../transaction/prepare-transaction.js\";\nimport { getTransactionGasCost } from \"../../../../transaction/utils.js\";\nimport type { Hex } from \"../../../../utils/encoding/hex.js\";\nimport { resolvePromisedValue } from \"../../../../utils/promise/resolve-promised-value.js\";\nimport type { Wallet } from \"../../../../wallets/interfaces/wallet.js\";\nimport { hasSponsoredTransactionsEnabled } from \"../../../../wallets/smart/is-smart-wallet.js\";\nimport { getTokenBalance } from \"../../../../wallets/utils/getTokenBalance.js\";\nimport { getWalletBalance } from \"../../../../wallets/utils/getWalletBalance.js\";\nimport type { LocaleId } from \"../../../web/ui/types.js\";\nimport type { Theme } from \"../../design-system/index.js\";\nimport type { SupportedTokens } from \"../../utils/defaultTokens.js\";\n\n/**\n * Configuration for the \"Pay Modal\" that opens when the user doesn't have enough funds to send a transaction.\n * Set `payModal: false` to disable the \"Pay Modal\" popup\n *\n * This configuration object includes the following properties to configure the \"Pay Modal\" UI:\n *\n * ### `locale`\n * The language to use for the \"Pay Modal\" UI. Defaults to `\"en_US\"`.\n *\n * ### `supportedTokens`\n * An object of type [`SupportedTokens`](https://portal.thirdweb.com/references/typescript/v5/SupportedTokens) to configure the tokens to show for a chain.\n *\n * ### `theme`\n * The theme to use for the \"Pay Modal\" UI. Defaults to `\"dark\"`.\n *\n * It can be set to `\"light\"` or `\"dark\"` or an object of type [`Theme`](https://portal.thirdweb.com/references/typescript/v5/Theme) for a custom theme.\n *\n * Refer to [`lightTheme`](https://portal.thirdweb.com/references/typescript/v5/lightTheme)\n * or [`darkTheme`](https://portal.thirdweb.com/references/typescript/v5/darkTheme) helper functions to use the default light or dark theme and customize it.\n */\nexport type SendTransactionPayModalConfig =\n  | {\n      metadata?: {\n        name?: string;\n        image?: string;\n      };\n      locale?: LocaleId;\n      supportedTokens?: SupportedTokens;\n      theme?: Theme | \"light\" | \"dark\";\n      buyWithCrypto?:\n        | false\n        | {\n            testMode?: boolean;\n          };\n      buyWithFiat?:\n        | false\n        | {\n            prefillSource?: {\n              currency?: \"USD\" | \"CAD\" | \"GBP\" | \"EUR\" | \"JPY\";\n            };\n            testMode?: boolean;\n            preferredProvider?: FiatProvider;\n          };\n      purchaseData?: PurchaseData;\n      /**\n       * Callback to be called when the user successfully completes the purchase.\n       */\n      onPurchaseSuccess?: (\n        info?:\n          | {\n              type: \"crypto\";\n              status: BuyWithCryptoStatus;\n            }\n          | {\n              type: \"fiat\";\n              status: BuyWithFiatStatus;\n            }\n          | {\n              type: \"transaction\";\n              chainId: number;\n              transactionHash: Hex;\n            },\n      ) => void;\n      showThirdwebBranding?: boolean;\n      /**\n       * The user's ISO 3166 alpha-2 country code. This is used to determine onramp provider support.\n       */\n      country?: string;\n      /**\n       * The currency to use for showing the fiat values\n       * @default \"USD\"\n       */\n      currency?: SupportedFiatCurrency;\n    }\n  | false;\n\n/**\n * Configuration for the `useSendTransaction` hook.\n */\nexport type SendTransactionConfig = {\n  /**\n   * Refer to [`SendTransactionPayModalConfig`](https://portal.thirdweb.com/references/typescript/v5/SendTransactionPayModalConfig) for more details.\n   */\n  payModal?: SendTransactionPayModalConfig;\n\n  /**\n   * Configuration for gasless transactions.\n   * Refer to [`GaslessOptions`](https://portal.thirdweb.com/references/typescript/v5/GaslessOptions) for more details.\n   */\n  gasless?: GaslessOptions;\n};\n\nexport type ShowModalData = {\n  mode: \"buy\" | \"deposit\";\n  tx: PreparedTransaction;\n  sendTx: () => void;\n  rejectTx: (reason: Error) => void;\n  resolveTx: (data: WaitForReceiptOptions) => void;\n};\n\n/**\n * A hook to send a transaction.\n * @returns A mutation object to send a transaction.\n * @example\n * ```jsx\n * import { useSendTransaction } from \"thirdweb/react\";\n * const { mutate: sendTx, data: transactionResult } = useSendTransaction();\n *\n * // later\n * sendTx(tx);\n * ```\n * @internal\n */\nexport function useSendTransactionCore(args: {\n  showPayModal?: (data: ShowModalData) => void;\n  gasless?: GaslessOptions;\n  wallet: Wallet | undefined;\n  switchChain: (chain: Chain) => Promise<void>;\n}): UseMutationResult<\n  WaitForReceiptOptions,\n  Error,\n  SendTransactionOptions[\"transaction\"]\n> {\n  const { showPayModal, gasless, wallet, switchChain } = args;\n  let _account = wallet?.getAccount();\n\n  return useMutation({\n    mutationFn: async (tx) => {\n      // switch chain if needed\n      if (wallet && tx.chain.id !== wallet.getChain()?.id) {\n        await switchChain(tx.chain);\n        // in smart wallet case, account may change after chain switch\n        _account = wallet.getAccount();\n\n        // ensure that the account has switched to the correct chain\n        if (wallet.getChain()?.id !== tx.chain.id) {\n          throw new Error(`Could not switch to chain ${tx.chain.id}`);\n        }\n      }\n\n      const account = _account;\n\n      if (!account) {\n        throw new Error(\"No active account\");\n      }\n\n      if (!showPayModal) {\n        trackPayEvent({\n          chainId: tx.chain.id,\n          client: tx.client,\n          event: \"pay_transaction_modal_disabled\",\n          walletAddress: account.address,\n          walletType: wallet?.id,\n        });\n        return sendTransaction({\n          account,\n          gasless,\n          transaction: tx,\n        });\n      }\n\n      return new Promise<WaitForReceiptOptions>((resolve, reject) => {\n        const sendTx = async () => {\n          try {\n            const res = await sendTransaction({\n              account,\n              gasless,\n              transaction: tx,\n            });\n\n            resolve(res);\n          } catch (e) {\n            // Track insufficient funds errors specifically\n            if (isInsufficientFundsError(e)) {\n              trackInsufficientFundsError({\n                chainId: tx.chain.id,\n                client: tx.client,\n                contractAddress: await resolvePromisedValue(tx.to ?? undefined),\n                error: e,\n                transactionValue: await resolvePromisedValue(tx.value),\n                walletAddress: account.address,\n              });\n            }\n\n            reject(e);\n          }\n        };\n\n        (async () => {\n          try {\n            const [_nativeValue, _erc20Value] = await Promise.all([\n              resolvePromisedValue(tx.value),\n              resolvePromisedValue(tx.erc20Value),\n            ]);\n\n            const nativeValue = _nativeValue || 0n;\n            const erc20Value = _erc20Value?.amountWei || 0n;\n\n            const [nativeBalance, erc20Balance, gasCost] = await Promise.all([\n              getWalletBalance({\n                address: account.address,\n                chain: tx.chain,\n                client: tx.client,\n              }),\n              _erc20Value?.tokenAddress\n                ? getTokenBalance({\n                    account,\n                    chain: tx.chain,\n                    client: tx.client,\n                    tokenAddress: _erc20Value.tokenAddress,\n                  })\n                : undefined,\n              getTransactionGasCost(tx, account.address),\n            ]);\n\n            const gasSponsored = hasSponsoredTransactionsEnabled(wallet);\n            const txGasCost = gasSponsored ? 0n : gasCost;\n            const nativeCost = nativeValue + txGasCost;\n\n            const shouldShowModal =\n              (erc20Value > 0n &&\n                erc20Balance &&\n                erc20Balance.value < erc20Value) ||\n              (nativeCost > 0n && nativeBalance.value < nativeCost);\n\n            if (shouldShowModal) {\n              const tokens = await Bridge.tokens({\n                client: tx.client,\n                chainId: tx.chain.id,\n                tokenAddress: _erc20Value?.tokenAddress,\n              }).catch((err) => {\n                trackPayEvent({\n                  client: tx.client,\n                  error: err?.message,\n                  event: \"pay_transaction_modal_pay_api_error\",\n                  toChainId: tx.chain.id,\n                  walletAddress: account.address,\n                  walletType: wallet?.id,\n                });\n                return null;\n              });\n\n              if (!tokens || tokens.length === 0) {\n                // not a supported token -> show deposit screen\n                trackPayEvent({\n                  client: tx.client,\n                  error: JSON.stringify({\n                    chain: tx.chain.id,\n                    message: \"chain/token not supported\",\n                    token: _erc20Value?.tokenAddress,\n                  }),\n                  event: \"pay_transaction_modal_chain_token_not_supported\",\n                  toChainId: tx.chain.id,\n                  toToken: _erc20Value?.tokenAddress || undefined,\n                  walletAddress: account.address,\n                  walletType: wallet?.id,\n                });\n\n                showPayModal({\n                  mode: \"deposit\",\n                  rejectTx: reject,\n                  resolveTx: resolve,\n                  sendTx,\n                  tx,\n                });\n                return;\n              }\n\n              // chain is supported, show buy mode\n              showPayModal({\n                mode: \"buy\",\n                rejectTx: reject,\n                resolveTx: resolve,\n                sendTx,\n                tx,\n              });\n            } else {\n              trackPayEvent({\n                client: tx.client,\n                event: \"pay_transaction_modal_has_enough_funds\",\n                toChainId: tx.chain.id,\n                toToken: _erc20Value?.tokenAddress || undefined,\n                walletAddress: account.address,\n                walletType: wallet?.id,\n              });\n              sendTx();\n            }\n          } catch (e) {\n            console.error(\"Failed to estimate cost\", e);\n            // send it anyway?\n            sendTx();\n          }\n        })();\n      });\n    },\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}