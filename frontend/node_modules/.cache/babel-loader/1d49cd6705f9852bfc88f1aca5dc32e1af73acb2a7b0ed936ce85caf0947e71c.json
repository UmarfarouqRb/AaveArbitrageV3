{"ast":null,"code":"import * as ox__Abi from \"ox/Abi\";\nimport * as ox__AbiConstructor from \"ox/AbiConstructor\";\nimport * as ox__AbiFunction from \"ox/AbiFunction\";\nimport { WrappedSignature as ox__WrappedSignature } from \"ox/erc6492\";\nimport * as ox__Signature from \"ox/Signature\";\nimport { getContract } from \"../contract/contract.js\";\nimport { isValidSignature } from \"../extensions/erc1271/__generated__/isValidSignature/read/isValidSignature.js\";\nimport { eth_call } from \"../rpc/actions/eth_call.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport { isZkSyncChain } from \"../utils/any-evm/zksync/isZkSyncChain.js\";\nimport { isContractDeployed } from \"../utils/bytecode/is-contract-deployed.js\";\nimport { fromBytes } from \"../utils/encoding/from-bytes.js\";\nimport { hexToBool, isHex } from \"../utils/encoding/hex.js\";\nimport { serializeErc6492Signature } from \"./serialize-erc6492-signature.js\";\nconst ZKSYNC_VALIDATOR_ADDRESS = \"0xfB688330379976DA81eB64Fe4BF50d7401763B9C\";\n/**\n * Verify that an address created the provided signature for a given hash using [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492). This function is interoperable with all wallet types, including EOAs.\n * This function should rarely be used directly, instead use @see {import(\"./verify-signature.js\")} and @see {import(\"./verify-typed-data.js\")}}\n *\n * @param {Hex} options.hash The hash that was signed\n * @param {string | Uint8Array | Signature} options.signature The signature that was signed\n * @param {string} options.address The address that signed the hash\n * @param {ThirdwebClient} options.client The Thirdweb client\n * @param {Chain} options.chain The chain that the address is on. For an EOA, this can be any chain.\n * @param {string} [options.accountFactory.address] The address of the account factory that created the account if using a smart account with a custom account factory\n * @param {Hex} [options.accountFactory.verificationCalldata] The calldata that was used to create the account if using a smart account with a custom account factory\n *\n * @returns {Promise<boolean>} A promise that resolves to `true` if the signature is valid, or `false` otherwise.\n *\n * @example\n * ```ts\n * import { verifyHash } from \"thirdweb/utils\";\n * const isValid = await verifyHash({\n *   hash: \"0x1234\",\n *   signature: \"0x1234\",\n *   address: \"0x1234\",\n *   client,\n *   chain,\n * });\n * ```\n *\n * @auth\n */\nexport async function verifyHash(_ref) {\n  let {\n    hash,\n    signature,\n    address,\n    client,\n    chain,\n    accountFactory\n  } = _ref;\n  const signatureHex = (() => {\n    if (isHex(signature)) return signature;\n    if (typeof signature === \"object\" && \"r\" in signature && \"s\" in signature) return ox__Signature.toHex(signature);\n    if (signature instanceof Uint8Array) return fromBytes(signature, \"hex\");\n    // We should never hit this but TS doesn't know that\n    throw new Error(\"Invalid signature type for signature \".concat(signature, \": \").concat(typeof signature));\n  })();\n  const isDeployed = await isContractDeployed(getContract({\n    address,\n    chain,\n    client\n  }));\n  if (isDeployed) {\n    const validEip1271 = await verifyEip1271Signature({\n      contract: getContract({\n        address,\n        chain,\n        client\n      }),\n      hash,\n      signature: signatureHex\n    }).catch(err => {\n      console.error(\"Error verifying EIP-1271 signature\", err);\n      return false;\n    });\n    if (validEip1271) {\n      return true;\n    }\n  }\n  // contract not deployed, use erc6492 validator to verify signature\n  const wrappedSignature = await (async () => {\n    // If no factory is provided, we have to assume its already deployed or is an EOA\n    // TODO: Figure out how to automatically tell if our default factory was used\n    if (!accountFactory) return signatureHex;\n    // If this sigature was already wrapped for ERC-6492, carry on\n    if (ox__WrappedSignature.validate(signatureHex)) return signatureHex;\n    // Otherwise, serialize the signature for ERC-6492 validation\n    return serializeErc6492Signature({\n      address: accountFactory.address,\n      data: accountFactory.verificationCalldata,\n      signature: signatureHex\n    });\n  })();\n  let verificationData;\n  const zkSyncChain = await isZkSyncChain(chain);\n  const abi = ox__Abi.from(ox__WrappedSignature.universalSignatureValidatorAbi);\n  if (zkSyncChain) {\n    // zksync chains dont support deploying code with eth_call\n    // need to call a deployed contract instead\n    verificationData = {\n      data: ox__AbiFunction.encodeData(ox__AbiFunction.fromAbi(abi, \"isValidSig\"), [address, hash, wrappedSignature]),\n      to: ZKSYNC_VALIDATOR_ADDRESS\n    };\n  } else {\n    const validatorConstructor = ox__AbiConstructor.fromAbi(abi);\n    verificationData = {\n      data: ox__AbiConstructor.encode(validatorConstructor, {\n        args: [address, hash, wrappedSignature],\n        bytecode: ox__WrappedSignature.universalSignatureValidatorBytecode\n      })\n    };\n  }\n  const rpcRequest = getRpcClient({\n    chain,\n    client\n  });\n  try {\n    const result = await eth_call(rpcRequest, verificationData);\n    return hexToBool(result);\n  } catch (_unused) {\n    // Some chains do not support the eth_call simulation and will fail, so we fall back to regular EIP1271 validation\n    const validEip1271 = await verifyEip1271Signature({\n      contract: getContract({\n        address,\n        chain,\n        client\n      }),\n      hash,\n      signature: signatureHex\n    }).catch(err => {\n      console.error(\"Error verifying EIP-1271 signature\", err);\n      return false;\n    });\n    if (validEip1271) {\n      return true;\n    }\n    // TODO: Improve overall RPC error handling so we can tell if this was an actual verification failure or some other error\n    // Verification failed somehow\n    return false;\n  }\n}\nconst EIP_1271_MAGIC_VALUE = \"0x1626ba7e\";\nexport async function verifyEip1271Signature(_ref2) {\n  let {\n    hash,\n    signature,\n    contract\n  } = _ref2;\n  try {\n    const result = await isValidSignature({\n      contract,\n      hash,\n      signature\n    });\n    return result === EIP_1271_MAGIC_VALUE;\n  } catch (err) {\n    console.error(\"Error verifying EIP-1271 signature\", err);\n    return false;\n  }\n}","map":{"version":3,"names":["ox__Abi","ox__AbiConstructor","ox__AbiFunction","WrappedSignature","ox__WrappedSignature","ox__Signature","getContract","isValidSignature","eth_call","getRpcClient","isZkSyncChain","isContractDeployed","fromBytes","hexToBool","isHex","serializeErc6492Signature","ZKSYNC_VALIDATOR_ADDRESS","verifyHash","_ref","hash","signature","address","client","chain","accountFactory","signatureHex","toHex","Uint8Array","Error","concat","isDeployed","validEip1271","verifyEip1271Signature","contract","catch","err","console","error","wrappedSignature","validate","data","verificationCalldata","verificationData","zkSyncChain","abi","from","universalSignatureValidatorAbi","encodeData","fromAbi","to","validatorConstructor","encode","args","bytecode","universalSignatureValidatorBytecode","rpcRequest","result","_unused","EIP_1271_MAGIC_VALUE","_ref2"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/auth/verify-hash.ts"],"sourcesContent":["import * as ox__Abi from \"ox/Abi\";\nimport * as ox__AbiConstructor from \"ox/AbiConstructor\";\nimport * as ox__AbiFunction from \"ox/AbiFunction\";\nimport { WrappedSignature as ox__WrappedSignature } from \"ox/erc6492\";\nimport * as ox__Signature from \"ox/Signature\";\nimport type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { getContract, type ThirdwebContract } from \"../contract/contract.js\";\nimport { isValidSignature } from \"../extensions/erc1271/__generated__/isValidSignature/read/isValidSignature.js\";\nimport { eth_call } from \"../rpc/actions/eth_call.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport type { Address } from \"../utils/address.js\";\nimport { isZkSyncChain } from \"../utils/any-evm/zksync/isZkSyncChain.js\";\nimport { isContractDeployed } from \"../utils/bytecode/is-contract-deployed.js\";\nimport { fromBytes } from \"../utils/encoding/from-bytes.js\";\nimport { type Hex, hexToBool, isHex } from \"../utils/encoding/hex.js\";\nimport { serializeErc6492Signature } from \"./serialize-erc6492-signature.js\";\n\nexport type VerifyHashParams = {\n  hash: Hex;\n  signature: string | Uint8Array | ox__Signature.Signature;\n  address: string;\n  client: ThirdwebClient;\n  chain: Chain;\n  accountFactory?: {\n    address: string;\n    verificationCalldata: Hex;\n  };\n};\n\nconst ZKSYNC_VALIDATOR_ADDRESS: Address =\n  \"0xfB688330379976DA81eB64Fe4BF50d7401763B9C\";\n\n/**\n * Verify that an address created the provided signature for a given hash using [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492). This function is interoperable with all wallet types, including EOAs.\n * This function should rarely be used directly, instead use @see {import(\"./verify-signature.js\")} and @see {import(\"./verify-typed-data.js\")}}\n *\n * @param {Hex} options.hash The hash that was signed\n * @param {string | Uint8Array | Signature} options.signature The signature that was signed\n * @param {string} options.address The address that signed the hash\n * @param {ThirdwebClient} options.client The Thirdweb client\n * @param {Chain} options.chain The chain that the address is on. For an EOA, this can be any chain.\n * @param {string} [options.accountFactory.address] The address of the account factory that created the account if using a smart account with a custom account factory\n * @param {Hex} [options.accountFactory.verificationCalldata] The calldata that was used to create the account if using a smart account with a custom account factory\n *\n * @returns {Promise<boolean>} A promise that resolves to `true` if the signature is valid, or `false` otherwise.\n *\n * @example\n * ```ts\n * import { verifyHash } from \"thirdweb/utils\";\n * const isValid = await verifyHash({\n *   hash: \"0x1234\",\n *   signature: \"0x1234\",\n *   address: \"0x1234\",\n *   client,\n *   chain,\n * });\n * ```\n *\n * @auth\n */\nexport async function verifyHash({\n  hash,\n  signature,\n  address,\n  client,\n  chain,\n  accountFactory,\n}: VerifyHashParams): Promise<boolean> {\n  const signatureHex = (() => {\n    if (isHex(signature)) return signature;\n    if (typeof signature === \"object\" && \"r\" in signature && \"s\" in signature)\n      return ox__Signature.toHex(signature);\n    if (signature instanceof Uint8Array) return fromBytes(signature, \"hex\");\n    // We should never hit this but TS doesn't know that\n    throw new Error(\n      `Invalid signature type for signature ${signature}: ${typeof signature}`,\n    );\n  })();\n\n  const isDeployed = await isContractDeployed(\n    getContract({\n      address,\n      chain,\n      client,\n    }),\n  );\n\n  if (isDeployed) {\n    const validEip1271 = await verifyEip1271Signature({\n      contract: getContract({\n        address,\n        chain,\n        client,\n      }),\n      hash,\n      signature: signatureHex,\n    }).catch((err) => {\n      console.error(\"Error verifying EIP-1271 signature\", err);\n      return false;\n    });\n    if (validEip1271) {\n      return true;\n    }\n  }\n\n  // contract not deployed, use erc6492 validator to verify signature\n  const wrappedSignature: Hex = await (async () => {\n    // If no factory is provided, we have to assume its already deployed or is an EOA\n    // TODO: Figure out how to automatically tell if our default factory was used\n    if (!accountFactory) return signatureHex;\n\n    // If this sigature was already wrapped for ERC-6492, carry on\n    if (ox__WrappedSignature.validate(signatureHex)) return signatureHex;\n\n    // Otherwise, serialize the signature for ERC-6492 validation\n    return serializeErc6492Signature({\n      address: accountFactory.address,\n      data: accountFactory.verificationCalldata,\n      signature: signatureHex,\n    });\n  })();\n\n  let verificationData: {\n    to?: Address;\n    data: Hex;\n  };\n\n  const zkSyncChain = await isZkSyncChain(chain);\n  const abi = ox__Abi.from(ox__WrappedSignature.universalSignatureValidatorAbi);\n  if (zkSyncChain) {\n    // zksync chains dont support deploying code with eth_call\n    // need to call a deployed contract instead\n    verificationData = {\n      data: ox__AbiFunction.encodeData(\n        ox__AbiFunction.fromAbi(abi, \"isValidSig\"),\n        [address, hash, wrappedSignature],\n      ),\n      to: ZKSYNC_VALIDATOR_ADDRESS,\n    };\n  } else {\n    const validatorConstructor = ox__AbiConstructor.fromAbi(abi);\n    verificationData = {\n      data: ox__AbiConstructor.encode(validatorConstructor, {\n        args: [address, hash, wrappedSignature],\n        bytecode: ox__WrappedSignature.universalSignatureValidatorBytecode,\n      }),\n    };\n  }\n\n  const rpcRequest = getRpcClient({\n    chain,\n    client,\n  });\n\n  try {\n    const result = await eth_call(rpcRequest, verificationData);\n    return hexToBool(result);\n  } catch {\n    // Some chains do not support the eth_call simulation and will fail, so we fall back to regular EIP1271 validation\n    const validEip1271 = await verifyEip1271Signature({\n      contract: getContract({\n        address,\n        chain,\n        client,\n      }),\n      hash,\n      signature: signatureHex,\n    }).catch((err) => {\n      console.error(\"Error verifying EIP-1271 signature\", err);\n      return false;\n    });\n    if (validEip1271) {\n      return true;\n    }\n    // TODO: Improve overall RPC error handling so we can tell if this was an actual verification failure or some other error\n    // Verification failed somehow\n    return false;\n  }\n}\n\nconst EIP_1271_MAGIC_VALUE = \"0x1626ba7e\";\nexport async function verifyEip1271Signature({\n  hash,\n  signature,\n  contract,\n}: {\n  hash: Hex;\n  signature: Hex;\n  contract: ThirdwebContract;\n}): Promise<boolean> {\n  try {\n    const result = await isValidSignature({\n      contract,\n      hash,\n      signature,\n    });\n    return result === EIP_1271_MAGIC_VALUE;\n  } catch (err) {\n    console.error(\"Error verifying EIP-1271 signature\", err);\n    return false;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}