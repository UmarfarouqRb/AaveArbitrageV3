{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"account\", \"client\", \"hash\", \"index\"];\nimport { parseAbi } from 'abitype';\nimport { readContract } from '../../actions/public/readContract.js';\nimport { sendTransaction } from '../../actions/wallet/sendTransaction.js';\nimport { AccountNotFoundError } from '../../errors/account.js';\nimport { ChainNotFoundError } from '../../errors/chain.js';\nimport { decodeAbiParameters, encodeFunctionData, parseAccount, slice } from '../../utils/index.js';\nimport { WithdrawalLogNotFoundError } from '../errors/bridge.js';\nimport { getWithdrawalL2ToL1Log } from '../utils/bridge/getWithdrawalL2ToL1Log.js';\nimport { getWithdrawalLog } from '../utils/bridge/getWithdrawalLog.js';\nimport { getDefaultBridgeAddresses } from './getDefaultBridgeAddresses.js';\nimport { getLogProof } from './getLogProof.js';\n/**\n * Proves the inclusion of the `L2->L1` withdrawal message.\n *\n * @param client - Client to use\n * @param parameters - {@link FinalizeWithdrawalParameters}\n * @returns hash - The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link FinalizeWithdrawalReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet, zksync } from 'viem/chains'\n * import { finalizeWithdrawal, publicActionsL2 } from 'viem/zksync'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const clientL2 = createPublicClient({\n *   chain: zksync,\n *   transport: http(),\n * }).extend(publicActionsL2())\n *\n * const hash = await finalizeWithdrawal(client, {\n *     account: privateKeyToAccount('0x…'),\n *     client: clientL2,\n *     hash: '0x...',\n * })\n *\n * @example Account Hoisting\n * import { createPublicClient, createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet, zksync } from 'viem/chains'\n * import { finalizeWithdrawal, publicActionsL2 } from 'viem/zksync'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const clientL2 = createPublicClient({\n *   chain: zksync,\n *   transport: http(),\n * }).extend(publicActionsL2())\n *\n * const hash = await finalizeWithdrawal(client, {\n *     client: clientL2,\n *     hash: '0x…',\n * })\n */\nexport async function finalizeWithdrawal(client, parameters) {\n  const {\n      account: account_ = client.account,\n      client: l2Client,\n      hash,\n      index = 0\n    } = parameters,\n    rest = _objectWithoutProperties(parameters, _excluded);\n  const account = account_ ? parseAccount(account_) : client.account;\n  if (!account) throw new AccountNotFoundError({\n    docsPath: '/docs/actions/wallet/sendTransaction'\n  });\n  if (!l2Client.chain) throw new ChainNotFoundError();\n  const finalizeWithdrawalParams = await getFinalizeWithdrawalParams(l2Client, {\n    hash,\n    index\n  });\n  const l1Nullifier = (await getBridgeAddresses(client, l2Client)).l1Nullifier;\n  const data = encodeFunctionData({\n    abi: parseAbi(['function finalizeDeposit((uint256 chainId, uint256 l2BatchNumber, uint256 l2MessageIndex, address l2Sender, uint16 l2TxNumberInBatch, bytes message, bytes32[] merkleProof) _finalizeWithdrawalParams)']),\n    functionName: 'finalizeDeposit',\n    args: [{\n      chainId: BigInt(l2Client.chain.id),\n      l2BatchNumber: finalizeWithdrawalParams.l1BatchNumber,\n      l2MessageIndex: BigInt(finalizeWithdrawalParams.l2MessageIndex),\n      l2Sender: finalizeWithdrawalParams.sender,\n      l2TxNumberInBatch: Number(finalizeWithdrawalParams.l2TxNumberInBlock),\n      message: finalizeWithdrawalParams.message,\n      merkleProof: finalizeWithdrawalParams.proof\n    }]\n  });\n  return await sendTransaction(client, _objectSpread({\n    account,\n    to: l1Nullifier,\n    data\n  }, rest));\n}\nasync function getFinalizeWithdrawalParams(client, parameters) {\n  const {\n    hash\n  } = parameters;\n  const {\n    log,\n    l1BatchTxId\n  } = await getWithdrawalLog(client, parameters);\n  const {\n    l2ToL1LogIndex\n  } = await getWithdrawalL2ToL1Log(client, parameters);\n  const sender = slice(log.topics[1], 12);\n  const proof = await getLogProof(client, {\n    txHash: hash,\n    index: l2ToL1LogIndex\n  });\n  if (!proof) {\n    throw new WithdrawalLogNotFoundError({\n      hash\n    });\n  }\n  const [message] = decodeAbiParameters([{\n    type: 'bytes'\n  }], log.data);\n  return {\n    l1BatchNumber: log.l1BatchNumber,\n    l2MessageIndex: proof.id,\n    l2TxNumberInBlock: l1BatchTxId,\n    message,\n    sender,\n    proof: proof.proof\n  };\n}\nasync function getBridgeAddresses(client, l2Client) {\n  const addresses = await getDefaultBridgeAddresses(l2Client);\n  let l1Nullifier = addresses.l1Nullifier;\n  let l1NativeTokenVault = addresses.l1NativeTokenVault;\n  if (!l1Nullifier) l1Nullifier = await readContract(client, {\n    address: addresses.sharedL1,\n    abi: parseAbi(['function L1_NULLIFIER() view returns (address)']),\n    functionName: 'L1_NULLIFIER',\n    args: []\n  });\n  if (!l1NativeTokenVault) l1NativeTokenVault = await readContract(client, {\n    address: addresses.sharedL1,\n    abi: parseAbi(['function nativeTokenVault() view returns (address)']),\n    functionName: 'nativeTokenVault',\n    args: []\n  });\n  return _objectSpread(_objectSpread({}, addresses), {}, {\n    l1Nullifier,\n    l1NativeTokenVault\n  });\n}","map":{"version":3,"names":["parseAbi","readContract","sendTransaction","AccountNotFoundError","ChainNotFoundError","decodeAbiParameters","encodeFunctionData","parseAccount","slice","WithdrawalLogNotFoundError","getWithdrawalL2ToL1Log","getWithdrawalLog","getDefaultBridgeAddresses","getLogProof","finalizeWithdrawal","client","parameters","account","account_","l2Client","hash","index","rest","_objectWithoutProperties","_excluded","docsPath","chain","finalizeWithdrawalParams","getFinalizeWithdrawalParams","l1Nullifier","getBridgeAddresses","data","abi","functionName","args","chainId","BigInt","id","l2BatchNumber","l1BatchNumber","l2MessageIndex","l2Sender","sender","l2TxNumberInBatch","Number","l2TxNumberInBlock","message","merkleProof","proof","_objectSpread","to","log","l1BatchTxId","l2ToL1LogIndex","topics","txHash","type","addresses","l1NativeTokenVault","address","sharedL1"],"sources":["/home/user/Arbitrage/frontend/node_modules/viem/zksync/actions/finalizeWithdrawal.ts"],"sourcesContent":["import { type Address, parseAbi } from 'abitype'\nimport type { Account } from '../../accounts/types.js'\nimport { readContract } from '../../actions/public/readContract.js'\nimport {\n  type SendTransactionErrorType,\n  type SendTransactionParameters,\n  type SendTransactionRequest,\n  type SendTransactionReturnType,\n  sendTransaction,\n} from '../../actions/wallet/sendTransaction.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../errors/account.js'\nimport {\n  ChainNotFoundError,\n  type ChainNotFoundErrorType,\n} from '../../errors/chain.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport {\n  decodeAbiParameters,\n  encodeFunctionData,\n  parseAccount,\n  slice,\n} from '../../utils/index.js'\nimport {\n  WithdrawalLogNotFoundError,\n  type WithdrawalLogNotFoundErrorType,\n} from '../errors/bridge.js'\nimport type { ChainEIP712 } from '../types/chain.js'\nimport type { BridgeContractAddresses } from '../types/contract.js'\nimport { getWithdrawalL2ToL1Log } from '../utils/bridge/getWithdrawalL2ToL1Log.js'\nimport { getWithdrawalLog } from '../utils/bridge/getWithdrawalLog.js'\nimport { getDefaultBridgeAddresses } from './getDefaultBridgeAddresses.js'\nimport { getLogProof } from './getLogProof.js'\n\nexport type FinalizeWithdrawalParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  chainL2 extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  accountL2 extends Account | undefined = Account | undefined,\n  request extends SendTransactionRequest<\n    chain,\n    chainOverride\n  > = SendTransactionRequest<chain, chainOverride>,\n> = Omit<\n  SendTransactionParameters<chain, account, chainOverride, request>,\n  'value' | 'data' | 'to'\n> & {\n  /** L2 client */\n  client: Client<Transport, chainL2, accountL2>\n  /** Hash of the L2 transaction where the withdrawal was initiated. */\n  hash: Hex\n  /** In case there were multiple withdrawals in one transaction, you may pass an index of the\n   withdrawal you want to finalize. */\n  index?: number | undefined\n}\n\nexport type FinalizeWithdrawalReturnType = SendTransactionReturnType\n\nexport type FinalizeWithdrawalErrorType =\n  | SendTransactionErrorType\n  | WithdrawalLogNotFoundErrorType\n  | ChainNotFoundErrorType\n\n/**\n * Proves the inclusion of the `L2->L1` withdrawal message.\n *\n * @param client - Client to use\n * @param parameters - {@link FinalizeWithdrawalParameters}\n * @returns hash - The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link FinalizeWithdrawalReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet, zksync } from 'viem/chains'\n * import { finalizeWithdrawal, publicActionsL2 } from 'viem/zksync'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const clientL2 = createPublicClient({\n *   chain: zksync,\n *   transport: http(),\n * }).extend(publicActionsL2())\n *\n * const hash = await finalizeWithdrawal(client, {\n *     account: privateKeyToAccount('0x…'),\n *     client: clientL2,\n *     hash: '0x...',\n * })\n *\n * @example Account Hoisting\n * import { createPublicClient, createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet, zksync } from 'viem/chains'\n * import { finalizeWithdrawal, publicActionsL2 } from 'viem/zksync'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const clientL2 = createPublicClient({\n *   chain: zksync,\n *   transport: http(),\n * }).extend(publicActionsL2())\n *\n * const hash = await finalizeWithdrawal(client, {\n *     client: clientL2,\n *     hash: '0x…',\n * })\n */\nexport async function finalizeWithdrawal<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  accountL2 extends Account | undefined,\n  const request extends SendTransactionRequest<chain, chainOverride>,\n  chainOverride extends Chain | undefined,\n  chainL2 extends ChainEIP712 | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: FinalizeWithdrawalParameters<\n    chain,\n    account,\n    chainOverride,\n    chainL2,\n    accountL2,\n    request\n  >,\n): Promise<FinalizeWithdrawalReturnType> {\n  const {\n    account: account_ = client.account,\n    client: l2Client,\n    hash,\n    index = 0,\n    ...rest\n  } = parameters\n  const account = account_ ? parseAccount(account_) : client.account\n  if (!account)\n    throw new AccountNotFoundError({\n      docsPath: '/docs/actions/wallet/sendTransaction',\n    })\n  if (!l2Client.chain) throw new ChainNotFoundError()\n\n  const finalizeWithdrawalParams = await getFinalizeWithdrawalParams(l2Client, {\n    hash,\n    index,\n  })\n\n  const l1Nullifier = (await getBridgeAddresses(client, l2Client)).l1Nullifier\n\n  const data = encodeFunctionData({\n    abi: parseAbi([\n      'function finalizeDeposit((uint256 chainId, uint256 l2BatchNumber, uint256 l2MessageIndex, address l2Sender, uint16 l2TxNumberInBatch, bytes message, bytes32[] merkleProof) _finalizeWithdrawalParams)',\n    ]),\n    functionName: 'finalizeDeposit',\n    args: [\n      {\n        chainId: BigInt(l2Client.chain.id),\n        l2BatchNumber: finalizeWithdrawalParams.l1BatchNumber!,\n        l2MessageIndex: BigInt(finalizeWithdrawalParams.l2MessageIndex),\n        l2Sender: finalizeWithdrawalParams.sender,\n        l2TxNumberInBatch: Number(finalizeWithdrawalParams.l2TxNumberInBlock),\n        message: finalizeWithdrawalParams.message,\n        merkleProof: finalizeWithdrawalParams.proof,\n      },\n    ],\n  })\n\n  return await sendTransaction(client, {\n    account,\n    to: l1Nullifier,\n    data,\n    ...rest,\n  } as SendTransactionParameters)\n}\n\nasync function getFinalizeWithdrawalParams<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: { hash: Hex; index: number },\n) {\n  const { hash } = parameters\n  const { log, l1BatchTxId } = await getWithdrawalLog(client, parameters)\n  const { l2ToL1LogIndex } = await getWithdrawalL2ToL1Log(client, parameters)\n  const sender = slice(log.topics[1]!, 12) as Address\n  const proof = await getLogProof(client, {\n    txHash: hash,\n    index: l2ToL1LogIndex!,\n  })\n  if (!proof) {\n    throw new WithdrawalLogNotFoundError({ hash })\n  }\n\n  const [message] = decodeAbiParameters([{ type: 'bytes' }], log.data)\n\n  return {\n    l1BatchNumber: log.l1BatchNumber,\n    l2MessageIndex: proof.id,\n    l2TxNumberInBlock: l1BatchTxId,\n    message,\n    sender,\n    proof: proof.proof,\n  }\n}\n\nasync function getBridgeAddresses<\n  chain extends Chain | undefined,\n  chainL2 extends ChainEIP712 | undefined,\n>(\n  client: Client<Transport, chain>,\n  l2Client: Client<Transport, chainL2>,\n): Promise<\n  BridgeContractAddresses & {\n    l1Nullifier: Address\n    l1NativeTokenVault: Address\n  }\n> {\n  const addresses = await getDefaultBridgeAddresses(l2Client)\n  let l1Nullifier = addresses.l1Nullifier\n  let l1NativeTokenVault = addresses.l1NativeTokenVault\n\n  if (!l1Nullifier)\n    l1Nullifier = await readContract(client, {\n      address: addresses.sharedL1,\n      abi: parseAbi(['function L1_NULLIFIER() view returns (address)']),\n      functionName: 'L1_NULLIFIER',\n      args: [],\n    })\n  if (!l1NativeTokenVault)\n    l1NativeTokenVault = await readContract(client, {\n      address: addresses.sharedL1,\n      abi: parseAbi(['function nativeTokenVault() view returns (address)']),\n      functionName: 'nativeTokenVault',\n      args: [],\n    })\n\n  return {\n    ...addresses,\n    l1Nullifier,\n    l1NativeTokenVault,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}