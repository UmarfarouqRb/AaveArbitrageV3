{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"account\", \"chain\", \"client\", \"contractAddress\", \"calldata\", \"l2Value\", \"mintValue\", \"operatorTip\", \"factoryDeps\", \"gasPerPubdataByte\", \"refundRecipient\", \"l2GasLimit\", \"value\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\"];\nimport { generatePrivateKey } from '../../accounts/generatePrivateKey.js';\nimport { privateKeyToAddress } from '../../accounts/utils/privateKeyToAddress.js';\nimport { readContract } from '../../actions/public/readContract.js';\nimport { sendTransaction } from '../../actions/wallet/sendTransaction.js';\nimport { publicActions } from '../../clients/decorators/public.js';\nimport { AccountNotFoundError } from '../../errors/account.js';\nimport { ClientChainNotConfiguredError } from '../../errors/chain.js';\nimport { encodeFunctionData, isAddressEqual, parseAccount } from '../../utils/index.js';\nimport { bridgehubAbi } from '../constants/abis.js';\nimport { ethAddressInContracts } from '../constants/address.js';\nimport { requiredL1ToL2GasPerPubdataLimit } from '../constants/number.js';\nimport { BaseFeeHigherThanValueError } from '../errors/bridge.js';\nimport { estimateGasL1ToL2 } from './estimateGasL1ToL2.js';\nimport { getBridgehubContractAddress } from './getBridgehubContractAddress.js';\n/**\n * Requests execution of a L2 transaction from L1.\n *\n * @param client - Client to use\n * @param parameters - {@link RequestExecuteParameters}\n * @returns hash - The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link RequestExecuteReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { zksync, mainnet } from 'viem/chains'\n * import { requestExecute, publicActionsL2 } from 'viem/zksync'\n *\n * const client = createPublicClient({\n *     chain: mainnet,\n *     transport: http(),\n * })\n *\n * const clientL2 = createPublicClient({\n *   chain: zksync,\n *   transport: http(),\n * }).extend(publicActionsL2())\n *\n * const hash = await requestExecute(client, {\n *     client: clientL2,\n *     account: privateKeyToAccount('0x…'),\n *     contractAddress: '0x43020e6e11cef7dce8e37baa09d9a996ac722057'\n *     calldata: '0x',\n *     l2Value: 1_000_000_000_000_000_000n,\n * })\n *\n * @example Account Hoisting\n * import { createPublicClient, createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { zksync, mainnet } from 'viem/chains'\n * import { requestExecute, publicActionsL2 } from 'viem/zksync'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const clientL2 = createPublicClient({\n *   chain: zksync,\n *   transport: http(),\n * }).extend(publicActionsL2())\n *\n * const hash = await requestExecute(client, {\n *     client: clientL2,\n *     contractAddress: '0x43020e6e11cef7dce8e37baa09d9a996ac722057'\n *     calldata: '0x',\n *     l2Value: 1_000_000_000_000_000_000n,\n * })\n */\nexport async function requestExecute(client, parameters) {\n  var _l2Client$account;\n  let {\n      account: account_ = client.account,\n      chain: chain_ = client.chain,\n      client: l2Client,\n      contractAddress,\n      calldata,\n      l2Value = 0n,\n      mintValue = 0n,\n      operatorTip = 0n,\n      factoryDeps = [],\n      gasPerPubdataByte = requiredL1ToL2GasPerPubdataLimit,\n      refundRecipient,\n      l2GasLimit,\n      value,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas\n    } = parameters,\n    rest = _objectWithoutProperties(parameters, _excluded);\n  const account = account_ ? parseAccount(account_) : client.account;\n  if (!account) throw new AccountNotFoundError({\n    docsPath: '/docs/actions/wallet/sendTransaction'\n  });\n  if (!l2Client.chain) throw new ClientChainNotConfiguredError();\n  const bridgehub = await getBridgehubContractAddress(l2Client);\n  const baseToken = await readContract(client, {\n    address: bridgehub,\n    abi: bridgehubAbi,\n    functionName: 'baseToken',\n    args: [BigInt(l2Client.chain.id)]\n  });\n  const isETHBasedChain = isAddressEqual(baseToken, ethAddressInContracts);\n  refundRecipient !== null && refundRecipient !== void 0 ? refundRecipient : refundRecipient = account.address;\n  l2GasLimit !== null && l2GasLimit !== void 0 ? l2GasLimit : l2GasLimit = await estimateGasL1ToL2(l2Client, {\n    chain: l2Client.chain,\n    // If the `from` address is not provided, we use a random address, because\n    // due to storage slot aggregation, the gas estimation will depend on the address\n    // and so estimation for the zero address may be smaller than for the sender.\n    account: (_l2Client$account = l2Client.account) !== null && _l2Client$account !== void 0 ? _l2Client$account : parseAccount(privateKeyToAddress(generatePrivateKey())),\n    data: calldata,\n    to: contractAddress,\n    value: l2Value,\n    gasPerPubdata: gasPerPubdataByte,\n    factoryDeps\n  });\n  let gasPriceForEstimation = maxFeePerGas || gasPrice;\n  if (!gasPriceForEstimation) {\n    const estimatedFee = await getFeePrice(client);\n    gasPriceForEstimation = estimatedFee.maxFeePerGas;\n    maxFeePerGas = estimatedFee.maxFeePerGas;\n    maxPriorityFeePerGas !== null && maxPriorityFeePerGas !== void 0 ? maxPriorityFeePerGas : maxPriorityFeePerGas = estimatedFee.maxPriorityFeePerGas;\n  }\n  const baseCost = await readContract(client, {\n    address: bridgehub,\n    abi: bridgehubAbi,\n    functionName: 'l2TransactionBaseCost',\n    args: [BigInt(l2Client.chain.id), gasPriceForEstimation, l2GasLimit, gasPerPubdataByte]\n  });\n  const l2Costs = baseCost + operatorTip + l2Value;\n  let providedValue = isETHBasedChain ? value : mintValue;\n  if (!providedValue || providedValue === 0n) {\n    providedValue = l2Costs;\n  }\n  if (baseCost > providedValue) throw new BaseFeeHigherThanValueError(baseCost, providedValue);\n  const data = encodeFunctionData({\n    abi: bridgehubAbi,\n    functionName: 'requestL2TransactionDirect',\n    args: [{\n      chainId: BigInt(l2Client.chain.id),\n      mintValue: providedValue,\n      l2Contract: contractAddress,\n      l2Value: l2Value,\n      l2Calldata: calldata,\n      l2GasLimit: l2GasLimit,\n      l2GasPerPubdataByteLimit: gasPerPubdataByte,\n      factoryDeps: factoryDeps,\n      refundRecipient: refundRecipient\n    }]\n  });\n  return await sendTransaction(client, _objectSpread({\n    chain: chain_,\n    account: account,\n    to: bridgehub,\n    value: isETHBasedChain ? providedValue : value,\n    data,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas\n  }, rest));\n}\nasync function getFeePrice(client) {\n  const client_ = client.extend(publicActions);\n  const block = await client_.getBlock();\n  const baseFee = typeof block.baseFeePerGas !== 'bigint' ? await client_.getGasPrice() : block.baseFeePerGas;\n  const maxPriorityFeePerGas = await client_.estimateMaxPriorityFeePerGas();\n  return {\n    maxFeePerGas: baseFee * 3n / 2n + maxPriorityFeePerGas,\n    maxPriorityFeePerGas: maxPriorityFeePerGas\n  };\n}","map":{"version":3,"names":["generatePrivateKey","privateKeyToAddress","readContract","sendTransaction","publicActions","AccountNotFoundError","ClientChainNotConfiguredError","encodeFunctionData","isAddressEqual","parseAccount","bridgehubAbi","ethAddressInContracts","requiredL1ToL2GasPerPubdataLimit","BaseFeeHigherThanValueError","estimateGasL1ToL2","getBridgehubContractAddress","requestExecute","client","parameters","_l2Client$account","account","account_","chain","chain_","l2Client","contractAddress","calldata","l2Value","mintValue","operatorTip","factoryDeps","gasPerPubdataByte","refundRecipient","l2GasLimit","value","gasPrice","maxFeePerGas","maxPriorityFeePerGas","rest","_objectWithoutProperties","_excluded","docsPath","bridgehub","baseToken","address","abi","functionName","args","BigInt","id","isETHBasedChain","data","to","gasPerPubdata","gasPriceForEstimation","estimatedFee","getFeePrice","baseCost","l2Costs","providedValue","chainId","l2Contract","l2Calldata","l2GasPerPubdataByteLimit","_objectSpread","client_","extend","block","getBlock","baseFee","baseFeePerGas","getGasPrice","estimateMaxPriorityFeePerGas"],"sources":["/home/user/Arbitrage/frontend/node_modules/viem/zksync/actions/requestExecute.ts"],"sourcesContent":["import type { Address } from 'abitype'\nimport { generatePrivateKey } from '../../accounts/generatePrivateKey.js'\nimport type { Account } from '../../accounts/types.js'\nimport { privateKeyToAddress } from '../../accounts/utils/privateKeyToAddress.js'\nimport { readContract } from '../../actions/public/readContract.js'\nimport {\n  type SendTransactionErrorType,\n  type SendTransactionParameters,\n  type SendTransactionReturnType,\n  sendTransaction,\n} from '../../actions/wallet/sendTransaction.js'\nimport type { Client } from '../../clients/createClient.js'\nimport { publicActions } from '../../clients/decorators/public.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../errors/account.js'\nimport { ClientChainNotConfiguredError } from '../../errors/chain.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { UnionEvaluate, UnionOmit } from '../../types/utils.js'\nimport {\n  encodeFunctionData,\n  type FormattedTransactionRequest,\n  isAddressEqual,\n  parseAccount,\n} from '../../utils/index.js'\nimport { bridgehubAbi } from '../constants/abis.js'\nimport { ethAddressInContracts } from '../constants/address.js'\nimport { requiredL1ToL2GasPerPubdataLimit } from '../constants/number.js'\nimport {\n  BaseFeeHigherThanValueError,\n  type BaseFeeHigherThanValueErrorType,\n} from '../errors/bridge.js'\nimport type { ChainEIP712 } from '../types/chain.js'\nimport { estimateGasL1ToL2 } from './estimateGasL1ToL2.js'\nimport { getBridgehubContractAddress } from './getBridgehubContractAddress.js'\n\nexport type RequestExecuteParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  chainL2 extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  accountL2 extends Account | undefined = Account | undefined,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = UnionEvaluate<\n  UnionOmit<FormattedTransactionRequest<_derivedChain>, 'data' | 'to' | 'from'>\n> &\n  Partial<GetChainParameter<chain, chainOverride>> &\n  Partial<GetAccountParameter<account>> & {\n    /** L2 client. */\n    client: Client<Transport, chainL2, accountL2>\n    /** The L2 contract to be called. */\n    contractAddress: Address\n    /** The input of the L2 transaction. */\n    calldata: Hex\n    /** Maximum amount of L2 gas that transaction can consume during execution on L2. */\n    l2GasLimit?: bigint | undefined\n    /** The amount of base token that needs to be minted on non-ETH-based L2. */\n    mintValue?: bigint | undefined\n    /** The `msg.value` of L2 transaction. */\n    l2Value?: bigint | undefined\n    /** An array of L2 bytecodes that will be marked as known on L2. */\n    factoryDeps?: Hex[] | undefined\n    /** (currently not used) The tip the operator will receive on top of\n     the base cost of the transaction. */\n    operatorTip?: bigint | undefined\n    /** The L2 gas price for each published L1 calldata byte. */\n    gasPerPubdataByte?: bigint | undefined\n    /** The address on L2 that will receive the refund for the transaction.\n     If the transaction fails, it will also be the address to receive `l2Value`. */\n    refundRecipient?: Address | undefined\n  }\n\nexport type RequestExecuteReturnType = SendTransactionReturnType\n\nexport type RequestExecuteErrorType =\n  | SendTransactionErrorType\n  | BaseFeeHigherThanValueErrorType\n\n/**\n * Requests execution of a L2 transaction from L1.\n *\n * @param client - Client to use\n * @param parameters - {@link RequestExecuteParameters}\n * @returns hash - The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link RequestExecuteReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { zksync, mainnet } from 'viem/chains'\n * import { requestExecute, publicActionsL2 } from 'viem/zksync'\n *\n * const client = createPublicClient({\n *     chain: mainnet,\n *     transport: http(),\n * })\n *\n * const clientL2 = createPublicClient({\n *   chain: zksync,\n *   transport: http(),\n * }).extend(publicActionsL2())\n *\n * const hash = await requestExecute(client, {\n *     client: clientL2,\n *     account: privateKeyToAccount('0x…'),\n *     contractAddress: '0x43020e6e11cef7dce8e37baa09d9a996ac722057'\n *     calldata: '0x',\n *     l2Value: 1_000_000_000_000_000_000n,\n * })\n *\n * @example Account Hoisting\n * import { createPublicClient, createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { zksync, mainnet } from 'viem/chains'\n * import { requestExecute, publicActionsL2 } from 'viem/zksync'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const clientL2 = createPublicClient({\n *   chain: zksync,\n *   transport: http(),\n * }).extend(publicActionsL2())\n *\n * const hash = await requestExecute(client, {\n *     client: clientL2,\n *     contractAddress: '0x43020e6e11cef7dce8e37baa09d9a996ac722057'\n *     calldata: '0x',\n *     l2Value: 1_000_000_000_000_000_000n,\n * })\n */\nexport async function requestExecute<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  chainL2 extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  accountL2 extends Account | undefined = Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: RequestExecuteParameters<\n    chain,\n    account,\n    chainOverride,\n    chainL2,\n    accountL2\n  >,\n): Promise<RequestExecuteReturnType> {\n  let {\n    account: account_ = client.account,\n    chain: chain_ = client.chain,\n    client: l2Client,\n    contractAddress,\n    calldata,\n    l2Value = 0n,\n    mintValue = 0n,\n    operatorTip = 0n,\n    factoryDeps = [],\n    gasPerPubdataByte = requiredL1ToL2GasPerPubdataLimit,\n    refundRecipient,\n    l2GasLimit,\n    value,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    ...rest\n  } = parameters\n\n  const account = account_ ? parseAccount(account_) : client.account\n  if (!account)\n    throw new AccountNotFoundError({\n      docsPath: '/docs/actions/wallet/sendTransaction',\n    })\n  if (!l2Client.chain) throw new ClientChainNotConfiguredError()\n\n  const bridgehub = await getBridgehubContractAddress(l2Client)\n  const baseToken = await readContract(client, {\n    address: bridgehub,\n    abi: bridgehubAbi,\n    functionName: 'baseToken',\n    args: [BigInt(l2Client.chain.id)],\n  })\n  const isETHBasedChain = isAddressEqual(baseToken, ethAddressInContracts)\n\n  refundRecipient ??= account.address\n  l2GasLimit ??= await estimateGasL1ToL2(l2Client, {\n    chain: l2Client.chain,\n    // If the `from` address is not provided, we use a random address, because\n    // due to storage slot aggregation, the gas estimation will depend on the address\n    // and so estimation for the zero address may be smaller than for the sender.\n    account:\n      l2Client.account ??\n      parseAccount(privateKeyToAddress(generatePrivateKey())),\n    data: calldata,\n    to: contractAddress,\n    value: l2Value,\n    gasPerPubdata: gasPerPubdataByte,\n    factoryDeps,\n  })\n\n  let gasPriceForEstimation = maxFeePerGas || gasPrice\n  if (!gasPriceForEstimation) {\n    const estimatedFee = await getFeePrice(client)\n    gasPriceForEstimation = estimatedFee.maxFeePerGas\n    maxFeePerGas = estimatedFee.maxFeePerGas\n    maxPriorityFeePerGas ??= estimatedFee.maxPriorityFeePerGas\n  }\n\n  const baseCost = await readContract(client, {\n    address: bridgehub,\n    abi: bridgehubAbi,\n    functionName: 'l2TransactionBaseCost',\n    args: [\n      BigInt(l2Client.chain.id),\n      gasPriceForEstimation,\n      l2GasLimit,\n      gasPerPubdataByte,\n    ],\n  })\n\n  const l2Costs = baseCost + operatorTip + l2Value\n  let providedValue = isETHBasedChain ? value : mintValue\n  if (!providedValue || providedValue === 0n) {\n    providedValue = l2Costs\n  }\n\n  if (baseCost > providedValue)\n    throw new BaseFeeHigherThanValueError(baseCost, providedValue)\n\n  const data = encodeFunctionData({\n    abi: bridgehubAbi,\n    functionName: 'requestL2TransactionDirect',\n    args: [\n      {\n        chainId: BigInt(l2Client.chain.id),\n        mintValue: providedValue,\n        l2Contract: contractAddress,\n        l2Value: l2Value,\n        l2Calldata: calldata,\n        l2GasLimit: l2GasLimit,\n        l2GasPerPubdataByteLimit: gasPerPubdataByte,\n        factoryDeps: factoryDeps,\n        refundRecipient: refundRecipient,\n      },\n    ],\n  })\n\n  return await sendTransaction(client, {\n    chain: chain_,\n    account: account,\n    to: bridgehub,\n    value: isETHBasedChain ? providedValue : value,\n    data,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    ...rest,\n  } as SendTransactionParameters)\n}\n\nasync function getFeePrice<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n) {\n  const client_ = client.extend(publicActions)\n  const block = await client_.getBlock()\n  const baseFee =\n    typeof block.baseFeePerGas !== 'bigint'\n      ? await client_.getGasPrice()\n      : block.baseFeePerGas\n  const maxPriorityFeePerGas = await client_.estimateMaxPriorityFeePerGas()\n\n  return {\n    maxFeePerGas: (baseFee * 3n) / 2n + maxPriorityFeePerGas,\n    maxPriorityFeePerGas: maxPriorityFeePerGas,\n  }\n}\n"],"mappings":";;;AACA,SAASA,kBAAkB,QAAQ,sCAAsC;AAEzE,SAASC,mBAAmB,QAAQ,6CAA6C;AACjF,SAASC,YAAY,QAAQ,sCAAsC;AACnE,SAIEC,eAAe,QACV,yCAAyC;AAEhD,SAASC,aAAa,QAAQ,oCAAoC;AAElE,SAASC,oBAAoB,QAAQ,yBAAyB;AAC9D,SAASC,6BAA6B,QAAQ,uBAAuB;AASrE,SACEC,kBAAkB,EAElBC,cAAc,EACdC,YAAY,QACP,sBAAsB;AAC7B,SAASC,YAAY,QAAQ,sBAAsB;AACnD,SAASC,qBAAqB,QAAQ,yBAAyB;AAC/D,SAASC,gCAAgC,QAAQ,wBAAwB;AACzE,SACEC,2BAA2B,QAEtB,qBAAqB;AAE5B,SAASC,iBAAiB,QAAQ,wBAAwB;AAC1D,SAASC,2BAA2B,QAAQ,kCAAkC;AA4C9E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuDA,OAAO,eAAeC,cAAcA,CAOlCC,MAAyC,EACzCC,UAMC;EAAA,IAAAC,iBAAA;EAED,IAAI;MACFC,OAAO,EAAEC,QAAQ,GAAGJ,MAAM,CAACG,OAAO;MAClCE,KAAK,EAAEC,MAAM,GAAGN,MAAM,CAACK,KAAK;MAC5BL,MAAM,EAAEO,QAAQ;MAChBC,eAAe;MACfC,QAAQ;MACRC,OAAO,GAAG,EAAE;MACZC,SAAS,GAAG,EAAE;MACdC,WAAW,GAAG,EAAE;MAChBC,WAAW,GAAG,EAAE;MAChBC,iBAAiB,GAAGnB,gCAAgC;MACpDoB,eAAe;MACfC,UAAU;MACVC,KAAK;MACLC,QAAQ;MACRC,YAAY;MACZC;IACO,CACR,GAAGnB,UAAU;IADToB,IAAI,GAAAC,wBAAA,CACLrB,UAAU,EAAAsB,SAAA;EAEd,MAAMpB,OAAO,GAAGC,QAAQ,GAAGZ,YAAY,CAACY,QAAQ,CAAC,GAAGJ,MAAM,CAACG,OAAO;EAClE,IAAI,CAACA,OAAO,EACV,MAAM,IAAIf,oBAAoB,CAAC;IAC7BoC,QAAQ,EAAE;GACX,CAAC;EACJ,IAAI,CAACjB,QAAQ,CAACF,KAAK,EAAE,MAAM,IAAIhB,6BAA6B,EAAE;EAE9D,MAAMoC,SAAS,GAAG,MAAM3B,2BAA2B,CAACS,QAAQ,CAAC;EAC7D,MAAMmB,SAAS,GAAG,MAAMzC,YAAY,CAACe,MAAM,EAAE;IAC3C2B,OAAO,EAAEF,SAAS;IAClBG,GAAG,EAAEnC,YAAY;IACjBoC,YAAY,EAAE,WAAW;IACzBC,IAAI,EAAE,CAACC,MAAM,CAACxB,QAAQ,CAACF,KAAK,CAAC2B,EAAE,CAAC;GACjC,CAAC;EACF,MAAMC,eAAe,GAAG1C,cAAc,CAACmC,SAAS,EAAEhC,qBAAqB,CAAC;EAExEqB,eAAe,aAAfA,eAAe,cAAfA,eAAe,GAAfA,eAAe,GAAKZ,OAAO,CAACwB,OAAO;EACnCX,UAAU,aAAVA,UAAU,cAAVA,UAAU,GAAVA,UAAU,GAAK,MAAMnB,iBAAiB,CAACU,QAAQ,EAAE;IAC/CF,KAAK,EAAEE,QAAQ,CAACF,KAAK;IACrB;IACA;IACA;IACAF,OAAO,GAAAD,iBAAA,GACLK,QAAQ,CAACJ,OAAO,cAAAD,iBAAA,cAAAA,iBAAA,GAChBV,YAAY,CAACR,mBAAmB,CAACD,kBAAkB,EAAE,CAAC,CAAC;IACzDmD,IAAI,EAAEzB,QAAQ;IACd0B,EAAE,EAAE3B,eAAe;IACnBS,KAAK,EAAEP,OAAO;IACd0B,aAAa,EAAEtB,iBAAiB;IAChCD;GACD,CAAC;EAEF,IAAIwB,qBAAqB,GAAGlB,YAAY,IAAID,QAAQ;EACpD,IAAI,CAACmB,qBAAqB,EAAE;IAC1B,MAAMC,YAAY,GAAG,MAAMC,WAAW,CAACvC,MAAM,CAAC;IAC9CqC,qBAAqB,GAAGC,YAAY,CAACnB,YAAY;IACjDA,YAAY,GAAGmB,YAAY,CAACnB,YAAY;IACxCC,oBAAoB,aAApBA,oBAAoB,cAApBA,oBAAoB,GAApBA,oBAAoB,GAAKkB,YAAY,CAAClB,oBAAoB;EAC5D;EAEA,MAAMoB,QAAQ,GAAG,MAAMvD,YAAY,CAACe,MAAM,EAAE;IAC1C2B,OAAO,EAAEF,SAAS;IAClBG,GAAG,EAAEnC,YAAY;IACjBoC,YAAY,EAAE,uBAAuB;IACrCC,IAAI,EAAE,CACJC,MAAM,CAACxB,QAAQ,CAACF,KAAK,CAAC2B,EAAE,CAAC,EACzBK,qBAAqB,EACrBrB,UAAU,EACVF,iBAAiB;GAEpB,CAAC;EAEF,MAAM2B,OAAO,GAAGD,QAAQ,GAAG5B,WAAW,GAAGF,OAAO;EAChD,IAAIgC,aAAa,GAAGT,eAAe,GAAGhB,KAAK,GAAGN,SAAS;EACvD,IAAI,CAAC+B,aAAa,IAAIA,aAAa,KAAK,EAAE,EAAE;IAC1CA,aAAa,GAAGD,OAAO;EACzB;EAEA,IAAID,QAAQ,GAAGE,aAAa,EAC1B,MAAM,IAAI9C,2BAA2B,CAAC4C,QAAQ,EAAEE,aAAa,CAAC;EAEhE,MAAMR,IAAI,GAAG5C,kBAAkB,CAAC;IAC9BsC,GAAG,EAAEnC,YAAY;IACjBoC,YAAY,EAAE,4BAA4B;IAC1CC,IAAI,EAAE,CACJ;MACEa,OAAO,EAAEZ,MAAM,CAACxB,QAAQ,CAACF,KAAK,CAAC2B,EAAE,CAAC;MAClCrB,SAAS,EAAE+B,aAAa;MACxBE,UAAU,EAAEpC,eAAe;MAC3BE,OAAO,EAAEA,OAAO;MAChBmC,UAAU,EAAEpC,QAAQ;MACpBO,UAAU,EAAEA,UAAU;MACtB8B,wBAAwB,EAAEhC,iBAAiB;MAC3CD,WAAW,EAAEA,WAAW;MACxBE,eAAe,EAAEA;KAClB;GAEJ,CAAC;EAEF,OAAO,MAAM7B,eAAe,CAACc,MAAM,EAAA+C,aAAA;IACjC1C,KAAK,EAAEC,MAAM;IACbH,OAAO,EAAEA,OAAO;IAChBgC,EAAE,EAAEV,SAAS;IACbR,KAAK,EAAEgB,eAAe,GAAGS,aAAa,GAAGzB,KAAK;IAC9CiB,IAAI;IACJhB,QAAQ;IACRC,YAAY;IACZC;EAAoB,GACjBC,IAAI,CACqB,CAAC;AACjC;AAEA,eAAekB,WAAWA,CACxBvC,MAAgC;EAEhC,MAAMgD,OAAO,GAAGhD,MAAM,CAACiD,MAAM,CAAC9D,aAAa,CAAC;EAC5C,MAAM+D,KAAK,GAAG,MAAMF,OAAO,CAACG,QAAQ,EAAE;EACtC,MAAMC,OAAO,GACX,OAAOF,KAAK,CAACG,aAAa,KAAK,QAAQ,GACnC,MAAML,OAAO,CAACM,WAAW,EAAE,GAC3BJ,KAAK,CAACG,aAAa;EACzB,MAAMjC,oBAAoB,GAAG,MAAM4B,OAAO,CAACO,4BAA4B,EAAE;EAEzE,OAAO;IACLpC,YAAY,EAAGiC,OAAO,GAAG,EAAE,GAAI,EAAE,GAAGhC,oBAAoB;IACxDA,oBAAoB,EAAEA;GACvB;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}