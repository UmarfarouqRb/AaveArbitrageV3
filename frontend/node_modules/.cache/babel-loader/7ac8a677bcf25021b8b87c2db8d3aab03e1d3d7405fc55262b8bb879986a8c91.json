{"ast":null,"code":"// ADAPTED FROM https://github.com/merkletreejs/merkletreejs\nimport { uint8ArrayToHex } from \"../utils/encoding/hex.js\";\nimport { hexToBytes } from \"../utils/encoding/to-bytes.js\";\nimport { keccak256 } from \"../utils/hashing/keccak256.js\";\nimport { areUint8ArraysEqual, compareUint8Arrays, concatUint8Arrays } from \"../utils/uint8-array.js\";\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */\nexport class MerkleTree {\n  constructor(leaves) {\n    Object.defineProperty(this, \"leaves\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"layers\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    this.leaves = leaves.map(el => el instanceof Uint8Array ? el : hexToBytes(el));\n    this.leaves = this.leaves.sort(compareUint8Arrays);\n    this.createHashes(this.leaves);\n  }\n  getHexRoot() {\n    return uint8ArrayToHex(this.getRoot());\n  }\n  getHexProof(leaf, index) {\n    return this.getProof(leaf, index).map(item => uint8ArrayToHex(item.data));\n  }\n  // private below\n  createHashes(nodes) {\n    this.layers = [nodes];\n    while (nodes.length > 1) {\n      const layerIndex = this.layers.length;\n      this.layers.push([]);\n      const layerLimit = nodes.length;\n      for (let i = 0; i < nodes.length; i += 2) {\n        if (i >= layerLimit) {\n          // biome-ignore lint/style/noNonNullAssertion: in bounds\n          this.layers[layerIndex].push(...nodes.slice(layerLimit));\n          break;\n        }\n        if (i + 1 === nodes.length) {\n          if (nodes.length % 2 === 1) {\n            // push copy of hash and continue iteration\n            // biome-ignore lint/style/noNonNullAssertion: in bounds\n            this.layers[layerIndex].push(nodes[i]);\n            continue;\n          }\n        }\n        // biome-ignore lint/style/noNonNullAssertion: in bounds\n        const left = nodes[i];\n        // biome-ignore lint/style/noNonNullAssertion: in bounds\n        const right = i + 1 === nodes.length ? left : nodes[i + 1];\n        const combined = [left, right];\n        combined.sort(compareUint8Arrays);\n        const hash = keccak256(concatUint8Arrays(combined), \"bytes\");\n        // biome-ignore lint/style/noNonNullAssertion: in bounds\n        this.layers[layerIndex].push(hash);\n      }\n      // biome-ignore lint/style/noParameterAssign: part of the functionality\n      // biome-ignore lint/style/noNonNullAssertion: in bounds\n      nodes = this.layers[layerIndex];\n    }\n  }\n  getRoot() {\n    if (this.layers.length === 0) {\n      return new Uint8Array();\n    }\n    // biome-ignore lint/style/noNonNullAssertion: in bounds\n    return this.layers[this.layers.length - 1][0] || new Uint8Array();\n  }\n  getProof(leaf, index) {\n    if (typeof leaf === \"undefined\") {\n      throw new Error(\"leaf is required\");\n    }\n    leaf = leaf instanceof Uint8Array ? leaf : hexToBytes(leaf);\n    const proof = [];\n    if (!Number.isInteger(index)) {\n      index = -1;\n      for (let i = 0; i < this.leaves.length; i++) {\n        // biome-ignore lint/style/noNonNullAssertion: within bounds\n        if (areUint8ArraysEqual(leaf, this.leaves[i])) {\n          index = i;\n        }\n      }\n    }\n    // @ts-expect-error - issue from original code\n    if (index <= -1) {\n      return [];\n    }\n    for (let i = 0; i < this.layers.length; i++) {\n      // biome-ignore lint/style/noNonNullAssertion: in bounds\n      const layer = this.layers[i];\n      // @ts-expect-error - issue from original code\n      const isRightNode = index % 2;\n      const pairIndex = isRightNode ?\n      // @ts-expect-error - issue from original code\n      index - 1 :\n      // Proof Generation for Non-Bitcoin Trees\n      // @ts-expect-error - issue from original code\n      index + 1;\n      if (pairIndex < layer.length) {\n        proof.push({\n          data: layer[pairIndex],\n          position: isRightNode ? \"left\" : \"right\"\n        });\n      }\n      // set index to parent index\n      // @ts-expect-error - issue from original code\n      index = index / 2 | 0;\n    }\n    // @ts-expect-error - issue from original code\n    return proof;\n  }\n}","map":{"version":3,"names":["uint8ArrayToHex","hexToBytes","keccak256","areUint8ArraysEqual","compareUint8Arrays","concatUint8Arrays","MerkleTree","constructor","leaves","Object","defineProperty","map","el","Uint8Array","sort","createHashes","getHexRoot","getRoot","getHexProof","leaf","index","getProof","item","data","nodes","layers","length","layerIndex","push","layerLimit","i","slice","left","right","combined","hash","Error","proof","Number","isInteger","layer","isRightNode","pairIndex","position"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/merkletree/MerkleTree.ts"],"sourcesContent":["// ADAPTED FROM https://github.com/merkletreejs/merkletreejs\nimport { type Hex, uint8ArrayToHex } from \"../utils/encoding/hex.js\";\nimport { hexToBytes } from \"../utils/encoding/to-bytes.js\";\nimport { keccak256 } from \"../utils/hashing/keccak256.js\";\nimport {\n  areUint8ArraysEqual,\n  compareUint8Arrays,\n  concatUint8Arrays,\n} from \"../utils/uint8-array.js\";\n\n// TODO: clean this up more, there is probably something to be said to move this entirely out of a class\n\ntype TLeaf = Uint8Array;\ntype TLayer = Uint8Array[];\n\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */\nexport class MerkleTree {\n  private leaves: TLeaf[] = [];\n  private layers: TLayer[] = [];\n\n  constructor(leaves: (Uint8Array | Hex)[]) {\n    this.leaves = leaves.map((el) =>\n      el instanceof Uint8Array ? el : hexToBytes(el),\n    );\n\n    this.leaves = this.leaves.sort(compareUint8Arrays);\n\n    this.createHashes(this.leaves);\n  }\n\n  public getHexRoot(): `0x${string}` {\n    return uint8ArrayToHex(this.getRoot());\n  }\n\n  public getHexProof(leaf: Uint8Array | Hex, index?: number): `0x${string}`[] {\n    return this.getProof(leaf, index).map((item) => uint8ArrayToHex(item.data));\n  }\n\n  // private below\n\n  private createHashes(nodes: Uint8Array[]) {\n    this.layers = [nodes];\n    while (nodes.length > 1) {\n      const layerIndex = this.layers.length;\n\n      this.layers.push([]);\n\n      const layerLimit = nodes.length;\n\n      for (let i = 0; i < nodes.length; i += 2) {\n        if (i >= layerLimit) {\n          // biome-ignore lint/style/noNonNullAssertion: in bounds\n          this.layers[layerIndex]!.push(...nodes.slice(layerLimit));\n          break;\n        }\n        if (i + 1 === nodes.length) {\n          if (nodes.length % 2 === 1) {\n            // push copy of hash and continue iteration\n            // biome-ignore lint/style/noNonNullAssertion: in bounds\n            this.layers[layerIndex]!.push(nodes[i]!);\n            continue;\n          }\n        }\n\n        // biome-ignore lint/style/noNonNullAssertion: in bounds\n        const left = nodes[i]!;\n        // biome-ignore lint/style/noNonNullAssertion: in bounds\n        const right = i + 1 === nodes.length ? left : nodes[i + 1]!;\n        const combined = [left, right];\n\n        combined.sort(compareUint8Arrays);\n\n        const hash = keccak256(concatUint8Arrays(combined), \"bytes\");\n\n        // biome-ignore lint/style/noNonNullAssertion: in bounds\n        this.layers[layerIndex]!.push(hash);\n      }\n      // biome-ignore lint/style/noParameterAssign: part of the functionality\n      // biome-ignore lint/style/noNonNullAssertion: in bounds\n      nodes = this.layers[layerIndex]!;\n    }\n  }\n\n  private getRoot(): Uint8Array {\n    if (this.layers.length === 0) {\n      return new Uint8Array();\n    }\n\n    // biome-ignore lint/style/noNonNullAssertion: in bounds\n    return this.layers[this.layers.length - 1]![0] || new Uint8Array();\n  }\n\n  private getProof(\n    leaf: Uint8Array | Hex,\n    index?: number,\n  ): { position: \"left\" | \"right\"; data: Uint8Array }[] {\n    if (typeof leaf === \"undefined\") {\n      throw new Error(\"leaf is required\");\n    }\n\n    leaf = leaf instanceof Uint8Array ? leaf : hexToBytes(leaf);\n    const proof = [];\n\n    if (!Number.isInteger(index)) {\n      index = -1;\n\n      for (let i = 0; i < this.leaves.length; i++) {\n        // biome-ignore lint/style/noNonNullAssertion: within bounds\n        if (areUint8ArraysEqual(leaf, this.leaves[i]!)) {\n          index = i;\n        }\n      }\n    }\n\n    // @ts-expect-error - issue from original code\n    if (index <= -1) {\n      return [];\n    }\n\n    for (let i = 0; i < this.layers.length; i++) {\n      // biome-ignore lint/style/noNonNullAssertion: in bounds\n      const layer = this.layers[i]!;\n      // @ts-expect-error - issue from original code\n      const isRightNode = index % 2;\n      const pairIndex = isRightNode\n        ? // @ts-expect-error - issue from original code\n          index - 1\n        : // Proof Generation for Non-Bitcoin Trees\n          // @ts-expect-error - issue from original code\n          index + 1;\n\n      if (pairIndex < layer.length) {\n        proof.push({\n          data: layer[pairIndex],\n          position: isRightNode ? \"left\" : \"right\",\n        });\n      }\n\n      // set index to parent index\n      // @ts-expect-error - issue from original code\n      index = (index / 2) | 0;\n    }\n\n    // @ts-expect-error - issue from original code\n    return proof;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}