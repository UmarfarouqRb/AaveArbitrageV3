{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { formatAbi, parseAbi } from \"abitype\";\nimport { sepolia } from \"viem/chains\";\nimport { download } from \"../../storage/download.js\";\nimport { getClientFetch } from \"../../utils/fetch.js\";\nimport { withCache } from \"../../utils/promise/withCache.js\";\nimport { getContract } from \"../contract.js\";\n/**\n * Resolves the ABI (Application Binary Interface) for a given contract.\n * If the ABI is already cached, it returns the cached value.\n * Otherwise, it tries to resolve the ABI from the contract's API.\n * If that fails, it resolves the ABI from the contract's bytecode.\n * @param contract The contract for which to resolve the ABI.\n * @param contractApiBaseUrl The base URL of the contract API. Defaults to \"https://contract.thirdweb.com/abi\".\n * @returns A promise that resolves to the ABI of the contract.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveContractAbi } from \"thirdweb/contract\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveContractAbi(myContract);\n * ```\n * @contract\n */\nexport function resolveContractAbi(contract) {\n  let contractApiBaseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"https://contract.thirdweb.com/abi\";\n  return withCache(async () => {\n    // if the contract already HAS a user defined we always use that!\n    if (contract.abi) {\n      return contract.abi;\n    }\n    // for local chains, we need to resolve the composite abi from bytecode\n    if (contract.chain.id === 31337 || contract.chain.id === 1337 || contract.chain.id === sepolia.id // FIXME remove this once contract API handles 7702 delegation\n    ) {\n      return await resolveCompositeAbi(contract);\n    }\n    // try to get it from the api\n    try {\n      return await resolveAbiFromContractApi(contract, contractApiBaseUrl);\n    } catch (_unused) {\n      // if that fails, try to resolve it from the bytecode\n      return await resolveCompositeAbi(contract);\n    }\n  }, {\n    cacheKey: \"\".concat(contract.chain.id, \"-\").concat(contract.address),\n    cacheTime: 1000 * 60 * 60 * 1 // 1 hour\n  });\n}\n/**\n * Resolves the ABI (Application Binary Interface) for a contract from the contract API.\n * @param contract The ThirdwebContract instance representing the contract.\n * @param contractApiBaseUrl The base URL of the contract API. Defaults to \"https://contract.thirdweb.com/abi\".\n * @returns A promise that resolves to the ABI of the contract.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveAbiFromContractApi } from \"thirdweb/contract\"\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveAbiFromContractApi(myContract);\n * ```\n * @contract\n */\nexport async function resolveAbiFromContractApi(\n// biome-ignore lint/suspicious/noExplicitAny: library function that accepts any contract type\ncontract) {\n  let contractApiBaseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"https://contract.thirdweb.com/abi\";\n  const response = await getClientFetch(contract.client)(\"\".concat(contractApiBaseUrl, \"/\").concat(contract.chain.id, \"/\").concat(contract.address));\n  const json = await response.json();\n  if (!json || json.error) {\n    throw new Error(\"Failed to resolve ABI from contract API. \".concat(json.error || \"\"));\n  }\n  return json;\n}\n/**\n * Resolves the ABI (Application Binary Interface) from the bytecode of a contract.\n * @param contract The ThirdwebContract instance.\n * @returns The resolved ABI as a generic type.\n * @throws Error if no IPFS URI is found in the bytecode.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveAbiFromBytecode } from \"thirdweb/contract\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveAbiFromBytecode(myContract);\n * ```\n * @contract\n */\nexport async function resolveAbiFromBytecode(\n// biome-ignore lint/suspicious/noExplicitAny: library function that accepts any contract type\ncontract) {\n  const [{\n    resolveImplementation\n  }, {\n    extractIPFSUri\n  }] = await Promise.all([import(\"../../utils/bytecode/resolveImplementation.js\"), import(\"../../utils/bytecode/extractIPFS.js\")]);\n  const {\n    bytecode\n  } = await resolveImplementation(contract);\n  if (bytecode === \"0x\") {\n    const {\n      id,\n      name\n    } = contract.chain;\n    throw new Error(\"Failed to load contract bytecode. Make sure the contract [\".concat(contract.address, \"] exists on the chain [\").concat(name || \"Unknown Chain\", \" (chain id: \").concat(id, \")]\"));\n  }\n  const ipfsUri = extractIPFSUri(bytecode);\n  if (!ipfsUri) {\n    // just early exit if we can't find an IPFS URI\n    return [];\n  }\n  try {\n    const res = await download({\n      client: contract.client,\n      uri: ipfsUri\n    });\n    const json = await res.json();\n    // ABI is at `json.output.abi`\n    return json.output.abi;\n  } catch (_unused2) {\n    // if we can't resolve the ABI from the IPFS URI, return an empty array\n    return [];\n  }\n}\nconst PLUGINS_ABI = {\n  inputs: [],\n  name: \"getAllPlugins\",\n  outputs: [{\n    components: [{\n      internalType: \"bytes4\",\n      name: \"functionSelector\",\n      type: \"bytes4\"\n    }, {\n      internalType: \"string\",\n      name: \"functionSignature\",\n      type: \"string\"\n    }, {\n      internalType: \"address\",\n      name: \"pluginAddress\",\n      type: \"address\"\n    }],\n    internalType: \"struct IPluginMap.Plugin[]\",\n    name: \"registered\",\n    type: \"tuple[]\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n};\nconst BASE_ROUTER_ABI = {\n  inputs: [],\n  name: \"getAllExtensions\",\n  outputs: [{\n    components: [{\n      components: [{\n        internalType: \"string\",\n        name: \"name\",\n        type: \"string\"\n      }, {\n        internalType: \"string\",\n        name: \"metadataURI\",\n        type: \"string\"\n      }, {\n        internalType: \"address\",\n        name: \"implementation\",\n        type: \"address\"\n      }],\n      internalType: \"struct IExtension.ExtensionMetadata\",\n      name: \"metadata\",\n      type: \"tuple\"\n    }, {\n      components: [{\n        internalType: \"bytes4\",\n        name: \"functionSelector\",\n        type: \"bytes4\"\n      }, {\n        internalType: \"string\",\n        name: \"functionSignature\",\n        type: \"string\"\n      }],\n      internalType: \"struct IExtension.ExtensionFunction[]\",\n      name: \"functions\",\n      type: \"tuple[]\"\n    }],\n    internalType: \"struct IExtension.Extension[]\",\n    name: \"allExtensions\",\n    type: \"tuple[]\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n};\nconst DIAMOND_ABI = {\n  inputs: [],\n  name: \"facets\",\n  outputs: [{\n    components: [{\n      internalType: \"address\",\n      name: \"facetAddress\",\n      type: \"address\"\n    }, {\n      internalType: \"bytes4[]\",\n      name: \"functionSelectors\",\n      type: \"bytes4[]\"\n    }],\n    type: \"tuple[]\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n};\n/**\n * Resolves the ABI for a contract based on its bytecode.\n * If the contract follows the plugin-pattern or dynamic pattern, it resolves the ABIs for the plugins and merges them with the root ABI.\n * If the contract follows the base router pattern, it resolves the ABIs for the plugins and merges them with the root ABI.\n * If the contract follows the diamond pattern, it resolves the ABIs for the facets and merges them with the root ABI.\n * @param contract The contract for which to resolve the ABI.\n * @param rootAbi The root ABI to use for the contract. If not provided, it resolves the ABI from the contract's bytecode.\n * @param resolveSubAbi A function to resolve the ABI for a sub-contract. If not provided, it uses the default ABI resolution logic.\n * @returns The resolved ABI for the contract.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveCompositeAbiFromBytecode } from \"thirdweb/contract\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveCompositeAbiFromBytecode(myContract);\n * ```\n * @contract\n */\nexport async function resolveCompositeAbi(contract, rootAbi, resolveSubAbi) {\n  const [rootAbi_, pluginPatternAddresses, baseRouterAddresses, modularExtensionAddresses, diamondFacetAddresses] = await Promise.all([rootAbi ? rootAbi : resolveAbiFromBytecode(contract),\n  // check these all at the same time\n  resolvePluginPatternAddresses(contract), resolveBaseRouterAddresses(contract), resolveModularModuleAddresses(contract), resolveDiamondFacetAddresses(contract)]);\n  const mergedPlugins = [...new Set([...pluginPatternAddresses, ...baseRouterAddresses, ...modularExtensionAddresses, ...diamondFacetAddresses])];\n  // no plugins\n  if (!mergedPlugins.length) {\n    return rootAbi_;\n  }\n  // get all the abis for the plugins\n  const pluginAbis = await getAbisForPlugins({\n    contract,\n    plugins: mergedPlugins,\n    resolveSubAbi\n  });\n  // join them together\n  return joinAbis({\n    pluginAbis,\n    rootAbi: rootAbi_\n  });\n}\nasync function resolvePluginPatternAddresses(contract) {\n  try {\n    const {\n      readContract\n    } = await import(\"../../transaction/read-contract.js\");\n    const pluginMap = await readContract({\n      contract,\n      method: PLUGINS_ABI\n    });\n    // if there are no plugins, return the root ABI\n    if (!pluginMap.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return [...new Set(pluginMap.map(item => item.pluginAddress))];\n  } catch (_unused3) {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\nasync function resolveBaseRouterAddresses(contract) {\n  try {\n    const {\n      readContract\n    } = await import(\"../../transaction/read-contract.js\");\n    const pluginMap = await readContract({\n      contract,\n      method: BASE_ROUTER_ABI\n    });\n    // if there are no plugins, return the root ABI\n    if (!pluginMap.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return [...new Set(pluginMap.map(item => item.metadata.implementation))];\n  } catch (_unused4) {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\nasync function resolveModularModuleAddresses(contract) {\n  try {\n    const {\n      getInstalledModules\n    } = await import(\"../../extensions/modules/__generated__/IModularCore/read/getInstalledModules.js\");\n    const modules = await getInstalledModules({\n      contract\n    });\n    // if there are no plugins, return the root ABI\n    if (!modules.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return [...new Set(modules.map(item => item.implementation))];\n  } catch (_unused5) {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\nasync function resolveDiamondFacetAddresses(contract) {\n  try {\n    const {\n      readContract\n    } = await import(\"../../transaction/read-contract.js\");\n    const facets = await readContract({\n      contract,\n      method: DIAMOND_ABI\n    });\n    // if there are no facets, return the root ABI\n    if (!facets.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return facets.map(item => item.facetAddress);\n  } catch (_unused6) {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\nasync function getAbisForPlugins(options) {\n  return Promise.all(options.plugins.map(pluginAddress => {\n    const newContract = getContract(_objectSpread(_objectSpread({}, options.contract), {}, {\n      address: pluginAddress\n    }));\n    // if we have a method passed in that tells us how to resove the sub-api, use that\n    if (options.resolveSubAbi) {\n      return options.resolveSubAbi(newContract);\n    }\n    // otherwise default logic\n    return resolveAbiFromBytecode(newContract);\n  }));\n}\nfunction joinAbis(options) {\n  let mergedPlugins = options.pluginAbis.flat().filter(item => item.type !== \"constructor\");\n  if (options.rootAbi) {\n    mergedPlugins = [...options.rootAbi, ...mergedPlugins].filter(item => item.type !== \"fallback\" && item.type !== \"receive\").filter(Boolean);\n  }\n  // unique by formatting every abi and then throwing them in a set\n  // TODO: this may not be super efficient...\n  const humanReadableAbi = [...new Set(formatAbi(mergedPlugins))];\n  // finally parse it back out\n  return parseAbi(humanReadableAbi);\n}","map":{"version":3,"names":["formatAbi","parseAbi","sepolia","download","getClientFetch","withCache","getContract","resolveContractAbi","contract","contractApiBaseUrl","arguments","length","undefined","abi","chain","id","resolveCompositeAbi","resolveAbiFromContractApi","_unused","cacheKey","concat","address","cacheTime","response","client","json","error","Error","resolveAbiFromBytecode","resolveImplementation","extractIPFSUri","Promise","all","bytecode","name","ipfsUri","res","uri","output","_unused2","PLUGINS_ABI","inputs","outputs","components","internalType","type","stateMutability","BASE_ROUTER_ABI","DIAMOND_ABI","rootAbi","resolveSubAbi","rootAbi_","pluginPatternAddresses","baseRouterAddresses","modularExtensionAddresses","diamondFacetAddresses","resolvePluginPatternAddresses","resolveBaseRouterAddresses","resolveModularModuleAddresses","resolveDiamondFacetAddresses","mergedPlugins","Set","pluginAbis","getAbisForPlugins","plugins","joinAbis","readContract","pluginMap","method","map","item","pluginAddress","_unused3","metadata","implementation","_unused4","getInstalledModules","modules","_unused5","facets","facetAddress","_unused6","options","newContract","_objectSpread","flat","filter","Boolean","humanReadableAbi"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/contract/actions/resolve-abi.ts"],"sourcesContent":["import { type Abi, formatAbi, parseAbi } from \"abitype\";\nimport { sepolia } from \"viem/chains\";\nimport { download } from \"../../storage/download.js\";\nimport { getClientFetch } from \"../../utils/fetch.js\";\nimport { withCache } from \"../../utils/promise/withCache.js\";\nimport { getContract, type ThirdwebContract } from \"../contract.js\";\n\n/**\n * Resolves the ABI (Application Binary Interface) for a given contract.\n * If the ABI is already cached, it returns the cached value.\n * Otherwise, it tries to resolve the ABI from the contract's API.\n * If that fails, it resolves the ABI from the contract's bytecode.\n * @param contract The contract for which to resolve the ABI.\n * @param contractApiBaseUrl The base URL of the contract API. Defaults to \"https://contract.thirdweb.com/abi\".\n * @returns A promise that resolves to the ABI of the contract.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveContractAbi } from \"thirdweb/contract\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveContractAbi(myContract);\n * ```\n * @contract\n */\nexport function resolveContractAbi<abi extends Abi>(\n  contract: ThirdwebContract<abi>,\n  contractApiBaseUrl = \"https://contract.thirdweb.com/abi\",\n): Promise<abi> {\n  return withCache(\n    async () => {\n      // if the contract already HAS a user defined we always use that!\n      if (contract.abi) {\n        return contract.abi as abi;\n      }\n\n      // for local chains, we need to resolve the composite abi from bytecode\n      if (\n        contract.chain.id === 31337 ||\n        contract.chain.id === 1337 ||\n        contract.chain.id === sepolia.id // FIXME remove this once contract API handles 7702 delegation\n      ) {\n        return (await resolveCompositeAbi(contract as ThirdwebContract)) as abi;\n      }\n\n      // try to get it from the api\n      try {\n        return (await resolveAbiFromContractApi(\n          contract,\n          contractApiBaseUrl,\n        )) as abi;\n      } catch {\n        // if that fails, try to resolve it from the bytecode\n        return (await resolveCompositeAbi(contract as ThirdwebContract)) as abi;\n      }\n    },\n    {\n      cacheKey: `${contract.chain.id}-${contract.address}`,\n      cacheTime: 1000 * 60 * 60 * 1, // 1 hour\n    },\n  );\n}\n\n/**\n * Resolves the ABI (Application Binary Interface) for a contract from the contract API.\n * @param contract The ThirdwebContract instance representing the contract.\n * @param contractApiBaseUrl The base URL of the contract API. Defaults to \"https://contract.thirdweb.com/abi\".\n * @returns A promise that resolves to the ABI of the contract.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveAbiFromContractApi } from \"thirdweb/contract\"\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveAbiFromContractApi(myContract);\n * ```\n * @contract\n */\nexport async function resolveAbiFromContractApi(\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any contract type\n  contract: ThirdwebContract<any>,\n  contractApiBaseUrl = \"https://contract.thirdweb.com/abi\",\n): Promise<Abi> {\n  const response = await getClientFetch(contract.client)(\n    `${contractApiBaseUrl}/${contract.chain.id}/${contract.address}`,\n  );\n  const json = await response.json();\n  if (!json || json.error) {\n    throw new Error(\n      `Failed to resolve ABI from contract API. ${json.error || \"\"}`,\n    );\n  }\n  return json;\n}\n\n/**\n * Resolves the ABI (Application Binary Interface) from the bytecode of a contract.\n * @param contract The ThirdwebContract instance.\n * @returns The resolved ABI as a generic type.\n * @throws Error if no IPFS URI is found in the bytecode.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveAbiFromBytecode } from \"thirdweb/contract\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveAbiFromBytecode(myContract);\n * ```\n * @contract\n */\nexport async function resolveAbiFromBytecode(\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any contract type\n  contract: ThirdwebContract<any>,\n): Promise<Abi> {\n  const [{ resolveImplementation }, { extractIPFSUri }] = await Promise.all([\n    import(\"../../utils/bytecode/resolveImplementation.js\"),\n    import(\"../../utils/bytecode/extractIPFS.js\"),\n  ]);\n  const { bytecode } = await resolveImplementation(contract);\n  if (bytecode === \"0x\") {\n    const { id, name } = contract.chain;\n    throw new Error(\n      `Failed to load contract bytecode. Make sure the contract [${\n        contract.address\n      }] exists on the chain [${name || \"Unknown Chain\"} (chain id: ${id})]`,\n    );\n  }\n  const ipfsUri = extractIPFSUri(bytecode);\n  if (!ipfsUri) {\n    // just early exit if we can't find an IPFS URI\n    return [];\n  }\n  try {\n    const res = await download({ client: contract.client, uri: ipfsUri });\n    const json = await res.json();\n    // ABI is at `json.output.abi`\n    return json.output.abi;\n  } catch {\n    // if we can't resolve the ABI from the IPFS URI, return an empty array\n    return [];\n  }\n}\n\nconst PLUGINS_ABI = {\n  inputs: [],\n  name: \"getAllPlugins\",\n  outputs: [\n    {\n      components: [\n        {\n          internalType: \"bytes4\",\n          name: \"functionSelector\",\n          type: \"bytes4\",\n        },\n        {\n          internalType: \"string\",\n          name: \"functionSignature\",\n          type: \"string\",\n        },\n        {\n          internalType: \"address\",\n          name: \"pluginAddress\",\n          type: \"address\",\n        },\n      ],\n      internalType: \"struct IPluginMap.Plugin[]\",\n      name: \"registered\",\n      type: \"tuple[]\",\n    },\n  ],\n  stateMutability: \"view\",\n  type: \"function\",\n} as const;\n\nconst BASE_ROUTER_ABI = {\n  inputs: [],\n  name: \"getAllExtensions\",\n  outputs: [\n    {\n      components: [\n        {\n          components: [\n            {\n              internalType: \"string\",\n              name: \"name\",\n              type: \"string\",\n            },\n            {\n              internalType: \"string\",\n              name: \"metadataURI\",\n              type: \"string\",\n            },\n            {\n              internalType: \"address\",\n              name: \"implementation\",\n              type: \"address\",\n            },\n          ],\n          internalType: \"struct IExtension.ExtensionMetadata\",\n          name: \"metadata\",\n          type: \"tuple\",\n        },\n        {\n          components: [\n            {\n              internalType: \"bytes4\",\n              name: \"functionSelector\",\n              type: \"bytes4\",\n            },\n            {\n              internalType: \"string\",\n              name: \"functionSignature\",\n              type: \"string\",\n            },\n          ],\n          internalType: \"struct IExtension.ExtensionFunction[]\",\n          name: \"functions\",\n          type: \"tuple[]\",\n        },\n      ],\n      internalType: \"struct IExtension.Extension[]\",\n      name: \"allExtensions\",\n      type: \"tuple[]\",\n    },\n  ],\n  stateMutability: \"view\",\n  type: \"function\",\n} as const;\n\nconst DIAMOND_ABI = {\n  inputs: [],\n  name: \"facets\",\n  outputs: [\n    {\n      components: [\n        {\n          internalType: \"address\",\n          name: \"facetAddress\",\n          type: \"address\",\n        },\n        {\n          internalType: \"bytes4[]\",\n          name: \"functionSelectors\",\n          type: \"bytes4[]\",\n        },\n      ],\n      type: \"tuple[]\",\n    },\n  ],\n  stateMutability: \"view\",\n  type: \"function\",\n} as const;\n\n/**\n * Resolves the ABI for a contract based on its bytecode.\n * If the contract follows the plugin-pattern or dynamic pattern, it resolves the ABIs for the plugins and merges them with the root ABI.\n * If the contract follows the base router pattern, it resolves the ABIs for the plugins and merges them with the root ABI.\n * If the contract follows the diamond pattern, it resolves the ABIs for the facets and merges them with the root ABI.\n * @param contract The contract for which to resolve the ABI.\n * @param rootAbi The root ABI to use for the contract. If not provided, it resolves the ABI from the contract's bytecode.\n * @param resolveSubAbi A function to resolve the ABI for a sub-contract. If not provided, it uses the default ABI resolution logic.\n * @returns The resolved ABI for the contract.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveCompositeAbiFromBytecode } from \"thirdweb/contract\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveCompositeAbiFromBytecode(myContract);\n * ```\n * @contract\n */\nexport async function resolveCompositeAbi(\n  contract: ThirdwebContract,\n  rootAbi?: Abi,\n  resolveSubAbi?: (contract: ThirdwebContract) => Promise<Abi>,\n) {\n  const [\n    rootAbi_,\n    pluginPatternAddresses,\n    baseRouterAddresses,\n    modularExtensionAddresses,\n    diamondFacetAddresses,\n  ] = await Promise.all([\n    rootAbi ? rootAbi : resolveAbiFromBytecode(contract),\n    // check these all at the same time\n    resolvePluginPatternAddresses(contract),\n    resolveBaseRouterAddresses(contract),\n    resolveModularModuleAddresses(contract),\n    resolveDiamondFacetAddresses(contract),\n  ]);\n\n  const mergedPlugins = [\n    ...new Set([\n      ...pluginPatternAddresses,\n      ...baseRouterAddresses,\n      ...modularExtensionAddresses,\n      ...diamondFacetAddresses,\n    ]),\n  ];\n\n  // no plugins\n  if (!mergedPlugins.length) {\n    return rootAbi_;\n  }\n  // get all the abis for the plugins\n  const pluginAbis = await getAbisForPlugins({\n    contract,\n    plugins: mergedPlugins,\n    resolveSubAbi,\n  });\n\n  // join them together\n  return joinAbis({ pluginAbis, rootAbi: rootAbi_ });\n}\n\nasync function resolvePluginPatternAddresses(\n  contract: ThirdwebContract,\n): Promise<string[]> {\n  try {\n    const { readContract } = await import(\"../../transaction/read-contract.js\");\n    const pluginMap = await readContract({\n      contract,\n      method: PLUGINS_ABI,\n    });\n    // if there are no plugins, return the root ABI\n    if (!pluginMap.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return [...new Set(pluginMap.map((item) => item.pluginAddress))];\n  } catch {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\n\nasync function resolveBaseRouterAddresses(\n  contract: ThirdwebContract,\n): Promise<string[]> {\n  try {\n    const { readContract } = await import(\"../../transaction/read-contract.js\");\n    const pluginMap = await readContract({\n      contract,\n      method: BASE_ROUTER_ABI,\n    });\n    // if there are no plugins, return the root ABI\n    if (!pluginMap.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return [...new Set(pluginMap.map((item) => item.metadata.implementation))];\n  } catch {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\n\nasync function resolveModularModuleAddresses(\n  contract: ThirdwebContract,\n): Promise<string[]> {\n  try {\n    const { getInstalledModules } = await import(\n      \"../../extensions/modules/__generated__/IModularCore/read/getInstalledModules.js\"\n    );\n    const modules = await getInstalledModules({ contract });\n    // if there are no plugins, return the root ABI\n    if (!modules.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return [...new Set(modules.map((item) => item.implementation))];\n  } catch {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\n\nasync function resolveDiamondFacetAddresses(\n  contract: ThirdwebContract,\n): Promise<string[]> {\n  try {\n    const { readContract } = await import(\"../../transaction/read-contract.js\");\n    const facets = await readContract({ contract, method: DIAMOND_ABI });\n    // if there are no facets, return the root ABI\n    if (!facets.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return facets.map((item) => item.facetAddress);\n  } catch {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\n\ntype GetAbisForPluginsOptions = {\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any contract type\n  contract: ThirdwebContract<any>;\n  plugins: string[];\n  resolveSubAbi?: (contract: ThirdwebContract) => Promise<Abi>;\n};\n\nasync function getAbisForPlugins(\n  options: GetAbisForPluginsOptions,\n): Promise<Abi[]> {\n  return Promise.all(\n    options.plugins.map((pluginAddress) => {\n      const newContract = getContract({\n        ...options.contract,\n        address: pluginAddress,\n      });\n      // if we have a method passed in that tells us how to resove the sub-api, use that\n      if (options.resolveSubAbi) {\n        return options.resolveSubAbi(newContract);\n      }\n      // otherwise default logic\n      return resolveAbiFromBytecode(newContract);\n    }),\n  );\n}\n\ntype JoinAbisOptions = {\n  pluginAbis: Abi[];\n  rootAbi?: Abi;\n};\n\nfunction joinAbis(options: JoinAbisOptions): Abi {\n  let mergedPlugins: Abi = options.pluginAbis\n    .flat()\n    .filter((item) => item.type !== \"constructor\");\n\n  if (options.rootAbi) {\n    mergedPlugins = [...options.rootAbi, ...mergedPlugins]\n      .filter((item) => item.type !== \"fallback\" && item.type !== \"receive\")\n      .filter(Boolean);\n  }\n\n  // unique by formatting every abi and then throwing them in a set\n  // TODO: this may not be super efficient...\n  const humanReadableAbi = [...new Set(formatAbi(mergedPlugins))];\n\n  // finally parse it back out\n  return parseAbi(humanReadableAbi);\n}\n"],"mappings":";AAAA,SAAmBA,SAAS,EAAEC,QAAQ,QAAQ,SAAS;AACvD,SAASC,OAAO,QAAQ,aAAa;AACrC,SAASC,QAAQ,QAAQ,2BAA2B;AACpD,SAASC,cAAc,QAAQ,sBAAsB;AACrD,SAASC,SAAS,QAAQ,kCAAkC;AAC5D,SAASC,WAAW,QAA+B,gBAAgB;AAEnE;;;;;;;;;;;;;;;;;;;;;;;AAuBA,OAAM,SAAUC,kBAAkBA,CAChCC,QAA+B,EACyB;EAAA,IAAxDC,kBAAkB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,mCAAmC;EAExD,OAAOL,SAAS,CACd,YAAW;IACT;IACA,IAAIG,QAAQ,CAACK,GAAG,EAAE;MAChB,OAAOL,QAAQ,CAACK,GAAU;IAC5B;IAEA;IACA,IACEL,QAAQ,CAACM,KAAK,CAACC,EAAE,KAAK,KAAK,IAC3BP,QAAQ,CAACM,KAAK,CAACC,EAAE,KAAK,IAAI,IAC1BP,QAAQ,CAACM,KAAK,CAACC,EAAE,KAAKb,OAAO,CAACa,EAAE,CAAC;IAAA,EACjC;MACA,OAAQ,MAAMC,mBAAmB,CAACR,QAA4B,CAAC;IACjE;IAEA;IACA,IAAI;MACF,OAAQ,MAAMS,yBAAyB,CACrCT,QAAQ,EACRC,kBAAkB,CACnB;IACH,CAAC,CAAC,OAAAS,OAAA,EAAM;MACN;MACA,OAAQ,MAAMF,mBAAmB,CAACR,QAA4B,CAAC;IACjE;EACF,CAAC,EACD;IACEW,QAAQ,KAAAC,MAAA,CAAKZ,QAAQ,CAACM,KAAK,CAACC,EAAE,OAAAK,MAAA,CAAIZ,QAAQ,CAACa,OAAO,CAAE;IACpDC,SAAS,EAAE,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAE;GAChC,CACF;AACH;AAEA;;;;;;;;;;;;;;;;;;;;AAoBA,OAAO,eAAeL,yBAAyBA;AAC7C;AACAT,QAA+B,EACyB;EAAA,IAAxDC,kBAAkB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,mCAAmC;EAExD,MAAMa,QAAQ,GAAG,MAAMnB,cAAc,CAACI,QAAQ,CAACgB,MAAM,CAAC,IAAAJ,MAAA,CACjDX,kBAAkB,OAAAW,MAAA,CAAIZ,QAAQ,CAACM,KAAK,CAACC,EAAE,OAAAK,MAAA,CAAIZ,QAAQ,CAACa,OAAO,CAAE,CACjE;EACD,MAAMI,IAAI,GAAG,MAAMF,QAAQ,CAACE,IAAI,EAAE;EAClC,IAAI,CAACA,IAAI,IAAIA,IAAI,CAACC,KAAK,EAAE;IACvB,MAAM,IAAIC,KAAK,6CAAAP,MAAA,CAC+BK,IAAI,CAACC,KAAK,IAAI,EAAE,CAAE,CAC/D;EACH;EACA,OAAOD,IAAI;AACb;AAEA;;;;;;;;;;;;;;;;;;;;AAoBA,OAAO,eAAeG,sBAAsBA;AAC1C;AACApB,QAA+B;EAE/B,MAAM,CAAC;IAAEqB;EAAqB,CAAE,EAAE;IAAEC;EAAc,CAAE,CAAC,GAAG,MAAMC,OAAO,CAACC,GAAG,CAAC,CACxE,MAAM,CAAC,+CAA+C,CAAC,EACvD,MAAM,CAAC,qCAAqC,CAAC,CAC9C,CAAC;EACF,MAAM;IAAEC;EAAQ,CAAE,GAAG,MAAMJ,qBAAqB,CAACrB,QAAQ,CAAC;EAC1D,IAAIyB,QAAQ,KAAK,IAAI,EAAE;IACrB,MAAM;MAAElB,EAAE;MAAEmB;IAAI,CAAE,GAAG1B,QAAQ,CAACM,KAAK;IACnC,MAAM,IAAIa,KAAK,8DAAAP,MAAA,CAEXZ,QAAQ,CAACa,OACX,6BAAAD,MAAA,CAA0Bc,IAAI,IAAI,eAAe,kBAAAd,MAAA,CAAeL,EAAE,OAAI,CACvE;EACH;EACA,MAAMoB,OAAO,GAAGL,cAAc,CAACG,QAAQ,CAAC;EACxC,IAAI,CAACE,OAAO,EAAE;IACZ;IACA,OAAO,EAAE;EACX;EACA,IAAI;IACF,MAAMC,GAAG,GAAG,MAAMjC,QAAQ,CAAC;MAAEqB,MAAM,EAAEhB,QAAQ,CAACgB,MAAM;MAAEa,GAAG,EAAEF;IAAO,CAAE,CAAC;IACrE,MAAMV,IAAI,GAAG,MAAMW,GAAG,CAACX,IAAI,EAAE;IAC7B;IACA,OAAOA,IAAI,CAACa,MAAM,CAACzB,GAAG;EACxB,CAAC,CAAC,OAAA0B,QAAA,EAAM;IACN;IACA,OAAO,EAAE;EACX;AACF;AAEA,MAAMC,WAAW,GAAG;EAClBC,MAAM,EAAE,EAAE;EACVP,IAAI,EAAE,eAAe;EACrBQ,OAAO,EAAE,CACP;IACEC,UAAU,EAAE,CACV;MACEC,YAAY,EAAE,QAAQ;MACtBV,IAAI,EAAE,kBAAkB;MACxBW,IAAI,EAAE;KACP,EACD;MACED,YAAY,EAAE,QAAQ;MACtBV,IAAI,EAAE,mBAAmB;MACzBW,IAAI,EAAE;KACP,EACD;MACED,YAAY,EAAE,SAAS;MACvBV,IAAI,EAAE,eAAe;MACrBW,IAAI,EAAE;KACP,CACF;IACDD,YAAY,EAAE,4BAA4B;IAC1CV,IAAI,EAAE,YAAY;IAClBW,IAAI,EAAE;GACP,CACF;EACDC,eAAe,EAAE,MAAM;EACvBD,IAAI,EAAE;CACE;AAEV,MAAME,eAAe,GAAG;EACtBN,MAAM,EAAE,EAAE;EACVP,IAAI,EAAE,kBAAkB;EACxBQ,OAAO,EAAE,CACP;IACEC,UAAU,EAAE,CACV;MACEA,UAAU,EAAE,CACV;QACEC,YAAY,EAAE,QAAQ;QACtBV,IAAI,EAAE,MAAM;QACZW,IAAI,EAAE;OACP,EACD;QACED,YAAY,EAAE,QAAQ;QACtBV,IAAI,EAAE,aAAa;QACnBW,IAAI,EAAE;OACP,EACD;QACED,YAAY,EAAE,SAAS;QACvBV,IAAI,EAAE,gBAAgB;QACtBW,IAAI,EAAE;OACP,CACF;MACDD,YAAY,EAAE,qCAAqC;MACnDV,IAAI,EAAE,UAAU;MAChBW,IAAI,EAAE;KACP,EACD;MACEF,UAAU,EAAE,CACV;QACEC,YAAY,EAAE,QAAQ;QACtBV,IAAI,EAAE,kBAAkB;QACxBW,IAAI,EAAE;OACP,EACD;QACED,YAAY,EAAE,QAAQ;QACtBV,IAAI,EAAE,mBAAmB;QACzBW,IAAI,EAAE;OACP,CACF;MACDD,YAAY,EAAE,uCAAuC;MACrDV,IAAI,EAAE,WAAW;MACjBW,IAAI,EAAE;KACP,CACF;IACDD,YAAY,EAAE,+BAA+B;IAC7CV,IAAI,EAAE,eAAe;IACrBW,IAAI,EAAE;GACP,CACF;EACDC,eAAe,EAAE,MAAM;EACvBD,IAAI,EAAE;CACE;AAEV,MAAMG,WAAW,GAAG;EAClBP,MAAM,EAAE,EAAE;EACVP,IAAI,EAAE,QAAQ;EACdQ,OAAO,EAAE,CACP;IACEC,UAAU,EAAE,CACV;MACEC,YAAY,EAAE,SAAS;MACvBV,IAAI,EAAE,cAAc;MACpBW,IAAI,EAAE;KACP,EACD;MACED,YAAY,EAAE,UAAU;MACxBV,IAAI,EAAE,mBAAmB;MACzBW,IAAI,EAAE;KACP,CACF;IACDA,IAAI,EAAE;GACP,CACF;EACDC,eAAe,EAAE,MAAM;EACvBD,IAAI,EAAE;CACE;AAEV;;;;;;;;;;;;;;;;;;;;;;;;AAwBA,OAAO,eAAe7B,mBAAmBA,CACvCR,QAA0B,EAC1ByC,OAAa,EACbC,aAA4D;EAE5D,MAAM,CACJC,QAAQ,EACRC,sBAAsB,EACtBC,mBAAmB,EACnBC,yBAAyB,EACzBC,qBAAqB,CACtB,GAAG,MAAMxB,OAAO,CAACC,GAAG,CAAC,CACpBiB,OAAO,GAAGA,OAAO,GAAGrB,sBAAsB,CAACpB,QAAQ,CAAC;EACpD;EACAgD,6BAA6B,CAAChD,QAAQ,CAAC,EACvCiD,0BAA0B,CAACjD,QAAQ,CAAC,EACpCkD,6BAA6B,CAAClD,QAAQ,CAAC,EACvCmD,4BAA4B,CAACnD,QAAQ,CAAC,CACvC,CAAC;EAEF,MAAMoD,aAAa,GAAG,CACpB,GAAG,IAAIC,GAAG,CAAC,CACT,GAAGT,sBAAsB,EACzB,GAAGC,mBAAmB,EACtB,GAAGC,yBAAyB,EAC5B,GAAGC,qBAAqB,CACzB,CAAC,CACH;EAED;EACA,IAAI,CAACK,aAAa,CAACjD,MAAM,EAAE;IACzB,OAAOwC,QAAQ;EACjB;EACA;EACA,MAAMW,UAAU,GAAG,MAAMC,iBAAiB,CAAC;IACzCvD,QAAQ;IACRwD,OAAO,EAAEJ,aAAa;IACtBV;GACD,CAAC;EAEF;EACA,OAAOe,QAAQ,CAAC;IAAEH,UAAU;IAAEb,OAAO,EAAEE;EAAQ,CAAE,CAAC;AACpD;AAEA,eAAeK,6BAA6BA,CAC1ChD,QAA0B;EAE1B,IAAI;IACF,MAAM;MAAE0D;IAAY,CAAE,GAAG,MAAM,MAAM,CAAC,oCAAoC,CAAC;IAC3E,MAAMC,SAAS,GAAG,MAAMD,YAAY,CAAC;MACnC1D,QAAQ;MACR4D,MAAM,EAAE5B;KACT,CAAC;IACF;IACA,IAAI,CAAC2B,SAAS,CAACxD,MAAM,EAAE;MACrB,OAAO,EAAE;IACX;IACA;IACA,OAAO,CAAC,GAAG,IAAIkD,GAAG,CAACM,SAAS,CAACE,GAAG,CAAEC,IAAI,IAAKA,IAAI,CAACC,aAAa,CAAC,CAAC,CAAC;EAClE,CAAC,CAAC,OAAAC,QAAA,EAAM;IACN;EAAA;EAEF,OAAO,EAAE;AACX;AAEA,eAAef,0BAA0BA,CACvCjD,QAA0B;EAE1B,IAAI;IACF,MAAM;MAAE0D;IAAY,CAAE,GAAG,MAAM,MAAM,CAAC,oCAAoC,CAAC;IAC3E,MAAMC,SAAS,GAAG,MAAMD,YAAY,CAAC;MACnC1D,QAAQ;MACR4D,MAAM,EAAErB;KACT,CAAC;IACF;IACA,IAAI,CAACoB,SAAS,CAACxD,MAAM,EAAE;MACrB,OAAO,EAAE;IACX;IACA;IACA,OAAO,CAAC,GAAG,IAAIkD,GAAG,CAACM,SAAS,CAACE,GAAG,CAAEC,IAAI,IAAKA,IAAI,CAACG,QAAQ,CAACC,cAAc,CAAC,CAAC,CAAC;EAC5E,CAAC,CAAC,OAAAC,QAAA,EAAM;IACN;EAAA;EAEF,OAAO,EAAE;AACX;AAEA,eAAejB,6BAA6BA,CAC1ClD,QAA0B;EAE1B,IAAI;IACF,MAAM;MAAEoE;IAAmB,CAAE,GAAG,MAAM,MAAM,CAC1C,iFAAiF,CAClF;IACD,MAAMC,OAAO,GAAG,MAAMD,mBAAmB,CAAC;MAAEpE;IAAQ,CAAE,CAAC;IACvD;IACA,IAAI,CAACqE,OAAO,CAAClE,MAAM,EAAE;MACnB,OAAO,EAAE;IACX;IACA;IACA,OAAO,CAAC,GAAG,IAAIkD,GAAG,CAACgB,OAAO,CAACR,GAAG,CAAEC,IAAI,IAAKA,IAAI,CAACI,cAAc,CAAC,CAAC,CAAC;EACjE,CAAC,CAAC,OAAAI,QAAA,EAAM;IACN;EAAA;EAEF,OAAO,EAAE;AACX;AAEA,eAAenB,4BAA4BA,CACzCnD,QAA0B;EAE1B,IAAI;IACF,MAAM;MAAE0D;IAAY,CAAE,GAAG,MAAM,MAAM,CAAC,oCAAoC,CAAC;IAC3E,MAAMa,MAAM,GAAG,MAAMb,YAAY,CAAC;MAAE1D,QAAQ;MAAE4D,MAAM,EAAEpB;IAAW,CAAE,CAAC;IACpE;IACA,IAAI,CAAC+B,MAAM,CAACpE,MAAM,EAAE;MAClB,OAAO,EAAE;IACX;IACA;IACA,OAAOoE,MAAM,CAACV,GAAG,CAAEC,IAAI,IAAKA,IAAI,CAACU,YAAY,CAAC;EAChD,CAAC,CAAC,OAAAC,QAAA,EAAM;IACN;EAAA;EAEF,OAAO,EAAE;AACX;AASA,eAAelB,iBAAiBA,CAC9BmB,OAAiC;EAEjC,OAAOnD,OAAO,CAACC,GAAG,CAChBkD,OAAO,CAAClB,OAAO,CAACK,GAAG,CAAEE,aAAa,IAAI;IACpC,MAAMY,WAAW,GAAG7E,WAAW,CAAA8E,aAAA,CAAAA,aAAA,KAC1BF,OAAO,CAAC1E,QAAQ;MACnBa,OAAO,EAAEkD;IAAa,EACvB,CAAC;IACF;IACA,IAAIW,OAAO,CAAChC,aAAa,EAAE;MACzB,OAAOgC,OAAO,CAAChC,aAAa,CAACiC,WAAW,CAAC;IAC3C;IACA;IACA,OAAOvD,sBAAsB,CAACuD,WAAW,CAAC;EAC5C,CAAC,CAAC,CACH;AACH;AAOA,SAASlB,QAAQA,CAACiB,OAAwB;EACxC,IAAItB,aAAa,GAAQsB,OAAO,CAACpB,UAAU,CACxCuB,IAAI,EAAE,CACNC,MAAM,CAAEhB,IAAI,IAAKA,IAAI,CAACzB,IAAI,KAAK,aAAa,CAAC;EAEhD,IAAIqC,OAAO,CAACjC,OAAO,EAAE;IACnBW,aAAa,GAAG,CAAC,GAAGsB,OAAO,CAACjC,OAAO,EAAE,GAAGW,aAAa,CAAC,CACnD0B,MAAM,CAAEhB,IAAI,IAAKA,IAAI,CAACzB,IAAI,KAAK,UAAU,IAAIyB,IAAI,CAACzB,IAAI,KAAK,SAAS,CAAC,CACrEyC,MAAM,CAACC,OAAO,CAAC;EACpB;EAEA;EACA;EACA,MAAMC,gBAAgB,GAAG,CAAC,GAAG,IAAI3B,GAAG,CAAC7D,SAAS,CAAC4D,aAAa,CAAC,CAAC,CAAC;EAE/D;EACA,OAAO3D,QAAQ,CAACuF,gBAAgB,CAAC;AACnC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}