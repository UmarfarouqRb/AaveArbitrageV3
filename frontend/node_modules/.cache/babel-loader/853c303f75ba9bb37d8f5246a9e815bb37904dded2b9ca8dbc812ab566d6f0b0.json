{"ast":null,"code":"\"use client\";\n\nimport _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"symbolResolver\", \"formatFn\", \"loadingComponent\", \"fallbackComponent\", \"queryOptions\"];\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { getChainMetadata } from \"../../../../../chains/utils.js\";\nimport { NATIVE_TOKEN_ADDRESS } from \"../../../../../constants/addresses.js\";\nimport { getContract } from \"../../../../../contract/contract.js\";\nimport { getContractMetadata } from \"../../../../../extensions/common/read/getContractMetadata.js\";\nimport { symbol } from \"../../../../../extensions/common/read/symbol.js\";\nimport { getFunctionId } from \"../../../../../utils/function-id.js\";\nimport { useTokenContext } from \"./provider.js\";\n/**\n * This component fetches then shows the symbol of a token. For ERC20 tokens, it calls the `symbol` function in the ERC20 contract.\n * It inherits all the attributes of a HTML <span> component, hence you can style it just like how you would style a normal <span>\n *\n *\n * @example\n * ### Basic usage\n * ```tsx\n * import { TokenProvider, TokenSymbol } from \"thirdweb/react\";\n * import { ethereum } from \"thirdweb/chains\";\n *\n * <TokenProvider {...props}>\n *   <TokenSymbol  />\n * </TokenProvider>\n * ```\n * Result:\n * ```html\n * <span>ETH</span>\n * ```\n *\n * ### Custom symbol resolver\n * By default, TokenSymbol calls the `symbol` function of your contract,\n * however, if your token as an unconventional way to fetch the symbol, you can pass the custom logic to the `symbolResolver` prop.\n * It can either be a string or a function (async) that returns or resolves to a string.\n * ```tsx\n * async function getSymbol() {\n *   // your own fetching logic\n *   return \"the symbol\";\n * }\n *\n * <TokenSymbol symbolResolver={getSymbol} />\n * ```\n * Alternatively, you can pass in a string directly:\n * ```tsx\n * <TokenSymbol symbolResolver=\"USDC.e\" />\n * ```\n *\n * ### Format the symbol (capitalize, truncate, etc.)\n * The TokenSymbol component accepts a `formatFn` which takes in a string and outputs a string\n * The function is used to modify the symbol of the token\n *\n * ```tsx\n * const concatStr = (str: string):string => str + \"Token\"\n *\n * <TokenSymbol formatFn={concatStr} />\n * ```\n *\n * Result:\n * ```html\n * <span>Ether Token</span>\n * ```\n *\n * ### Show a loading sign when the symbol is being fetched\n * ```tsx\n * import { TokenProvider, TokenSymbol } from \"thirdweb/react\";\n *\n * <TokenProvider address=\"0x...\">\n *   <TokenSymbol loadingComponent={<Spinner />} />\n * </TokenProvider>\n * ```\n *\n * ### Fallback to something when the symbol fails to resolve\n * ```tsx\n * <TokenProvider address=\"0x...\">\n *   <TokenSymbol fallbackComponent={\"Failed to load\"} />\n * </TokenProvider>\n * ```\n *\n * ### Custom query options for useQuery\n * This component uses `@tanstack-query`'s useQuery internally.\n * You can use the `queryOptions` prop for more fine-grained control\n * ```tsx\n * <TokenSymbol queryOptions={{\n *     enabled: isEnabled,\n *     retry: 4,\n *   }}\n * />\n * ```\n *\n * @component\n * @token\n * @beta\n */\nexport function TokenSymbol(_ref) {\n  let {\n      symbolResolver,\n      formatFn,\n      loadingComponent,\n      fallbackComponent,\n      queryOptions\n    } = _ref,\n    restProps = _objectWithoutProperties(_ref, _excluded);\n  const {\n    address,\n    client,\n    chain\n  } = useTokenContext();\n  const symbolQuery = useQuery(_objectSpread({\n    queryFn: async () => fetchTokenSymbol({\n      address,\n      chain,\n      client,\n      symbolResolver\n    }),\n    queryKey: getQueryKeys({\n      address,\n      chainId: chain.id,\n      symbolResolver\n    })\n  }, queryOptions));\n  if (symbolQuery.isLoading) {\n    return loadingComponent || null;\n  }\n  if (!symbolQuery.data) {\n    return fallbackComponent || null;\n  }\n  if (formatFn && typeof formatFn === \"function\") {\n    return _jsx(\"span\", _objectSpread(_objectSpread({}, restProps), {}, {\n      children: formatFn(symbolQuery.data)\n    }));\n  }\n  return _jsx(\"span\", _objectSpread(_objectSpread({}, restProps), {}, {\n    children: symbolQuery.data\n  }));\n}\n/**\n * @internal Exported for tests only\n */\nexport async function fetchTokenSymbol(props) {\n  const {\n    symbolResolver,\n    address,\n    client,\n    chain\n  } = props;\n  if (typeof symbolResolver === \"string\") {\n    return symbolResolver;\n  }\n  if (typeof symbolResolver === \"function\") {\n    return symbolResolver();\n  }\n  if (address.toLowerCase() === NATIVE_TOKEN_ADDRESS.toLowerCase()) {\n    // Don't wanna use `getChainSymbol` because it has some side effect (it catches error and defaults to \"ETH\")\n    return getChainMetadata(chain).then(data => data.nativeCurrency.symbol);\n  }\n  // Try to fetch the symbol from both the `symbol` function and the contract metadata\n  // then prioritize its result\n  const contract = getContract({\n    address,\n    chain,\n    client\n  });\n  const [_symbol, contractMetadata] = await Promise.all([symbol({\n    contract\n  }).catch(() => undefined), getContractMetadata({\n    contract\n  }).catch(() => undefined)]);\n  if (typeof _symbol === \"string\") {\n    return _symbol;\n  }\n  if (typeof (contractMetadata === null || contractMetadata === void 0 ? void 0 : contractMetadata.symbol) === \"string\") {\n    return contractMetadata.symbol;\n  }\n  throw new Error(\"Failed to resolve symbol from both symbol() and contract metadata\");\n}\n/**\n * @internal\n */\nexport function getQueryKeys(props) {\n  const {\n    chainId,\n    address,\n    symbolResolver\n  } = props;\n  return [\"_internal_token_symbol_\", chainId, address, {\n    resolver: typeof symbolResolver === \"string\" ? symbolResolver : typeof symbolResolver === \"function\" ? getFunctionId(symbolResolver) : undefined\n  }];\n}","map":{"version":3,"names":["_objectSpread","_objectWithoutProperties","_excluded","useQuery","getChainMetadata","NATIVE_TOKEN_ADDRESS","getContract","getContractMetadata","symbol","getFunctionId","useTokenContext","TokenSymbol","_ref","symbolResolver","formatFn","loadingComponent","fallbackComponent","queryOptions","restProps","address","client","chain","symbolQuery","queryFn","fetchTokenSymbol","queryKey","getQueryKeys","chainId","id","isLoading","data","_jsx","children","props","toLowerCase","then","nativeCurrency","contract","_symbol","contractMetadata","Promise","all","catch","undefined","Error","resolver"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/react/web/ui/prebuilt/Token/symbol.tsx"],"sourcesContent":["\"use client\";\n\nimport { type UseQueryOptions, useQuery } from \"@tanstack/react-query\";\nimport type React from \"react\";\nimport type { JSX } from \"react\";\nimport type { Chain } from \"../../../../../chains/types.js\";\nimport { getChainMetadata } from \"../../../../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../../../../client/client.js\";\nimport { NATIVE_TOKEN_ADDRESS } from \"../../../../../constants/addresses.js\";\nimport { getContract } from \"../../../../../contract/contract.js\";\nimport { getContractMetadata } from \"../../../../../extensions/common/read/getContractMetadata.js\";\nimport { symbol } from \"../../../../../extensions/common/read/symbol.js\";\nimport { getFunctionId } from \"../../../../../utils/function-id.js\";\nimport { useTokenContext } from \"./provider.js\";\n\n/**\n * Props for the TokenSymbol component\n * @component\n * @token\n */\nexport interface TokenSymbolProps\n  extends Omit<React.HTMLAttributes<HTMLSpanElement>, \"children\"> {\n  /**\n   * This prop can be a string or a (async) function that resolves to a string, representing the symbol of the token\n   * This is particularly useful if you already have a way to fetch the token symbol.\n   */\n  symbolResolver?: string | (() => string) | (() => Promise<string>);\n  /**\n   * A function to format the symbol's value\n   * Particularly useful to avoid overflowing-UI issues\n   *\n   * ```tsx\n   * <TokenSymbol formatFn={(str: string) => doSomething()} />\n   * ```\n   */\n  formatFn?: (str: string) => string;\n  /**\n   * This component will be shown while the symbol of the token is being fetched\n   * If not passed, the component will return `null`.\n   *\n   * You can/should pass a loading sign or spinner to this prop.\n   * @example\n   * ```tsx\n   * <TokenSymbol loadingComponent={<Spinner />} />\n   * ```\n   */\n  loadingComponent?: JSX.Element;\n  /**\n   * This component will be shown if the symbol fails to be retreived\n   * If not passed, the component will return `null`.\n   *\n   * You can/should pass a descriptive text/component to this prop, indicating that the\n   * symbol was not fetched successfully\n   * @example\n   * ```tsx\n   * <TokenSymbol fallbackComponent={\"Failed to load\"}\n   * />\n   * ```\n   */\n  fallbackComponent?: JSX.Element;\n  /**\n   * Optional `useQuery` params\n   */\n  queryOptions?: Omit<UseQueryOptions<string>, \"queryFn\" | \"queryKey\">;\n}\n\n/**\n * This component fetches then shows the symbol of a token. For ERC20 tokens, it calls the `symbol` function in the ERC20 contract.\n * It inherits all the attributes of a HTML <span> component, hence you can style it just like how you would style a normal <span>\n *\n *\n * @example\n * ### Basic usage\n * ```tsx\n * import { TokenProvider, TokenSymbol } from \"thirdweb/react\";\n * import { ethereum } from \"thirdweb/chains\";\n *\n * <TokenProvider {...props}>\n *   <TokenSymbol  />\n * </TokenProvider>\n * ```\n * Result:\n * ```html\n * <span>ETH</span>\n * ```\n *\n * ### Custom symbol resolver\n * By default, TokenSymbol calls the `symbol` function of your contract,\n * however, if your token as an unconventional way to fetch the symbol, you can pass the custom logic to the `symbolResolver` prop.\n * It can either be a string or a function (async) that returns or resolves to a string.\n * ```tsx\n * async function getSymbol() {\n *   // your own fetching logic\n *   return \"the symbol\";\n * }\n *\n * <TokenSymbol symbolResolver={getSymbol} />\n * ```\n * Alternatively, you can pass in a string directly:\n * ```tsx\n * <TokenSymbol symbolResolver=\"USDC.e\" />\n * ```\n *\n * ### Format the symbol (capitalize, truncate, etc.)\n * The TokenSymbol component accepts a `formatFn` which takes in a string and outputs a string\n * The function is used to modify the symbol of the token\n *\n * ```tsx\n * const concatStr = (str: string):string => str + \"Token\"\n *\n * <TokenSymbol formatFn={concatStr} />\n * ```\n *\n * Result:\n * ```html\n * <span>Ether Token</span>\n * ```\n *\n * ### Show a loading sign when the symbol is being fetched\n * ```tsx\n * import { TokenProvider, TokenSymbol } from \"thirdweb/react\";\n *\n * <TokenProvider address=\"0x...\">\n *   <TokenSymbol loadingComponent={<Spinner />} />\n * </TokenProvider>\n * ```\n *\n * ### Fallback to something when the symbol fails to resolve\n * ```tsx\n * <TokenProvider address=\"0x...\">\n *   <TokenSymbol fallbackComponent={\"Failed to load\"} />\n * </TokenProvider>\n * ```\n *\n * ### Custom query options for useQuery\n * This component uses `@tanstack-query`'s useQuery internally.\n * You can use the `queryOptions` prop for more fine-grained control\n * ```tsx\n * <TokenSymbol queryOptions={{\n *     enabled: isEnabled,\n *     retry: 4,\n *   }}\n * />\n * ```\n *\n * @component\n * @token\n * @beta\n */\nexport function TokenSymbol({\n  symbolResolver,\n  formatFn,\n  loadingComponent,\n  fallbackComponent,\n  queryOptions,\n  ...restProps\n}: TokenSymbolProps) {\n  const { address, client, chain } = useTokenContext();\n  const symbolQuery = useQuery({\n    queryFn: async () =>\n      fetchTokenSymbol({ address, chain, client, symbolResolver }),\n    queryKey: getQueryKeys({ address, chainId: chain.id, symbolResolver }),\n    ...queryOptions,\n  });\n\n  if (symbolQuery.isLoading) {\n    return loadingComponent || null;\n  }\n\n  if (!symbolQuery.data) {\n    return fallbackComponent || null;\n  }\n\n  if (formatFn && typeof formatFn === \"function\") {\n    return <span {...restProps}>{formatFn(symbolQuery.data)}</span>;\n  }\n\n  return <span {...restProps}>{symbolQuery.data}</span>;\n}\n\n/**\n * @internal Exported for tests only\n */\nexport async function fetchTokenSymbol(props: {\n  address: string;\n  client: ThirdwebClient;\n  chain: Chain;\n  symbolResolver?: string | (() => string) | (() => Promise<string>);\n}): Promise<string> {\n  const { symbolResolver, address, client, chain } = props;\n  if (typeof symbolResolver === \"string\") {\n    return symbolResolver;\n  }\n  if (typeof symbolResolver === \"function\") {\n    return symbolResolver();\n  }\n  if (address.toLowerCase() === NATIVE_TOKEN_ADDRESS.toLowerCase()) {\n    // Don't wanna use `getChainSymbol` because it has some side effect (it catches error and defaults to \"ETH\")\n    return getChainMetadata(chain).then((data) => data.nativeCurrency.symbol);\n  }\n\n  // Try to fetch the symbol from both the `symbol` function and the contract metadata\n  // then prioritize its result\n  const contract = getContract({ address, chain, client });\n  const [_symbol, contractMetadata] = await Promise.all([\n    symbol({ contract }).catch(() => undefined),\n    getContractMetadata({ contract }).catch(() => undefined),\n  ]);\n  if (typeof _symbol === \"string\") {\n    return _symbol;\n  }\n  if (typeof contractMetadata?.symbol === \"string\") {\n    return contractMetadata.symbol;\n  }\n  throw new Error(\n    \"Failed to resolve symbol from both symbol() and contract metadata\",\n  );\n}\n\n/**\n * @internal\n */\nexport function getQueryKeys(props: {\n  chainId: number;\n  address: string;\n  symbolResolver?: string | (() => string) | (() => Promise<string>);\n}) {\n  const { chainId, address, symbolResolver } = props;\n  return [\n    \"_internal_token_symbol_\",\n    chainId,\n    address,\n    {\n      resolver:\n        typeof symbolResolver === \"string\"\n          ? symbolResolver\n          : typeof symbolResolver === \"function\"\n            ? getFunctionId(symbolResolver)\n            : undefined,\n    },\n  ] as const;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}