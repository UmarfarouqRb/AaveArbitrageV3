{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { getOwnedNFTs as getInsightNFTs } from \"../../../insight/get-nfts.js\";\nimport { getNFT } from \"./getNFT.js\";\nimport { getOwnedTokenIds } from \"./getOwnedTokenIds.js\";\n/**\n * Retrieves the owned ERC1155 NFTs for a given wallet address.\n * @param options - The transaction options and parameters.\n * @returns A promise that resolves to an array of ERC1155 NFTs owned by the wallet address, along with the quantity owned.\n * @extension ERC1155\n * @example\n * ```ts\n * import { getOwnedNFTs } from \"thirdweb/extensions/erc1155\";\n * const nfts = await getOwnedNFTs({\n *  contract,\n *  start: 0,\n *  count: 10,\n *  address: \"0x123...\",\n * });\n * ```\n */\nexport async function getOwnedNFTs(options) {\n  const {\n    useIndexer = true\n  } = options;\n  if (useIndexer) {\n    try {\n      return await getOwnedNFTsFromInsight(options);\n    } catch (_unused) {\n      return await getOwnedNFTsFromRPC(options);\n    }\n  }\n  return await getOwnedNFTsFromRPC(options);\n}\nasync function getOwnedNFTsFromInsight(options) {\n  const limit = 50;\n  const nfts = [];\n  let page = 0;\n  let hasMore = true;\n  // TODO (insight): add support for contract address filters\n  while (hasMore) {\n    const pageResults = await getInsightNFTs({\n      chains: [options.contract.chain],\n      client: options.contract.client,\n      ownerAddress: options.address,\n      contractAddresses: [options.contract.address],\n      queryOptions: {\n        limit,\n        page\n      }\n    });\n    nfts.push(...pageResults);\n    // If we got fewer results than the limit, we've reached the end\n    if (pageResults.length < limit) {\n      hasMore = false;\n    } else {\n      page++;\n    }\n  }\n  const results = nfts;\n  return results.filter(n => n.tokenAddress.toLowerCase() === options.contract.address.toLowerCase()).map(result => _objectSpread(_objectSpread({}, result), {}, {\n    owner: options.address\n  }));\n}\nasync function getOwnedNFTsFromRPC(options) {\n  const ownedBalances = await getOwnedTokenIds(options);\n  const nfts = await Promise.all(ownedBalances.map(ob => getNFT(_objectSpread(_objectSpread({}, options), {}, {\n    tokenId: ob.tokenId,\n    useIndexer: false\n  }))));\n  return nfts.map((nft, index) => {\n    var _ownedBalances$index;\n    return _objectSpread(_objectSpread({}, nft), {}, {\n      owner: options.address,\n      quantityOwned: ((_ownedBalances$index = ownedBalances[index]) === null || _ownedBalances$index === void 0 ? void 0 : _ownedBalances$index.balance) || 0n\n    });\n  });\n}","map":{"version":3,"names":["getOwnedNFTs","getInsightNFTs","getNFT","getOwnedTokenIds","options","useIndexer","getOwnedNFTsFromInsight","_unused","getOwnedNFTsFromRPC","limit","nfts","page","hasMore","pageResults","chains","contract","chain","client","ownerAddress","address","contractAddresses","queryOptions","push","length","results","filter","n","tokenAddress","toLowerCase","map","result","_objectSpread","owner","ownedBalances","Promise","all","ob","tokenId","nft","index","_ownedBalances$index","quantityOwned","balance"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/extensions/erc1155/read/getOwnedNFTs.ts"],"sourcesContent":["import { getOwnedNFTs as getInsightNFTs } from \"../../../insight/get-nfts.js\";\nimport type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport type { NFT } from \"../../../utils/nft/parseNft.js\";\nimport { getNFT } from \"./getNFT.js\";\nimport {\n  type GetOwnedTokenIdsParams,\n  getOwnedTokenIds,\n} from \"./getOwnedTokenIds.js\";\n/**\n * Parameters for retrieving NFTs.\n * @extension ERC1155\n */\nexport type GetOwnedNFTsParams = GetOwnedTokenIdsParams & {\n  /**\n   * Whether to use the insight API to fetch the NFTs.\n   * @default true\n   */\n  useIndexer?: boolean;\n};\n\n/**\n * Retrieves the owned ERC1155 NFTs for a given wallet address.\n * @param options - The transaction options and parameters.\n * @returns A promise that resolves to an array of ERC1155 NFTs owned by the wallet address, along with the quantity owned.\n * @extension ERC1155\n * @example\n * ```ts\n * import { getOwnedNFTs } from \"thirdweb/extensions/erc1155\";\n * const nfts = await getOwnedNFTs({\n *  contract,\n *  start: 0,\n *  count: 10,\n *  address: \"0x123...\",\n * });\n * ```\n */\nexport async function getOwnedNFTs(\n  options: BaseTransactionOptions<GetOwnedNFTsParams>,\n): Promise<(NFT & { quantityOwned: bigint })[]> {\n  const { useIndexer = true } = options;\n  if (useIndexer) {\n    try {\n      return await getOwnedNFTsFromInsight(options);\n    } catch {\n      return await getOwnedNFTsFromRPC(options);\n    }\n  }\n  return await getOwnedNFTsFromRPC(options);\n}\n\nasync function getOwnedNFTsFromInsight(\n  options: BaseTransactionOptions<GetOwnedNFTsParams>,\n): Promise<(NFT & { quantityOwned: bigint })[]> {\n  const limit = 50;\n  const nfts: (NFT & { quantityOwned: bigint })[] = [];\n  let page = 0;\n  let hasMore = true;\n\n  // TODO (insight): add support for contract address filters\n  while (hasMore) {\n    const pageResults = await getInsightNFTs({\n      chains: [options.contract.chain],\n      client: options.contract.client,\n      ownerAddress: options.address,\n      contractAddresses: [options.contract.address],\n      queryOptions: {\n        limit,\n        page,\n      },\n    });\n\n    nfts.push(...pageResults);\n\n    // If we got fewer results than the limit, we've reached the end\n    if (pageResults.length < limit) {\n      hasMore = false;\n    } else {\n      page++;\n    }\n  }\n\n  const results = nfts;\n\n  return results\n    .filter(\n      (n) =>\n        n.tokenAddress.toLowerCase() === options.contract.address.toLowerCase(),\n    )\n    .map((result) => ({\n      ...result,\n      owner: options.address,\n    }));\n}\n\nasync function getOwnedNFTsFromRPC(\n  options: BaseTransactionOptions<GetOwnedNFTsParams>,\n): Promise<(NFT & { quantityOwned: bigint })[]> {\n  const ownedBalances = await getOwnedTokenIds(options);\n\n  const nfts = await Promise.all(\n    ownedBalances.map((ob) =>\n      getNFT({ ...options, tokenId: ob.tokenId, useIndexer: false }),\n    ),\n  );\n\n  return nfts.map((nft, index) => ({\n    ...nft,\n    owner: options.address,\n    quantityOwned: ownedBalances[index]?.balance || 0n,\n  }));\n}\n"],"mappings":";AAAA,SAASA,YAAY,IAAIC,cAAc,QAAQ,8BAA8B;AAG7E,SAASC,MAAM,QAAQ,aAAa;AACpC,SAEEC,gBAAgB,QACX,uBAAuB;AAa9B;;;;;;;;;;;;;;;;AAgBA,OAAO,eAAeH,YAAYA,CAChCI,OAAmD;EAEnD,MAAM;IAAEC,UAAU,GAAG;EAAI,CAAE,GAAGD,OAAO;EACrC,IAAIC,UAAU,EAAE;IACd,IAAI;MACF,OAAO,MAAMC,uBAAuB,CAACF,OAAO,CAAC;IAC/C,CAAC,CAAC,OAAAG,OAAA,EAAM;MACN,OAAO,MAAMC,mBAAmB,CAACJ,OAAO,CAAC;IAC3C;EACF;EACA,OAAO,MAAMI,mBAAmB,CAACJ,OAAO,CAAC;AAC3C;AAEA,eAAeE,uBAAuBA,CACpCF,OAAmD;EAEnD,MAAMK,KAAK,GAAG,EAAE;EAChB,MAAMC,IAAI,GAAwC,EAAE;EACpD,IAAIC,IAAI,GAAG,CAAC;EACZ,IAAIC,OAAO,GAAG,IAAI;EAElB;EACA,OAAOA,OAAO,EAAE;IACd,MAAMC,WAAW,GAAG,MAAMZ,cAAc,CAAC;MACvCa,MAAM,EAAE,CAACV,OAAO,CAACW,QAAQ,CAACC,KAAK,CAAC;MAChCC,MAAM,EAAEb,OAAO,CAACW,QAAQ,CAACE,MAAM;MAC/BC,YAAY,EAAEd,OAAO,CAACe,OAAO;MAC7BC,iBAAiB,EAAE,CAAChB,OAAO,CAACW,QAAQ,CAACI,OAAO,CAAC;MAC7CE,YAAY,EAAE;QACZZ,KAAK;QACLE;;KAEH,CAAC;IAEFD,IAAI,CAACY,IAAI,CAAC,GAAGT,WAAW,CAAC;IAEzB;IACA,IAAIA,WAAW,CAACU,MAAM,GAAGd,KAAK,EAAE;MAC9BG,OAAO,GAAG,KAAK;IACjB,CAAC,MAAM;MACLD,IAAI,EAAE;IACR;EACF;EAEA,MAAMa,OAAO,GAAGd,IAAI;EAEpB,OAAOc,OAAO,CACXC,MAAM,CACJC,CAAC,IACAA,CAAC,CAACC,YAAY,CAACC,WAAW,EAAE,KAAKxB,OAAO,CAACW,QAAQ,CAACI,OAAO,CAACS,WAAW,EAAE,CAC1E,CACAC,GAAG,CAAEC,MAAM,IAAAC,aAAA,CAAAA,aAAA,KACPD,MAAM;IACTE,KAAK,EAAE5B,OAAO,CAACe;EAAO,EACtB,CAAC;AACP;AAEA,eAAeX,mBAAmBA,CAChCJ,OAAmD;EAEnD,MAAM6B,aAAa,GAAG,MAAM9B,gBAAgB,CAACC,OAAO,CAAC;EAErD,MAAMM,IAAI,GAAG,MAAMwB,OAAO,CAACC,GAAG,CAC5BF,aAAa,CAACJ,GAAG,CAAEO,EAAE,IACnBlC,MAAM,CAAA6B,aAAA,CAAAA,aAAA,KAAM3B,OAAO;IAAEiC,OAAO,EAAED,EAAE,CAACC,OAAO;IAAEhC,UAAU,EAAE;EAAK,EAAE,CAAC,CAC/D,CACF;EAED,OAAOK,IAAI,CAACmB,GAAG,CAAC,CAACS,GAAG,EAAEC,KAAK;IAAA,IAAAC,oBAAA;IAAA,OAAAT,aAAA,CAAAA,aAAA,KACtBO,GAAG;MACNN,KAAK,EAAE5B,OAAO,CAACe,OAAO;MACtBsB,aAAa,EAAE,EAAAD,oBAAA,GAAAP,aAAa,CAACM,KAAK,CAAC,cAAAC,oBAAA,uBAApBA,oBAAA,CAAsBE,OAAO,KAAI;IAAE;EAAA,CAClD,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}