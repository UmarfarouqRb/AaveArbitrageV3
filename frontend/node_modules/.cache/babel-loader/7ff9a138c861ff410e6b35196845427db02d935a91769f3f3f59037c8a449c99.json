{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { getBytecode } from \"../../contract/actions/get-bytecode.js\";\nimport { getContract } from \"../../contract/contract.js\";\nimport { eth_getStorageAt } from \"../../rpc/actions/eth_getStorageAt.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { readContract } from \"../../transaction/read-contract.js\";\nimport { isAddress } from \"../address.js\";\nimport { extractMinimalProxyImplementationAddress } from \"./extractMinimalProxyImplementationAddress.js\";\n// TODO: move to const exports\nconst AddressZero = \"0x0000000000000000000000000000000000000000\";\nconst ZERO_BYTES32 = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n/**\n * Resolves the implementation address and bytecode for a given proxy contract.\n * @param contract The contract to resolve the implementation for.\n * @returns A promise that resolves to an object containing the implementation address and bytecode.\n * @example\n * ```ts\n * import { resolveImplementation } from \"thirdweb/utils\";\n * const implementation = await resolveImplementation(contract);\n * ```\n * @contract\n */\nexport async function resolveImplementation(\n// biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\ncontract) {\n  const [originalBytecode, beacon] = await Promise.all([getBytecode(contract), getBeaconFromStorageSlot(contract)]);\n  // check minimal proxy first synchronously\n  const minimalProxyImplementationAddress = extractMinimalProxyImplementationAddress(originalBytecode);\n  if (minimalProxyImplementationAddress) {\n    return {\n      address: minimalProxyImplementationAddress,\n      bytecode: await getBytecode(getContract(_objectSpread(_objectSpread({}, contract), {}, {\n        address: minimalProxyImplementationAddress\n      })))\n    };\n  }\n  // check other proxy types\n  let implementationAddress;\n  if (beacon && beacon !== AddressZero) {\n    // In case of a BeaconProxy, it is setup as BeaconProxy --> Beacon --> Implementation\n    // Hence we replace the proxy address with Beacon address, and continue further resolving below\n    contract = getContract(_objectSpread(_objectSpread({}, contract), {}, {\n      address: beacon\n    }));\n    implementationAddress = await getImplementationFromContractCall(contract);\n  } else {\n    implementationAddress = await getImplementationFromStorageSlot(contract);\n  }\n  if (implementationAddress && isAddress(implementationAddress) && implementationAddress !== AddressZero) {\n    const implementationBytecode = await getBytecode(_objectSpread(_objectSpread({}, contract), {}, {\n      address: implementationAddress\n    }));\n    // return the original contract bytecode if the implementation bytecode is empty\n    if (implementationBytecode === \"0x\") {\n      return {\n        address: contract.address,\n        bytecode: originalBytecode\n      };\n    }\n    return {\n      address: implementationAddress,\n      bytecode: implementationBytecode\n    };\n  }\n  return {\n    address: contract.address,\n    bytecode: originalBytecode\n  };\n}\nasync function getBeaconFromStorageSlot(\n// biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\ncontract) {\n  /**\n   * The storage slot of the Beacon as defined in EIP-1967\n   * See https://eips.ethereum.org/EIPS/eip-1967#beacon-contract-address\n   *\n   * bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1))\n   */\n  const rpcRequest = getRpcClient({\n    chain: contract.chain,\n    client: contract.client\n  });\n  try {\n    const proxyStorage = await eth_getStorageAt(rpcRequest, {\n      address: contract.address,\n      position: \"0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50\"\n    });\n    if (proxyStorage.length >= 40) {\n      return \"0x\".concat(proxyStorage.slice(-40));\n    }\n    return undefined;\n  } catch (_unused) {\n    return undefined;\n  }\n}\nasync function getImplementationFromStorageSlot(\n// biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\ncontract) {\n  const rpcRequest = getRpcClient({\n    chain: contract.chain,\n    client: contract.client\n  });\n  try {\n    const proxyStoragePromises = [eth_getStorageAt(rpcRequest, {\n      address: contract.address,\n      position: \"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\"\n    }), eth_getStorageAt(rpcRequest, {\n      address: contract.address,\n      position:\n      // keccak256(\"matic.network.proxy.implementation\") - used in polygon USDT proxy: https://polygonscan.com/address/0xc2132d05d31c914a87c6611c10748aeb04b58e8f#code\n      \"0xbaab7dbf64751104133af04abc7d9979f0fda3b059a322a8333f533d3f32bf7f\"\n    }), eth_getStorageAt(rpcRequest, {\n      address: contract.address,\n      position:\n      // keccak256(\"org.zeppelinos.proxy.implementation\") - e.g. base USDC proxy: https://basescan.org/address/0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913#code\n      \"0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3\"\n    })];\n    const proxyStorages = await Promise.all(proxyStoragePromises);\n    const proxyStorage = proxyStorages.find(storage => storage !== ZERO_BYTES32);\n    return proxyStorage ? \"0x\".concat(proxyStorage.slice(-40)) : AddressZero;\n  } catch (_unused2) {\n    return undefined;\n  }\n}\nconst UPGRADEABLE_PROXY_ABI = {\n  inputs: [],\n  name: \"implementation\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n};\nasync function getImplementationFromContractCall(\n// biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\ncontract) {\n  try {\n    return await readContract({\n      contract,\n      method: UPGRADEABLE_PROXY_ABI\n    });\n  } catch (_unused3) {\n    return undefined;\n  }\n}","map":{"version":3,"names":["getBytecode","getContract","eth_getStorageAt","getRpcClient","readContract","isAddress","extractMinimalProxyImplementationAddress","AddressZero","ZERO_BYTES32","resolveImplementation","contract","originalBytecode","beacon","Promise","all","getBeaconFromStorageSlot","minimalProxyImplementationAddress","address","bytecode","_objectSpread","implementationAddress","getImplementationFromContractCall","getImplementationFromStorageSlot","implementationBytecode","rpcRequest","chain","client","proxyStorage","position","length","concat","slice","undefined","_unused","proxyStoragePromises","proxyStorages","find","storage","_unused2","UPGRADEABLE_PROXY_ABI","inputs","name","outputs","internalType","type","stateMutability","method","_unused3"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/utils/bytecode/resolveImplementation.ts"],"sourcesContent":["import { getBytecode } from \"../../contract/actions/get-bytecode.js\";\nimport { getContract, type ThirdwebContract } from \"../../contract/contract.js\";\nimport { eth_getStorageAt } from \"../../rpc/actions/eth_getStorageAt.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { readContract } from \"../../transaction/read-contract.js\";\nimport { isAddress } from \"../address.js\";\nimport type { Hex } from \"../encoding/hex.js\";\nimport { extractMinimalProxyImplementationAddress } from \"./extractMinimalProxyImplementationAddress.js\";\n\n// TODO: move to const exports\nconst AddressZero = \"0x0000000000000000000000000000000000000000\";\nconst ZERO_BYTES32 =\n  \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n\n/**\n * Resolves the implementation address and bytecode for a given proxy contract.\n * @param contract The contract to resolve the implementation for.\n * @returns A promise that resolves to an object containing the implementation address and bytecode.\n * @example\n * ```ts\n * import { resolveImplementation } from \"thirdweb/utils\";\n * const implementation = await resolveImplementation(contract);\n * ```\n * @contract\n */\nexport async function resolveImplementation(\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  contract: ThirdwebContract<any>,\n): Promise<{ address: string; bytecode: Hex }> {\n  const [originalBytecode, beacon] = await Promise.all([\n    getBytecode(contract),\n    getBeaconFromStorageSlot(contract),\n  ]);\n  // check minimal proxy first synchronously\n  const minimalProxyImplementationAddress =\n    extractMinimalProxyImplementationAddress(originalBytecode);\n  if (minimalProxyImplementationAddress) {\n    return {\n      address: minimalProxyImplementationAddress,\n      bytecode: await getBytecode(\n        getContract({\n          ...contract,\n          address: minimalProxyImplementationAddress,\n        }),\n      ),\n    };\n  }\n\n  // check other proxy types\n  let implementationAddress: string | undefined;\n\n  if (beacon && beacon !== AddressZero) {\n    // In case of a BeaconProxy, it is setup as BeaconProxy --> Beacon --> Implementation\n    // Hence we replace the proxy address with Beacon address, and continue further resolving below\n    contract = getContract({\n      ...contract,\n      address: beacon,\n    });\n\n    implementationAddress = await getImplementationFromContractCall(contract);\n  } else {\n    implementationAddress = await getImplementationFromStorageSlot(contract);\n  }\n\n  if (\n    implementationAddress &&\n    isAddress(implementationAddress) &&\n    implementationAddress !== AddressZero\n  ) {\n    const implementationBytecode = await getBytecode({\n      ...contract,\n      address: implementationAddress,\n    });\n    // return the original contract bytecode if the implementation bytecode is empty\n    if (implementationBytecode === \"0x\") {\n      return {\n        address: contract.address,\n        bytecode: originalBytecode,\n      };\n    }\n\n    return {\n      address: implementationAddress,\n      bytecode: implementationBytecode,\n    };\n  }\n\n  return { address: contract.address, bytecode: originalBytecode };\n}\n\nasync function getBeaconFromStorageSlot(\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  contract: ThirdwebContract<any>,\n): Promise<string | undefined> {\n  /**\n   * The storage slot of the Beacon as defined in EIP-1967\n   * See https://eips.ethereum.org/EIPS/eip-1967#beacon-contract-address\n   *\n   * bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1))\n   */\n  const rpcRequest = getRpcClient({\n    chain: contract.chain,\n    client: contract.client,\n  });\n\n  try {\n    const proxyStorage = await eth_getStorageAt(rpcRequest, {\n      address: contract.address,\n      position:\n        \"0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50\",\n    });\n    if (proxyStorage.length >= 40) {\n      return `0x${proxyStorage.slice(-40)}`;\n    }\n    return undefined;\n  } catch {\n    return undefined;\n  }\n}\n\nasync function getImplementationFromStorageSlot(\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  contract: ThirdwebContract<any>,\n): Promise<string | undefined> {\n  const rpcRequest = getRpcClient({\n    chain: contract.chain,\n    client: contract.client,\n  });\n\n  try {\n    const proxyStoragePromises = [\n      eth_getStorageAt(rpcRequest, {\n        address: contract.address,\n        position:\n          \"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\",\n      }),\n      eth_getStorageAt(rpcRequest, {\n        address: contract.address,\n        position:\n          // keccak256(\"matic.network.proxy.implementation\") - used in polygon USDT proxy: https://polygonscan.com/address/0xc2132d05d31c914a87c6611c10748aeb04b58e8f#code\n          \"0xbaab7dbf64751104133af04abc7d9979f0fda3b059a322a8333f533d3f32bf7f\",\n      }),\n      eth_getStorageAt(rpcRequest, {\n        address: contract.address,\n        position:\n          // keccak256(\"org.zeppelinos.proxy.implementation\") - e.g. base USDC proxy: https://basescan.org/address/0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913#code\n          \"0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3\",\n      }),\n    ];\n\n    const proxyStorages = await Promise.all(proxyStoragePromises);\n    const proxyStorage = proxyStorages.find(\n      (storage) => storage !== ZERO_BYTES32,\n    );\n\n    return proxyStorage ? `0x${proxyStorage.slice(-40)}` : AddressZero;\n  } catch {\n    return undefined;\n  }\n}\n\nconst UPGRADEABLE_PROXY_ABI = {\n  inputs: [],\n  name: \"implementation\",\n  outputs: [\n    {\n      internalType: \"address\",\n      name: \"\",\n      type: \"address\",\n    },\n  ],\n  stateMutability: \"view\",\n  type: \"function\",\n} as const;\n\nasync function getImplementationFromContractCall(\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  contract: ThirdwebContract<any>,\n): Promise<string | undefined> {\n  try {\n    return await readContract({ contract, method: UPGRADEABLE_PROXY_ABI });\n  } catch {\n    return undefined;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}