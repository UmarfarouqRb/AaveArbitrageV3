{"ast":null,"code":"const DEFAULT_GATEWAY = \"https://{clientId}.ipfscdn.io/ipfs/{cid}\";\n/**\n * Resolves the scheme of a given URI and returns the corresponding URL.\n * If the URI starts with \"ipfs://\", it constructs a URL using the IPFS client ID and the IPFS gateway.\n * If the URI starts with \"http\", it returns the URI as is.\n * Otherwise, it throws an error indicating an invalid URI scheme.\n * @param options - The options object containing the URI and the IPFS client.\n * @returns The resolved URL.\n * @throws Error if the URI scheme is invalid.\n * @example\n * ```ts\n * import { resolveScheme } from \"thirdweb/storage\";\n * const url = resolveScheme({\n *  client,\n *  uri: \"ipfs://Qm...\",\n * });\n * ```\n * @storage\n */\nexport function resolveScheme(options) {\n  if (options.uri.startsWith(\"ipfs://\")) {\n    var _options$client$confi, _options$client$confi2;\n    const gateway = (_options$client$confi = (_options$client$confi2 = options.client.config) === null || _options$client$confi2 === void 0 || (_options$client$confi2 = _options$client$confi2.storage) === null || _options$client$confi2 === void 0 ? void 0 : _options$client$confi2.gatewayUrl) !== null && _options$client$confi !== void 0 ? _options$client$confi : DEFAULT_GATEWAY;\n    const clientId = options.client.clientId;\n    const cid = findIPFSCidFromUri(options.uri);\n    let bundleId;\n    if (typeof globalThis !== \"undefined\" && \"Application\" in globalThis) {\n      // shims use wallet connect RN module which injects Application info in globalThis\n      // biome-ignore lint/suspicious/noExplicitAny: get around globalThis typing\n      bundleId = globalThis.Application.applicationId;\n    }\n    // purposefully using SPLIT here and not replace for CID to avoid cases where users don't know the schema\n    // also only splitting on `/ipfs` to avoid cases where people pass non `/` terminated gateway urls\n    return \"\".concat(gateway.replace(\"{clientId}\", clientId).split(\"/ipfs\")[0], \"/ipfs/\").concat(cid).concat(bundleId ? \"?bundleId=\".concat(bundleId) : \"\");\n  }\n  if (options.uri.startsWith(\"http\")) {\n    return options.uri;\n  }\n  throw new Error(\"Invalid URI scheme, expected \\\"ipfs://\\\" or \\\"http(s)://\\\"\");\n}\n/**\n * @internal\n */\nexport function findIPFSCidFromUri(uri) {\n  if (!uri.startsWith(\"ipfs://\")) {\n    // do not touch URIs that are not ipfs URIs\n    return uri;\n  }\n  // first index of `/Qm` or `/bafy` in the uri (case insensitive)\n  const firstIndex = uri.search(/\\/(Qm|baf)/i);\n  // we start one character after the first `/` to avoid including it in the CID\n  return uri.slice(firstIndex + 1);\n}\n/**\n * Uploads or extracts URIs from the given files.\n * @template T - The type of the files (File, Buffer, String).\n * @param files - The files to upload or extract URIs from.\n * @param client - The Thirdweb client.\n * @param [startNumber] - The starting number for rewriting file names.\n * @returns - A promise that resolves to an array of URIs.\n * @throws {Error} - If the files are not all of the same type (all URI or all FileOrBufferOrString).\n * @internal\n *\n */\nexport async function uploadOrExtractURIs(files, client, startNumber) {\n  if (isUriList(files)) {\n    return files;\n  }\n  if (isMetadataList(files)) {\n    const {\n      upload\n    } = await import(\"../storage/upload.js\");\n    const uris = await upload({\n      client,\n      files,\n      rewriteFileNames: {\n        fileStartNumber: startNumber || 0\n      }\n    });\n    return Array.isArray(uris) ? uris : [uris];\n  }\n  throw new Error(\"Files must all be of the same type (all URI or all FileOrBufferOrString)\");\n}\n/**\n * Retrieves the base URI from a batch of URIs.\n *\n * @param uris - An array of URIs.\n * @returns The base URI shared by all URIs in the batch.\n * @throws If the batch contains URIs with different base URIs or if no base URI is found.\n * @internal\n */\nexport function getBaseUriFromBatch(uris) {\n  uris = Array.isArray(uris) ? uris : [uris];\n  const [base, ...rest] = uris.map(uri => {\n    // remove query parameters\n    [uri] = uri.split(\"?\");\n    // remove fragments\n    [uri] = uri.split(\"#\");\n    // if the URI ends with a `/`, remove it\n    if (uri.endsWith(\"/\")) {\n      uri = uri.slice(0, -1);\n    }\n    // remove the last part of the URI & add the trailing `/`\n    return \"\".concat(uri.split(\"/\").slice(0, -1).join(\"/\"), \"/\");\n  });\n  if (!base) {\n    throw new Error(\"Batch of URIs is empty\");\n  }\n  if (rest.some(uri => uri !== base)) {\n    throw new Error(\"All URIs in the batch must have the same base URI\");\n  }\n  return base;\n}\nfunction isUriList(metadatas) {\n  return metadatas.every(m => typeof m === \"string\");\n}\nfunction isMetadataList(metadatas) {\n  return metadatas.every(m => typeof m !== \"string\");\n}","map":{"version":3,"names":["DEFAULT_GATEWAY","resolveScheme","options","uri","startsWith","_options$client$confi","_options$client$confi2","gateway","client","config","storage","gatewayUrl","clientId","cid","findIPFSCidFromUri","bundleId","globalThis","Application","applicationId","concat","replace","split","Error","firstIndex","search","slice","uploadOrExtractURIs","files","startNumber","isUriList","isMetadataList","upload","uris","rewriteFileNames","fileStartNumber","Array","isArray","getBaseUriFromBatch","base","rest","map","endsWith","join","some","metadatas","every","m"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/utils/ipfs.ts"],"sourcesContent":["import type { ThirdwebClient } from \"../client/client.js\";\nimport type { FileOrBufferOrString } from \"../storage/upload/types.js\";\n\nexport type ResolveSchemeOptions = {\n  client: ThirdwebClient;\n  uri: string;\n};\n\nconst DEFAULT_GATEWAY = \"https://{clientId}.ipfscdn.io/ipfs/{cid}\";\n\n/**\n * Resolves the scheme of a given URI and returns the corresponding URL.\n * If the URI starts with \"ipfs://\", it constructs a URL using the IPFS client ID and the IPFS gateway.\n * If the URI starts with \"http\", it returns the URI as is.\n * Otherwise, it throws an error indicating an invalid URI scheme.\n * @param options - The options object containing the URI and the IPFS client.\n * @returns The resolved URL.\n * @throws Error if the URI scheme is invalid.\n * @example\n * ```ts\n * import { resolveScheme } from \"thirdweb/storage\";\n * const url = resolveScheme({\n *  client,\n *  uri: \"ipfs://Qm...\",\n * });\n * ```\n * @storage\n */\nexport function resolveScheme(options: ResolveSchemeOptions) {\n  if (options.uri.startsWith(\"ipfs://\")) {\n    const gateway =\n      options.client.config?.storage?.gatewayUrl ?? DEFAULT_GATEWAY;\n    const clientId = options.client.clientId;\n    const cid = findIPFSCidFromUri(options.uri);\n\n    let bundleId: string | undefined;\n    if (typeof globalThis !== \"undefined\" && \"Application\" in globalThis) {\n      // shims use wallet connect RN module which injects Application info in globalThis\n      // biome-ignore lint/suspicious/noExplicitAny: get around globalThis typing\n      bundleId = (globalThis as any).Application.applicationId;\n    }\n\n    // purposefully using SPLIT here and not replace for CID to avoid cases where users don't know the schema\n    // also only splitting on `/ipfs` to avoid cases where people pass non `/` terminated gateway urls\n    return `${\n      gateway.replace(\"{clientId}\", clientId).split(\"/ipfs\")[0]\n    }/ipfs/${cid}${bundleId ? `?bundleId=${bundleId}` : \"\"}`;\n  }\n  if (options.uri.startsWith(\"http\")) {\n    return options.uri;\n  }\n  throw new Error(`Invalid URI scheme, expected \"ipfs://\" or \"http(s)://\"`);\n}\n\n/**\n * @internal\n */\nexport function findIPFSCidFromUri(uri: string) {\n  if (!uri.startsWith(\"ipfs://\")) {\n    // do not touch URIs that are not ipfs URIs\n    return uri;\n  }\n\n  // first index of `/Qm` or `/bafy` in the uri (case insensitive)\n  const firstIndex = uri.search(/\\/(Qm|baf)/i);\n  // we start one character after the first `/` to avoid including it in the CID\n  return uri.slice(firstIndex + 1);\n}\n/**\n * Uploads or extracts URIs from the given files.\n * @template T - The type of the files (File, Buffer, String).\n * @param files - The files to upload or extract URIs from.\n * @param client - The Thirdweb client.\n * @param [startNumber] - The starting number for rewriting file names.\n * @returns - A promise that resolves to an array of URIs.\n * @throws {Error} - If the files are not all of the same type (all URI or all FileOrBufferOrString).\n * @internal\n *\n */\nexport async function uploadOrExtractURIs<\n  T extends FileOrBufferOrString | Record<string, unknown>,\n>(files: T[], client: ThirdwebClient, startNumber?: number): Promise<string[]> {\n  if (isUriList(files)) {\n    return files;\n  }\n  if (isMetadataList(files)) {\n    const { upload } = await import(\"../storage/upload.js\");\n    const uris = await upload({\n      client,\n      files,\n      rewriteFileNames: {\n        fileStartNumber: startNumber || 0,\n      },\n    });\n    return Array.isArray(uris) ? uris : [uris];\n  }\n  throw new Error(\n    \"Files must all be of the same type (all URI or all FileOrBufferOrString)\",\n  );\n}\n\n/**\n * Retrieves the base URI from a batch of URIs.\n *\n * @param uris - An array of URIs.\n * @returns The base URI shared by all URIs in the batch.\n * @throws If the batch contains URIs with different base URIs or if no base URI is found.\n * @internal\n */\nexport function getBaseUriFromBatch(uris: string | string[]): string {\n  uris = Array.isArray(uris) ? uris : [uris];\n  const [base, ...rest] = uris.map((uri) => {\n    // remove query parameters\n    [uri] = uri.split(\"?\") as [string];\n    // remove fragments\n    [uri] = uri.split(\"#\") as [string];\n\n    // if the URI ends with a `/`, remove it\n    if (uri.endsWith(\"/\")) {\n      uri = uri.slice(0, -1);\n    }\n\n    // remove the last part of the URI & add the trailing `/`\n    return `${uri.split(\"/\").slice(0, -1).join(\"/\")}/`;\n  });\n\n  if (!base) {\n    throw new Error(\"Batch of URIs is empty\");\n  }\n\n  if (rest.some((uri) => uri !== base)) {\n    throw new Error(\"All URIs in the batch must have the same base URI\");\n  }\n  return base;\n}\n\nfunction isUriList<T extends FileOrBufferOrString | Record<string, unknown>>(\n  metadatas: (string | T)[],\n): metadatas is string[] {\n  return metadatas.every((m) => typeof m === \"string\");\n}\n\nfunction isMetadataList<\n  T extends FileOrBufferOrString | Record<string, unknown>,\n>(metadatas: (string | T)[]): metadatas is T[] {\n  return metadatas.every((m) => typeof m !== \"string\");\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}