{"ast":null,"code":"import { serializeErc6492Signature } from \"../../../auth/serialize-erc6492-signature.js\";\nimport { verifyEip1271Signature } from \"../../../auth/verify-hash.js\";\nimport { encode } from \"../../../transaction/actions/encode.js\";\nimport { encodeAbiParameters } from \"../../../utils/abi/encodeAbiParameters.js\";\nimport { isContractDeployed } from \"../../../utils/bytecode/is-contract-deployed.js\";\nimport { hashMessage } from \"../../../utils/hashing/hashMessage.js\";\nimport { hashTypedData } from \"../../../utils/hashing/hashTypedData.js\";\nimport { prepareCreateAccount } from \"./calls.js\";\n/**\n * If the account is already deployed, generate an ERC-1271 signature.\n * If the account is not deployed, generate an ERC-6492 signature unless otherwise specified.\n *\n * @internal\n */\nexport async function smartAccountSignMessage(_ref) {\n  let {\n    accountContract,\n    factoryContract,\n    options,\n    message\n  } = _ref;\n  const originalMsgHash = hashMessage(message);\n  let sig;\n  const wrappedMessageHash = encodeAbiParameters([{\n    type: \"bytes32\"\n  }], [originalMsgHash]);\n  sig = await options.personalAccount.signTypedData({\n    domain: {\n      chainId: options.chain.id,\n      name: \"Account\",\n      verifyingContract: accountContract.address,\n      version: \"1\"\n    },\n    message: {\n      message: wrappedMessageHash\n    },\n    primaryType: \"AccountMessage\",\n    types: {\n      AccountMessage: [{\n        name: \"message\",\n        type: \"bytes\"\n      }]\n    }\n  });\n  const isDeployed = await isContractDeployed(accountContract);\n  if (isDeployed) {\n    const isValid = await verifyEip1271Signature({\n      contract: accountContract,\n      hash: originalMsgHash,\n      signature: sig\n    });\n    if (isValid) {\n      return sig;\n    }\n    throw new Error(\"Failed to verify signature\");\n  } else {\n    var _options$overrides, _options$overrides2;\n    const deployTx = prepareCreateAccount({\n      accountSalt: (_options$overrides = options.overrides) === null || _options$overrides === void 0 ? void 0 : _options$overrides.accountSalt,\n      adminAddress: options.personalAccount.address,\n      createAccountOverride: (_options$overrides2 = options.overrides) === null || _options$overrides2 === void 0 ? void 0 : _options$overrides2.createAccount,\n      factoryContract\n    });\n    if (!deployTx) {\n      throw new Error(\"Create account override not provided\");\n    }\n    const initCode = await encode(deployTx);\n    const erc6492Sig = serializeErc6492Signature({\n      address: factoryContract.address,\n      data: initCode,\n      signature: sig\n    });\n    return erc6492Sig;\n  }\n}\nexport async function smartAccountSignTypedData(_ref2) {\n  var _typedData$domain, _accountContract$addr;\n  let {\n    accountContract,\n    factoryContract,\n    options,\n    typedData\n  } = _ref2;\n  const isSelfVerifyingContract = ((_typedData$domain = typedData.domain) === null || _typedData$domain === void 0 || (_typedData$domain = _typedData$domain.verifyingContract) === null || _typedData$domain === void 0 ? void 0 : _typedData$domain.toLowerCase()) === ((_accountContract$addr = accountContract.address) === null || _accountContract$addr === void 0 ? void 0 : _accountContract$addr.toLowerCase());\n  if (isSelfVerifyingContract) {\n    // if the contract is self-verifying, we can just sign the message with the EOA (ie. adding a session key)\n    return options.personalAccount.signTypedData(typedData);\n  }\n  const originalMsgHash = hashTypedData(typedData);\n  let sig;\n  const wrappedMessageHash = encodeAbiParameters([{\n    type: \"bytes32\"\n  }], [originalMsgHash]);\n  sig = await options.personalAccount.signTypedData({\n    domain: {\n      chainId: options.chain.id,\n      name: \"Account\",\n      verifyingContract: accountContract.address,\n      version: \"1\"\n    },\n    message: {\n      message: wrappedMessageHash\n    },\n    primaryType: \"AccountMessage\",\n    types: {\n      AccountMessage: [{\n        name: \"message\",\n        type: \"bytes\"\n      }]\n    }\n  });\n  const isDeployed = await isContractDeployed(accountContract);\n  if (isDeployed) {\n    const isValid = await verifyEip1271Signature({\n      contract: accountContract,\n      hash: originalMsgHash,\n      signature: sig\n    });\n    if (isValid) {\n      return sig;\n    }\n    throw new Error(\"Failed to verify signature\");\n  } else {\n    var _options$overrides3, _options$overrides4;\n    const deployTx = prepareCreateAccount({\n      accountSalt: (_options$overrides3 = options.overrides) === null || _options$overrides3 === void 0 ? void 0 : _options$overrides3.accountSalt,\n      adminAddress: options.personalAccount.address,\n      createAccountOverride: (_options$overrides4 = options.overrides) === null || _options$overrides4 === void 0 ? void 0 : _options$overrides4.createAccount,\n      factoryContract\n    });\n    if (!deployTx) {\n      throw new Error(\"Create account override not provided\");\n    }\n    const initCode = await encode(deployTx);\n    const erc6492Sig = serializeErc6492Signature({\n      address: factoryContract.address,\n      data: initCode,\n      signature: sig\n    });\n    return erc6492Sig;\n  }\n}\nexport async function confirmContractDeployment(args) {\n  const {\n    accountContract\n  } = args;\n  const startTime = Date.now();\n  const timeout = 60000; // wait 1 minute max\n  const {\n    isContractDeployed\n  } = await import(\"../../../utils/bytecode/is-contract-deployed.js\");\n  let isDeployed = await isContractDeployed(accountContract);\n  while (!isDeployed) {\n    if (Date.now() - startTime > timeout) {\n      throw new Error(\"Timeout: Smart account deployment not confirmed after 1 minute\");\n    }\n    await new Promise(resolve => setTimeout(resolve, 500));\n    isDeployed = await isContractDeployed(accountContract);\n  }\n}\n/**\n * Deployes a smart account via a dummy transaction. If the account is already deployed, this will do nothing.\n *\n * @param args - Arguments for the deployment.\n * @param args.smartAccount - The smart account to deploy.\n * @param args.chain - The chain to deploy on.\n * @param args.client - The client to use for the deployment.\n * @param args.accountContract - The account contract to deploy.\n *\n * @example\n * ```ts\n * import { deploySmartAccount } from \"thirdweb\";\n *\n * const account = await deploySmartAccount({\n *   smartAccount,\n *   chain,\n *   client,\n *   accountContract,\n * });\n * ```\n *\n * @wallet\n */\nexport async function deploySmartAccount(args) {\n  const {\n    chain,\n    client,\n    smartAccount,\n    accountContract\n  } = args;\n  const isDeployed = await isContractDeployed(accountContract);\n  if (isDeployed) {\n    return;\n  }\n  const [{\n    sendTransaction\n  }, {\n    prepareTransaction\n  }] = await Promise.all([import(\"../../../transaction/actions/send-transaction.js\"), import(\"../../../transaction/prepare-transaction.js\")]);\n  const dummyTx = prepareTransaction({\n    chain: chain,\n    client: client,\n    gas: 50000n,\n    to: accountContract.address,\n    value: 0n // force gas to avoid simulation error\n  });\n  const deployResult = await sendTransaction({\n    account: smartAccount,\n    transaction: dummyTx\n  });\n  await confirmContractDeployment({\n    accountContract\n  });\n  return deployResult;\n}","map":{"version":3,"names":["serializeErc6492Signature","verifyEip1271Signature","encode","encodeAbiParameters","isContractDeployed","hashMessage","hashTypedData","prepareCreateAccount","smartAccountSignMessage","_ref","accountContract","factoryContract","options","message","originalMsgHash","sig","wrappedMessageHash","type","personalAccount","signTypedData","domain","chainId","chain","id","name","verifyingContract","address","version","primaryType","types","AccountMessage","isDeployed","isValid","contract","hash","signature","Error","_options$overrides","_options$overrides2","deployTx","accountSalt","overrides","adminAddress","createAccountOverride","createAccount","initCode","erc6492Sig","data","smartAccountSignTypedData","_ref2","_typedData$domain","_accountContract$addr","typedData","isSelfVerifyingContract","toLowerCase","_options$overrides3","_options$overrides4","confirmContractDeployment","args","startTime","Date","now","timeout","Promise","resolve","setTimeout","deploySmartAccount","client","smartAccount","sendTransaction","prepareTransaction","all","dummyTx","gas","to","value","deployResult","account","transaction"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/wallets/smart/lib/signing.ts"],"sourcesContent":["import type * as ox__TypedData from \"ox/TypedData\";\nimport { serializeErc6492Signature } from \"../../../auth/serialize-erc6492-signature.js\";\nimport { verifyEip1271Signature } from \"../../../auth/verify-hash.js\";\nimport type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport type { ThirdwebContract } from \"../../../contract/contract.js\";\nimport { encode } from \"../../../transaction/actions/encode.js\";\nimport { encodeAbiParameters } from \"../../../utils/abi/encodeAbiParameters.js\";\nimport { isContractDeployed } from \"../../../utils/bytecode/is-contract-deployed.js\";\nimport { hashMessage } from \"../../../utils/hashing/hashMessage.js\";\nimport { hashTypedData } from \"../../../utils/hashing/hashTypedData.js\";\nimport type { SignableMessage } from \"../../../utils/types.js\";\nimport type { Account } from \"../../../wallets/interfaces/wallet.js\";\nimport type { SmartAccountOptions } from \"../types.js\";\nimport { prepareCreateAccount } from \"./calls.js\";\n\n/**\n * If the account is already deployed, generate an ERC-1271 signature.\n * If the account is not deployed, generate an ERC-6492 signature unless otherwise specified.\n *\n * @internal\n */\nexport async function smartAccountSignMessage({\n  accountContract,\n  factoryContract,\n  options,\n  message,\n}: {\n  accountContract: ThirdwebContract;\n  factoryContract: ThirdwebContract;\n  options: SmartAccountOptions;\n  message: SignableMessage;\n}) {\n  const originalMsgHash = hashMessage(message);\n\n  let sig: `0x${string}`;\n  const wrappedMessageHash = encodeAbiParameters(\n    [{ type: \"bytes32\" }],\n    [originalMsgHash],\n  );\n\n  sig = await options.personalAccount.signTypedData({\n    domain: {\n      chainId: options.chain.id,\n      name: \"Account\",\n      verifyingContract: accountContract.address,\n      version: \"1\",\n    },\n    message: { message: wrappedMessageHash },\n    primaryType: \"AccountMessage\",\n    types: { AccountMessage: [{ name: \"message\", type: \"bytes\" }] },\n  });\n\n  const isDeployed = await isContractDeployed(accountContract);\n  if (isDeployed) {\n    const isValid = await verifyEip1271Signature({\n      contract: accountContract,\n      hash: originalMsgHash,\n      signature: sig,\n    });\n    if (isValid) {\n      return sig;\n    }\n    throw new Error(\"Failed to verify signature\");\n  } else {\n    const deployTx = prepareCreateAccount({\n      accountSalt: options.overrides?.accountSalt,\n      adminAddress: options.personalAccount.address,\n      createAccountOverride: options.overrides?.createAccount,\n      factoryContract,\n    });\n    if (!deployTx) {\n      throw new Error(\"Create account override not provided\");\n    }\n    const initCode = await encode(deployTx);\n    const erc6492Sig = serializeErc6492Signature({\n      address: factoryContract.address,\n      data: initCode,\n      signature: sig,\n    });\n\n    return erc6492Sig;\n  }\n}\n\nexport async function smartAccountSignTypedData<\n  const typedData extends ox__TypedData.TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n>({\n  accountContract,\n  factoryContract,\n  options,\n  typedData,\n}: {\n  accountContract: ThirdwebContract;\n  factoryContract: ThirdwebContract;\n  options: SmartAccountOptions;\n  typedData: ox__TypedData.Definition<typedData, primaryType>;\n}) {\n  const isSelfVerifyingContract =\n    (\n      typedData.domain as ox__TypedData.Domain\n    )?.verifyingContract?.toLowerCase() ===\n    accountContract.address?.toLowerCase();\n\n  if (isSelfVerifyingContract) {\n    // if the contract is self-verifying, we can just sign the message with the EOA (ie. adding a session key)\n    return options.personalAccount.signTypedData(typedData);\n  }\n\n  const originalMsgHash = hashTypedData(typedData);\n\n  let sig: `0x${string}`;\n  const wrappedMessageHash = encodeAbiParameters(\n    [{ type: \"bytes32\" }],\n    [originalMsgHash],\n  );\n  sig = await options.personalAccount.signTypedData({\n    domain: {\n      chainId: options.chain.id,\n      name: \"Account\",\n      verifyingContract: accountContract.address,\n      version: \"1\",\n    },\n    message: { message: wrappedMessageHash },\n    primaryType: \"AccountMessage\",\n    types: { AccountMessage: [{ name: \"message\", type: \"bytes\" }] },\n  });\n\n  const isDeployed = await isContractDeployed(accountContract);\n  if (isDeployed) {\n    const isValid = await verifyEip1271Signature({\n      contract: accountContract,\n      hash: originalMsgHash,\n      signature: sig,\n    });\n    if (isValid) {\n      return sig;\n    }\n    throw new Error(\"Failed to verify signature\");\n  } else {\n    const deployTx = prepareCreateAccount({\n      accountSalt: options.overrides?.accountSalt,\n      adminAddress: options.personalAccount.address,\n      createAccountOverride: options.overrides?.createAccount,\n      factoryContract,\n    });\n    if (!deployTx) {\n      throw new Error(\"Create account override not provided\");\n    }\n    const initCode = await encode(deployTx);\n    const erc6492Sig = serializeErc6492Signature({\n      address: factoryContract.address,\n      data: initCode,\n      signature: sig,\n    });\n\n    return erc6492Sig;\n  }\n}\n\nexport async function confirmContractDeployment(args: {\n  accountContract: ThirdwebContract;\n}) {\n  const { accountContract } = args;\n  const startTime = Date.now();\n  const timeout = 60000; // wait 1 minute max\n  const { isContractDeployed } = await import(\n    \"../../../utils/bytecode/is-contract-deployed.js\"\n  );\n  let isDeployed = await isContractDeployed(accountContract);\n  while (!isDeployed) {\n    if (Date.now() - startTime > timeout) {\n      throw new Error(\n        \"Timeout: Smart account deployment not confirmed after 1 minute\",\n      );\n    }\n    await new Promise((resolve) => setTimeout(resolve, 500));\n    isDeployed = await isContractDeployed(accountContract);\n  }\n}\n\n/**\n * Deployes a smart account via a dummy transaction. If the account is already deployed, this will do nothing.\n *\n * @param args - Arguments for the deployment.\n * @param args.smartAccount - The smart account to deploy.\n * @param args.chain - The chain to deploy on.\n * @param args.client - The client to use for the deployment.\n * @param args.accountContract - The account contract to deploy.\n *\n * @example\n * ```ts\n * import { deploySmartAccount } from \"thirdweb\";\n *\n * const account = await deploySmartAccount({\n *   smartAccount,\n *   chain,\n *   client,\n *   accountContract,\n * });\n * ```\n *\n * @wallet\n */\nexport async function deploySmartAccount(args: {\n  smartAccount: Account;\n  chain: Chain;\n  client: ThirdwebClient;\n  accountContract: ThirdwebContract;\n}) {\n  const { chain, client, smartAccount, accountContract } = args;\n  const isDeployed = await isContractDeployed(accountContract);\n  if (isDeployed) {\n    return;\n  }\n\n  const [{ sendTransaction }, { prepareTransaction }] = await Promise.all([\n    import(\"../../../transaction/actions/send-transaction.js\"),\n    import(\"../../../transaction/prepare-transaction.js\"),\n  ]);\n  const dummyTx = prepareTransaction({\n    chain: chain,\n    client: client,\n    gas: 50000n,\n    to: accountContract.address,\n    value: 0n, // force gas to avoid simulation error\n  });\n  const deployResult = await sendTransaction({\n    account: smartAccount,\n    transaction: dummyTx,\n  });\n\n  await confirmContractDeployment({\n    accountContract,\n  });\n\n  return deployResult;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}