{"ast":null,"code":"import { getTransactions } from \"../insight/get-transactions.js\";\nimport { createStore } from \"../reactive/store.js\";\nconst transactionsByAddress = new Map();\n/**\n * Retrieve the transaction store for a given address.\n * @param address - The address to retrieve the transaction store for.\n * @returns A store of transactions for the given account to subscribe to.\n * @transaction\n * @example\n * ```ts\n * import { getTransactionStore } from \"thirdweb/transaction\";\n *\n * const store = getTransactionStore(\"0x...\");\n * store.subscribe((transactions) => {\n *   console.log(transactions);\n * });\n * ```\n */\nexport function getTransactionStore(address) {\n  const existingStore = transactionsByAddress.get(address);\n  if (existingStore) {\n    return existingStore;\n  }\n  const newStore = createStore([]);\n  transactionsByAddress.set(address, newStore);\n  return newStore;\n}\n/**\n * @internal\n */\nexport function addTransactionToStore(options) {\n  const {\n    address,\n    transactionHash,\n    chainId\n  } = options;\n  const tranasctionStore = getTransactionStore(address);\n  tranasctionStore.setValue([...tranasctionStore.getValue(), {\n    chainId,\n    transactionHash\n  }]);\n  transactionsByAddress.set(address, tranasctionStore);\n}\n/**\n * @internal for now\n */\nexport async function getPastTransactions(options) {\n  const {\n    walletAddress,\n    chain,\n    client\n  } = options;\n  const oneMonthsAgoInSeconds = Math.floor((Date.now() - 1 * 30 * 24 * 60 * 60 * 1000) / 1000);\n  const result = await getTransactions({\n    chains: [chain],\n    client,\n    queryOptions: {\n      filter_block_timestamp_gte: oneMonthsAgoInSeconds,\n      limit: 20,\n      decode: true\n    },\n    walletAddress\n  });\n  return result.map(tx => ({\n    chainId: typeof tx.chain_id === \"string\" ? Number(tx.chain_id) : tx.chain_id,\n    receipt: {\n      status: tx.status === 0 ? \"failed\" : \"success\",\n      to: tx.to_address\n    },\n    transactionHash: tx.hash,\n    decoded: tx.decoded\n  }));\n}","map":{"version":3,"names":["getTransactions","createStore","transactionsByAddress","Map","getTransactionStore","address","existingStore","get","newStore","set","addTransactionToStore","options","transactionHash","chainId","tranasctionStore","setValue","getValue","getPastTransactions","walletAddress","chain","client","oneMonthsAgoInSeconds","Math","floor","Date","now","result","chains","queryOptions","filter_block_timestamp_gte","limit","decode","map","tx","chain_id","Number","receipt","status","to","to_address","hash","decoded"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/transaction/transaction-store.ts"],"sourcesContent":["import type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { getTransactions } from \"../insight/get-transactions.js\";\nimport { createStore, type Store } from \"../reactive/store.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\n\nexport type StoredTransaction = {\n  transactionHash: Hex;\n  chainId: number;\n  receipt?: {\n    status: \"success\" | \"failed\";\n    to: string;\n  };\n  decoded?: {\n    name: string;\n    signature: string;\n    inputs?: {\n      [key: string]: unknown;\n    };\n  };\n};\n\nconst transactionsByAddress = new Map<string, Store<StoredTransaction[]>>();\n\n/**\n * Retrieve the transaction store for a given address.\n * @param address - The address to retrieve the transaction store for.\n * @returns A store of transactions for the given account to subscribe to.\n * @transaction\n * @example\n * ```ts\n * import { getTransactionStore } from \"thirdweb/transaction\";\n *\n * const store = getTransactionStore(\"0x...\");\n * store.subscribe((transactions) => {\n *   console.log(transactions);\n * });\n * ```\n */\nexport function getTransactionStore(\n  address: string,\n): Store<StoredTransaction[]> {\n  const existingStore = transactionsByAddress.get(address);\n  if (existingStore) {\n    return existingStore;\n  }\n\n  const newStore = createStore<StoredTransaction[]>([]);\n  transactionsByAddress.set(address, newStore);\n\n  return newStore;\n}\n\n/**\n * @internal\n */\nexport function addTransactionToStore(options: {\n  address: string;\n  transactionHash: Hex;\n  chainId: number;\n}) {\n  const { address, transactionHash, chainId } = options;\n  const tranasctionStore = getTransactionStore(address);\n\n  tranasctionStore.setValue([\n    ...tranasctionStore.getValue(),\n    { chainId, transactionHash },\n  ]);\n\n  transactionsByAddress.set(address, tranasctionStore);\n}\n\n/**\n * @internal for now\n */\nexport async function getPastTransactions(options: {\n  walletAddress: string;\n  chain: Chain;\n  client: ThirdwebClient;\n}): Promise<StoredTransaction[]> {\n  const { walletAddress, chain, client } = options;\n  const oneMonthsAgoInSeconds = Math.floor(\n    (Date.now() - 1 * 30 * 24 * 60 * 60 * 1000) / 1000,\n  );\n  const result = await getTransactions({\n    chains: [chain],\n    client,\n    queryOptions: {\n      filter_block_timestamp_gte: oneMonthsAgoInSeconds,\n      limit: 20,\n      decode: true,\n    },\n    walletAddress,\n  });\n  return result.map((tx) => ({\n    chainId:\n      typeof tx.chain_id === \"string\"\n        ? Number(tx.chain_id)\n        : (tx.chain_id as number),\n    receipt: {\n      status: tx.status === 0 ? \"failed\" : \"success\",\n      to: tx.to_address,\n    },\n    transactionHash: tx.hash as Hex,\n    decoded: tx.decoded,\n  }));\n}\n"],"mappings":"AAEA,SAASA,eAAe,QAAQ,gCAAgC;AAChE,SAASC,WAAW,QAAoB,sBAAsB;AAmB9D,MAAMC,qBAAqB,GAAG,IAAIC,GAAG,EAAsC;AAE3E;;;;;;;;;;;;;;;AAeA,OAAM,SAAUC,mBAAmBA,CACjCC,OAAe;EAEf,MAAMC,aAAa,GAAGJ,qBAAqB,CAACK,GAAG,CAACF,OAAO,CAAC;EACxD,IAAIC,aAAa,EAAE;IACjB,OAAOA,aAAa;EACtB;EAEA,MAAME,QAAQ,GAAGP,WAAW,CAAsB,EAAE,CAAC;EACrDC,qBAAqB,CAACO,GAAG,CAACJ,OAAO,EAAEG,QAAQ,CAAC;EAE5C,OAAOA,QAAQ;AACjB;AAEA;;;AAGA,OAAM,SAAUE,qBAAqBA,CAACC,OAIrC;EACC,MAAM;IAAEN,OAAO;IAAEO,eAAe;IAAEC;EAAO,CAAE,GAAGF,OAAO;EACrD,MAAMG,gBAAgB,GAAGV,mBAAmB,CAACC,OAAO,CAAC;EAErDS,gBAAgB,CAACC,QAAQ,CAAC,CACxB,GAAGD,gBAAgB,CAACE,QAAQ,EAAE,EAC9B;IAAEH,OAAO;IAAED;EAAe,CAAE,CAC7B,CAAC;EAEFV,qBAAqB,CAACO,GAAG,CAACJ,OAAO,EAAES,gBAAgB,CAAC;AACtD;AAEA;;;AAGA,OAAO,eAAeG,mBAAmBA,CAACN,OAIzC;EACC,MAAM;IAAEO,aAAa;IAAEC,KAAK;IAAEC;EAAM,CAAE,GAAGT,OAAO;EAChD,MAAMU,qBAAqB,GAAGC,IAAI,CAACC,KAAK,CACtC,CAACC,IAAI,CAACC,GAAG,EAAE,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,IAAI,IAAI,CACnD;EACD,MAAMC,MAAM,GAAG,MAAM1B,eAAe,CAAC;IACnC2B,MAAM,EAAE,CAACR,KAAK,CAAC;IACfC,MAAM;IACNQ,YAAY,EAAE;MACZC,0BAA0B,EAAER,qBAAqB;MACjDS,KAAK,EAAE,EAAE;MACTC,MAAM,EAAE;KACT;IACDb;GACD,CAAC;EACF,OAAOQ,MAAM,CAACM,GAAG,CAAEC,EAAE,KAAM;IACzBpB,OAAO,EACL,OAAOoB,EAAE,CAACC,QAAQ,KAAK,QAAQ,GAC3BC,MAAM,CAACF,EAAE,CAACC,QAAQ,CAAC,GAClBD,EAAE,CAACC,QAAmB;IAC7BE,OAAO,EAAE;MACPC,MAAM,EAAEJ,EAAE,CAACI,MAAM,KAAK,CAAC,GAAG,QAAQ,GAAG,SAAS;MAC9CC,EAAE,EAAEL,EAAE,CAACM;KACR;IACD3B,eAAe,EAAEqB,EAAE,CAACO,IAAW;IAC/BC,OAAO,EAAER,EAAE,CAACQ;GACb,CAAC,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}