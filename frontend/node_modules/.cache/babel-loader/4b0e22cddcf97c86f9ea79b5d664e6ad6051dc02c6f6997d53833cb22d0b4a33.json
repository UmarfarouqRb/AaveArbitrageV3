{"ast":null,"code":"\"use client\";\n\nimport _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"nameResolver\", \"formatFn\", \"loadingComponent\", \"fallbackComponent\", \"queryOptions\"];\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { getChainMetadata } from \"../../../../../chains/utils.js\";\nimport { NATIVE_TOKEN_ADDRESS } from \"../../../../../constants/addresses.js\";\nimport { getContract } from \"../../../../../contract/contract.js\";\nimport { getContractMetadata } from \"../../../../../extensions/common/read/getContractMetadata.js\";\nimport { name } from \"../../../../../extensions/common/read/name.js\";\nimport { getFunctionId } from \"../../../../../utils/function-id.js\";\nimport { useTokenContext } from \"./provider.js\";\n/**\n * This component fetches then shows the name of a token. For ERC20 tokens, it calls the `name` function in the ERC20 contract.\n * It inherits all the attributes of a HTML <span> component, hence you can style it just like how you would style a normal <span>\n *\n *\n * @example\n * ### Basic usage\n * ```tsx\n * import { TokenProvider, TokenName } from \"thirdweb/react\";\n * import { ethereum } from \"thirdweb/chains\";\n *\n * <TokenProvider {...props}>\n *   <TokenName  />\n * </TokenProvider>\n * ```\n * Result:\n * ```html\n * <span>Ether</span>\n * ```\n *\n * ### Custom name resolver\n * By default TokenName will call the `name` method of the token contract.\n * However if you have a different way to fetch the name, you can pass the function to the `nameResolver` prop.\n * Note: nameResolver should either be a string or a function (async) that returns a string.\n * ```tsx\n * async function fetchNameMethod() {\n *   // your own fetching logic\n *   return \"the token name\";\n * }\n *\n * <TokenName nameResolver={fetchNameMethod} />\n * ```\n *\n * Alternatively you can also pass in a string directly:\n * ```tsx\n * <TokenName nameResolver=\"USD Coin Circle\" />\n * ```\n *\n *\n * ### Format the name (capitalize, truncate, etc.)\n * The TokenName component accepts a `formatFn` which takes in a string and outputs a string\n * The function is used to modify the name of the token\n *\n * ```tsx\n * const concatStr = (str: string):string => str + \"Token\"\n *\n * <TokenName formatFn={concatStr} />\n * ```\n *\n * Result:\n * ```html\n * <span>Ether Token</span>\n * ```\n *\n * ### Show a loading sign when the name is being fetched\n * ```tsx\n * import { TokenProvider, TokenName } from \"thirdweb/react\";\n *\n * <TokenProvider address=\"0x...\">\n *   <TokenName loadingComponent={<Spinner />} />\n * </TokenProvider>\n * ```\n *\n * ### Fallback to something when the name fails to resolve\n * ```tsx\n * <TokenProvider address=\"0x...\">\n *   <TokenName fallbackComponent={\"Failed to load\"} />\n * </TokenProvider>\n * ```\n *\n * ### Custom query options for useQuery\n * This component uses `@tanstack-query`'s useQuery internally.\n * You can use the `queryOptions` prop for more fine-grained control\n * ```tsx\n * <TokenName\n *   queryOptions={{\n *     enabled: isEnabled,\n *     retry: 4,\n *   }}\n * />\n * ```\n *\n * @component\n * @token\n * @beta\n */\nexport function TokenName(_ref) {\n  let {\n      nameResolver,\n      formatFn,\n      loadingComponent,\n      fallbackComponent,\n      queryOptions\n    } = _ref,\n    restProps = _objectWithoutProperties(_ref, _excluded);\n  const {\n    address,\n    client,\n    chain\n  } = useTokenContext();\n  const nameQuery = useQuery(_objectSpread({\n    queryFn: async () => fetchTokenName({\n      address,\n      chain,\n      client,\n      nameResolver\n    }),\n    queryKey: getQueryKeys({\n      address,\n      chainId: chain.id,\n      nameResolver\n    })\n  }, queryOptions));\n  if (nameQuery.isLoading) {\n    return loadingComponent || null;\n  }\n  if (!nameQuery.data) {\n    return fallbackComponent || null;\n  }\n  if (formatFn && typeof formatFn === \"function\") {\n    return _jsx(\"span\", _objectSpread(_objectSpread({}, restProps), {}, {\n      children: formatFn(nameQuery.data)\n    }));\n  }\n  return _jsx(\"span\", _objectSpread(_objectSpread({}, restProps), {}, {\n    children: nameQuery.data\n  }));\n}\n/**\n * @internal Exported for tests only\n */\nexport async function fetchTokenName(props) {\n  const {\n    nameResolver,\n    address,\n    client,\n    chain\n  } = props;\n  if (typeof nameResolver === \"string\") {\n    return nameResolver;\n  }\n  if (typeof nameResolver === \"function\") {\n    return nameResolver();\n  }\n  if (address.toLowerCase() === NATIVE_TOKEN_ADDRESS.toLowerCase()) {\n    // Don't wanna use `getChainName` because it has some side effect (it catches error and defaults to \"ETH\")\n    return getChainMetadata(chain).then(data => data.nativeCurrency.name);\n  }\n  // Try to fetch the name from both the `name` function and the contract metadata\n  // then prioritize its result\n  const contract = getContract({\n    address,\n    chain,\n    client\n  });\n  const [_name, contractMetadata] = await Promise.all([name({\n    contract\n  }).catch(() => undefined), getContractMetadata({\n    contract\n  }).catch(() => undefined)]);\n  if (typeof _name === \"string\") {\n    return _name;\n  }\n  if (typeof (contractMetadata === null || contractMetadata === void 0 ? void 0 : contractMetadata.name) === \"string\") {\n    return contractMetadata.name;\n  }\n  throw new Error(\"Failed to resolve name from both name() and contract metadata\");\n}\n/**\n * @internal\n */\nexport function getQueryKeys(props) {\n  const {\n    chainId,\n    address,\n    nameResolver\n  } = props;\n  return [\"_internal_token_name_\", chainId, address, {\n    resolver: typeof nameResolver === \"string\" ? nameResolver : typeof nameResolver === \"function\" ? getFunctionId(nameResolver) : undefined\n  }];\n}","map":{"version":3,"names":["_objectSpread","_objectWithoutProperties","_excluded","useQuery","getChainMetadata","NATIVE_TOKEN_ADDRESS","getContract","getContractMetadata","name","getFunctionId","useTokenContext","TokenName","_ref","nameResolver","formatFn","loadingComponent","fallbackComponent","queryOptions","restProps","address","client","chain","nameQuery","queryFn","fetchTokenName","queryKey","getQueryKeys","chainId","id","isLoading","data","_jsx","children","props","toLowerCase","then","nativeCurrency","contract","_name","contractMetadata","Promise","all","catch","undefined","Error","resolver"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/react/web/ui/prebuilt/Token/name.tsx"],"sourcesContent":["\"use client\";\n\nimport { type UseQueryOptions, useQuery } from \"@tanstack/react-query\";\nimport type React from \"react\";\nimport type { JSX } from \"react\";\nimport type { Chain } from \"../../../../../chains/types.js\";\nimport { getChainMetadata } from \"../../../../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../../../../client/client.js\";\nimport { NATIVE_TOKEN_ADDRESS } from \"../../../../../constants/addresses.js\";\nimport { getContract } from \"../../../../../contract/contract.js\";\nimport { getContractMetadata } from \"../../../../../extensions/common/read/getContractMetadata.js\";\nimport { name } from \"../../../../../extensions/common/read/name.js\";\nimport { getFunctionId } from \"../../../../../utils/function-id.js\";\nimport { useTokenContext } from \"./provider.js\";\n\n/**\n * Props for the TokenName component\n * @component\n * @token\n */\nexport interface TokenNameProps\n  extends Omit<React.HTMLAttributes<HTMLSpanElement>, \"children\"> {\n  /**\n   * This prop can be a string or a (async) function that resolves to a string, representing the name of the token\n   * This is particularly useful if you already have a way to fetch the token name.\n   */\n  nameResolver?: string | (() => string) | (() => Promise<string>);\n  /**\n   * A function to format the name's display value\n   * Particularly useful to avoid overflowing-UI issues\n   *\n   * ```tsx\n   * <TokenName formatFn={(str: string) => doSomething()} />\n   * ```\n   */\n  formatFn?: (str: string) => string;\n  /**\n   * This component will be shown while the name of the token is being fetched\n   * If not passed, the component will return `null`.\n   *\n   * You can/should pass a loading sign or spinner to this prop.\n   * @example\n   * ```tsx\n   * <TokenName loadingComponent={<Spinner />} />\n   * ```\n   */\n  loadingComponent?: JSX.Element;\n  /**\n   * This component will be shown if the name fails to be retreived\n   * If not passed, the component will return `null`.\n   *\n   * You can/should pass a descriptive text/component to this prop, indicating that the\n   * name was not fetched successfully\n   * @example\n   * ```tsx\n   * <TokenName fallbackComponent={\"Failed to load\"}\n   * />\n   * ```\n   */\n  fallbackComponent?: JSX.Element;\n  /**\n   * Optional `useQuery` params\n   */\n  queryOptions?: Omit<UseQueryOptions<string>, \"queryFn\" | \"queryKey\">;\n}\n\n/**\n * This component fetches then shows the name of a token. For ERC20 tokens, it calls the `name` function in the ERC20 contract.\n * It inherits all the attributes of a HTML <span> component, hence you can style it just like how you would style a normal <span>\n *\n *\n * @example\n * ### Basic usage\n * ```tsx\n * import { TokenProvider, TokenName } from \"thirdweb/react\";\n * import { ethereum } from \"thirdweb/chains\";\n *\n * <TokenProvider {...props}>\n *   <TokenName  />\n * </TokenProvider>\n * ```\n * Result:\n * ```html\n * <span>Ether</span>\n * ```\n *\n * ### Custom name resolver\n * By default TokenName will call the `name` method of the token contract.\n * However if you have a different way to fetch the name, you can pass the function to the `nameResolver` prop.\n * Note: nameResolver should either be a string or a function (async) that returns a string.\n * ```tsx\n * async function fetchNameMethod() {\n *   // your own fetching logic\n *   return \"the token name\";\n * }\n *\n * <TokenName nameResolver={fetchNameMethod} />\n * ```\n *\n * Alternatively you can also pass in a string directly:\n * ```tsx\n * <TokenName nameResolver=\"USD Coin Circle\" />\n * ```\n *\n *\n * ### Format the name (capitalize, truncate, etc.)\n * The TokenName component accepts a `formatFn` which takes in a string and outputs a string\n * The function is used to modify the name of the token\n *\n * ```tsx\n * const concatStr = (str: string):string => str + \"Token\"\n *\n * <TokenName formatFn={concatStr} />\n * ```\n *\n * Result:\n * ```html\n * <span>Ether Token</span>\n * ```\n *\n * ### Show a loading sign when the name is being fetched\n * ```tsx\n * import { TokenProvider, TokenName } from \"thirdweb/react\";\n *\n * <TokenProvider address=\"0x...\">\n *   <TokenName loadingComponent={<Spinner />} />\n * </TokenProvider>\n * ```\n *\n * ### Fallback to something when the name fails to resolve\n * ```tsx\n * <TokenProvider address=\"0x...\">\n *   <TokenName fallbackComponent={\"Failed to load\"} />\n * </TokenProvider>\n * ```\n *\n * ### Custom query options for useQuery\n * This component uses `@tanstack-query`'s useQuery internally.\n * You can use the `queryOptions` prop for more fine-grained control\n * ```tsx\n * <TokenName\n *   queryOptions={{\n *     enabled: isEnabled,\n *     retry: 4,\n *   }}\n * />\n * ```\n *\n * @component\n * @token\n * @beta\n */\nexport function TokenName({\n  nameResolver,\n  formatFn,\n  loadingComponent,\n  fallbackComponent,\n  queryOptions,\n  ...restProps\n}: TokenNameProps) {\n  const { address, client, chain } = useTokenContext();\n  const nameQuery = useQuery({\n    queryFn: async () =>\n      fetchTokenName({ address, chain, client, nameResolver }),\n    queryKey: getQueryKeys({ address, chainId: chain.id, nameResolver }),\n    ...queryOptions,\n  });\n\n  if (nameQuery.isLoading) {\n    return loadingComponent || null;\n  }\n\n  if (!nameQuery.data) {\n    return fallbackComponent || null;\n  }\n\n  if (formatFn && typeof formatFn === \"function\") {\n    return <span {...restProps}>{formatFn(nameQuery.data)}</span>;\n  }\n\n  return <span {...restProps}>{nameQuery.data}</span>;\n}\n\n/**\n * @internal Exported for tests only\n */\nexport async function fetchTokenName(props: {\n  address: string;\n  client: ThirdwebClient;\n  chain: Chain;\n  nameResolver?: string | (() => string) | (() => Promise<string>);\n}) {\n  const { nameResolver, address, client, chain } = props;\n  if (typeof nameResolver === \"string\") {\n    return nameResolver;\n  }\n  if (typeof nameResolver === \"function\") {\n    return nameResolver();\n  }\n  if (address.toLowerCase() === NATIVE_TOKEN_ADDRESS.toLowerCase()) {\n    // Don't wanna use `getChainName` because it has some side effect (it catches error and defaults to \"ETH\")\n    return getChainMetadata(chain).then((data) => data.nativeCurrency.name);\n  }\n\n  // Try to fetch the name from both the `name` function and the contract metadata\n  // then prioritize its result\n  const contract = getContract({ address, chain, client });\n  const [_name, contractMetadata] = await Promise.all([\n    name({ contract }).catch(() => undefined),\n    getContractMetadata({ contract }).catch(() => undefined),\n  ]);\n  if (typeof _name === \"string\") {\n    return _name;\n  }\n  if (typeof contractMetadata?.name === \"string\") {\n    return contractMetadata.name;\n  }\n  throw new Error(\n    \"Failed to resolve name from both name() and contract metadata\",\n  );\n}\n\n/**\n * @internal\n */\nexport function getQueryKeys(props: {\n  chainId: number;\n  address: string;\n  nameResolver?: string | (() => string) | (() => Promise<string>);\n}) {\n  const { chainId, address, nameResolver } = props;\n  return [\n    \"_internal_token_name_\",\n    chainId,\n    address,\n    {\n      resolver:\n        typeof nameResolver === \"string\"\n          ? nameResolver\n          : typeof nameResolver === \"function\"\n            ? getFunctionId(nameResolver)\n            : undefined,\n    },\n  ] as const;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}