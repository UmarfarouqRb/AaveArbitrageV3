{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"wallet\"];\nimport { encode } from \"../../transaction/actions/encode.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { numberToHex } from \"../../utils/encoding/hex.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\n/**\n * Send [EIP-5792](https://eips.ethereum.org/EIPS/eip-5792) calls to a wallet.\n * This function works with all Thirdweb wallets (in-app and smart) and certain injected wallets that already support EIP-5792.\n * Transactions will be bundled and sponsored when those capabilities are supported, otherwise they will be sent as individual transactions.\n *\n *  This function is dependent on the wallet's support for EIP-5792 and could fail.\n *\n * @param {SendCallsOptions} options\n * @param {Wallet} options.wallet - The wallet to send the calls to.\n * @param {PreparedSendCall[]} options.calls - An array of prepared transactions to send.\n * @param {WalletSendCallsParameters[number][\"capabilities\"]} [options.capabilities] - Capabilities objects to use, see the [EIP-5792 spec](https://eips.ethereum.org/EIPS/eip-5792) for details.\n * @param {string} [options.version=\"1.0\"] - The `wallet_sendCalls` version to use, defaults to \"1.0\".\n * @param {Chain} [options.chain] - A {@link Chain} instance to override the wallet's current chain.\n * @throws an error if the wallet does not support EIP-5792.\n * @returns The ID of the bundle of the calls.\n *\n * @see getCallsStatus for how to retrieve the status of the bundle.\n * @see getCapabilities for how to retrieve the capabilities of the wallet.\n * @beta\n * @example\n * ```ts\n * import { createThirdwebClient } from \"thirdweb\";\n * import { sendCalls } from \"thirdweb/wallets/eip5792\";\n *\n * const client = createThirdwebClient({ clientId: ... });\n * const wallet = createWallet(\"com.coinbase.wallet\");\n * await wallet.connect({ client });\n *\n * const sendTx1 = approve({\n      contract: USDT_CONTRACT,\n      amount: 100,\n      spender: \"0x33d9B8BEfE81027E2C859EDc84F5636cbb202Ed6\",\n    });\n * const sendTx2 = approve({\n      contract: USDT_CONTRACT,\n      amount: 100,\n      spender: \"0x2a4f24F935Eb178e3e7BA9B53A5Ee6d8407C0709\",\n    });\n * const bundleId = await sendCalls({\n *   wallet,\n *   client,\n *   calls: [sendTx1, sendTx2],\n * });\n * ```\n * Sponsor transactions with a paymaster:\n * ```ts\n * const bundleId = await sendCalls({\n *   wallet,\n *   client,\n *   calls: [send1, send2],\n *   capabilities: {\n *     paymasterService: {\n *       url: `https://${CHAIN.id}.bundler.thirdweb.com/${client.clientId}`\n *     }\n *   }\n * });\n * ```\n * We recommend proxying any paymaster calls via an API route you setup and control.\n *\n * @extension EIP5792\n */\nexport async function sendCalls(options) {\n  var _wallet$getChain;\n  const {\n    wallet,\n    chain\n  } = options;\n  const account = wallet.getAccount();\n  if (!account) {\n    throw new Error(\"Cannot send calls, no account connected for wallet: \".concat(wallet.id));\n  }\n  const firstCall = options.calls[0];\n  if (!firstCall) {\n    throw new Error(\"No calls to send\");\n  }\n  const callChain = firstCall.chain || chain;\n  if (((_wallet$getChain = wallet.getChain()) === null || _wallet$getChain === void 0 ? void 0 : _wallet$getChain.id) !== callChain.id) {\n    await wallet.switchChain(callChain);\n  }\n  // check internal implementations\n  if (account.sendCalls) {\n    const {\n        wallet: _\n      } = options,\n      optionsWithoutWallet = _objectWithoutProperties(options, _excluded);\n    const result = await account.sendCalls(optionsWithoutWallet);\n    return _objectSpread(_objectSpread({}, result), {}, {\n      wallet\n    });\n  }\n  throw new Error(\"Cannot send calls, wallet \".concat(wallet.id, \" does not support EIP-5792\"));\n}\nexport async function toProviderCallParams(options, account) {\n  var _options$atomicRequir;\n  const firstCall = options.calls[0];\n  if (!firstCall) {\n    throw new Error(\"No calls to send\");\n  }\n  const {\n    calls,\n    capabilities,\n    version = \"2.0.0\",\n    chain = firstCall.chain\n  } = options;\n  const preparedCalls = await Promise.all(calls.map(async call => {\n    const {\n      to,\n      value\n    } = call;\n    if (to === undefined && call.data === undefined) {\n      throw new Error(\"Cannot send call, `to` or `data` must be provided.\");\n    }\n    const [_to, _data, _value] = await Promise.all([resolvePromisedValue(to), encode(call), resolvePromisedValue(value)]);\n    if (_to) {\n      return {\n        data: _data,\n        to: getAddress(_to),\n        value: typeof _value === \"bigint\" || typeof _value === \"number\" ? numberToHex(_value) : undefined\n      };\n    }\n    return {\n      data: _data,\n      to: undefined,\n      value: undefined\n    };\n  }));\n  const injectedWalletCallParams = [{\n    // see: https://eips.ethereum.org/EIPS/eip-5792#wallet_sendcalls\n    atomicRequired: (_options$atomicRequir = options.atomicRequired) !== null && _options$atomicRequir !== void 0 ? _options$atomicRequir : false,\n    calls: preparedCalls,\n    capabilities,\n    chainId: numberToHex(chain.id),\n    from: getAddress(account.address),\n    version\n  }];\n  return {\n    callParams: injectedWalletCallParams,\n    chain\n  };\n}","map":{"version":3,"names":["encode","getAddress","numberToHex","resolvePromisedValue","sendCalls","options","_wallet$getChain","wallet","chain","account","getAccount","Error","concat","id","firstCall","calls","callChain","getChain","switchChain","_","optionsWithoutWallet","_objectWithoutProperties","_excluded","result","_objectSpread","toProviderCallParams","_options$atomicRequir","capabilities","version","preparedCalls","Promise","all","map","call","to","value","undefined","data","_to","_data","_value","injectedWalletCallParams","atomicRequired","chainId","from","address","callParams"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/wallets/eip5792/send-calls.ts"],"sourcesContent":["import type { Abi, AbiFunction } from \"abitype\";\nimport type { WalletSendCallsParameters as ViemWalletSendCallsParameters } from \"viem\";\nimport type { Chain } from \"../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { encode } from \"../../transaction/actions/encode.js\";\nimport type { PreparedTransaction } from \"../../transaction/prepare-transaction.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { type Hex, numberToHex } from \"../../utils/encoding/hex.js\";\nimport {\n  type PromisedObject,\n  resolvePromisedValue,\n} from \"../../utils/promise/resolve-promised-value.js\";\nimport type { OneOf, Prettify } from \"../../utils/type-utils.js\";\nimport type { Account, Wallet } from \"../interfaces/wallet.js\";\nimport type { WalletId } from \"../wallet-types.js\";\nimport type {\n  EIP5792Call,\n  WalletSendCallsId,\n  WalletSendCallsParameters,\n} from \"./types.js\";\n\ntype WalletCall = OneOf<{\n  to?: string | undefined; // TODO: Make this required but compatible with StaticPrepareTransactionOptions to prevent runtime error\n  data?: Hex | undefined;\n  value?: bigint | undefined;\n}>;\n\nexport type PreparedSendCall<\n  abi extends Abi = [],\n  abiFunction extends AbiFunction = AbiFunction,\n> = PreparedTransaction<abi, abiFunction, PrepareCallOptions>;\n\nexport type PrepareCallOptions = {\n  chain: Chain;\n  client: ThirdwebClient;\n} & PromisedObject<WalletCall>;\n\nexport type SendCallsOptions<\n  ID extends WalletId = WalletId,\n  abi extends Abi = [],\n  abiFunction extends AbiFunction = AbiFunction,\n> = Prettify<{\n  wallet: Wallet<ID>;\n  calls: PreparedSendCall<abi, abiFunction>[];\n  capabilities?: WalletSendCallsParameters[number][\"capabilities\"];\n  version?: WalletSendCallsParameters[number][\"version\"];\n  chain?: Chain;\n  atomicRequired?: boolean;\n}>;\n\nexport type SendCallsResult = Prettify<{\n  id: WalletSendCallsId;\n  client: ThirdwebClient;\n  chain: Chain;\n  wallet: Wallet;\n}>;\n\n/**\n * Send [EIP-5792](https://eips.ethereum.org/EIPS/eip-5792) calls to a wallet.\n * This function works with all Thirdweb wallets (in-app and smart) and certain injected wallets that already support EIP-5792.\n * Transactions will be bundled and sponsored when those capabilities are supported, otherwise they will be sent as individual transactions.\n *\n *  This function is dependent on the wallet's support for EIP-5792 and could fail.\n *\n * @param {SendCallsOptions} options\n * @param {Wallet} options.wallet - The wallet to send the calls to.\n * @param {PreparedSendCall[]} options.calls - An array of prepared transactions to send.\n * @param {WalletSendCallsParameters[number][\"capabilities\"]} [options.capabilities] - Capabilities objects to use, see the [EIP-5792 spec](https://eips.ethereum.org/EIPS/eip-5792) for details.\n * @param {string} [options.version=\"1.0\"] - The `wallet_sendCalls` version to use, defaults to \"1.0\".\n * @param {Chain} [options.chain] - A {@link Chain} instance to override the wallet's current chain.\n * @throws an error if the wallet does not support EIP-5792.\n * @returns The ID of the bundle of the calls.\n *\n * @see getCallsStatus for how to retrieve the status of the bundle.\n * @see getCapabilities for how to retrieve the capabilities of the wallet.\n * @beta\n * @example\n * ```ts\n * import { createThirdwebClient } from \"thirdweb\";\n * import { sendCalls } from \"thirdweb/wallets/eip5792\";\n *\n * const client = createThirdwebClient({ clientId: ... });\n * const wallet = createWallet(\"com.coinbase.wallet\");\n * await wallet.connect({ client });\n *\n * const sendTx1 = approve({\n      contract: USDT_CONTRACT,\n      amount: 100,\n      spender: \"0x33d9B8BEfE81027E2C859EDc84F5636cbb202Ed6\",\n    });\n * const sendTx2 = approve({\n      contract: USDT_CONTRACT,\n      amount: 100,\n      spender: \"0x2a4f24F935Eb178e3e7BA9B53A5Ee6d8407C0709\",\n    });\n * const bundleId = await sendCalls({\n *   wallet,\n *   client,\n *   calls: [sendTx1, sendTx2],\n * });\n * ```\n * Sponsor transactions with a paymaster:\n * ```ts\n * const bundleId = await sendCalls({\n *   wallet,\n *   client,\n *   calls: [send1, send2],\n *   capabilities: {\n *     paymasterService: {\n *       url: `https://${CHAIN.id}.bundler.thirdweb.com/${client.clientId}`\n *     }\n *   }\n * });\n * ```\n * We recommend proxying any paymaster calls via an API route you setup and control.\n *\n * @extension EIP5792\n */\nexport async function sendCalls<const ID extends WalletId>(\n  options: SendCallsOptions<ID>,\n): Promise<SendCallsResult> {\n  const { wallet, chain } = options;\n\n  const account = wallet.getAccount();\n  if (!account) {\n    throw new Error(\n      `Cannot send calls, no account connected for wallet: ${wallet.id}`,\n    );\n  }\n\n  const firstCall = options.calls[0];\n  if (!firstCall) {\n    throw new Error(\"No calls to send\");\n  }\n\n  const callChain = firstCall.chain || chain;\n\n  if (wallet.getChain()?.id !== callChain.id) {\n    await wallet.switchChain(callChain);\n  }\n\n  // check internal implementations\n  if (account.sendCalls) {\n    const { wallet: _, ...optionsWithoutWallet } = options;\n    const result = await account.sendCalls(optionsWithoutWallet);\n    return {\n      ...result,\n      wallet,\n    };\n  }\n\n  throw new Error(\n    `Cannot send calls, wallet ${wallet.id} does not support EIP-5792`,\n  );\n}\n\nexport async function toProviderCallParams(\n  options: Omit<SendCallsOptions, \"wallet\">,\n  account: Account,\n): Promise<{ callParams: ViemWalletSendCallsParameters; chain: Chain }> {\n  const firstCall = options.calls[0];\n  if (!firstCall) {\n    throw new Error(\"No calls to send\");\n  }\n\n  const {\n    calls,\n    capabilities,\n    version = \"2.0.0\",\n    chain = firstCall.chain,\n  } = options;\n\n  const preparedCalls: EIP5792Call[] = await Promise.all(\n    calls.map(async (call) => {\n      const { to, value } = call;\n      if (to === undefined && call.data === undefined) {\n        throw new Error(\"Cannot send call, `to` or `data` must be provided.\");\n      }\n\n      const [_to, _data, _value] = await Promise.all([\n        resolvePromisedValue(to),\n        encode(call),\n        resolvePromisedValue(value),\n      ]);\n\n      if (_to) {\n        return {\n          data: _data as Hex,\n          to: getAddress(_to),\n          value:\n            typeof _value === \"bigint\" || typeof _value === \"number\"\n              ? numberToHex(_value)\n              : undefined,\n        };\n      }\n\n      return {\n        data: _data as Hex,\n        to: undefined,\n        value: undefined,\n      };\n    }),\n  );\n\n  const injectedWalletCallParams: ViemWalletSendCallsParameters = [\n    {\n      // see: https://eips.ethereum.org/EIPS/eip-5792#wallet_sendcalls\n      atomicRequired: options.atomicRequired ?? false,\n      calls: preparedCalls,\n      capabilities,\n      chainId: numberToHex(chain.id),\n      from: getAddress(account.address),\n      version,\n    },\n  ];\n\n  return { callParams: injectedWalletCallParams, chain };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}