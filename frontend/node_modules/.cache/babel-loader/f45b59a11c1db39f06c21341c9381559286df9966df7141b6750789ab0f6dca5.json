{"ast":null,"code":"import { timeoutPromise } from \"../../utils/timeoutPromise.js\";\nimport { isEcosystemWallet } from \"../ecosystem/is-ecosystem-wallet.js\";\nimport { ClientScopedStorage } from \"../in-app/core/authentication/client-scoped-storage.js\";\nimport { isInAppSigner } from \"../in-app/core/wallet/is-in-app-signer.js\";\nimport { getUrlToken } from \"../in-app/web/lib/get-url-token.js\";\nimport { getLastConnectedChain, getStoredActiveWalletId, getStoredConnectedWalletIds } from \"../manager/index.js\";\nlet lastAutoConnectionResultPromise;\n/**\n * @internal\n */\nexport const autoConnectCore = async props => {\n  // if an auto connect was attempted already\n  if (lastAutoConnectionResultPromise && !props.force) {\n    // wait for its resolution\n    const lastResult = await lastAutoConnectionResultPromise;\n    // if it was successful, return true\n    // if not continue with the new auto connect\n    if (lastResult) {\n      return true;\n    }\n  }\n  const resultPromise = _autoConnectCore(props);\n  lastAutoConnectionResultPromise = resultPromise;\n  return resultPromise;\n};\nconst _autoConnectCore = async _ref => {\n  var _props$timeout, _props$siweAuth, _props$siweAuth2, _props$siweAuth3;\n  let {\n    storage,\n    props,\n    createWalletFn,\n    manager,\n    connectOverride,\n    setLastAuthProvider\n  } = _ref;\n  const {\n    wallets,\n    onConnect\n  } = props;\n  const timeout = (_props$timeout = props.timeout) !== null && _props$timeout !== void 0 ? _props$timeout : 15000;\n  let autoConnected = false;\n  manager.isAutoConnecting.setValue(true);\n  let [lastConnectedWalletIds, lastActiveWalletId] = await Promise.all([getStoredConnectedWalletIds(storage), getStoredActiveWalletId(storage)]);\n  const urlToken = getUrlToken();\n  // If an auth cookie is found and this site supports the wallet, we'll set the auth cookie in the client storage\n  const wallet = wallets.find(w => w.id === (urlToken === null || urlToken === void 0 ? void 0 : urlToken.walletId));\n  if (urlToken !== null && urlToken !== void 0 && urlToken.authCookie && wallet) {\n    var _wallet$getConfig;\n    const clientStorage = new ClientScopedStorage({\n      clientId: props.client.clientId,\n      ecosystem: isEcosystemWallet(wallet) ? {\n        id: wallet.id,\n        partnerId: (_wallet$getConfig = wallet.getConfig()) === null || _wallet$getConfig === void 0 ? void 0 : _wallet$getConfig.partnerId\n      } : undefined,\n      storage\n    });\n    await clientStorage.saveAuthCookie(urlToken.authCookie);\n  }\n  if (urlToken !== null && urlToken !== void 0 && urlToken.walletId) {\n    var _lastConnectedWalletI;\n    lastActiveWalletId = urlToken.walletId;\n    lastConnectedWalletIds = (_lastConnectedWalletI = lastConnectedWalletIds) !== null && _lastConnectedWalletI !== void 0 && _lastConnectedWalletI.includes(urlToken.walletId) ? lastConnectedWalletIds : [urlToken.walletId, ...(lastConnectedWalletIds || [])];\n  }\n  if (urlToken !== null && urlToken !== void 0 && urlToken.authProvider) {\n    await (setLastAuthProvider === null || setLastAuthProvider === void 0 ? void 0 : setLastAuthProvider(urlToken.authProvider, storage));\n  }\n  // if no wallets were last connected or we didn't receive an auth token\n  if (!lastConnectedWalletIds) {\n    return autoConnected;\n  }\n  // this flow can actually be used for a first connection in the case of a redirect\n  // in that case, we default to the passed chain to connect to\n  const lastConnectedChain = (await getLastConnectedChain(storage)) || props.chain;\n  const availableWallets = lastConnectedWalletIds.map(id => {\n    const specifiedWallet = wallets.find(w => w.id === id);\n    if (specifiedWallet) {\n      return specifiedWallet;\n    }\n    return createWalletFn(id);\n  });\n  const activeWallet = lastActiveWalletId && (availableWallets.find(w => w.id === lastActiveWalletId) || createWalletFn(lastActiveWalletId));\n  if (activeWallet) {\n    manager.activeWalletConnectionStatusStore.setValue(\"connecting\"); // only set connecting status if we are connecting the last active EOA\n    await timeoutPromise(handleWalletConnection({\n      authResult: urlToken === null || urlToken === void 0 ? void 0 : urlToken.authResult,\n      client: props.client,\n      lastConnectedChain,\n      wallet: activeWallet\n    }), {\n      message: \"AutoConnect timeout: \".concat(timeout, \"ms limit exceeded.\"),\n      ms: timeout\n    }).catch(err => {\n      console.warn(err.message);\n      if (props.onTimeout) {\n        props.onTimeout();\n      }\n    });\n    try {\n      // connected wallet could be activeWallet or smart wallet\n      const connectedWallet = await (connectOverride ? connectOverride(activeWallet) : manager.connect(activeWallet, {\n        accountAbstraction: props.accountAbstraction,\n        client: props.client\n      }));\n      if (connectedWallet) {\n        autoConnected = true;\n        try {\n          onConnect === null || onConnect === void 0 || onConnect(connectedWallet);\n        } catch (_unused) {\n          // ignore\n        }\n      } else {\n        manager.activeWalletConnectionStatusStore.setValue(\"disconnected\");\n      }\n    } catch (e) {\n      if (e instanceof Error) {\n        console.warn(\"Error auto connecting wallet:\", e.message);\n      }\n      manager.activeWalletConnectionStatusStore.setValue(\"disconnected\");\n    }\n  } else {\n    manager.activeWalletConnectionStatusStore.setValue(\"disconnected\");\n  }\n  // then connect wallets that were last connected but were not set as active\n  const otherWallets = availableWallets.filter(w => w.id !== lastActiveWalletId && lastConnectedWalletIds.includes(w.id));\n  for (const wallet of otherWallets) {\n    try {\n      await handleWalletConnection({\n        authResult: urlToken === null || urlToken === void 0 ? void 0 : urlToken.authResult,\n        client: props.client,\n        lastConnectedChain,\n        wallet\n      });\n      manager.addConnectedWallet(wallet);\n    } catch (_unused2) {\n      // no-op\n    }\n  }\n  // Auto-login with SIWE\n  const isIAW = activeWallet && isInAppSigner({\n    connectedWallets: activeWallet ? [activeWallet, ...otherWallets] : otherWallets,\n    wallet: activeWallet\n  });\n  if (isIAW && (_props$siweAuth = props.siweAuth) !== null && _props$siweAuth !== void 0 && _props$siweAuth.requiresAuth && !((_props$siweAuth2 = props.siweAuth) !== null && _props$siweAuth2 !== void 0 && _props$siweAuth2.isLoggedIn) && !((_props$siweAuth3 = props.siweAuth) !== null && _props$siweAuth3 !== void 0 && _props$siweAuth3.isLoggingIn)) {\n    var _props$siweAuth4;\n    await ((_props$siweAuth4 = props.siweAuth) === null || _props$siweAuth4 === void 0 ? void 0 : _props$siweAuth4.doLogin().catch(err => {\n      console.warn(\"Error signing in with SIWE:\", err.message);\n    }));\n  }\n  manager.isAutoConnecting.setValue(false);\n  return autoConnected; // useQuery needs a return value\n};\n/**\n * @internal\n */\nexport async function handleWalletConnection(props) {\n  return props.wallet.autoConnect({\n    authResult: props.authResult,\n    chain: props.lastConnectedChain,\n    client: props.client\n  });\n}","map":{"version":3,"names":["timeoutPromise","isEcosystemWallet","ClientScopedStorage","isInAppSigner","getUrlToken","getLastConnectedChain","getStoredActiveWalletId","getStoredConnectedWalletIds","lastAutoConnectionResultPromise","autoConnectCore","props","force","lastResult","resultPromise","_autoConnectCore","_ref","_props$timeout","_props$siweAuth","_props$siweAuth2","_props$siweAuth3","storage","createWalletFn","manager","connectOverride","setLastAuthProvider","wallets","onConnect","timeout","autoConnected","isAutoConnecting","setValue","lastConnectedWalletIds","lastActiveWalletId","Promise","all","urlToken","wallet","find","w","id","walletId","authCookie","_wallet$getConfig","clientStorage","clientId","client","ecosystem","partnerId","getConfig","undefined","saveAuthCookie","_lastConnectedWalletI","includes","authProvider","lastConnectedChain","chain","availableWallets","map","specifiedWallet","activeWallet","activeWalletConnectionStatusStore","handleWalletConnection","authResult","message","concat","ms","catch","err","console","warn","onTimeout","connectedWallet","connect","accountAbstraction","_unused","e","Error","otherWallets","filter","addConnectedWallet","_unused2","isIAW","connectedWallets","siweAuth","requiresAuth","isLoggedIn","isLoggingIn","_props$siweAuth4","doLogin","autoConnect"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/wallets/connection/autoConnectCore.ts"],"sourcesContent":["import type { Chain } from \"../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport type { AsyncStorage } from \"../../utils/storage/AsyncStorage.js\";\nimport { timeoutPromise } from \"../../utils/timeoutPromise.js\";\nimport { isEcosystemWallet } from \"../ecosystem/is-ecosystem-wallet.js\";\nimport { ClientScopedStorage } from \"../in-app/core/authentication/client-scoped-storage.js\";\nimport type {\n  AuthArgsType,\n  AuthStoredTokenWithCookieReturnType,\n} from \"../in-app/core/authentication/types.js\";\nimport { isInAppSigner } from \"../in-app/core/wallet/is-in-app-signer.js\";\nimport { getUrlToken } from \"../in-app/web/lib/get-url-token.js\";\nimport type { Wallet } from \"../interfaces/wallet.js\";\nimport {\n  type ConnectionManager,\n  getLastConnectedChain,\n  getStoredActiveWalletId,\n  getStoredConnectedWalletIds,\n} from \"../manager/index.js\";\nimport type { WalletId } from \"../wallet-types.js\";\nimport type { AutoConnectProps } from \"./types.js\";\n\ntype AutoConnectCoreProps = {\n  storage: AsyncStorage;\n  props: AutoConnectProps & { wallets: Wallet[] };\n  createWalletFn: (id: WalletId) => Wallet;\n  manager: ConnectionManager;\n  connectOverride?: (\n    walletOrFn: Wallet | (() => Promise<Wallet>),\n  ) => Promise<Wallet | null>;\n  setLastAuthProvider?: (\n    authProvider: AuthArgsType[\"strategy\"],\n    storage: AsyncStorage,\n  ) => Promise<void>;\n  /**\n   * If true, the auto connect will be forced even if autoConnect has already been attempted successfully earlier.\n   *\n   * @default `false`\n   */\n  force?: boolean;\n};\n\nlet lastAutoConnectionResultPromise: Promise<boolean> | undefined;\n\n/**\n * @internal\n */\nexport const autoConnectCore = async (props: AutoConnectCoreProps) => {\n  // if an auto connect was attempted already\n  if (lastAutoConnectionResultPromise && !props.force) {\n    // wait for its resolution\n    const lastResult = await lastAutoConnectionResultPromise;\n    // if it was successful, return true\n    // if not continue with the new auto connect\n    if (lastResult) {\n      return true;\n    }\n  }\n\n  const resultPromise = _autoConnectCore(props);\n  lastAutoConnectionResultPromise = resultPromise;\n  return resultPromise;\n};\n\nconst _autoConnectCore = async ({\n  storage,\n  props,\n  createWalletFn,\n  manager,\n  connectOverride,\n  setLastAuthProvider,\n}: AutoConnectCoreProps): Promise<boolean> => {\n  const { wallets, onConnect } = props;\n  const timeout = props.timeout ?? 15000;\n\n  let autoConnected = false;\n  manager.isAutoConnecting.setValue(true);\n\n  let [lastConnectedWalletIds, lastActiveWalletId] = await Promise.all([\n    getStoredConnectedWalletIds(storage),\n    getStoredActiveWalletId(storage),\n  ]);\n\n  const urlToken = getUrlToken();\n\n  // If an auth cookie is found and this site supports the wallet, we'll set the auth cookie in the client storage\n  const wallet = wallets.find((w) => w.id === urlToken?.walletId);\n  if (urlToken?.authCookie && wallet) {\n    const clientStorage = new ClientScopedStorage({\n      clientId: props.client.clientId,\n      ecosystem: isEcosystemWallet(wallet)\n        ? {\n            id: wallet.id,\n            partnerId: wallet.getConfig()?.partnerId,\n          }\n        : undefined,\n      storage,\n    });\n    await clientStorage.saveAuthCookie(urlToken.authCookie);\n  }\n  if (urlToken?.walletId) {\n    lastActiveWalletId = urlToken.walletId;\n    lastConnectedWalletIds = lastConnectedWalletIds?.includes(urlToken.walletId)\n      ? lastConnectedWalletIds\n      : [urlToken.walletId, ...(lastConnectedWalletIds || [])];\n  }\n\n  if (urlToken?.authProvider) {\n    await setLastAuthProvider?.(urlToken.authProvider, storage);\n  }\n\n  // if no wallets were last connected or we didn't receive an auth token\n  if (!lastConnectedWalletIds) {\n    return autoConnected;\n  }\n\n  // this flow can actually be used for a first connection in the case of a redirect\n  // in that case, we default to the passed chain to connect to\n  const lastConnectedChain =\n    (await getLastConnectedChain(storage)) || props.chain;\n  const availableWallets = lastConnectedWalletIds.map((id) => {\n    const specifiedWallet = wallets.find((w) => w.id === id);\n    if (specifiedWallet) {\n      return specifiedWallet;\n    }\n    return createWalletFn(id as WalletId);\n  });\n  const activeWallet =\n    lastActiveWalletId &&\n    (availableWallets.find((w) => w.id === lastActiveWalletId) ||\n      createWalletFn(lastActiveWalletId));\n\n  if (activeWallet) {\n    manager.activeWalletConnectionStatusStore.setValue(\"connecting\"); // only set connecting status if we are connecting the last active EOA\n    await timeoutPromise(\n      handleWalletConnection({\n        authResult: urlToken?.authResult,\n        client: props.client,\n        lastConnectedChain,\n        wallet: activeWallet,\n      }),\n      {\n        message: `AutoConnect timeout: ${timeout}ms limit exceeded.`,\n        ms: timeout,\n      },\n    ).catch((err) => {\n      console.warn(err.message);\n      if (props.onTimeout) {\n        props.onTimeout();\n      }\n    });\n\n    try {\n      // connected wallet could be activeWallet or smart wallet\n      const connectedWallet = await (connectOverride\n        ? connectOverride(activeWallet)\n        : manager.connect(activeWallet, {\n            accountAbstraction: props.accountAbstraction,\n            client: props.client,\n          }));\n      if (connectedWallet) {\n        autoConnected = true;\n        try {\n          onConnect?.(connectedWallet);\n        } catch {\n          // ignore\n        }\n      } else {\n        manager.activeWalletConnectionStatusStore.setValue(\"disconnected\");\n      }\n    } catch (e) {\n      if (e instanceof Error) {\n        console.warn(\"Error auto connecting wallet:\", e.message);\n      }\n      manager.activeWalletConnectionStatusStore.setValue(\"disconnected\");\n    }\n  } else {\n    manager.activeWalletConnectionStatusStore.setValue(\"disconnected\");\n  }\n\n  // then connect wallets that were last connected but were not set as active\n  const otherWallets = availableWallets.filter(\n    (w) => w.id !== lastActiveWalletId && lastConnectedWalletIds.includes(w.id),\n  );\n  for (const wallet of otherWallets) {\n    try {\n      await handleWalletConnection({\n        authResult: urlToken?.authResult,\n        client: props.client,\n        lastConnectedChain,\n        wallet,\n      });\n      manager.addConnectedWallet(wallet);\n    } catch {\n      // no-op\n    }\n  }\n\n  // Auto-login with SIWE\n  const isIAW =\n    activeWallet &&\n    isInAppSigner({\n      connectedWallets: activeWallet\n        ? [activeWallet, ...otherWallets]\n        : otherWallets,\n      wallet: activeWallet,\n    });\n  if (\n    isIAW &&\n    props.siweAuth?.requiresAuth &&\n    !props.siweAuth?.isLoggedIn &&\n    !props.siweAuth?.isLoggingIn\n  ) {\n    await props.siweAuth?.doLogin().catch((err) => {\n      console.warn(\"Error signing in with SIWE:\", err.message);\n    });\n  }\n  manager.isAutoConnecting.setValue(false);\n  return autoConnected; // useQuery needs a return value\n};\n\n/**\n * @internal\n */\nexport async function handleWalletConnection(props: {\n  wallet: Wallet;\n  client: ThirdwebClient;\n  authResult: AuthStoredTokenWithCookieReturnType | undefined;\n  lastConnectedChain: Chain | undefined;\n}) {\n  return props.wallet.autoConnect({\n    authResult: props.authResult,\n    chain: props.lastConnectedChain,\n    client: props.client,\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}