{"ast":null,"code":"import { z } from \"zod/v4-mini\";\nimport { isAddress } from \"../utils/address.js\";\nimport { isHex } from \"../utils/encoding/hex.js\";\nconst hexSchema = z.string().check(z.refine(isHex, {\n  message: \"Invalid hex string\"\n}));\nconst addressSchema = z.string().check(z.refine(isAddress, {\n  message: \"Invalid address\"\n}));\nconst tokenSchema = z.object({\n  address: addressSchema,\n  chainId: z.coerce.number(),\n  decimals: z.coerce.number(),\n  iconUri: z.optional(z.string()),\n  name: z.string(),\n  priceUsd: z.coerce.number(),\n  symbol: z.string()\n});\nconst onchainWebhookSchema = z.discriminatedUnion(\"version\", [z.object({\n  data: z.object({}),\n  type: z.literal(\"pay.onchain-transaction\"),\n  version: z.literal(1)\n}), z.object({\n  data: z.object({\n    action: z.enum([\"TRANSFER\", \"BUY\", \"SELL\"]),\n    clientId: z.string(),\n    destinationAmount: z.coerce.bigint(),\n    destinationToken: tokenSchema,\n    developerFeeBps: z.coerce.number(),\n    developerFeeRecipient: addressSchema,\n    originAmount: z.coerce.bigint(),\n    originToken: tokenSchema,\n    paymentId: z.string(),\n    // only exists when the payment was triggered from a developer specified payment link\n    paymentLinkId: z.optional(z.string()),\n    purchaseData: z.optional(z.record(z.string(), z.unknown())),\n    receiver: addressSchema,\n    sender: addressSchema,\n    status: z.enum([\"PENDING\", \"FAILED\", \"COMPLETED\"]),\n    transactions: z.array(z.object({\n      chainId: z.coerce.number(),\n      transactionHash: hexSchema\n    })),\n    type: z.string()\n  }),\n  type: z.literal(\"pay.onchain-transaction\"),\n  version: z.literal(2)\n})]);\nconst onrampWebhookSchema = z.discriminatedUnion(\"version\", [z.object({\n  data: z.object({}),\n  type: z.literal(\"pay.onramp-transaction\"),\n  version: z.literal(1)\n}), z.object({\n  data: z.object({\n    amount: z.coerce.bigint(),\n    currency: z.string(),\n    currencyAmount: z.number(),\n    id: z.string(),\n    onramp: z.string(),\n    paymentLinkId: z.optional(z.string()),\n    purchaseData: z.unknown(),\n    receiver: addressSchema,\n    sender: z.optional(addressSchema),\n    status: z.enum([\"PENDING\", \"COMPLETED\", \"FAILED\"]),\n    token: tokenSchema,\n    transactionHash: z.optional(hexSchema)\n  }),\n  type: z.literal(\"pay.onramp-transaction\"),\n  version: z.literal(2)\n})]);\nconst webhookSchema = z.discriminatedUnion(\"type\", [onchainWebhookSchema, onrampWebhookSchema]);\n/**\n * Parses an incoming Bridge webhook payload.\n *\n * @param payload - The raw text body received from thirdweb.\n * @param headers - The webhook headers received from thirdweb.\n * @param secret - The webhook secret to verify the payload with.\n * @bridge Webhook\n * @beta\n */\nexport async function parse(\n/**\n * Raw text body received from thirdweb.\n */\npayload,\n/**\n * The webhook headers received from thirdweb.\n */\nheaders,\n/**\n * The webhook secret to verify the payload with.\n */\nsecret) {\n  let tolerance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 300;\n  // Get the signature and timestamp from headers\n  const receivedSignature = headers[\"x-payload-signature\"] || headers[\"x-pay-signature\"];\n  const receivedTimestamp = headers[\"x-timestamp\"] || headers[\"x-pay-timestamp\"];\n  if (!receivedSignature || !receivedTimestamp) {\n    throw new Error(\"Missing required webhook headers: signature or timestamp\");\n  }\n  // Verify timestamp\n  const now = Math.floor(Date.now() / 1000);\n  const timestamp = Number.parseInt(receivedTimestamp, 10);\n  const diff = Math.abs(now - timestamp);\n  if (diff > tolerance) {\n    throw new Error(\"Webhook timestamp is too old. Difference: \".concat(diff, \"s, tolerance: \").concat(tolerance, \"s\"));\n  }\n  // Generate signature using the same method as the sender\n  const encoder = new TextEncoder();\n  const key = await crypto.subtle.importKey(\"raw\", encoder.encode(secret), {\n    hash: \"SHA-256\",\n    name: \"HMAC\"\n  }, false, [\"sign\"]);\n  const signature = await crypto.subtle.sign(\"HMAC\", key, encoder.encode(\"\".concat(receivedTimestamp, \".\").concat(payload)));\n  // Convert the signature to hex string\n  const computedSignature = Array.from(new Uint8Array(signature)).map(b => b.toString(16).padStart(2, \"0\")).join(\"\");\n  // Compare signatures\n  if (computedSignature !== receivedSignature) {\n    throw new Error(\"Invalid webhook signature\");\n  }\n  // Parse the payload as JSON\n  let payloadObject;\n  try {\n    payloadObject = JSON.parse(payload);\n  } catch (_unused) {\n    throw new Error(\"Invalid webhook payload: not valid JSON\");\n  }\n  const parsedPayload = webhookSchema.parse(payloadObject);\n  // v1 is no longer supported\n  if (parsedPayload.version === 1) {\n    throw new Error(\"Invalid webhook payload: version 1 is no longer supported, please upgrade to webhook version 2.\");\n  }\n  return parsedPayload;\n}","map":{"version":3,"names":["z","isAddress","isHex","hexSchema","string","check","refine","message","addressSchema","tokenSchema","object","address","chainId","coerce","number","decimals","iconUri","optional","name","priceUsd","symbol","onchainWebhookSchema","discriminatedUnion","data","type","literal","version","action","enum","clientId","destinationAmount","bigint","destinationToken","developerFeeBps","developerFeeRecipient","originAmount","originToken","paymentId","paymentLinkId","purchaseData","record","unknown","receiver","sender","status","transactions","array","transactionHash","onrampWebhookSchema","amount","currency","currencyAmount","id","onramp","token","webhookSchema","parse","payload","headers","secret","tolerance","arguments","length","undefined","receivedSignature","receivedTimestamp","Error","now","Math","floor","Date","timestamp","Number","parseInt","diff","abs","concat","encoder","TextEncoder","key","crypto","subtle","importKey","encode","hash","signature","sign","computedSignature","Array","from","Uint8Array","map","b","toString","padStart","join","payloadObject","JSON","_unused","parsedPayload"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/bridge/Webhook.ts"],"sourcesContent":["import { z } from \"zod/v4-mini\";\nimport { isAddress } from \"../utils/address.js\";\nimport { isHex } from \"../utils/encoding/hex.js\";\n\nconst hexSchema = z\n  .string()\n  .check(z.refine(isHex, { message: \"Invalid hex string\" }));\nconst addressSchema = z\n  .string()\n  .check(z.refine(isAddress, { message: \"Invalid address\" }));\nconst tokenSchema = z.object({\n  address: addressSchema,\n  chainId: z.coerce.number(),\n  decimals: z.coerce.number(),\n  iconUri: z.optional(z.string()),\n  name: z.string(),\n  priceUsd: z.coerce.number(),\n  symbol: z.string(),\n});\n\nconst onchainWebhookSchema = z.discriminatedUnion(\"version\", [\n  z.object({\n    data: z.object({}),\n    type: z.literal(\"pay.onchain-transaction\"),\n    version: z.literal(1),\n  }),\n  z.object({\n    data: z.object({\n      action: z.enum([\"TRANSFER\", \"BUY\", \"SELL\"]),\n      clientId: z.string(),\n      destinationAmount: z.coerce.bigint(),\n      destinationToken: tokenSchema,\n      developerFeeBps: z.coerce.number(),\n      developerFeeRecipient: addressSchema,\n      originAmount: z.coerce.bigint(),\n      originToken: tokenSchema,\n      paymentId: z.string(),\n      // only exists when the payment was triggered from a developer specified payment link\n      paymentLinkId: z.optional(z.string()),\n      purchaseData: z.optional(z.record(z.string(), z.unknown())),\n      receiver: addressSchema,\n      sender: addressSchema,\n      status: z.enum([\"PENDING\", \"FAILED\", \"COMPLETED\"]),\n      transactions: z.array(\n        z.object({\n          chainId: z.coerce.number(),\n          transactionHash: hexSchema,\n        }),\n      ),\n      type: z.string(),\n    }),\n    type: z.literal(\"pay.onchain-transaction\"),\n    version: z.literal(2),\n  }),\n]);\n\nconst onrampWebhookSchema = z.discriminatedUnion(\"version\", [\n  z.object({\n    data: z.object({}),\n    type: z.literal(\"pay.onramp-transaction\"),\n    version: z.literal(1),\n  }),\n  z.object({\n    data: z.object({\n      amount: z.coerce.bigint(),\n      currency: z.string(),\n      currencyAmount: z.number(),\n      id: z.string(),\n      onramp: z.string(),\n      paymentLinkId: z.optional(z.string()),\n      purchaseData: z.unknown(),\n      receiver: addressSchema,\n      sender: z.optional(addressSchema),\n      status: z.enum([\"PENDING\", \"COMPLETED\", \"FAILED\"]),\n      token: tokenSchema,\n      transactionHash: z.optional(hexSchema),\n    }),\n    type: z.literal(\"pay.onramp-transaction\"),\n    version: z.literal(2),\n  }),\n]);\n\nconst webhookSchema = z.discriminatedUnion(\"type\", [\n  onchainWebhookSchema,\n  onrampWebhookSchema,\n]);\nexport type WebhookPayload = Exclude<\n  z.infer<typeof webhookSchema>,\n  { version: 1 }\n>;\n\n/**\n * Parses an incoming Bridge webhook payload.\n *\n * @param payload - The raw text body received from thirdweb.\n * @param headers - The webhook headers received from thirdweb.\n * @param secret - The webhook secret to verify the payload with.\n * @bridge Webhook\n * @beta\n */\nexport async function parse(\n  /**\n   * Raw text body received from thirdweb.\n   */\n  payload: string,\n\n  /**\n   * The webhook headers received from thirdweb.\n   */\n  headers: Record<string, string>,\n\n  /**\n   * The webhook secret to verify the payload with.\n   */\n  secret: string,\n\n  /**\n   * The tolerance in seconds for the timestamp verification.\n   */\n  tolerance = 300, // Default to 5 minutes if not specified\n): Promise<WebhookPayload> {\n  // Get the signature and timestamp from headers\n  const receivedSignature =\n    headers[\"x-payload-signature\"] || headers[\"x-pay-signature\"];\n  const receivedTimestamp =\n    headers[\"x-timestamp\"] || headers[\"x-pay-timestamp\"];\n\n  if (!receivedSignature || !receivedTimestamp) {\n    throw new Error(\"Missing required webhook headers: signature or timestamp\");\n  }\n\n  // Verify timestamp\n  const now = Math.floor(Date.now() / 1000);\n  const timestamp = Number.parseInt(receivedTimestamp, 10);\n  const diff = Math.abs(now - timestamp);\n\n  if (diff > tolerance) {\n    throw new Error(\n      `Webhook timestamp is too old. Difference: ${diff}s, tolerance: ${tolerance}s`,\n    );\n  }\n\n  // Generate signature using the same method as the sender\n  const encoder = new TextEncoder();\n  const key = await crypto.subtle.importKey(\n    \"raw\",\n    encoder.encode(secret),\n    { hash: \"SHA-256\", name: \"HMAC\" },\n    false,\n    [\"sign\"],\n  );\n\n  const signature = await crypto.subtle.sign(\n    \"HMAC\",\n    key,\n    encoder.encode(`${receivedTimestamp}.${payload}`),\n  );\n\n  // Convert the signature to hex string\n  const computedSignature = Array.from(new Uint8Array(signature))\n    .map((b) => b.toString(16).padStart(2, \"0\"))\n    .join(\"\");\n\n  // Compare signatures\n  if (computedSignature !== receivedSignature) {\n    throw new Error(\"Invalid webhook signature\");\n  }\n\n  // Parse the payload as JSON\n  let payloadObject: unknown;\n  try {\n    payloadObject = JSON.parse(payload) as unknown;\n  } catch {\n    throw new Error(\"Invalid webhook payload: not valid JSON\");\n  }\n\n  const parsedPayload = webhookSchema.parse(payloadObject);\n\n  // v1 is no longer supported\n  if (parsedPayload.version === 1) {\n    throw new Error(\n      \"Invalid webhook payload: version 1 is no longer supported, please upgrade to webhook version 2.\",\n    );\n  }\n\n  return parsedPayload satisfies WebhookPayload;\n}\n"],"mappings":"AAAA,SAASA,CAAC,QAAQ,aAAa;AAC/B,SAASC,SAAS,QAAQ,qBAAqB;AAC/C,SAASC,KAAK,QAAQ,0BAA0B;AAEhD,MAAMC,SAAS,GAAGH,CAAC,CAChBI,MAAM,EAAE,CACRC,KAAK,CAACL,CAAC,CAACM,MAAM,CAACJ,KAAK,EAAE;EAAEK,OAAO,EAAE;AAAoB,CAAE,CAAC,CAAC;AAC5D,MAAMC,aAAa,GAAGR,CAAC,CACpBI,MAAM,EAAE,CACRC,KAAK,CAACL,CAAC,CAACM,MAAM,CAACL,SAAS,EAAE;EAAEM,OAAO,EAAE;AAAiB,CAAE,CAAC,CAAC;AAC7D,MAAME,WAAW,GAAGT,CAAC,CAACU,MAAM,CAAC;EAC3BC,OAAO,EAAEH,aAAa;EACtBI,OAAO,EAAEZ,CAAC,CAACa,MAAM,CAACC,MAAM,EAAE;EAC1BC,QAAQ,EAAEf,CAAC,CAACa,MAAM,CAACC,MAAM,EAAE;EAC3BE,OAAO,EAAEhB,CAAC,CAACiB,QAAQ,CAACjB,CAAC,CAACI,MAAM,EAAE,CAAC;EAC/Bc,IAAI,EAAElB,CAAC,CAACI,MAAM,EAAE;EAChBe,QAAQ,EAAEnB,CAAC,CAACa,MAAM,CAACC,MAAM,EAAE;EAC3BM,MAAM,EAAEpB,CAAC,CAACI,MAAM;CACjB,CAAC;AAEF,MAAMiB,oBAAoB,GAAGrB,CAAC,CAACsB,kBAAkB,CAAC,SAAS,EAAE,CAC3DtB,CAAC,CAACU,MAAM,CAAC;EACPa,IAAI,EAAEvB,CAAC,CAACU,MAAM,CAAC,EAAE,CAAC;EAClBc,IAAI,EAAExB,CAAC,CAACyB,OAAO,CAAC,yBAAyB,CAAC;EAC1CC,OAAO,EAAE1B,CAAC,CAACyB,OAAO,CAAC,CAAC;CACrB,CAAC,EACFzB,CAAC,CAACU,MAAM,CAAC;EACPa,IAAI,EAAEvB,CAAC,CAACU,MAAM,CAAC;IACbiB,MAAM,EAAE3B,CAAC,CAAC4B,IAAI,CAAC,CAAC,UAAU,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;IAC3CC,QAAQ,EAAE7B,CAAC,CAACI,MAAM,EAAE;IACpB0B,iBAAiB,EAAE9B,CAAC,CAACa,MAAM,CAACkB,MAAM,EAAE;IACpCC,gBAAgB,EAAEvB,WAAW;IAC7BwB,eAAe,EAAEjC,CAAC,CAACa,MAAM,CAACC,MAAM,EAAE;IAClCoB,qBAAqB,EAAE1B,aAAa;IACpC2B,YAAY,EAAEnC,CAAC,CAACa,MAAM,CAACkB,MAAM,EAAE;IAC/BK,WAAW,EAAE3B,WAAW;IACxB4B,SAAS,EAAErC,CAAC,CAACI,MAAM,EAAE;IACrB;IACAkC,aAAa,EAAEtC,CAAC,CAACiB,QAAQ,CAACjB,CAAC,CAACI,MAAM,EAAE,CAAC;IACrCmC,YAAY,EAAEvC,CAAC,CAACiB,QAAQ,CAACjB,CAAC,CAACwC,MAAM,CAACxC,CAAC,CAACI,MAAM,EAAE,EAAEJ,CAAC,CAACyC,OAAO,EAAE,CAAC,CAAC;IAC3DC,QAAQ,EAAElC,aAAa;IACvBmC,MAAM,EAAEnC,aAAa;IACrBoC,MAAM,EAAE5C,CAAC,CAAC4B,IAAI,CAAC,CAAC,SAAS,EAAE,QAAQ,EAAE,WAAW,CAAC,CAAC;IAClDiB,YAAY,EAAE7C,CAAC,CAAC8C,KAAK,CACnB9C,CAAC,CAACU,MAAM,CAAC;MACPE,OAAO,EAAEZ,CAAC,CAACa,MAAM,CAACC,MAAM,EAAE;MAC1BiC,eAAe,EAAE5C;KAClB,CAAC,CACH;IACDqB,IAAI,EAAExB,CAAC,CAACI,MAAM;GACf,CAAC;EACFoB,IAAI,EAAExB,CAAC,CAACyB,OAAO,CAAC,yBAAyB,CAAC;EAC1CC,OAAO,EAAE1B,CAAC,CAACyB,OAAO,CAAC,CAAC;CACrB,CAAC,CACH,CAAC;AAEF,MAAMuB,mBAAmB,GAAGhD,CAAC,CAACsB,kBAAkB,CAAC,SAAS,EAAE,CAC1DtB,CAAC,CAACU,MAAM,CAAC;EACPa,IAAI,EAAEvB,CAAC,CAACU,MAAM,CAAC,EAAE,CAAC;EAClBc,IAAI,EAAExB,CAAC,CAACyB,OAAO,CAAC,wBAAwB,CAAC;EACzCC,OAAO,EAAE1B,CAAC,CAACyB,OAAO,CAAC,CAAC;CACrB,CAAC,EACFzB,CAAC,CAACU,MAAM,CAAC;EACPa,IAAI,EAAEvB,CAAC,CAACU,MAAM,CAAC;IACbuC,MAAM,EAAEjD,CAAC,CAACa,MAAM,CAACkB,MAAM,EAAE;IACzBmB,QAAQ,EAAElD,CAAC,CAACI,MAAM,EAAE;IACpB+C,cAAc,EAAEnD,CAAC,CAACc,MAAM,EAAE;IAC1BsC,EAAE,EAAEpD,CAAC,CAACI,MAAM,EAAE;IACdiD,MAAM,EAAErD,CAAC,CAACI,MAAM,EAAE;IAClBkC,aAAa,EAAEtC,CAAC,CAACiB,QAAQ,CAACjB,CAAC,CAACI,MAAM,EAAE,CAAC;IACrCmC,YAAY,EAAEvC,CAAC,CAACyC,OAAO,EAAE;IACzBC,QAAQ,EAAElC,aAAa;IACvBmC,MAAM,EAAE3C,CAAC,CAACiB,QAAQ,CAACT,aAAa,CAAC;IACjCoC,MAAM,EAAE5C,CAAC,CAAC4B,IAAI,CAAC,CAAC,SAAS,EAAE,WAAW,EAAE,QAAQ,CAAC,CAAC;IAClD0B,KAAK,EAAE7C,WAAW;IAClBsC,eAAe,EAAE/C,CAAC,CAACiB,QAAQ,CAACd,SAAS;GACtC,CAAC;EACFqB,IAAI,EAAExB,CAAC,CAACyB,OAAO,CAAC,wBAAwB,CAAC;EACzCC,OAAO,EAAE1B,CAAC,CAACyB,OAAO,CAAC,CAAC;CACrB,CAAC,CACH,CAAC;AAEF,MAAM8B,aAAa,GAAGvD,CAAC,CAACsB,kBAAkB,CAAC,MAAM,EAAE,CACjDD,oBAAoB,EACpB2B,mBAAmB,CACpB,CAAC;AAMF;;;;;;;;;AASA,OAAO,eAAeQ,KAAKA;AACzB;;;AAGAC,OAAe;AAEf;;;AAGAC,OAA+B;AAE/B;;;AAGAC,MAAc,EAKC;EAAA,IAAfC,SAAS,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,GAAG;EAEf;EACA,MAAMG,iBAAiB,GACrBN,OAAO,CAAC,qBAAqB,CAAC,IAAIA,OAAO,CAAC,iBAAiB,CAAC;EAC9D,MAAMO,iBAAiB,GACrBP,OAAO,CAAC,aAAa,CAAC,IAAIA,OAAO,CAAC,iBAAiB,CAAC;EAEtD,IAAI,CAACM,iBAAiB,IAAI,CAACC,iBAAiB,EAAE;IAC5C,MAAM,IAAIC,KAAK,CAAC,0DAA0D,CAAC;EAC7E;EAEA;EACA,MAAMC,GAAG,GAAGC,IAAI,CAACC,KAAK,CAACC,IAAI,CAACH,GAAG,EAAE,GAAG,IAAI,CAAC;EACzC,MAAMI,SAAS,GAAGC,MAAM,CAACC,QAAQ,CAACR,iBAAiB,EAAE,EAAE,CAAC;EACxD,MAAMS,IAAI,GAAGN,IAAI,CAACO,GAAG,CAACR,GAAG,GAAGI,SAAS,CAAC;EAEtC,IAAIG,IAAI,GAAGd,SAAS,EAAE;IACpB,MAAM,IAAIM,KAAK,8CAAAU,MAAA,CACgCF,IAAI,oBAAAE,MAAA,CAAiBhB,SAAS,MAAG,CAC/E;EACH;EAEA;EACA,MAAMiB,OAAO,GAAG,IAAIC,WAAW,EAAE;EACjC,MAAMC,GAAG,GAAG,MAAMC,MAAM,CAACC,MAAM,CAACC,SAAS,CACvC,KAAK,EACLL,OAAO,CAACM,MAAM,CAACxB,MAAM,CAAC,EACtB;IAAEyB,IAAI,EAAE,SAAS;IAAElE,IAAI,EAAE;EAAM,CAAE,EACjC,KAAK,EACL,CAAC,MAAM,CAAC,CACT;EAED,MAAMmE,SAAS,GAAG,MAAML,MAAM,CAACC,MAAM,CAACK,IAAI,CACxC,MAAM,EACNP,GAAG,EACHF,OAAO,CAACM,MAAM,IAAAP,MAAA,CAAIX,iBAAiB,OAAAW,MAAA,CAAInB,OAAO,CAAE,CAAC,CAClD;EAED;EACA,MAAM8B,iBAAiB,GAAGC,KAAK,CAACC,IAAI,CAAC,IAAIC,UAAU,CAACL,SAAS,CAAC,CAAC,CAC5DM,GAAG,CAAEC,CAAC,IAAKA,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAC3CC,IAAI,CAAC,EAAE,CAAC;EAEX;EACA,IAAIR,iBAAiB,KAAKvB,iBAAiB,EAAE;IAC3C,MAAM,IAAIE,KAAK,CAAC,2BAA2B,CAAC;EAC9C;EAEA;EACA,IAAI8B,aAAsB;EAC1B,IAAI;IACFA,aAAa,GAAGC,IAAI,CAACzC,KAAK,CAACC,OAAO,CAAY;EAChD,CAAC,CAAC,OAAAyC,OAAA,EAAM;IACN,MAAM,IAAIhC,KAAK,CAAC,yCAAyC,CAAC;EAC5D;EAEA,MAAMiC,aAAa,GAAG5C,aAAa,CAACC,KAAK,CAACwC,aAAa,CAAC;EAExD;EACA,IAAIG,aAAa,CAACzE,OAAO,KAAK,CAAC,EAAE;IAC/B,MAAM,IAAIwC,KAAK,CACb,iGAAiG,CAClG;EACH;EAEA,OAAOiC,aAAsC;AAC/C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}