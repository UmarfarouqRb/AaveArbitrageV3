{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"account\", \"chain\", \"client\", \"depositHash\"];\nimport { parseAbi } from 'abitype';\nimport { getTransaction } from '../../actions/public/getTransaction.js';\nimport { getTransactionReceipt } from '../../actions/public/getTransactionReceipt.js';\nimport { readContract } from '../../actions/public/readContract.js';\nimport { sendTransaction } from '../../actions/wallet/sendTransaction.js';\nimport { zeroHash } from '../../constants/bytes.js';\nimport { AccountNotFoundError } from '../../errors/account.js';\nimport { ClientChainNotConfiguredError } from '../../errors/chain.js';\nimport { decodeAbiParameters, decodeFunctionData, encodeAbiParameters, encodeFunctionData, isAddressEqual, parseAccount } from '../../utils/index.js';\nimport { bootloaderFormalAddress } from '../constants/address.js';\nimport { CannotClaimSuccessfulDepositError, L2BridgeNotFoundError, LogProofNotFoundError } from '../errors/bridge.js';\nimport { undoL1ToL2Alias } from '../utils/bridge/undoL1ToL2Alias.js';\nimport { getDefaultBridgeAddresses } from './getDefaultBridgeAddresses.js';\nimport { getLogProof } from './getLogProof.js';\n/**\n * Withdraws funds from the initiated deposit, which failed when finalizing on L2.\n * If the deposit L2 transaction has failed, it sends an L1 transaction calling `claimFailedDeposit` method of the\n * L1 bridge, which results in returning L1 tokens back to the depositor.\n *\n * @param client - Client to use\n * @param parameters - {@link ClaimFailedDepositParameters}\n * @returns hash - The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link ClaimFailedDepositReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { zksync, mainnet } from 'viem/chains'\n * import { claimFailedDeposit, publicActionsL2 } from 'viem/zksync'\n *\n * const client = createPublicClient({\n *     chain: mainnet,\n *     transport: http(),\n * })\n *\n * const clientL2 = createPublicClient({\n *   chain: zksync,\n *   transport: http(),\n * }).extend(publicActionsL2())\n *\n * const account = privateKeyToAccount('0x…')\n *\n * const hash = await claimFailedDeposit(client, {\n *     client: clientL2,\n *     account,\n *     depositHash: <L2_HASH_OF_FAILED_DEPOSIT>,\n * })\n *\n * @example Account Hoisting\n * import { createPublicClient, createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { zksync, mainnet } from 'viem/chains'\n * import { publicActionsL2 } from 'viem/zksync'\n *\n * const walletClient = createWalletClient({\n *   chain: mainnet,\n *   transport: http(),\n *   account: privateKeyToAccount('0x…'),\n * })\n *\n * const clientL2 = createPublicClient({\n *   chain: zksync,\n *   transport: http(),\n * }).extend(publicActionsL2())\n *\n * const hash = await claimFailedDeposit(walletClient, {\n *     client: clientL2,\n *     depositHash: <L2_HASH_OF_FAILED_DEPOSIT>,\n * })\n */\nexport async function claimFailedDeposit(client, parameters) {\n  const {\n      account: account_ = client.account,\n      chain: chain_ = client.chain,\n      client: l2Client,\n      depositHash\n    } = parameters,\n    rest = _objectWithoutProperties(parameters, _excluded);\n  const account = account_ ? parseAccount(account_) : client.account;\n  if (!account) throw new AccountNotFoundError({\n    docsPath: '/docs/actions/wallet/sendTransaction'\n  });\n  if (!l2Client.chain) throw new ClientChainNotConfiguredError();\n  const receipt = await getTransactionReceipt(l2Client, {\n    hash: depositHash\n  });\n  const successL2ToL1LogIndex = receipt.l2ToL1Logs.findIndex(l2ToL1log => isAddressEqual(l2ToL1log.sender, bootloaderFormalAddress) && l2ToL1log.key === depositHash);\n  const successL2ToL1Log = receipt.l2ToL1Logs[successL2ToL1LogIndex];\n  if ((successL2ToL1Log === null || successL2ToL1Log === void 0 ? void 0 : successL2ToL1Log.value) !== zeroHash) throw new CannotClaimSuccessfulDepositError({\n    hash: depositHash\n  });\n  const tx = await getTransaction(l2Client, {\n    hash: depositHash\n  });\n  // Undo the aliasing, since the Mailbox contract set it as for contract address.\n  const l1BridgeAddress = undoL1ToL2Alias(receipt.from);\n  const l2BridgeAddress = receipt.to;\n  if (!l2BridgeAddress) throw new L2BridgeNotFoundError();\n  const l1NativeTokenVault = (await getBridgeAddresses(client, l2Client)).l1NativeTokenVault;\n  let depositSender;\n  let assetId;\n  let assetData;\n  try {\n    const {\n      args\n    } = decodeFunctionData({\n      abi: parseAbi(['function finalizeDeposit(address _l1Sender, address _l2Receiver, address _l1Token, uint256 _amount, bytes _data)']),\n      data: tx.input\n    });\n    assetData = encodeAbiParameters([{\n      type: 'uint256'\n    }, {\n      type: 'address'\n    }, {\n      type: 'address'\n    }], [args[3], args[1], args[2]]);\n    assetId = await readContract(client, {\n      address: l1NativeTokenVault,\n      abi: parseAbi(['function assetId(address token) view returns (bytes32)']),\n      functionName: 'assetId',\n      args: [args[2]]\n    });\n    depositSender = args[0];\n    if (assetId === zeroHash) throw new Error(\"Token \".concat(args[2], \" not registered in NTV\"));\n  } catch (_e) {\n    const {\n      args\n    } = decodeFunctionData({\n      abi: parseAbi(['function finalizeDeposit(uint256 _chainId, bytes32 _assetId, bytes _transferData)']),\n      data: tx.input\n    });\n    assetId = args[1];\n    const transferData = args[2];\n    const l1TokenAddress = await readContract(client, {\n      address: l1NativeTokenVault,\n      abi: parseAbi(['function tokenAddress(bytes32 assetId) view returns (address)']),\n      functionName: 'tokenAddress',\n      args: [assetId]\n    });\n    const transferDataDecoded = decodeAbiParameters([{\n      type: 'address'\n    }, {\n      type: 'address'\n    }, {\n      type: 'address'\n    }, {\n      type: 'uint256'\n    }, {\n      type: 'bytes'\n    }], transferData);\n    assetData = encodeAbiParameters([{\n      type: 'uint256'\n    }, {\n      type: 'address'\n    }, {\n      type: 'address'\n    }], [transferDataDecoded[3], transferDataDecoded[1], l1TokenAddress]);\n    depositSender = transferDataDecoded[0];\n  }\n  const proof = await getLogProof(l2Client, {\n    txHash: depositHash,\n    index: successL2ToL1LogIndex\n  });\n  if (!proof) throw new LogProofNotFoundError({\n    hash: depositHash,\n    index: successL2ToL1LogIndex\n  });\n  const data = encodeFunctionData({\n    abi: parseAbi(['function bridgeRecoverFailedTransfer(uint256 _chainId, address _depositSender, bytes32 _assetId, bytes _assetData, bytes32 _l2TxHash, uint256 _l2BatchNumber, uint256 _l2MessageIndex, uint16 _l2TxNumberInBatch, bytes32[] _merkleProof)']),\n    functionName: 'bridgeRecoverFailedTransfer',\n    args: [BigInt(l2Client.chain.id), depositSender, assetId, assetData, depositHash, receipt.l1BatchNumber, BigInt(proof.id), Number(receipt.l1BatchTxIndex), proof.proof]\n  });\n  return await sendTransaction(client, _objectSpread({\n    chain: chain_,\n    account,\n    to: l1BridgeAddress,\n    data\n  }, rest));\n}\nasync function getBridgeAddresses(client, l2Client) {\n  const addresses = await getDefaultBridgeAddresses(l2Client);\n  let l1Nullifier = addresses.l1Nullifier;\n  let l1NativeTokenVault = addresses.l1NativeTokenVault;\n  if (!l1Nullifier) l1Nullifier = await readContract(client, {\n    address: addresses.sharedL1,\n    abi: parseAbi(['function L1_NULLIFIER() view returns (address)']),\n    functionName: 'L1_NULLIFIER',\n    args: []\n  });\n  if (!l1NativeTokenVault) l1NativeTokenVault = await readContract(client, {\n    address: addresses.sharedL1,\n    abi: parseAbi(['function nativeTokenVault() view returns (address)']),\n    functionName: 'nativeTokenVault',\n    args: []\n  });\n  return _objectSpread(_objectSpread({}, addresses), {}, {\n    l1Nullifier,\n    l1NativeTokenVault\n  });\n}","map":{"version":3,"names":["parseAbi","getTransaction","getTransactionReceipt","readContract","sendTransaction","zeroHash","AccountNotFoundError","ClientChainNotConfiguredError","decodeAbiParameters","decodeFunctionData","encodeAbiParameters","encodeFunctionData","isAddressEqual","parseAccount","bootloaderFormalAddress","CannotClaimSuccessfulDepositError","L2BridgeNotFoundError","LogProofNotFoundError","undoL1ToL2Alias","getDefaultBridgeAddresses","getLogProof","claimFailedDeposit","client","parameters","account","account_","chain","chain_","l2Client","depositHash","rest","_objectWithoutProperties","_excluded","docsPath","receipt","hash","successL2ToL1LogIndex","l2ToL1Logs","findIndex","l2ToL1log","sender","key","successL2ToL1Log","value","tx","l1BridgeAddress","from","l2BridgeAddress","to","l1NativeTokenVault","getBridgeAddresses","depositSender","assetId","assetData","args","abi","data","input","type","address","functionName","Error","concat","_e","transferData","l1TokenAddress","transferDataDecoded","proof","txHash","index","BigInt","id","l1BatchNumber","Number","l1BatchTxIndex","_objectSpread","addresses","l1Nullifier","sharedL1"],"sources":["/home/user/Arbitrage/frontend/node_modules/viem/zksync/actions/claimFailedDeposit.ts"],"sourcesContent":["import { type Address, parseAbi } from 'abitype'\nimport type { Account } from '../../accounts/types.js'\nimport { getTransaction } from '../../actions/public/getTransaction.js'\nimport { getTransactionReceipt } from '../../actions/public/getTransactionReceipt.js'\nimport { readContract } from '../../actions/public/readContract.js'\nimport {\n  type SendTransactionErrorType,\n  type SendTransactionParameters,\n  type SendTransactionReturnType,\n  sendTransaction,\n} from '../../actions/wallet/sendTransaction.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { zeroHash } from '../../constants/bytes.js'\nimport { AccountNotFoundError } from '../../errors/account.js'\nimport { ClientChainNotConfiguredError } from '../../errors/chain.js'\nimport type { TransactionReceiptNotFoundErrorType } from '../../errors/transaction.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../types/chain.js'\nimport type { Hash, Hex } from '../../types/misc.js'\nimport type { UnionEvaluate, UnionOmit } from '../../types/utils.js'\nimport {\n  decodeAbiParameters,\n  decodeFunctionData,\n  encodeAbiParameters,\n  encodeFunctionData,\n  type FormattedTransactionRequest,\n  isAddressEqual,\n  parseAccount,\n} from '../../utils/index.js'\nimport { bootloaderFormalAddress } from '../constants/address.js'\nimport {\n  CannotClaimSuccessfulDepositError,\n  type CannotClaimSuccessfulDepositErrorType,\n  L2BridgeNotFoundError,\n  type L2BridgeNotFoundErrorType,\n  LogProofNotFoundError,\n  type LogProofNotFoundErrorType,\n} from '../errors/bridge.js'\nimport type { ChainEIP712 } from '../types/chain.js'\nimport type { BridgeContractAddresses } from '../types/contract.js'\nimport type { ZksyncTransactionReceipt } from '../types/transaction.js'\nimport { undoL1ToL2Alias } from '../utils/bridge/undoL1ToL2Alias.js'\nimport { getDefaultBridgeAddresses } from './getDefaultBridgeAddresses.js'\nimport { getLogProof } from './getLogProof.js'\n\nexport type ClaimFailedDepositParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  chainL2 extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  accountL2 extends Account | undefined = Account | undefined,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = UnionEvaluate<\n  UnionOmit<FormattedTransactionRequest<_derivedChain>, 'data' | 'to' | 'from'>\n> &\n  Partial<GetChainParameter<chain, chainOverride>> &\n  Partial<GetAccountParameter<account>> & {\n    /** L2 client. */\n    client: Client<Transport, chainL2, accountL2>\n    /** The L2 transaction hash of the failed deposit. */\n    depositHash: Hash\n  }\n\nexport type ClaimFailedDepositReturnType = SendTransactionReturnType\n\nexport type ClaimFailedDepositErrorType =\n  | SendTransactionErrorType\n  | TransactionReceiptNotFoundErrorType\n  | CannotClaimSuccessfulDepositErrorType\n  | LogProofNotFoundErrorType\n  | L2BridgeNotFoundErrorType\n\n/**\n * Withdraws funds from the initiated deposit, which failed when finalizing on L2.\n * If the deposit L2 transaction has failed, it sends an L1 transaction calling `claimFailedDeposit` method of the\n * L1 bridge, which results in returning L1 tokens back to the depositor.\n *\n * @param client - Client to use\n * @param parameters - {@link ClaimFailedDepositParameters}\n * @returns hash - The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link ClaimFailedDepositReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { zksync, mainnet } from 'viem/chains'\n * import { claimFailedDeposit, publicActionsL2 } from 'viem/zksync'\n *\n * const client = createPublicClient({\n *     chain: mainnet,\n *     transport: http(),\n * })\n *\n * const clientL2 = createPublicClient({\n *   chain: zksync,\n *   transport: http(),\n * }).extend(publicActionsL2())\n *\n * const account = privateKeyToAccount('0x…')\n *\n * const hash = await claimFailedDeposit(client, {\n *     client: clientL2,\n *     account,\n *     depositHash: <L2_HASH_OF_FAILED_DEPOSIT>,\n * })\n *\n * @example Account Hoisting\n * import { createPublicClient, createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { zksync, mainnet } from 'viem/chains'\n * import { publicActionsL2 } from 'viem/zksync'\n *\n * const walletClient = createWalletClient({\n *   chain: mainnet,\n *   transport: http(),\n *   account: privateKeyToAccount('0x…'),\n * })\n *\n * const clientL2 = createPublicClient({\n *   chain: zksync,\n *   transport: http(),\n * }).extend(publicActionsL2())\n *\n * const hash = await claimFailedDeposit(walletClient, {\n *     client: clientL2,\n *     depositHash: <L2_HASH_OF_FAILED_DEPOSIT>,\n * })\n */\nexport async function claimFailedDeposit<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  chainL2 extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  accountL2 extends Account | undefined = Account | undefined,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: ClaimFailedDepositParameters<\n    chain,\n    account,\n    chainOverride,\n    chainL2,\n    accountL2\n  >,\n): Promise<ClaimFailedDepositReturnType> {\n  const {\n    account: account_ = client.account,\n    chain: chain_ = client.chain,\n    client: l2Client,\n    depositHash,\n    ...rest\n  } = parameters\n\n  const account = account_ ? parseAccount(account_) : client.account\n  if (!account)\n    throw new AccountNotFoundError({\n      docsPath: '/docs/actions/wallet/sendTransaction',\n    })\n  if (!l2Client.chain) throw new ClientChainNotConfiguredError()\n\n  const receipt = <ZksyncTransactionReceipt>(\n    await getTransactionReceipt(l2Client, { hash: depositHash })\n  )\n\n  const successL2ToL1LogIndex = receipt.l2ToL1Logs.findIndex(\n    (l2ToL1log) =>\n      isAddressEqual(<Hex>l2ToL1log.sender, bootloaderFormalAddress) &&\n      l2ToL1log.key === depositHash,\n  )\n  const successL2ToL1Log = receipt.l2ToL1Logs[successL2ToL1LogIndex]\n  if (successL2ToL1Log?.value !== zeroHash)\n    throw new CannotClaimSuccessfulDepositError({ hash: depositHash })\n\n  const tx = await getTransaction(l2Client, { hash: depositHash })\n\n  // Undo the aliasing, since the Mailbox contract set it as for contract address.\n  const l1BridgeAddress = undoL1ToL2Alias(receipt.from)\n  const l2BridgeAddress = receipt.to\n  if (!l2BridgeAddress) throw new L2BridgeNotFoundError()\n\n  const l1NativeTokenVault = (await getBridgeAddresses(client, l2Client))\n    .l1NativeTokenVault\n\n  let depositSender: Hex\n  let assetId: Hex\n  let assetData: Hex\n  try {\n    const { args } = decodeFunctionData({\n      abi: parseAbi([\n        'function finalizeDeposit(address _l1Sender, address _l2Receiver, address _l1Token, uint256 _amount, bytes _data)',\n      ]),\n      data: tx.input,\n    })\n    assetData = encodeAbiParameters(\n      [{ type: 'uint256' }, { type: 'address' }, { type: 'address' }],\n      [args[3], args[1], args[2]],\n    )\n    assetId = await readContract(client, {\n      address: l1NativeTokenVault,\n      abi: parseAbi(['function assetId(address token) view returns (bytes32)']),\n      functionName: 'assetId',\n      args: [args[2]],\n    })\n    depositSender = args[0]\n    if (assetId === zeroHash)\n      throw new Error(`Token ${args[2]} not registered in NTV`)\n  } catch (_e) {\n    const { args } = decodeFunctionData({\n      abi: parseAbi([\n        'function finalizeDeposit(uint256 _chainId, bytes32 _assetId, bytes _transferData)',\n      ]),\n      data: tx.input,\n    })\n    assetId = args[1]\n    const transferData = args[2]\n    const l1TokenAddress = await readContract(client, {\n      address: l1NativeTokenVault,\n      abi: parseAbi([\n        'function tokenAddress(bytes32 assetId) view returns (address)',\n      ]),\n      functionName: 'tokenAddress',\n      args: [assetId],\n    })\n    const transferDataDecoded = decodeAbiParameters(\n      [\n        { type: 'address' },\n        { type: 'address' },\n        { type: 'address' },\n        { type: 'uint256' },\n        { type: 'bytes' },\n      ],\n      transferData,\n    )\n    assetData = encodeAbiParameters(\n      [{ type: 'uint256' }, { type: 'address' }, { type: 'address' }],\n      [transferDataDecoded[3], transferDataDecoded[1], l1TokenAddress],\n    )\n    depositSender = transferDataDecoded[0]\n  }\n\n  const proof = await getLogProof(l2Client, {\n    txHash: depositHash,\n    index: successL2ToL1LogIndex,\n  })\n  if (!proof)\n    throw new LogProofNotFoundError({\n      hash: depositHash,\n      index: successL2ToL1LogIndex,\n    })\n\n  const data = encodeFunctionData({\n    abi: parseAbi([\n      'function bridgeRecoverFailedTransfer(uint256 _chainId, address _depositSender, bytes32 _assetId, bytes _assetData, bytes32 _l2TxHash, uint256 _l2BatchNumber, uint256 _l2MessageIndex, uint16 _l2TxNumberInBatch, bytes32[] _merkleProof)',\n    ]),\n    functionName: 'bridgeRecoverFailedTransfer',\n    args: [\n      BigInt(l2Client.chain.id),\n      depositSender,\n      assetId,\n      assetData,\n      depositHash,\n      receipt.l1BatchNumber!,\n      BigInt(proof.id),\n      Number(receipt.l1BatchTxIndex),\n      proof.proof,\n    ],\n  })\n\n  return await sendTransaction(client, {\n    chain: chain_,\n    account,\n    to: l1BridgeAddress,\n    data,\n    ...rest,\n  } as SendTransactionParameters)\n}\n\nasync function getBridgeAddresses<\n  chain extends Chain | undefined,\n  chainL2 extends ChainEIP712 | undefined,\n>(\n  client: Client<Transport, chain>,\n  l2Client: Client<Transport, chainL2>,\n): Promise<\n  BridgeContractAddresses & {\n    l1Nullifier: Address\n    l1NativeTokenVault: Address\n  }\n> {\n  const addresses = await getDefaultBridgeAddresses(l2Client)\n  let l1Nullifier = addresses.l1Nullifier\n  let l1NativeTokenVault = addresses.l1NativeTokenVault\n\n  if (!l1Nullifier)\n    l1Nullifier = await readContract(client, {\n      address: addresses.sharedL1,\n      abi: parseAbi(['function L1_NULLIFIER() view returns (address)']),\n      functionName: 'L1_NULLIFIER',\n      args: [],\n    })\n  if (!l1NativeTokenVault)\n    l1NativeTokenVault = await readContract(client, {\n      address: addresses.sharedL1,\n      abi: parseAbi(['function nativeTokenVault() view returns (address)']),\n      functionName: 'nativeTokenVault',\n      args: [],\n    })\n\n  return {\n    ...addresses,\n    l1Nullifier,\n    l1NativeTokenVault,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}