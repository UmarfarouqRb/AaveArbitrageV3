{"ast":null,"code":"/* biome-ignore-all lint: IGNORED */\n// original source: https://github.com/kriszyp/cbor-x/blob/master/decode.js\n// heavily modified to remove all non-essential code\n// TODO: re-enable typescript and properly type this\n// @ts-nocheck - TODO: re-enable typescript and properly type this\nlet src;\nlet srcEnd;\nlet position = 0;\nconst EMPTY_ARRAY = [];\nlet strings = EMPTY_ARRAY;\nlet stringPosition = 0;\nlet currentDecoder = {};\nlet currentStructures;\nlet srcString;\nconst srcStringStart = 0;\nlet srcStringEnd = 0;\nlet bundledStrings;\nlet referenceMap;\nconst currentExtensions = [];\nlet packedValues;\nlet dataView;\nconst defaultOptions = {\n  mapsAsObjects: true,\n  useRecords: false\n};\nfunction readFixedString(length) {\n  let result;\n  if (length < 16) {\n    if (result = shortStringInJS(length)) return result;\n  }\n  if (length > 64 && decoder) return decoder.decode(src.subarray(position, position += length));\n  const end = position + length;\n  const units = [];\n  result = \"\";\n  while (position < end) {\n    const byte1 = src[position++];\n    if ((byte1 & 0x80) === 0) {\n      // 1 byte\n      units.push(byte1);\n    } else if ((byte1 & 0xe0) === 0xc0) {\n      // 2 bytes\n      const byte2 = src[position++] & 0x3f;\n      units.push((byte1 & 0x1f) << 6 | byte2);\n    } else if ((byte1 & 0xf0) === 0xe0) {\n      // 3 bytes\n      const byte2 = src[position++] & 0x3f;\n      const byte3 = src[position++] & 0x3f;\n      units.push((byte1 & 0x1f) << 12 | byte2 << 6 | byte3);\n    } else if ((byte1 & 0xf8) === 0xf0) {\n      // 4 bytes\n      const byte2 = src[position++] & 0x3f;\n      const byte3 = src[position++] & 0x3f;\n      const byte4 = src[position++] & 0x3f;\n      let unit = (byte1 & 0x07) << 0x12 | byte2 << 0x0c | byte3 << 0x06 | byte4;\n      if (unit > 0xffff) {\n        unit -= 0x10000;\n        units.push(unit >>> 10 & 0x3ff | 0xd800);\n        unit = 0xdc00 | unit & 0x3ff;\n      }\n      units.push(unit);\n    } else {\n      units.push(byte1);\n    }\n    if (units.length >= 0x1000) {\n      result += fromCharCode.apply(String, units);\n      units.length = 0;\n    }\n  }\n  if (units.length > 0) {\n    result += fromCharCode.apply(String, units);\n  }\n  return result;\n}\nclass Decoder {\n  constructor() {\n    Object.assign(this, defaultOptions);\n  }\n  decodeKey(key) {\n    return key;\n  }\n  decode(source) {\n    let end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    srcEnd = end > -1 ? end : source.length;\n    position = 0;\n    stringPosition = 0;\n    srcStringEnd = 0;\n    srcString = null;\n    strings = EMPTY_ARRAY;\n    bundledStrings = null;\n    src = source;\n    // this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n    // technique for getting data from a database where it can be copied into an existing buffer instead of creating\n    // new ones\n    try {\n      dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));\n    } catch (error) {\n      // if it doesn't have a buffer, maybe it is the wrong type of object\n      src = null;\n      if (source instanceof Uint8Array) {\n        throw error;\n      }\n      throw new Error(\"Source must be a Uint8Array or Buffer but was a \".concat(source && typeof source === \"object\" ? source.constructor.name : typeof source));\n    }\n    if (this instanceof Decoder) {\n      currentDecoder = this;\n      packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);\n      if (!currentStructures || currentStructures.length > 0) {\n        currentStructures = [];\n      }\n    } else {\n      currentDecoder = defaultOptions;\n      if (!currentStructures || currentStructures.length > 0) {\n        currentStructures = [];\n      }\n      packedValues = null;\n    }\n    return checkedRead();\n  }\n}\nfunction checkedRead() {\n  try {\n    const result = read();\n    if (bundledStrings) {\n      if (position >= bundledStrings.postBundlePosition) {\n        const error = new Error(\"Unexpected bundle position\");\n        error.incomplete = true;\n        throw error;\n      }\n      // bundled strings to skip past\n      position = bundledStrings.postBundlePosition;\n      bundledStrings = null;\n    }\n    if (position === srcEnd) {\n      // finished reading this source, cleanup references\n      currentStructures = null;\n      src = null;\n      if (referenceMap) {\n        referenceMap = null;\n      }\n    } else if (position > srcEnd) {\n      // over read\n      const error = new Error(\"Unexpected end of CBOR data\");\n      error.incomplete = true;\n      throw error;\n    } else {\n      throw new Error(\"Data read, but end of buffer not reached\");\n    }\n    // else more to read, but we are reading sequentially, so don't clear source yet\n    return result;\n  } catch (error) {\n    clearSource();\n    if (error instanceof RangeError || error.message.startsWith(\"Unexpected end of buffer\")) {\n      error.incomplete = true;\n    }\n    throw error;\n  }\n}\nfunction read() {\n  let token = src[position++];\n  const majorType = token >> 5;\n  token = token & 0x1f;\n  if (token > 0x17) {\n    switch (token) {\n      case 0x18:\n        token = src[position++];\n        break;\n      default:\n        throw new Error(\"Unknown token \".concat(token));\n    }\n  }\n  switch (majorType) {\n    case 0:\n      // positive int\n      return token;\n    case 1:\n      // negative int\n      return ~token;\n    case 2:\n      // buffer\n      return readBin(token);\n    case 3:\n      // string\n      if (srcStringEnd >= position) {\n        return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);\n      }\n      if (srcStringEnd === 0 && srcEnd < 140 && token < 32) {\n        // for small blocks, avoiding the overhead of the extract call is helpful\n        const string = token < 16 ? shortStringInJS(token) : longStringInJS(token);\n        if (string !== null) {\n          return string;\n        }\n      }\n      return readFixedString(token);\n    case 4:\n      {\n        // array\n        const array = new Array(token);\n        for (let i = 0; i < token; i++) {\n          array[i] = read();\n        }\n        return array;\n      }\n    case 5:\n      {\n        // map\n        const object = {};\n        for (let i = 0; i < token; i++) {\n          object[safeKey(read())] = read();\n        }\n        return object;\n      }\n    default:\n      // negative int\n      if (Number.isNaN(token)) {\n        const error = new Error(\"Unexpected end of CBOR data\");\n        error.incomplete = true;\n        throw error;\n      }\n      throw new Error(\"Unknown CBOR token \".concat(token));\n  }\n}\nfunction safeKey(key) {\n  // protect against prototype pollution\n  if (typeof key === \"string\") {\n    return key === \"__proto__\" ? \"__proto_\" : key;\n  }\n  if (typeof key !== \"object\") {\n    return key.toString();\n  }\n  // protect against expensive (DoS) string conversions\n  throw new Error(\"Invalid property name type \".concat(typeof key));\n}\nconst fromCharCode = String.fromCharCode;\nfunction longStringInJS(length) {\n  const start = position;\n  const bytes = new Array(length);\n  for (let i = 0; i < length; i++) {\n    const byte = src[position++];\n    if ((byte & 0x80) > 0) {\n      position = start;\n      return;\n    }\n    bytes[i] = byte;\n  }\n  return fromCharCode.apply(String, bytes);\n}\nfunction shortStringInJS(length) {\n  if (length < 4) {\n    if (length < 2) {\n      if (length === 0) {\n        return \"\";\n      }\n      const a = src[position++];\n      if ((a & 0x80) > 1) {\n        position -= 1;\n        return;\n      }\n      return fromCharCode(a);\n    }\n    const a = src[position++];\n    const b = src[position++];\n    if ((a & 0x80) > 0 || (b & 0x80) > 0) {\n      position -= 2;\n      return;\n    }\n    if (length < 3) {\n      return fromCharCode(a, b);\n    }\n    const c = src[position++];\n    if ((c & 0x80) > 0) {\n      position -= 3;\n      return;\n    }\n    return fromCharCode(a, b, c);\n  }\n  const a = src[position++];\n  const b = src[position++];\n  const c = src[position++];\n  const d = src[position++];\n  if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n    position -= 4;\n    return;\n  }\n  if (length < 6) {\n    if (length === 4) {\n      return fromCharCode(a, b, c, d);\n    }\n    const e = src[position++];\n    if ((e & 0x80) > 0) {\n      position -= 5;\n      return;\n    }\n    return fromCharCode(a, b, c, d, e);\n  }\n  if (length < 8) {\n    const e = src[position++];\n    const f = src[position++];\n    if ((e & 0x80) > 0 || (f & 0x80) > 0) {\n      position -= 6;\n      return;\n    }\n    if (length < 7) {\n      return fromCharCode(a, b, c, d, e, f);\n    }\n    const g = src[position++];\n    if ((g & 0x80) > 0) {\n      position -= 7;\n      return;\n    }\n    return fromCharCode(a, b, c, d, e, f, g);\n  }\n  const e = src[position++];\n  const f = src[position++];\n  const g = src[position++];\n  const h = src[position++];\n  if ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n    position -= 8;\n    return;\n  }\n  if (length < 10) {\n    if (length === 8) {\n      return fromCharCode(a, b, c, d, e, f, g, h);\n    }\n    const i = src[position++];\n    if ((i & 0x80) > 0) {\n      position -= 9;\n      return;\n    }\n    return fromCharCode(a, b, c, d, e, f, g, h, i);\n  }\n  if (length < 12) {\n    const i = src[position++];\n    const j = src[position++];\n    if ((i & 0x80) > 0 || (j & 0x80) > 0) {\n      position -= 10;\n      return;\n    }\n    if (length < 11) {\n      return fromCharCode(a, b, c, d, e, f, g, h, i, j);\n    }\n    const k = src[position++];\n    if ((k & 0x80) > 0) {\n      position -= 11;\n      return;\n    }\n    return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);\n  }\n  const i = src[position++];\n  const j = src[position++];\n  const k = src[position++];\n  const l = src[position++];\n  if ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n    position -= 12;\n    return;\n  }\n  if (length < 14) {\n    if (length === 12) {\n      return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);\n    }\n    const m = src[position++];\n    if ((m & 0x80) > 0) {\n      position -= 13;\n      return;\n    }\n    return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);\n  }\n  const m = src[position++];\n  const n = src[position++];\n  if ((m & 0x80) > 0 || (n & 0x80) > 0) {\n    position -= 14;\n    return;\n  }\n  if (length < 15) {\n    return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);\n  }\n  const o = src[position++];\n  if ((o & 0x80) > 0) {\n    position -= 15;\n    return;\n  }\n  return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);\n}\nfunction readBin(length) {\n  return currentDecoder.copyBuffers ?\n  // specifically use the copying slice (not the node one)\n  Uint8Array.prototype.slice.call(src, position, position += length) : src.subarray(position, position += length);\n}\nconst glbl = {\n  Error,\n  RegExp\n};\ncurrentExtensions[27] = data => {\n  // http://cbor.schmorp.de/generic-object\n  return (glbl[data[0]] || Error)(data[1], data[2]);\n};\nconst packedTable = read_ => {\n  if (src[position++] !== 0x84) {\n    const error = new Error(\"Packed values structure must be followed by a 4 element array\");\n    if (src.length < position) {\n      error.incomplete = true;\n    }\n    throw error;\n  }\n  const newPackedValues = read_(); // packed values\n  if (!newPackedValues || !newPackedValues.length) {\n    const error = new Error(\"Packed values structure must be followed by a 4 element array\");\n    error.incomplete = true;\n    throw error;\n  }\n  packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;\n  packedValues.prefixes = read_();\n  packedValues.suffixes = read_();\n  return read_(); // read the rump\n};\npackedTable.handlesRead = true;\ncurrentExtensions[28] = read_ => {\n  // shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n  if (!referenceMap) {\n    referenceMap = new Map();\n    referenceMap.id = 0;\n  }\n  const id = referenceMap.id++;\n  const token = src[position];\n  let target;\n  // TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n  // ahead past references to record structure definitions\n  if (token >> 5 === 4) {\n    target = [];\n  } else {\n    target = {};\n  }\n  const refEntry = {\n    target\n  }; // a placeholder object\n  referenceMap.set(id, refEntry);\n  const targetProperties = read_(); // read the next value as the target object to id\n  if (refEntry.used) {\n    // there is a cycle, so we have to assign properties to original target\n    return Object.assign(target, targetProperties);\n  }\n  refEntry.target = targetProperties; // the placeholder wasn't used, replace with the deserialized one\n  return targetProperties; // no cycle, can just use the returned read object\n};\nfunction clearSource() {\n  src = null;\n  referenceMap = null;\n  currentStructures = null;\n}\nconst mult10 = new Array(147); // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n  mult10[i] = /* @__PURE__ */(() => Number(\"1e\".concat(Math.floor(45.15 - i * 0.30103))))();\n}\nconst defaultDecoder = new Decoder();\nexport const decode = defaultDecoder.decode;","map":{"version":3,"names":["src","srcEnd","position","EMPTY_ARRAY","strings","stringPosition","currentDecoder","currentStructures","srcString","srcStringStart","srcStringEnd","bundledStrings","referenceMap","currentExtensions","packedValues","dataView","defaultOptions","mapsAsObjects","useRecords","readFixedString","length","result","shortStringInJS","decoder","decode","subarray","end","units","byte1","push","byte2","byte3","byte4","unit","fromCharCode","apply","String","Decoder","constructor","Object","assign","decodeKey","key","source","arguments","undefined","DataView","buffer","byteOffset","byteLength","error","Uint8Array","Error","concat","name","sharedValues","pack","Array","maxPrivatePackedValues","checkedRead","read","postBundlePosition","incomplete","clearSource","RangeError","message","startsWith","token","majorType","readBin","slice","string","longStringInJS","array","i","object","safeKey","Number","isNaN","toString","start","bytes","byte","a","b","c","d","e","f","g","h","j","k","l","m","n","o","copyBuffers","prototype","call","glbl","RegExp","data","packedTable","read_","newPackedValues","prefixes","suffixes","handlesRead","Map","id","target","refEntry","set","targetProperties","used","mult10","Math","floor","defaultDecoder"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/utils/bytecode/cbor-decode.ts"],"sourcesContent":["/* biome-ignore-all lint: IGNORED */\n\n// original source: https://github.com/kriszyp/cbor-x/blob/master/decode.js\n// heavily modified to remove all non-essential code\n\n// TODO: re-enable typescript and properly type this\n\n// @ts-nocheck - TODO: re-enable typescript and properly type this\n\nlet src;\nlet srcEnd;\nlet position = 0;\n\nconst EMPTY_ARRAY = [];\n\nlet strings = EMPTY_ARRAY;\n\nlet stringPosition = 0;\nlet currentDecoder = {};\nlet currentStructures;\nlet srcString;\nconst srcStringStart = 0;\nlet srcStringEnd = 0;\nlet bundledStrings;\nlet referenceMap;\nconst currentExtensions = [];\n\nlet packedValues;\n\nlet dataView;\n\nconst defaultOptions = {\n  mapsAsObjects: true,\n  useRecords: false,\n};\n\nfunction readFixedString(length) {\n  let result;\n  if (length < 16) {\n    if ((result = shortStringInJS(length))) return result;\n  }\n  if (length > 64 && decoder)\n    return decoder.decode(src.subarray(position, (position += length)));\n  const end = position + length;\n  const units = [];\n  result = \"\";\n  while (position < end) {\n    const byte1 = src[position++];\n    if ((byte1 & 0x80) === 0) {\n      // 1 byte\n      units.push(byte1);\n    } else if ((byte1 & 0xe0) === 0xc0) {\n      // 2 bytes\n      const byte2 = src[position++] & 0x3f;\n      units.push(((byte1 & 0x1f) << 6) | byte2);\n    } else if ((byte1 & 0xf0) === 0xe0) {\n      // 3 bytes\n      const byte2 = src[position++] & 0x3f;\n      const byte3 = src[position++] & 0x3f;\n      units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n    } else if ((byte1 & 0xf8) === 0xf0) {\n      // 4 bytes\n      const byte2 = src[position++] & 0x3f;\n      const byte3 = src[position++] & 0x3f;\n      const byte4 = src[position++] & 0x3f;\n      let unit =\n        ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n      if (unit > 0xffff) {\n        unit -= 0x10000;\n        units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n        unit = 0xdc00 | (unit & 0x3ff);\n      }\n      units.push(unit);\n    } else {\n      units.push(byte1);\n    }\n\n    if (units.length >= 0x1000) {\n      result += fromCharCode.apply(String, units);\n      units.length = 0;\n    }\n  }\n\n  if (units.length > 0) {\n    result += fromCharCode.apply(String, units);\n  }\n\n  return result;\n}\n\nclass Decoder {\n  constructor() {\n    Object.assign(this, defaultOptions);\n  }\n\n  decodeKey(key) {\n    return key;\n  }\n\n  decode(source, end = -1) {\n    srcEnd = end > -1 ? end : source.length;\n    position = 0;\n    stringPosition = 0;\n    srcStringEnd = 0;\n    srcString = null;\n    strings = EMPTY_ARRAY;\n    bundledStrings = null;\n    src = source;\n    // this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n    // technique for getting data from a database where it can be copied into an existing buffer instead of creating\n    // new ones\n    try {\n      dataView =\n        source.dataView ||\n        (source.dataView = new DataView(\n          source.buffer,\n          source.byteOffset,\n          source.byteLength,\n        ));\n    } catch (error) {\n      // if it doesn't have a buffer, maybe it is the wrong type of object\n      src = null;\n      if (source instanceof Uint8Array) {\n        throw error;\n      }\n      throw new Error(\n        `Source must be a Uint8Array or Buffer but was a ${\n          source && typeof source === \"object\"\n            ? source.constructor.name\n            : typeof source\n        }`,\n      );\n    }\n    if (this instanceof Decoder) {\n      currentDecoder = this;\n      packedValues =\n        this.sharedValues &&\n        (this.pack\n          ? new Array(this.maxPrivatePackedValues || 16).concat(\n              this.sharedValues,\n            )\n          : this.sharedValues);\n      if (!currentStructures || currentStructures.length > 0) {\n        currentStructures = [];\n      }\n    } else {\n      currentDecoder = defaultOptions;\n      if (!currentStructures || currentStructures.length > 0) {\n        currentStructures = [];\n      }\n      packedValues = null;\n    }\n    return checkedRead();\n  }\n}\n\nfunction checkedRead() {\n  try {\n    const result = read();\n    if (bundledStrings) {\n      if (position >= bundledStrings.postBundlePosition) {\n        const error = new Error(\"Unexpected bundle position\");\n        error.incomplete = true;\n        throw error;\n      }\n      // bundled strings to skip past\n      position = bundledStrings.postBundlePosition;\n      bundledStrings = null;\n    }\n\n    if (position === srcEnd) {\n      // finished reading this source, cleanup references\n      currentStructures = null;\n      src = null;\n      if (referenceMap) {\n        referenceMap = null;\n      }\n    } else if (position > srcEnd) {\n      // over read\n      const error = new Error(\"Unexpected end of CBOR data\");\n      error.incomplete = true;\n      throw error;\n    } else {\n      throw new Error(\"Data read, but end of buffer not reached\");\n    }\n    // else more to read, but we are reading sequentially, so don't clear source yet\n    return result;\n  } catch (error) {\n    clearSource();\n    if (\n      error instanceof RangeError ||\n      error.message.startsWith(\"Unexpected end of buffer\")\n    ) {\n      error.incomplete = true;\n    }\n    throw error;\n  }\n}\n\nfunction read() {\n  let token = src[position++];\n  const majorType = token >> 5;\n  token = token & 0x1f;\n  if (token > 0x17) {\n    switch (token) {\n      case 0x18:\n        token = src[position++];\n        break;\n\n      default:\n        throw new Error(`Unknown token ${token}`);\n    }\n  }\n  switch (majorType) {\n    case 0: // positive int\n      return token;\n    case 1: // negative int\n      return ~token;\n    case 2: // buffer\n      return readBin(token);\n    case 3: // string\n      if (srcStringEnd >= position) {\n        return srcString.slice(\n          position - srcStringStart,\n          (position += token) - srcStringStart,\n        );\n      }\n      if (srcStringEnd === 0 && srcEnd < 140 && token < 32) {\n        // for small blocks, avoiding the overhead of the extract call is helpful\n        const string =\n          token < 16 ? shortStringInJS(token) : longStringInJS(token);\n        if (string !== null) {\n          return string;\n        }\n      }\n      return readFixedString(token);\n    case 4: {\n      // array\n      const array = new Array(token);\n      for (let i = 0; i < token; i++) {\n        array[i] = read();\n      }\n      return array;\n    }\n\n    case 5: {\n      // map\n      const object = {};\n      for (let i = 0; i < token; i++) {\n        object[safeKey(read())] = read();\n      }\n      return object;\n    }\n    default: // negative int\n      if (Number.isNaN(token)) {\n        const error = new Error(\"Unexpected end of CBOR data\");\n        error.incomplete = true;\n        throw error;\n      }\n      throw new Error(`Unknown CBOR token ${token}`);\n  }\n}\n\nfunction safeKey(key) {\n  // protect against prototype pollution\n  if (typeof key === \"string\") {\n    return key === \"__proto__\" ? \"__proto_\" : key;\n  }\n  if (typeof key !== \"object\") {\n    return key.toString();\n  }\n  // protect against expensive (DoS) string conversions\n  throw new Error(`Invalid property name type ${typeof key}`);\n}\n\nconst fromCharCode = String.fromCharCode;\nfunction longStringInJS(length) {\n  const start = position;\n  const bytes = new Array(length);\n  for (let i = 0; i < length; i++) {\n    const byte = src[position++];\n    if ((byte & 0x80) > 0) {\n      position = start;\n      return;\n    }\n    bytes[i] = byte;\n  }\n  return fromCharCode.apply(String, bytes);\n}\nfunction shortStringInJS(length) {\n  if (length < 4) {\n    if (length < 2) {\n      if (length === 0) {\n        return \"\";\n      }\n      const a = src[position++];\n      if ((a & 0x80) > 1) {\n        position -= 1;\n        return;\n      }\n      return fromCharCode(a);\n    }\n    const a = src[position++];\n    const b = src[position++];\n    if ((a & 0x80) > 0 || (b & 0x80) > 0) {\n      position -= 2;\n      return;\n    }\n    if (length < 3) {\n      return fromCharCode(a, b);\n    }\n    const c = src[position++];\n    if ((c & 0x80) > 0) {\n      position -= 3;\n      return;\n    }\n    return fromCharCode(a, b, c);\n  }\n  const a = src[position++];\n  const b = src[position++];\n  const c = src[position++];\n  const d = src[position++];\n  if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n    position -= 4;\n    return;\n  }\n  if (length < 6) {\n    if (length === 4) {\n      return fromCharCode(a, b, c, d);\n    }\n    const e = src[position++];\n    if ((e & 0x80) > 0) {\n      position -= 5;\n      return;\n    }\n    return fromCharCode(a, b, c, d, e);\n  }\n  if (length < 8) {\n    const e = src[position++];\n    const f = src[position++];\n    if ((e & 0x80) > 0 || (f & 0x80) > 0) {\n      position -= 6;\n      return;\n    }\n    if (length < 7) {\n      return fromCharCode(a, b, c, d, e, f);\n    }\n    const g = src[position++];\n    if ((g & 0x80) > 0) {\n      position -= 7;\n      return;\n    }\n    return fromCharCode(a, b, c, d, e, f, g);\n  }\n  const e = src[position++];\n  const f = src[position++];\n  const g = src[position++];\n  const h = src[position++];\n  if ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n    position -= 8;\n    return;\n  }\n  if (length < 10) {\n    if (length === 8) {\n      return fromCharCode(a, b, c, d, e, f, g, h);\n    }\n    const i = src[position++];\n    if ((i & 0x80) > 0) {\n      position -= 9;\n      return;\n    }\n    return fromCharCode(a, b, c, d, e, f, g, h, i);\n  }\n  if (length < 12) {\n    const i = src[position++];\n    const j = src[position++];\n    if ((i & 0x80) > 0 || (j & 0x80) > 0) {\n      position -= 10;\n      return;\n    }\n    if (length < 11) {\n      return fromCharCode(a, b, c, d, e, f, g, h, i, j);\n    }\n    const k = src[position++];\n    if ((k & 0x80) > 0) {\n      position -= 11;\n      return;\n    }\n    return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);\n  }\n  const i = src[position++];\n  const j = src[position++];\n  const k = src[position++];\n  const l = src[position++];\n  if ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n    position -= 12;\n    return;\n  }\n  if (length < 14) {\n    if (length === 12) {\n      return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);\n    }\n    const m = src[position++];\n    if ((m & 0x80) > 0) {\n      position -= 13;\n      return;\n    }\n    return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);\n  }\n  const m = src[position++];\n  const n = src[position++];\n  if ((m & 0x80) > 0 || (n & 0x80) > 0) {\n    position -= 14;\n    return;\n  }\n  if (length < 15) {\n    return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);\n  }\n  const o = src[position++];\n  if ((o & 0x80) > 0) {\n    position -= 15;\n    return;\n  }\n  return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);\n}\n\nfunction readBin(length) {\n  return currentDecoder.copyBuffers\n    ? // specifically use the copying slice (not the node one)\n      Uint8Array.prototype.slice.call(src, position, (position += length))\n    : src.subarray(position, (position += length));\n}\n\nconst glbl = { Error, RegExp };\ncurrentExtensions[27] = (data) => {\n  // http://cbor.schmorp.de/generic-object\n  return (glbl[data[0]] || Error)(data[1], data[2]);\n};\nconst packedTable = (read_) => {\n  if (src[position++] !== 0x84) {\n    const error = new Error(\n      \"Packed values structure must be followed by a 4 element array\",\n    );\n    if (src.length < position) {\n      error.incomplete = true;\n    }\n    throw error;\n  }\n  const newPackedValues = read_(); // packed values\n  if (!newPackedValues || !newPackedValues.length) {\n    const error = new Error(\n      \"Packed values structure must be followed by a 4 element array\",\n    );\n    error.incomplete = true;\n    throw error;\n  }\n  packedValues = packedValues\n    ? newPackedValues.concat(packedValues.slice(newPackedValues.length))\n    : newPackedValues;\n  packedValues.prefixes = read_();\n  packedValues.suffixes = read_();\n  return read_(); // read the rump\n};\npackedTable.handlesRead = true;\n\ncurrentExtensions[28] = (read_) => {\n  // shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n  if (!referenceMap) {\n    referenceMap = new Map();\n    referenceMap.id = 0;\n  }\n  const id = referenceMap.id++;\n  const token = src[position];\n  let target;\n  // TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n  // ahead past references to record structure definitions\n  if (token >> 5 === 4) {\n    target = [];\n  } else {\n    target = {};\n  }\n\n  const refEntry = { target }; // a placeholder object\n  referenceMap.set(id, refEntry);\n  const targetProperties = read_(); // read the next value as the target object to id\n  if (refEntry.used) {\n    // there is a cycle, so we have to assign properties to original target\n    return Object.assign(target, targetProperties);\n  }\n  refEntry.target = targetProperties; // the placeholder wasn't used, replace with the deserialized one\n  return targetProperties; // no cycle, can just use the returned read object\n};\n\nfunction clearSource() {\n  src = null;\n  referenceMap = null;\n  currentStructures = null;\n}\n\nconst mult10 = new Array(147); // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n  mult10[i] = /* @__PURE__ */ (() =>\n    Number(`1e${Math.floor(45.15 - i * 0.30103)}`))();\n}\nconst defaultDecoder = new Decoder();\nexport const decode = defaultDecoder.decode;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}