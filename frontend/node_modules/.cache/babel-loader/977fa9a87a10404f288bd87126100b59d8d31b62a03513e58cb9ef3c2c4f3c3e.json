{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { sleep } from \"../../../../../utils/sleep.js\";\nconst iframeBaseStyle = {\n  backgroundColor: \"transparent\",\n  border: \"none\",\n  colorScheme: \"light\",\n  display: \"none\",\n  height: \"100%\",\n  pointerEvents: \"all\",\n  position: \"fixed\",\n  right: \"0px\",\n  top: \"0px\",\n  width: \"100%\",\n  zIndex: \"2147483646\"\n};\n// Global var to help track iframe state\nconst isIframeLoaded = new Map();\n/**\n * @internal\n */\n// biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\nexport class IframeCommunicator {\n  /**\n   * @internal\n   */\n  constructor(_ref) {\n    let {\n      link,\n      baseUrl,\n      iframeId,\n      container,\n      onIframeInitialize,\n      localStorage,\n      clientId,\n      ecosystem\n    } = _ref;\n    Object.defineProperty(this, \"iframe\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"POLLING_INTERVAL_SECONDS\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1.4\n    });\n    Object.defineProperty(this, \"iframeBaseUrl\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"localStorage\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"clientId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"ecosystem\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.localStorage = localStorage;\n    this.clientId = clientId;\n    this.ecosystem = ecosystem;\n    this.iframeBaseUrl = baseUrl;\n    if (typeof document === \"undefined\") {\n      return;\n    }\n    container = container !== null && container !== void 0 ? container : document.body;\n    // Creating the IFrame element for communication\n    let iframe = document.getElementById(iframeId);\n    const hrefLink = new URL(link);\n    // TODO (ew) - bring back version tracking\n    // const sdkVersion = process.env.THIRDWEB_EWS_SDK_VERSION;\n    // if (!sdkVersion) {\n    //   throw new Error(\"Missing THIRDWEB_EWS_SDK_VERSION env var\");\n    // }\n    // hrefLink.searchParams.set(\"sdkVersion\", sdkVersion);\n    if (!iframe || iframe.src !== hrefLink.href) {\n      // ! Do not update the hrefLink here or it'll cause multiple re-renders\n      iframe = document.createElement(\"iframe\");\n      const mergedIframeStyles = _objectSpread({}, iframeBaseStyle);\n      Object.assign(iframe.style, mergedIframeStyles);\n      iframe.setAttribute(\"id\", iframeId);\n      iframe.setAttribute(\"fetchpriority\", \"high\");\n      container.appendChild(iframe);\n      iframe.src = hrefLink.href;\n      // iframe.setAttribute(\"data-version\", sdkVersion);\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n      const onIframeLoaded = event => {\n        if (event.data.eventType === \"ewsIframeLoaded\") {\n          window.removeEventListener(\"message\", onIframeLoaded);\n          if (!iframe) {\n            console.warn(\"thirdweb iFrame not found\");\n            return;\n          }\n          this.onIframeLoadHandler(iframe, onIframeInitialize)();\n        }\n      };\n      window.addEventListener(\"message\", onIframeLoaded);\n    }\n    this.iframe = iframe;\n  }\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n  async onIframeLoadedInitVariables() {\n    var _this$ecosystem, _this$ecosystem2;\n    return {\n      authCookie: await this.localStorage.getAuthCookie(),\n      clientId: this.clientId,\n      deviceShareStored: await this.localStorage.getDeviceShare(),\n      ecosystemId: (_this$ecosystem = this.ecosystem) === null || _this$ecosystem === void 0 ? void 0 : _this$ecosystem.id,\n      partnerId: (_this$ecosystem2 = this.ecosystem) === null || _this$ecosystem2 === void 0 ? void 0 : _this$ecosystem2.partnerId,\n      walletUserId: await this.localStorage.getWalletUserId()\n    };\n  }\n  /**\n   * @internal\n   */\n  onIframeLoadHandler(iframe, onIframeInitialize) {\n    return async () => {\n      var _iframe$contentWindow;\n      const channel = new MessageChannel();\n      const promise = new Promise((res, rej) => {\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n        channel.port1.onmessage = event => {\n          const {\n            data\n          } = event;\n          channel.port1.close();\n          if (!data.success) {\n            rej(new Error(data.error));\n          }\n          isIframeLoaded.set(iframe.src, true);\n          if (onIframeInitialize) {\n            onIframeInitialize();\n          }\n          res(true);\n        };\n      });\n      iframe === null || iframe === void 0 || (_iframe$contentWindow = iframe.contentWindow) === null || _iframe$contentWindow === void 0 || _iframe$contentWindow.postMessage({\n        data: await this.onIframeLoadedInitVariables(),\n        eventType: \"initIframe\"\n      }, this.iframeBaseUrl, [channel.port2]);\n      await promise;\n    };\n  }\n  /**\n   * @internal\n   */\n  async call(_ref2) {\n    var _this$iframe$contentW;\n    let {\n      procedureName,\n      params,\n      showIframe = false\n    } = _ref2;\n    if (!this.iframe) {\n      throw new Error(\"Iframe not found. You are likely calling this from the backend where the DOM is not available.\");\n    }\n    while (!isIframeLoaded.get(this.iframe.src)) {\n      await sleep(this.POLLING_INTERVAL_SECONDS * 1000);\n    }\n    if (showIframe) {\n      this.iframe.style.display = \"block\";\n      // magic number to let the display render before performing the animation of the modal in\n      await sleep(0.005 * 1000);\n    }\n    const channel = new MessageChannel();\n    const promise = new Promise((res, rej) => {\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n      channel.port1.onmessage = async event => {\n        const {\n          data\n        } = event;\n        channel.port1.close();\n        if (showIframe) {\n          // magic number to let modal fade out before hiding it\n          await sleep(0.1 * 1000);\n          if (this.iframe) {\n            this.iframe.style.display = \"none\";\n          }\n        }\n        if (!data.success) {\n          rej(new Error(data.error));\n        } else {\n          res(data.data);\n        }\n      };\n    });\n    (_this$iframe$contentW = this.iframe.contentWindow) === null || _this$iframe$contentW === void 0 || _this$iframe$contentW.postMessage({\n      // Pass the initialization data on every request in case the iframe storage was reset (can happen in some environments such as iOS PWAs)\n      data: _objectSpread(_objectSpread({}, params), await this.onIframeLoadedInitVariables()),\n      eventType: procedureName\n    }, this.iframeBaseUrl, [channel.port2]);\n    return promise;\n  }\n  /**\n   * This has to be called by any iframe that will be removed from the DOM.\n   * Use to make sure that we reset the global loaded state of the particular iframe.src\n   * @internal\n   */\n  destroy() {\n    if (this.iframe) {\n      isIframeLoaded.delete(this.iframe.src);\n    }\n  }\n}","map":{"version":3,"names":["sleep","iframeBaseStyle","backgroundColor","border","colorScheme","display","height","pointerEvents","position","right","top","width","zIndex","isIframeLoaded","Map","IframeCommunicator","constructor","_ref","link","baseUrl","iframeId","container","onIframeInitialize","localStorage","clientId","ecosystem","Object","defineProperty","iframeBaseUrl","document","body","iframe","getElementById","hrefLink","URL","src","href","createElement","mergedIframeStyles","_objectSpread","assign","style","setAttribute","appendChild","onIframeLoaded","event","data","eventType","window","removeEventListener","console","warn","onIframeLoadHandler","addEventListener","onIframeLoadedInitVariables","_this$ecosystem","_this$ecosystem2","authCookie","getAuthCookie","deviceShareStored","getDeviceShare","ecosystemId","id","partnerId","walletUserId","getWalletUserId","_iframe$contentWindow","channel","MessageChannel","promise","Promise","res","rej","port1","onmessage","close","success","Error","error","set","contentWindow","postMessage","port2","call","_ref2","_this$iframe$contentW","procedureName","params","showIframe","get","POLLING_INTERVAL_SECONDS","destroy","delete"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/wallets/in-app/web/utils/iFrameCommunication/IframeCommunicator.ts"],"sourcesContent":["import { sleep } from \"../../../../../utils/sleep.js\";\nimport type { ClientScopedStorage } from \"../../../../../wallets/in-app/core/authentication/client-scoped-storage.js\";\nimport type { Ecosystem } from \"../../../../../wallets/in-app/core/wallet/types.js\";\n\ntype IFrameCommunicatorProps = {\n  link: string;\n  baseUrl: string;\n  iframeId: string;\n  container?: HTMLElement;\n  onIframeInitialize?: () => void;\n  localStorage: ClientScopedStorage;\n  clientId: string;\n  ecosystem?: Ecosystem;\n};\n\nconst iframeBaseStyle = {\n  backgroundColor: \"transparent\",\n  border: \"none\",\n  colorScheme: \"light\",\n  display: \"none\",\n  height: \"100%\",\n  pointerEvents: \"all\",\n  position: \"fixed\",\n  right: \"0px\",\n  top: \"0px\",\n  width: \"100%\",\n  zIndex: \"2147483646\",\n};\n\n// Global var to help track iframe state\nconst isIframeLoaded = new Map<string, boolean>();\n\n/**\n * @internal\n */\n// biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\nexport class IframeCommunicator<T extends { [key: string]: any }> {\n  private iframe?: HTMLIFrameElement;\n  private POLLING_INTERVAL_SECONDS = 1.4;\n  private iframeBaseUrl;\n  protected localStorage: ClientScopedStorage;\n  protected clientId: string;\n  protected ecosystem?: Ecosystem;\n\n  /**\n   * @internal\n   */\n  constructor({\n    link,\n    baseUrl,\n    iframeId,\n    container,\n    onIframeInitialize,\n    localStorage,\n    clientId,\n    ecosystem,\n  }: IFrameCommunicatorProps) {\n    this.localStorage = localStorage;\n    this.clientId = clientId;\n    this.ecosystem = ecosystem;\n    this.iframeBaseUrl = baseUrl;\n\n    if (typeof document === \"undefined\") {\n      return;\n    }\n    container = container ?? document.body;\n    // Creating the IFrame element for communication\n    let iframe = document.getElementById(iframeId) as HTMLIFrameElement | null;\n    const hrefLink = new URL(link);\n\n    // TODO (ew) - bring back version tracking\n    // const sdkVersion = process.env.THIRDWEB_EWS_SDK_VERSION;\n    // if (!sdkVersion) {\n    //   throw new Error(\"Missing THIRDWEB_EWS_SDK_VERSION env var\");\n    // }\n    // hrefLink.searchParams.set(\"sdkVersion\", sdkVersion);\n    if (!iframe || iframe.src !== hrefLink.href) {\n      // ! Do not update the hrefLink here or it'll cause multiple re-renders\n\n      iframe = document.createElement(\"iframe\");\n      const mergedIframeStyles = {\n        ...iframeBaseStyle,\n      };\n      Object.assign(iframe.style, mergedIframeStyles);\n      iframe.setAttribute(\"id\", iframeId);\n      iframe.setAttribute(\"fetchpriority\", \"high\");\n      container.appendChild(iframe);\n\n      iframe.src = hrefLink.href;\n\n      // iframe.setAttribute(\"data-version\", sdkVersion);\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n      const onIframeLoaded = (event: MessageEvent<any>) => {\n        if (event.data.eventType === \"ewsIframeLoaded\") {\n          window.removeEventListener(\"message\", onIframeLoaded);\n          if (!iframe) {\n            console.warn(\"thirdweb iFrame not found\");\n            return;\n          }\n          this.onIframeLoadHandler(iframe, onIframeInitialize)();\n        }\n      };\n      window.addEventListener(\"message\", onIframeLoaded);\n    }\n    this.iframe = iframe;\n  }\n\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n  protected async onIframeLoadedInitVariables(): Promise<Record<string, any>> {\n    return {\n      authCookie: await this.localStorage.getAuthCookie(),\n      clientId: this.clientId,\n      deviceShareStored: await this.localStorage.getDeviceShare(),\n      ecosystemId: this.ecosystem?.id,\n      partnerId: this.ecosystem?.partnerId,\n      walletUserId: await this.localStorage.getWalletUserId(),\n    };\n  }\n\n  /**\n   * @internal\n   */\n  onIframeLoadHandler(\n    iframe: HTMLIFrameElement,\n    onIframeInitialize?: () => void,\n  ) {\n    return async () => {\n      const channel = new MessageChannel();\n\n      const promise = new Promise((res, rej) => {\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n        channel.port1.onmessage = (event: any) => {\n          const { data } = event;\n          channel.port1.close();\n          if (!data.success) {\n            rej(new Error(data.error));\n          }\n          isIframeLoaded.set(iframe.src, true);\n          if (onIframeInitialize) {\n            onIframeInitialize();\n          }\n          res(true);\n        };\n      });\n\n      iframe?.contentWindow?.postMessage(\n        {\n          data: await this.onIframeLoadedInitVariables(),\n          eventType: \"initIframe\",\n        },\n        this.iframeBaseUrl,\n        [channel.port2],\n      );\n\n      await promise;\n    };\n  }\n\n  /**\n   * @internal\n   */\n  async call<ReturnData>({\n    procedureName,\n    params,\n    showIframe = false,\n  }: {\n    procedureName: keyof T;\n    params: T[keyof T];\n    showIframe?: boolean;\n  }) {\n    if (!this.iframe) {\n      throw new Error(\n        \"Iframe not found. You are likely calling this from the backend where the DOM is not available.\",\n      );\n    }\n    while (!isIframeLoaded.get(this.iframe.src)) {\n      await sleep(this.POLLING_INTERVAL_SECONDS * 1000);\n    }\n    if (showIframe) {\n      this.iframe.style.display = \"block\";\n      // magic number to let the display render before performing the animation of the modal in\n      await sleep(0.005 * 1000);\n    }\n\n    const channel = new MessageChannel();\n    const promise = new Promise<ReturnData>((res, rej) => {\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n      channel.port1.onmessage = async (event: any) => {\n        const { data } = event;\n        channel.port1.close();\n        if (showIframe) {\n          // magic number to let modal fade out before hiding it\n          await sleep(0.1 * 1000);\n          if (this.iframe) {\n            this.iframe.style.display = \"none\";\n          }\n        }\n        if (!data.success) {\n          rej(new Error(data.error));\n        } else {\n          res(data.data);\n        }\n      };\n    });\n\n    this.iframe.contentWindow?.postMessage(\n      {\n        // Pass the initialization data on every request in case the iframe storage was reset (can happen in some environments such as iOS PWAs)\n        data: {\n          ...params,\n          ...(await this.onIframeLoadedInitVariables()),\n        },\n        eventType: procedureName,\n      },\n      this.iframeBaseUrl,\n      [channel.port2],\n    );\n    return promise;\n  }\n\n  /**\n   * This has to be called by any iframe that will be removed from the DOM.\n   * Use to make sure that we reset the global loaded state of the particular iframe.src\n   * @internal\n   */\n  destroy() {\n    if (this.iframe) {\n      isIframeLoaded.delete(this.iframe.src);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}