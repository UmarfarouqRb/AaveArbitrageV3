{"ast":null,"code":"import _objectWithoutProperties from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nconst _excluded = [\"security\"];\nimport { getAuthToken } from \"../core/auth.js\";\nimport { jsonBodySerializer } from \"../core/bodySerializer.js\";\nimport { serializeArrayParam, serializeObjectParam, serializePrimitiveParam } from \"../core/pathSerializer.js\";\nconst PATH_PARAM_RE = /\\{[^{}]+\\}/g;\nconst defaultPathSerializer = _ref => {\n  let {\n    path,\n    url: _url\n  } = _ref;\n  let url = _url;\n  const matches = _url.match(PATH_PARAM_RE);\n  if (matches) {\n    for (const match of matches) {\n      let explode = false;\n      let name = match.substring(1, match.length - 1);\n      let style = \"simple\";\n      if (name.endsWith(\"*\")) {\n        explode = true;\n        name = name.substring(0, name.length - 1);\n      }\n      if (name.startsWith(\".\")) {\n        name = name.substring(1);\n        style = \"label\";\n      } else if (name.startsWith(\";\")) {\n        name = name.substring(1);\n        style = \"matrix\";\n      }\n      const value = path[name];\n      if (value === undefined || value === null) {\n        continue;\n      }\n      if (Array.isArray(value)) {\n        url = url.replace(match, serializeArrayParam({\n          explode,\n          name,\n          style,\n          value\n        }));\n        continue;\n      }\n      if (typeof value === \"object\") {\n        url = url.replace(match, serializeObjectParam({\n          explode,\n          name,\n          style,\n          value: value,\n          valueOnly: true\n        }));\n        continue;\n      }\n      if (style === \"matrix\") {\n        url = url.replace(match, \";\".concat(serializePrimitiveParam({\n          name,\n          value: value\n        })));\n        continue;\n      }\n      const replaceValue = encodeURIComponent(style === \"label\" ? \".\".concat(value) : value);\n      url = url.replace(match, replaceValue);\n    }\n  }\n  return url;\n};\nexport const createQuerySerializer = function () {\n  let {\n    allowReserved,\n    array,\n    object\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const querySerializer = queryParams => {\n    const search = [];\n    if (queryParams && typeof queryParams === \"object\") {\n      for (const name in queryParams) {\n        const value = queryParams[name];\n        if (value === undefined || value === null) {\n          continue;\n        }\n        if (Array.isArray(value)) {\n          const serializedArray = serializeArrayParam(_objectSpread({\n            allowReserved,\n            explode: true,\n            name,\n            style: \"form\",\n            value\n          }, array));\n          if (serializedArray) search.push(serializedArray);\n        } else if (typeof value === \"object\") {\n          const serializedObject = serializeObjectParam(_objectSpread({\n            allowReserved,\n            explode: true,\n            name,\n            style: \"deepObject\",\n            value: value\n          }, object));\n          if (serializedObject) search.push(serializedObject);\n        } else {\n          const serializedPrimitive = serializePrimitiveParam({\n            allowReserved,\n            name,\n            value: value\n          });\n          if (serializedPrimitive) search.push(serializedPrimitive);\n        }\n      }\n    }\n    return search.join(\"&\");\n  };\n  return querySerializer;\n};\n/**\n * Infers parseAs value from provided Content-Type header.\n */\nexport const getParseAs = contentType => {\n  var _contentType$split$;\n  if (!contentType) {\n    // If no Content-Type header is provided, the best we can do is return the raw response body,\n    // which is effectively the same as the 'stream' option.\n    return \"stream\";\n  }\n  const cleanContent = (_contentType$split$ = contentType.split(\";\")[0]) === null || _contentType$split$ === void 0 ? void 0 : _contentType$split$.trim();\n  if (!cleanContent) {\n    return;\n  }\n  if (cleanContent.startsWith(\"application/json\") || cleanContent.endsWith(\"+json\")) {\n    return \"json\";\n  }\n  if (cleanContent === \"multipart/form-data\") {\n    return \"formData\";\n  }\n  if ([\"application/\", \"audio/\", \"image/\", \"video/\"].some(type => cleanContent.startsWith(type))) {\n    return \"blob\";\n  }\n  if (cleanContent.startsWith(\"text/\")) {\n    return \"text\";\n  }\n  return;\n};\nexport const setAuthParams = async _ref2 => {\n  let {\n      security\n    } = _ref2,\n    options = _objectWithoutProperties(_ref2, _excluded);\n  for (const auth of security) {\n    var _auth$name;\n    const token = await getAuthToken(auth, options.auth);\n    if (!token) {\n      continue;\n    }\n    const name = (_auth$name = auth.name) !== null && _auth$name !== void 0 ? _auth$name : \"Authorization\";\n    switch (auth.in) {\n      case \"query\":\n        if (!options.query) {\n          options.query = {};\n        }\n        options.query[name] = token;\n        break;\n      case \"cookie\":\n        options.headers.append(\"Cookie\", \"\".concat(name, \"=\").concat(token));\n        break;\n      case \"header\":\n      default:\n        options.headers.set(name, token);\n        break;\n    }\n    return;\n  }\n};\nexport const buildUrl = options => {\n  const url = getUrl({\n    baseUrl: options.baseUrl,\n    path: options.path,\n    query: options.query,\n    querySerializer: typeof options.querySerializer === \"function\" ? options.querySerializer : createQuerySerializer(options.querySerializer),\n    url: options.url\n  });\n  return url;\n};\nexport const getUrl = _ref3 => {\n  let {\n    baseUrl,\n    path,\n    query,\n    querySerializer,\n    url: _url\n  } = _ref3;\n  const pathUrl = _url.startsWith(\"/\") ? _url : \"/\".concat(_url);\n  let url = (baseUrl !== null && baseUrl !== void 0 ? baseUrl : \"\") + pathUrl;\n  if (path) {\n    url = defaultPathSerializer({\n      path,\n      url\n    });\n  }\n  let search = query ? querySerializer(query) : \"\";\n  if (search.startsWith(\"?\")) {\n    search = search.substring(1);\n  }\n  if (search) {\n    url += \"?\".concat(search);\n  }\n  return url;\n};\nexport const mergeConfigs = (a, b) => {\n  var _config$baseUrl;\n  const config = _objectSpread(_objectSpread({}, a), b);\n  if ((_config$baseUrl = config.baseUrl) !== null && _config$baseUrl !== void 0 && _config$baseUrl.endsWith(\"/\")) {\n    config.baseUrl = config.baseUrl.substring(0, config.baseUrl.length - 1);\n  }\n  config.headers = mergeHeaders(a.headers, b.headers);\n  return config;\n};\nexport const mergeHeaders = function () {\n  const mergedHeaders = new Headers();\n  for (var _len = arguments.length, headers = new Array(_len), _key = 0; _key < _len; _key++) {\n    headers[_key] = arguments[_key];\n  }\n  for (const header of headers) {\n    if (!header || typeof header !== \"object\") {\n      continue;\n    }\n    const iterator = header instanceof Headers ? header.entries() : Object.entries(header);\n    for (const [key, value] of iterator) {\n      if (value === null) {\n        mergedHeaders.delete(key);\n      } else if (Array.isArray(value)) {\n        for (const v of value) {\n          mergedHeaders.append(key, v);\n        }\n      } else if (value !== undefined) {\n        // assume object headers are meant to be JSON stringified, i.e. their\n        // content value in OpenAPI specification is 'application/json'\n        mergedHeaders.set(key, typeof value === \"object\" ? JSON.stringify(value) : value);\n      }\n    }\n  }\n  return mergedHeaders;\n};\nclass Interceptors {\n  constructor() {\n    Object.defineProperty(this, \"_fns\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this._fns = [];\n  }\n  clear() {\n    this._fns = [];\n  }\n  getInterceptorIndex(id) {\n    if (typeof id === \"number\") {\n      return this._fns[id] ? id : -1;\n    } else {\n      return this._fns.indexOf(id);\n    }\n  }\n  exists(id) {\n    const index = this.getInterceptorIndex(id);\n    return !!this._fns[index];\n  }\n  eject(id) {\n    const index = this.getInterceptorIndex(id);\n    if (this._fns[index]) {\n      this._fns[index] = null;\n    }\n  }\n  update(id, fn) {\n    const index = this.getInterceptorIndex(id);\n    if (this._fns[index]) {\n      this._fns[index] = fn;\n      return id;\n    } else {\n      return false;\n    }\n  }\n  use(fn) {\n    this._fns = [...this._fns, fn];\n    return this._fns.length - 1;\n  }\n}\n// do not add `Middleware` as return type so we can use _fns internally\nexport const createInterceptors = () => ({\n  error: new Interceptors(),\n  request: new Interceptors(),\n  response: new Interceptors()\n});\nconst defaultQuerySerializer = createQuerySerializer({\n  allowReserved: false,\n  array: {\n    explode: true,\n    style: \"form\"\n  },\n  object: {\n    explode: true,\n    style: \"deepObject\"\n  }\n});\nconst defaultHeaders = {\n  \"Content-Type\": \"application/json\"\n};\nexport const createConfig = function () {\n  let override = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return _objectSpread(_objectSpread({}, jsonBodySerializer), {}, {\n    headers: defaultHeaders,\n    parseAs: \"auto\",\n    querySerializer: defaultQuerySerializer\n  }, override);\n};","map":{"version":3,"names":["getAuthToken","jsonBodySerializer","serializeArrayParam","serializeObjectParam","serializePrimitiveParam","PATH_PARAM_RE","defaultPathSerializer","_ref","path","url","_url","matches","match","explode","name","substring","length","style","endsWith","startsWith","value","undefined","Array","isArray","replace","valueOnly","concat","replaceValue","encodeURIComponent","createQuerySerializer","allowReserved","array","object","arguments","querySerializer","queryParams","search","serializedArray","_objectSpread","push","serializedObject","serializedPrimitive","join","getParseAs","contentType","_contentType$split$","cleanContent","split","trim","some","type","setAuthParams","_ref2","security","options","_objectWithoutProperties","_excluded","auth","_auth$name","token","in","query","headers","append","set","buildUrl","getUrl","baseUrl","_ref3","pathUrl","mergeConfigs","a","b","_config$baseUrl","config","mergeHeaders","mergedHeaders","Headers","_len","_key","header","iterator","entries","Object","key","delete","v","JSON","stringify","Interceptors","constructor","defineProperty","_fns","clear","getInterceptorIndex","id","indexOf","exists","index","eject","update","fn","use","createInterceptors","error","request","response","defaultQuerySerializer","defaultHeaders","createConfig","override","parseAs"],"sources":["/home/user/Arbitrage/frontend/node_modules/@thirdweb-dev/insight/src/client/client/utils.ts"],"sourcesContent":["import { getAuthToken } from \"../core/auth.js\";\nimport type {\n\tQuerySerializer,\n\tQuerySerializerOptions,\n} from \"../core/bodySerializer.js\";\nimport { jsonBodySerializer } from \"../core/bodySerializer.js\";\nimport {\n\tserializeArrayParam,\n\tserializeObjectParam,\n\tserializePrimitiveParam,\n} from \"../core/pathSerializer.js\";\nimport type { Client, ClientOptions, Config, RequestOptions } from \"./types.js\";\n\ninterface PathSerializer {\n\tpath: Record<string, unknown>;\n\turl: string;\n}\n\nconst PATH_PARAM_RE = /\\{[^{}]+\\}/g;\n\ntype ArrayStyle = \"form\" | \"spaceDelimited\" | \"pipeDelimited\";\ntype MatrixStyle = \"label\" | \"matrix\" | \"simple\";\ntype ArraySeparatorStyle = ArrayStyle | MatrixStyle;\n\nconst defaultPathSerializer = ({ path, url: _url }: PathSerializer) => {\n\tlet url = _url;\n\tconst matches = _url.match(PATH_PARAM_RE);\n\tif (matches) {\n\t\tfor (const match of matches) {\n\t\t\tlet explode = false;\n\t\t\tlet name = match.substring(1, match.length - 1);\n\t\t\tlet style: ArraySeparatorStyle = \"simple\";\n\n\t\t\tif (name.endsWith(\"*\")) {\n\t\t\t\texplode = true;\n\t\t\t\tname = name.substring(0, name.length - 1);\n\t\t\t}\n\n\t\t\tif (name.startsWith(\".\")) {\n\t\t\t\tname = name.substring(1);\n\t\t\t\tstyle = \"label\";\n\t\t\t} else if (name.startsWith(\";\")) {\n\t\t\t\tname = name.substring(1);\n\t\t\t\tstyle = \"matrix\";\n\t\t\t}\n\n\t\t\tconst value = path[name];\n\n\t\t\tif (value === undefined || value === null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\turl = url.replace(\n\t\t\t\t\tmatch,\n\t\t\t\t\tserializeArrayParam({ explode, name, style, value }),\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (typeof value === \"object\") {\n\t\t\t\turl = url.replace(\n\t\t\t\t\tmatch,\n\t\t\t\t\tserializeObjectParam({\n\t\t\t\t\t\texplode,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tstyle,\n\t\t\t\t\t\tvalue: value as Record<string, unknown>,\n\t\t\t\t\t\tvalueOnly: true,\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (style === \"matrix\") {\n\t\t\t\turl = url.replace(\n\t\t\t\t\tmatch,\n\t\t\t\t\t`;${serializePrimitiveParam({\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tvalue: value as string,\n\t\t\t\t\t})}`,\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst replaceValue = encodeURIComponent(\n\t\t\t\tstyle === \"label\" ? `.${value as string}` : (value as string),\n\t\t\t);\n\t\t\turl = url.replace(match, replaceValue);\n\t\t}\n\t}\n\treturn url;\n};\n\nexport const createQuerySerializer = <T = unknown>({\n\tallowReserved,\n\tarray,\n\tobject,\n}: QuerySerializerOptions = {}) => {\n\tconst querySerializer = (queryParams: T) => {\n\t\tconst search: string[] = [];\n\t\tif (queryParams && typeof queryParams === \"object\") {\n\t\t\tfor (const name in queryParams) {\n\t\t\t\tconst value = queryParams[name];\n\n\t\t\t\tif (value === undefined || value === null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tconst serializedArray = serializeArrayParam({\n\t\t\t\t\t\tallowReserved,\n\t\t\t\t\t\texplode: true,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tstyle: \"form\",\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t...array,\n\t\t\t\t\t});\n\t\t\t\t\tif (serializedArray) search.push(serializedArray);\n\t\t\t\t} else if (typeof value === \"object\") {\n\t\t\t\t\tconst serializedObject = serializeObjectParam({\n\t\t\t\t\t\tallowReserved,\n\t\t\t\t\t\texplode: true,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tstyle: \"deepObject\",\n\t\t\t\t\t\tvalue: value as Record<string, unknown>,\n\t\t\t\t\t\t...object,\n\t\t\t\t\t});\n\t\t\t\t\tif (serializedObject) search.push(serializedObject);\n\t\t\t\t} else {\n\t\t\t\t\tconst serializedPrimitive = serializePrimitiveParam({\n\t\t\t\t\t\tallowReserved,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tvalue: value as string,\n\t\t\t\t\t});\n\t\t\t\t\tif (serializedPrimitive) search.push(serializedPrimitive);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn search.join(\"&\");\n\t};\n\treturn querySerializer;\n};\n\n/**\n * Infers parseAs value from provided Content-Type header.\n */\nexport const getParseAs = (\n\tcontentType: string | null,\n): Exclude<Config[\"parseAs\"], \"auto\"> => {\n\tif (!contentType) {\n\t\t// If no Content-Type header is provided, the best we can do is return the raw response body,\n\t\t// which is effectively the same as the 'stream' option.\n\t\treturn \"stream\";\n\t}\n\n\tconst cleanContent = contentType.split(\";\")[0]?.trim();\n\n\tif (!cleanContent) {\n\t\treturn;\n\t}\n\n\tif (\n\t\tcleanContent.startsWith(\"application/json\") ||\n\t\tcleanContent.endsWith(\"+json\")\n\t) {\n\t\treturn \"json\";\n\t}\n\n\tif (cleanContent === \"multipart/form-data\") {\n\t\treturn \"formData\";\n\t}\n\n\tif (\n\t\t[\"application/\", \"audio/\", \"image/\", \"video/\"].some((type) =>\n\t\t\tcleanContent.startsWith(type),\n\t\t)\n\t) {\n\t\treturn \"blob\";\n\t}\n\n\tif (cleanContent.startsWith(\"text/\")) {\n\t\treturn \"text\";\n\t}\n\n\treturn;\n};\n\nexport const setAuthParams = async ({\n\tsecurity,\n\t...options\n}: Pick<Required<RequestOptions>, \"security\"> &\n\tPick<RequestOptions, \"auth\" | \"query\"> & {\n\t\theaders: Headers;\n\t}) => {\n\tfor (const auth of security) {\n\t\tconst token = await getAuthToken(auth, options.auth);\n\n\t\tif (!token) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst name = auth.name ?? \"Authorization\";\n\n\t\tswitch (auth.in) {\n\t\t\tcase \"query\":\n\t\t\t\tif (!options.query) {\n\t\t\t\t\toptions.query = {};\n\t\t\t\t}\n\t\t\t\toptions.query[name] = token;\n\t\t\t\tbreak;\n\t\t\tcase \"cookie\":\n\t\t\t\toptions.headers.append(\"Cookie\", `${name}=${token}`);\n\t\t\t\tbreak;\n\t\t\tcase \"header\":\n\t\t\tdefault:\n\t\t\t\toptions.headers.set(name, token);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn;\n\t}\n};\n\nexport const buildUrl: Client[\"buildUrl\"] = (options) => {\n\tconst url = getUrl({\n\t\tbaseUrl: options.baseUrl as string,\n\t\tpath: options.path,\n\t\tquery: options.query,\n\t\tquerySerializer:\n\t\t\ttypeof options.querySerializer === \"function\"\n\t\t\t\t? options.querySerializer\n\t\t\t\t: createQuerySerializer(options.querySerializer),\n\t\turl: options.url,\n\t});\n\treturn url;\n};\n\nexport const getUrl = ({\n\tbaseUrl,\n\tpath,\n\tquery,\n\tquerySerializer,\n\turl: _url,\n}: {\n\tbaseUrl?: string;\n\tpath?: Record<string, unknown>;\n\tquery?: Record<string, unknown>;\n\tquerySerializer: QuerySerializer;\n\turl: string;\n}) => {\n\tconst pathUrl = _url.startsWith(\"/\") ? _url : `/${_url}`;\n\tlet url = (baseUrl ?? \"\") + pathUrl;\n\tif (path) {\n\t\turl = defaultPathSerializer({ path, url });\n\t}\n\tlet search = query ? querySerializer(query) : \"\";\n\tif (search.startsWith(\"?\")) {\n\t\tsearch = search.substring(1);\n\t}\n\tif (search) {\n\t\turl += `?${search}`;\n\t}\n\treturn url;\n};\n\nexport const mergeConfigs = (a: Config, b: Config): Config => {\n\tconst config = { ...a, ...b };\n\tif (config.baseUrl?.endsWith(\"/\")) {\n\t\tconfig.baseUrl = config.baseUrl.substring(0, config.baseUrl.length - 1);\n\t}\n\tconfig.headers = mergeHeaders(a.headers, b.headers);\n\treturn config;\n};\n\nexport const mergeHeaders = (\n\t...headers: Array<Required<Config>[\"headers\"] | undefined>\n): Headers => {\n\tconst mergedHeaders = new Headers();\n\tfor (const header of headers) {\n\t\tif (!header || typeof header !== \"object\") {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst iterator =\n\t\t\theader instanceof Headers ? header.entries() : Object.entries(header);\n\n\t\tfor (const [key, value] of iterator) {\n\t\t\tif (value === null) {\n\t\t\t\tmergedHeaders.delete(key);\n\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\tfor (const v of value) {\n\t\t\t\t\tmergedHeaders.append(key, v as string);\n\t\t\t\t}\n\t\t\t} else if (value !== undefined) {\n\t\t\t\t// assume object headers are meant to be JSON stringified, i.e. their\n\t\t\t\t// content value in OpenAPI specification is 'application/json'\n\t\t\t\tmergedHeaders.set(\n\t\t\t\t\tkey,\n\t\t\t\t\ttypeof value === \"object\" ? JSON.stringify(value) : (value as string),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\treturn mergedHeaders;\n};\n\ntype ErrInterceptor<Err, Res, Req, Options> = (\n\terror: Err,\n\tresponse: Res,\n\trequest: Req,\n\toptions: Options,\n) => Err | Promise<Err>;\n\ntype ReqInterceptor<Req, Options> = (\n\trequest: Req,\n\toptions: Options,\n) => Req | Promise<Req>;\n\ntype ResInterceptor<Res, Req, Options> = (\n\tresponse: Res,\n\trequest: Req,\n\toptions: Options,\n) => Res | Promise<Res>;\n\nclass Interceptors<Interceptor> {\n\t_fns: (Interceptor | null)[];\n\n\tconstructor() {\n\t\tthis._fns = [];\n\t}\n\n\tclear() {\n\t\tthis._fns = [];\n\t}\n\n\tgetInterceptorIndex(id: number | Interceptor): number {\n\t\tif (typeof id === \"number\") {\n\t\t\treturn this._fns[id] ? id : -1;\n\t\t} else {\n\t\t\treturn this._fns.indexOf(id);\n\t\t}\n\t}\n\texists(id: number | Interceptor) {\n\t\tconst index = this.getInterceptorIndex(id);\n\t\treturn !!this._fns[index];\n\t}\n\n\teject(id: number | Interceptor) {\n\t\tconst index = this.getInterceptorIndex(id);\n\t\tif (this._fns[index]) {\n\t\t\tthis._fns[index] = null;\n\t\t}\n\t}\n\n\tupdate(id: number | Interceptor, fn: Interceptor) {\n\t\tconst index = this.getInterceptorIndex(id);\n\t\tif (this._fns[index]) {\n\t\t\tthis._fns[index] = fn;\n\t\t\treturn id;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tuse(fn: Interceptor) {\n\t\tthis._fns = [...this._fns, fn];\n\t\treturn this._fns.length - 1;\n\t}\n}\n\n// `createInterceptors()` response, meant for external use as it does not\n// expose internals\nexport interface Middleware<Req, Res, Err, Options> {\n\terror: Pick<\n\t\tInterceptors<ErrInterceptor<Err, Res, Req, Options>>,\n\t\t\"eject\" | \"use\"\n\t>;\n\trequest: Pick<Interceptors<ReqInterceptor<Req, Options>>, \"eject\" | \"use\">;\n\tresponse: Pick<\n\t\tInterceptors<ResInterceptor<Res, Req, Options>>,\n\t\t\"eject\" | \"use\"\n\t>;\n}\n\n// do not add `Middleware` as return type so we can use _fns internally\nexport const createInterceptors = <Req, Res, Err, Options>() => ({\n\terror: new Interceptors<ErrInterceptor<Err, Res, Req, Options>>(),\n\trequest: new Interceptors<ReqInterceptor<Req, Options>>(),\n\tresponse: new Interceptors<ResInterceptor<Res, Req, Options>>(),\n});\n\nconst defaultQuerySerializer = createQuerySerializer({\n\tallowReserved: false,\n\tarray: {\n\t\texplode: true,\n\t\tstyle: \"form\",\n\t},\n\tobject: {\n\t\texplode: true,\n\t\tstyle: \"deepObject\",\n\t},\n});\n\nconst defaultHeaders = {\n\t\"Content-Type\": \"application/json\",\n};\n\nexport const createConfig = <T extends ClientOptions = ClientOptions>(\n\toverride: Config<Omit<ClientOptions, keyof T> & T> = {},\n): Config<Omit<ClientOptions, keyof T> & T> => ({\n\t...jsonBodySerializer,\n\theaders: defaultHeaders,\n\tparseAs: \"auto\",\n\tquerySerializer: defaultQuerySerializer,\n\t...override,\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}