{"ast":null,"code":"\"use client\";\n\nimport _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"nameResolver\", \"formatFn\", \"loadingComponent\", \"fallbackComponent\", \"queryOptions\"];\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { getChainMetadata } from \"../../../../../chains/utils.js\";\nimport { getFunctionId } from \"../../../../../utils/function-id.js\";\nimport { useChainContext } from \"./provider.js\";\n/**\n * This component fetches then shows the name of a chain.\n * It inherits all the attributes of a HTML <span> component, hence you can style it just like how you would style a normal <span>\n *\n *\n * @example\n * ### Basic usage\n * ```tsx\n * import { ChainProvider, ChainName } from \"thirdweb/react\";\n * import { ethereum } from \"thirdweb/chains\";\n *\n * <ChainProvider {...props}>\n *   <ChainName  />\n * </ChainProvider>\n * ```\n * Result:\n * ```html\n * <span>Ethereum Mainnet</span>\n * ```\n *\n * ### Custom name resolver\n * By default ChainName will call the thirdweb API to retrieve the chain name.\n * However if you have a different way to fetch the name, you can pass the function to the `nameResolver` prop.\n * Note: nameResolver should either be a string or a function (async) that returns a string.\n * ```tsx\n * async function fetchNameMethod() {\n *   // your own fetching logic\n *   return \"the chain name\";\n * }\n *\n * <ChainName nameResolver={fetchNameMethod} />\n * ```\n *\n * Alternatively you can also pass in a string directly:\n * ```tsx\n * <ChainName nameResolver=\"ETH Mainnet\" />\n * ```\n *\n *\n * ### Format the name (capitalize, truncate, etc.)\n * The ChainName component accepts a `formatFn` which takes in a string and outputs a string\n * The function is used to modify the name of the chain\n *\n * ```tsx\n * const concatStr = (str: string):string => str + \"Network\"\n *\n * <ChainProvider {...props}>\n *   <ChainName formatFn={concatStr} />\n * </ChainProvider>\n * ```\n *\n * Result:\n * ```html\n * <span>Ethereum Mainnet Network</span>\n * ```\n *\n * ### Show a loading sign when the name is being fetched\n * ```tsx\n * import { ChainProvider, ChainName } from \"thirdweb/react\";\n *\n * <ChainProvider {...props}>\n *   <ChainName loadingComponent={<Spinner />} />\n * </ChainProvider>\n * ```\n *\n * ### Fallback to something when the name fails to resolve\n * ```tsx\n * <ChainProvider {...props}>\n *   <ChainName fallbackComponent={\"Failed to load\"} />\n * </ChainProvider>\n * ```\n *\n * ### Custom query options for useQuery\n * This component uses `@tanstack-query`'s useQuery internally.\n * You can use the `queryOptions` prop for more fine-grained control\n * ```tsx\n * <ChainName\n *   queryOptions={{\n *     enabled: isEnabled,\n *     retry: 4,\n *   }}\n * />\n * ```\n *\n * @component\n * @chain\n * @beta\n */\nexport function ChainName(_ref) {\n  let {\n      nameResolver,\n      formatFn,\n      loadingComponent,\n      fallbackComponent,\n      queryOptions\n    } = _ref,\n    restProps = _objectWithoutProperties(_ref, _excluded);\n  const {\n    chain\n  } = useChainContext();\n  const nameQuery = useQuery(_objectSpread({\n    queryFn: async () => fetchChainName({\n      chain,\n      nameResolver\n    }),\n    queryKey: getQueryKeys({\n      chainId: chain.id,\n      nameResolver\n    })\n  }, queryOptions));\n  if (nameQuery.isLoading) {\n    return loadingComponent || null;\n  }\n  if (!nameQuery.data) {\n    return fallbackComponent || null;\n  }\n  const displayValue = formatFn ? formatFn(nameQuery.data) : nameQuery.data;\n  return _jsx(\"span\", _objectSpread(_objectSpread({}, restProps), {}, {\n    children: displayValue\n  }));\n}\n/**\n * @internal Exported for tests only\n */\nexport async function fetchChainName(props) {\n  const {\n    nameResolver,\n    chain\n  } = props;\n  if (typeof nameResolver === \"string\") {\n    return nameResolver;\n  }\n  if (typeof nameResolver === \"function\") {\n    return nameResolver();\n  }\n  if (chain.name) {\n    return chain.name;\n  }\n  return getChainMetadata(chain).then(data => data.name);\n}\n/**\n * @internal Exported for tests\n */\nexport function getQueryKeys(props) {\n  if (typeof props.nameResolver === \"function\") {\n    return [\"_internal_chain_name_\", props.chainId, {\n      resolver: getFunctionId(props.nameResolver)\n    }];\n  }\n  return [\"_internal_chain_name_\", props.chainId];\n}","map":{"version":3,"names":["_objectSpread","_objectWithoutProperties","_excluded","useQuery","getChainMetadata","getFunctionId","useChainContext","ChainName","_ref","nameResolver","formatFn","loadingComponent","fallbackComponent","queryOptions","restProps","chain","nameQuery","queryFn","fetchChainName","queryKey","getQueryKeys","chainId","id","isLoading","data","displayValue","_jsx","children","props","name","then","resolver"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/react/web/ui/prebuilt/Chain/name.tsx"],"sourcesContent":["\"use client\";\n\nimport { type UseQueryOptions, useQuery } from \"@tanstack/react-query\";\nimport type React from \"react\";\nimport type { JSX } from \"react\";\nimport type { Chain } from \"../../../../../chains/types.js\";\nimport { getChainMetadata } from \"../../../../../chains/utils.js\";\nimport { getFunctionId } from \"../../../../../utils/function-id.js\";\nimport { useChainContext } from \"./provider.js\";\n\n/**\n * Props for the ChainName component\n * @component\n * @chain\n */\nexport interface ChainNameProps\n  extends Omit<React.HTMLAttributes<HTMLSpanElement>, \"children\"> {\n  /**\n   * This prop can be a string or a (async) function that resolves to a string, representing the name of the chain\n   * This is particularly useful if you already have a way to fetch the chain name.\n   */\n  nameResolver?: string | (() => string) | (() => Promise<string>);\n  /**\n   * A function to format the name's display value\n   * Particularly useful to avoid overflowing-UI issues\n   *\n   * ```tsx\n   * <ChainName formatFn={(str: string) => doSomething()} />\n   * ```\n   */\n  formatFn?: (str: string) => string;\n  /**\n   * This component will be shown while the name of the chain is being fetched\n   * If not passed, the component will return `null`.\n   *\n   * You can/should pass a loading sign or spinner to this prop.\n   * @example\n   * ```tsx\n   * <ChainName loadingComponent={<Spinner />} />\n   * ```\n   */\n  loadingComponent?: JSX.Element;\n  /**\n   * This component will be shown if the name fails to be retreived\n   * If not passed, the component will return `null`.\n   *\n   * You can/should pass a descriptive text/component to this prop, indicating that the\n   * name was not fetched successfully\n   * @example\n   * ```tsx\n   * <ChainName fallbackComponent={<span>Failed to load</span>}\n   * />\n   * ```\n   */\n  fallbackComponent?: JSX.Element;\n  /**\n   * Optional `useQuery` params\n   */\n  queryOptions?: Omit<UseQueryOptions<string>, \"queryFn\" | \"queryKey\">;\n}\n\n/**\n * This component fetches then shows the name of a chain.\n * It inherits all the attributes of a HTML <span> component, hence you can style it just like how you would style a normal <span>\n *\n *\n * @example\n * ### Basic usage\n * ```tsx\n * import { ChainProvider, ChainName } from \"thirdweb/react\";\n * import { ethereum } from \"thirdweb/chains\";\n *\n * <ChainProvider {...props}>\n *   <ChainName  />\n * </ChainProvider>\n * ```\n * Result:\n * ```html\n * <span>Ethereum Mainnet</span>\n * ```\n *\n * ### Custom name resolver\n * By default ChainName will call the thirdweb API to retrieve the chain name.\n * However if you have a different way to fetch the name, you can pass the function to the `nameResolver` prop.\n * Note: nameResolver should either be a string or a function (async) that returns a string.\n * ```tsx\n * async function fetchNameMethod() {\n *   // your own fetching logic\n *   return \"the chain name\";\n * }\n *\n * <ChainName nameResolver={fetchNameMethod} />\n * ```\n *\n * Alternatively you can also pass in a string directly:\n * ```tsx\n * <ChainName nameResolver=\"ETH Mainnet\" />\n * ```\n *\n *\n * ### Format the name (capitalize, truncate, etc.)\n * The ChainName component accepts a `formatFn` which takes in a string and outputs a string\n * The function is used to modify the name of the chain\n *\n * ```tsx\n * const concatStr = (str: string):string => str + \"Network\"\n *\n * <ChainProvider {...props}>\n *   <ChainName formatFn={concatStr} />\n * </ChainProvider>\n * ```\n *\n * Result:\n * ```html\n * <span>Ethereum Mainnet Network</span>\n * ```\n *\n * ### Show a loading sign when the name is being fetched\n * ```tsx\n * import { ChainProvider, ChainName } from \"thirdweb/react\";\n *\n * <ChainProvider {...props}>\n *   <ChainName loadingComponent={<Spinner />} />\n * </ChainProvider>\n * ```\n *\n * ### Fallback to something when the name fails to resolve\n * ```tsx\n * <ChainProvider {...props}>\n *   <ChainName fallbackComponent={\"Failed to load\"} />\n * </ChainProvider>\n * ```\n *\n * ### Custom query options for useQuery\n * This component uses `@tanstack-query`'s useQuery internally.\n * You can use the `queryOptions` prop for more fine-grained control\n * ```tsx\n * <ChainName\n *   queryOptions={{\n *     enabled: isEnabled,\n *     retry: 4,\n *   }}\n * />\n * ```\n *\n * @component\n * @chain\n * @beta\n */\nexport function ChainName({\n  nameResolver,\n  formatFn,\n  loadingComponent,\n  fallbackComponent,\n  queryOptions,\n  ...restProps\n}: ChainNameProps) {\n  const { chain } = useChainContext();\n  const nameQuery = useQuery({\n    queryFn: async () => fetchChainName({ chain, nameResolver }),\n    queryKey: getQueryKeys({ chainId: chain.id, nameResolver }),\n    ...queryOptions,\n  });\n\n  if (nameQuery.isLoading) {\n    return loadingComponent || null;\n  }\n\n  if (!nameQuery.data) {\n    return fallbackComponent || null;\n  }\n\n  const displayValue = formatFn ? formatFn(nameQuery.data) : nameQuery.data;\n\n  return <span {...restProps}>{displayValue}</span>;\n}\n\n/**\n * @internal Exported for tests only\n */\nexport async function fetchChainName(props: {\n  chain: Chain;\n  nameResolver?: string | (() => string) | (() => Promise<string>);\n}) {\n  const { nameResolver, chain } = props;\n  if (typeof nameResolver === \"string\") {\n    return nameResolver;\n  }\n  if (typeof nameResolver === \"function\") {\n    return nameResolver();\n  }\n  if (chain.name) {\n    return chain.name;\n  }\n  return getChainMetadata(chain).then((data) => data.name);\n}\n\n/**\n * @internal Exported for tests\n */\nexport function getQueryKeys(props: {\n  chainId: number;\n  nameResolver?: string | (() => string) | (() => Promise<string>);\n}) {\n  if (typeof props.nameResolver === \"function\") {\n    return [\n      \"_internal_chain_name_\",\n      props.chainId,\n      { resolver: getFunctionId(props.nameResolver) },\n    ] as const;\n  }\n  return [\"_internal_chain_name_\", props.chainId] as const;\n}\n"],"mappings":"AAAA,YAAY;;AAAC,OAAAA,aAAA;AAAA,OAAAC,wBAAA;AAAA,MAAAC,SAAA;;AAEb,SAA+BC,QAAQ,QAAQ,uBAAuB;AAItE,SAASC,gBAAgB,QAAQ,gCAAgC;AACjE,SAASC,aAAa,QAAQ,qCAAqC;AACnE,SAASC,eAAe,QAAQ,eAAe;AAqD/C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwFA,OAAM,SAAUC,SAASA,CAAAC,IAAA,EAOR;EAAA,IAPS;MACxBC,YAAY;MACZC,QAAQ;MACRC,gBAAgB;MAChBC,iBAAiB;MACjBC;IACY,CACG,GAAAL,IAAA;IADZM,SAAS,GAAAb,wBAAA,CAAAO,IAAA,EAAAN,SAAA;EAEZ,MAAM;IAAEa;EAAK,CAAE,GAAGT,eAAe,EAAE;EACnC,MAAMU,SAAS,GAAGb,QAAQ,CAAAH,aAAA;IACxBiB,OAAO,EAAE,MAAAA,CAAA,KAAYC,cAAc,CAAC;MAAEH,KAAK;MAAEN;IAAY,CAAE,CAAC;IAC5DU,QAAQ,EAAEC,YAAY,CAAC;MAAEC,OAAO,EAAEN,KAAK,CAACO,EAAE;MAAEb;IAAY,CAAE;EAAC,GACxDI,YAAY,CAChB,CAAC;EAEF,IAAIG,SAAS,CAACO,SAAS,EAAE;IACvB,OAAOZ,gBAAgB,IAAI,IAAI;EACjC;EAEA,IAAI,CAACK,SAAS,CAACQ,IAAI,EAAE;IACnB,OAAOZ,iBAAiB,IAAI,IAAI;EAClC;EAEA,MAAMa,YAAY,GAAGf,QAAQ,GAAGA,QAAQ,CAACM,SAAS,CAACQ,IAAI,CAAC,GAAGR,SAAS,CAACQ,IAAI;EAEzE,OAAOE,IAAA,SAAA1B,aAAA,CAAAA,aAAA,KAAUc,SAAS;IAAAa,QAAA,EAAGF;EAAY,GAAQ;AACnD;AAEA;;;AAGA,OAAO,eAAeP,cAAcA,CAACU,KAGpC;EACC,MAAM;IAAEnB,YAAY;IAAEM;EAAK,CAAE,GAAGa,KAAK;EACrC,IAAI,OAAOnB,YAAY,KAAK,QAAQ,EAAE;IACpC,OAAOA,YAAY;EACrB;EACA,IAAI,OAAOA,YAAY,KAAK,UAAU,EAAE;IACtC,OAAOA,YAAY,EAAE;EACvB;EACA,IAAIM,KAAK,CAACc,IAAI,EAAE;IACd,OAAOd,KAAK,CAACc,IAAI;EACnB;EACA,OAAOzB,gBAAgB,CAACW,KAAK,CAAC,CAACe,IAAI,CAAEN,IAAI,IAAKA,IAAI,CAACK,IAAI,CAAC;AAC1D;AAEA;;;AAGA,OAAM,SAAUT,YAAYA,CAACQ,KAG5B;EACC,IAAI,OAAOA,KAAK,CAACnB,YAAY,KAAK,UAAU,EAAE;IAC5C,OAAO,CACL,uBAAuB,EACvBmB,KAAK,CAACP,OAAO,EACb;MAAEU,QAAQ,EAAE1B,aAAa,CAACuB,KAAK,CAACnB,YAAY;IAAC,CAAE,CACvC;EACZ;EACA,OAAO,CAAC,uBAAuB,EAAEmB,KAAK,CAACP,OAAO,CAAU;AAC1D","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}