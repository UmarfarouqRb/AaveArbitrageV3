{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { sendCalls } from \"../../../../wallets/eip5792/send-calls.js\";\nimport { waitForCallsReceipt } from \"../../../../wallets/eip5792/wait-for-calls-receipt.js\";\nimport { invalidateWalletBalance } from \"../../providers/invalidateWalletBalance.js\";\nimport { useActiveWallet } from \"./useActiveWallet.js\";\n/**\n * A hook to send [EIP-5792](https://eips.ethereum.org/EIPS/eip-5792) calls to a wallet.\n * This hook works with all Thirdweb wallets (in-app and smart) and certain injected wallets that already support EIP-5792.\n * Transactions will be bundled and sponsored when those capabilities are supported, otherwise they will be sent as individual transactions.\n *\n * When calls are sent, all contracts that are interacted with will have their corresponding reads revalidated via React Query.\n *\n *  This hook is dependent on the wallet's support for EIP-5792 and could fail.\n *  The mutatuon function will use your currently connected wallet by default, but you can pass it a specific wallet to use if you'd like.\n *\n * @returns A React Query mutatuon object to interact with {@link sendCalls}\n * @throws an error if the wallet does not support EIP-5792.\n * @returns The ID of the bundle of the calls.\n *\n * @beta\n * @example\n * ```tsx\n * import { useSendCalls } from \"thirdweb/react\";\n *\n * const sendTx1 = approve({\n      contract: USDT_CONTRACT,\n      amount: 100,\n      spender: \"0x33d9B8BEfE81027E2C859EDc84F5636cbb202Ed6\",\n    });\n * const sendTx2 = approve({\n      contract: USDT_CONTRACT,\n      amount: 100,\n      spender: \"0x2a4f24F935Eb178e3e7BA9B53A5Ee6d8407C0709\",\n    });\n * const { mutate: sendCalls, data: id } = useSendCalls();\n * await sendCalls({\n *   wallet,\n *   client,\n *   calls: [sendTx1, sendTx2],\n * });\n * ```\n * Await the bundle's full confirmation:\n * ```tsx\n * const { mutate: sendCalls, data } = useSendCalls();\n * const { data: result, isLoading } = useWaitForCallsReceipt(data);\n * await sendCalls({\n *   wallet,\n *   client,\n *   calls: [sendTx1, sendTx2],\n * });\n *\n * console.log(\"Receipts:\", result.receipts);\n * ```\n * Sponsor transactions with a paymaster:\n * ```ts\n * const { mutate: sendCalls, data: id } = useSendCalls();\n * await sendCalls({\n *   client,\n *   calls: [sendTx1, sendTx2],\n *   capabilities: {\n *     paymasterService: {\n *       url: `https://${CHAIN.id}.bundler.thirdweb.com/${client.clientId}`\n *     }\n *   }\n * });\n * ```\n *  We recommend proxying any paymaster calls via an API route you setup and control.\n * @extension EIP5792\n */\nexport function useSendCalls() {\n  const activeWallet = useActiveWallet();\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationFn: async options => {\n      const {\n        wallet = activeWallet\n      } = options;\n      const chain = wallet === null || wallet === void 0 ? void 0 : wallet.getChain();\n      if (!wallet || !chain) {\n        throw new Error(\"Failed to send transactions, no connected wallet found.\");\n      }\n      return sendCalls(_objectSpread(_objectSpread({}, options), {}, {\n        wallet\n      }));\n    },\n    onSettled: async (result, _error, variables) => {\n      var _call$__contract;\n      // Attempt to invalidate any reads related to the sent transactions\n      if (!result) {\n        return;\n      }\n      const call = variables.calls[0];\n      if (!call) {\n        return;\n      }\n      const chain = ((_call$__contract = call.__contract) === null || _call$__contract === void 0 ? void 0 : _call$__contract.chain) || call.chain;\n      waitForCallsReceipt(result).then(() => {\n        for (const call of variables.calls) {\n          var _call$__contract2, _call$__contract3;\n          queryClient.invalidateQueries({\n            queryKey: [\"readContract\", ((_call$__contract2 = call.__contract) === null || _call$__contract2 === void 0 ? void 0 : _call$__contract2.chain.id) || chain.id, ((_call$__contract3 = call.__contract) === null || _call$__contract3 === void 0 ? void 0 : _call$__contract3.address) || call.to]\n          });\n        }\n        invalidateWalletBalance(queryClient, chain.id);\n      }).catch(error => {\n        console.error(\"Failed to confirm sent bundle and invalidate queries\", result, error);\n        return undefined;\n      });\n    }\n  });\n}","map":{"version":3,"names":["useMutation","useQueryClient","sendCalls","waitForCallsReceipt","invalidateWalletBalance","useActiveWallet","useSendCalls","activeWallet","queryClient","mutationFn","options","wallet","chain","getChain","Error","_objectSpread","onSettled","result","_error","variables","_call$__contract","call","calls","__contract","then","_call$__contract2","_call$__contract3","invalidateQueries","queryKey","id","address","to","catch","error","console","undefined"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/react/core/hooks/wallets/useSendCalls.ts"],"sourcesContent":["import {\n  type UseMutationResult,\n  useMutation,\n  useQueryClient,\n} from \"@tanstack/react-query\";\nimport {\n  type SendCallsOptions,\n  type SendCallsResult,\n  sendCalls,\n} from \"../../../../wallets/eip5792/send-calls.js\";\nimport { waitForCallsReceipt } from \"../../../../wallets/eip5792/wait-for-calls-receipt.js\";\nimport type { Wallet } from \"../../../../wallets/interfaces/wallet.js\";\nimport { invalidateWalletBalance } from \"../../providers/invalidateWalletBalance.js\";\nimport { useActiveWallet } from \"./useActiveWallet.js\";\n\n/**\n * A hook to send [EIP-5792](https://eips.ethereum.org/EIPS/eip-5792) calls to a wallet.\n * This hook works with all Thirdweb wallets (in-app and smart) and certain injected wallets that already support EIP-5792.\n * Transactions will be bundled and sponsored when those capabilities are supported, otherwise they will be sent as individual transactions.\n *\n * When calls are sent, all contracts that are interacted with will have their corresponding reads revalidated via React Query.\n *\n *  This hook is dependent on the wallet's support for EIP-5792 and could fail.\n *  The mutatuon function will use your currently connected wallet by default, but you can pass it a specific wallet to use if you'd like.\n *\n * @returns A React Query mutatuon object to interact with {@link sendCalls}\n * @throws an error if the wallet does not support EIP-5792.\n * @returns The ID of the bundle of the calls.\n *\n * @beta\n * @example\n * ```tsx\n * import { useSendCalls } from \"thirdweb/react\";\n *\n * const sendTx1 = approve({\n      contract: USDT_CONTRACT,\n      amount: 100,\n      spender: \"0x33d9B8BEfE81027E2C859EDc84F5636cbb202Ed6\",\n    });\n * const sendTx2 = approve({\n      contract: USDT_CONTRACT,\n      amount: 100,\n      spender: \"0x2a4f24F935Eb178e3e7BA9B53A5Ee6d8407C0709\",\n    });\n * const { mutate: sendCalls, data: id } = useSendCalls();\n * await sendCalls({\n *   wallet,\n *   client,\n *   calls: [sendTx1, sendTx2],\n * });\n * ```\n * Await the bundle's full confirmation:\n * ```tsx\n * const { mutate: sendCalls, data } = useSendCalls();\n * const { data: result, isLoading } = useWaitForCallsReceipt(data); \n * await sendCalls({\n *   wallet,\n *   client,\n *   calls: [sendTx1, sendTx2],\n * });\n * \n * console.log(\"Receipts:\", result.receipts);\n * ```\n * Sponsor transactions with a paymaster:\n * ```ts\n * const { mutate: sendCalls, data: id } = useSendCalls();\n * await sendCalls({\n *   client,\n *   calls: [sendTx1, sendTx2],\n *   capabilities: {\n *     paymasterService: {\n *       url: `https://${CHAIN.id}.bundler.thirdweb.com/${client.clientId}`\n *     }\n *   }\n * });\n * ```\n *  We recommend proxying any paymaster calls via an API route you setup and control.\n * @extension EIP5792\n */\nexport function useSendCalls(): UseMutationResult<\n  SendCallsResult,\n  Error,\n  Omit<SendCallsOptions, \"chain\" | \"wallet\"> & { wallet?: Wallet } // Optional wallet override\n> {\n  const activeWallet = useActiveWallet();\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: async (options) => {\n      const { wallet = activeWallet } = options;\n      const chain = wallet?.getChain();\n      if (!wallet || !chain) {\n        throw new Error(\n          \"Failed to send transactions, no connected wallet found.\",\n        );\n      }\n\n      return sendCalls({ ...options, wallet });\n    },\n    onSettled: async (result, _error, variables) => {\n      // Attempt to invalidate any reads related to the sent transactions\n      if (!result) {\n        return;\n      }\n      const call = variables.calls[0];\n      if (!call) {\n        return;\n      }\n      const chain = call.__contract?.chain || call.chain;\n\n      waitForCallsReceipt(result)\n        .then(() => {\n          for (const call of variables.calls) {\n            queryClient.invalidateQueries({\n              queryKey: [\n                \"readContract\",\n                call.__contract?.chain.id || chain.id,\n                call.__contract?.address || call.to,\n              ],\n            });\n          }\n          invalidateWalletBalance(queryClient, chain.id);\n        })\n        .catch((error) => {\n          console.error(\n            \"Failed to confirm sent bundle and invalidate queries\",\n            result,\n            error,\n          );\n          return undefined;\n        });\n    },\n  });\n}\n"],"mappings":";AAAA,SAEEA,WAAW,EACXC,cAAc,QACT,uBAAuB;AAC9B,SAGEC,SAAS,QACJ,2CAA2C;AAClD,SAASC,mBAAmB,QAAQ,uDAAuD;AAE3F,SAASC,uBAAuB,QAAQ,4CAA4C;AACpF,SAASC,eAAe,QAAQ,sBAAsB;AAEtD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgEA,OAAM,SAAUC,YAAYA,CAAA;EAK1B,MAAMC,YAAY,GAAGF,eAAe,EAAE;EACtC,MAAMG,WAAW,GAAGP,cAAc,EAAE;EAEpC,OAAOD,WAAW,CAAC;IACjBS,UAAU,EAAE,MAAOC,OAAO,IAAI;MAC5B,MAAM;QAAEC,MAAM,GAAGJ;MAAY,CAAE,GAAGG,OAAO;MACzC,MAAME,KAAK,GAAGD,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEE,QAAQ,EAAE;MAChC,IAAI,CAACF,MAAM,IAAI,CAACC,KAAK,EAAE;QACrB,MAAM,IAAIE,KAAK,CACb,yDAAyD,CAC1D;MACH;MAEA,OAAOZ,SAAS,CAAAa,aAAA,CAAAA,aAAA,KAAML,OAAO;QAAEC;MAAM,EAAE,CAAC;IAC1C,CAAC;IACDK,SAAS,EAAE,MAAAA,CAAOC,MAAM,EAAEC,MAAM,EAAEC,SAAS,KAAI;MAAA,IAAAC,gBAAA;MAC7C;MACA,IAAI,CAACH,MAAM,EAAE;QACX;MACF;MACA,MAAMI,IAAI,GAAGF,SAAS,CAACG,KAAK,CAAC,CAAC,CAAC;MAC/B,IAAI,CAACD,IAAI,EAAE;QACT;MACF;MACA,MAAMT,KAAK,GAAG,EAAAQ,gBAAA,GAAAC,IAAI,CAACE,UAAU,cAAAH,gBAAA,uBAAfA,gBAAA,CAAiBR,KAAK,KAAIS,IAAI,CAACT,KAAK;MAElDT,mBAAmB,CAACc,MAAM,CAAC,CACxBO,IAAI,CAAC,MAAK;QACT,KAAK,MAAMH,IAAI,IAAIF,SAAS,CAACG,KAAK,EAAE;UAAA,IAAAG,iBAAA,EAAAC,iBAAA;UAClClB,WAAW,CAACmB,iBAAiB,CAAC;YAC5BC,QAAQ,EAAE,CACR,cAAc,EACd,EAAAH,iBAAA,GAAAJ,IAAI,CAACE,UAAU,cAAAE,iBAAA,uBAAfA,iBAAA,CAAiBb,KAAK,CAACiB,EAAE,KAAIjB,KAAK,CAACiB,EAAE,EACrC,EAAAH,iBAAA,GAAAL,IAAI,CAACE,UAAU,cAAAG,iBAAA,uBAAfA,iBAAA,CAAiBI,OAAO,KAAIT,IAAI,CAACU,EAAE;WAEtC,CAAC;QACJ;QACA3B,uBAAuB,CAACI,WAAW,EAAEI,KAAK,CAACiB,EAAE,CAAC;MAChD,CAAC,CAAC,CACDG,KAAK,CAAEC,KAAK,IAAI;QACfC,OAAO,CAACD,KAAK,CACX,sDAAsD,EACtDhB,MAAM,EACNgB,KAAK,CACN;QACD,OAAOE,SAAS;MAClB,CAAC,CAAC;IACN;GACD,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}