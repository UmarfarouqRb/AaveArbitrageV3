{"ast":null,"code":"import { readContract } from '../../actions/public/readContract.js';\nimport { isAddressEqual } from '../../utils/index.js';\nimport { l2SharedBridgeAbi } from '../constants/abis.js';\nimport { ethAddressInContracts, l2BaseTokenAddress, legacyEthAddress } from '../constants/address.js';\nimport { getBaseTokenL1Address } from './getBaseTokenL1Address.js';\nimport { getDefaultBridgeAddresses } from './getDefaultBridgeAddresses.js';\n/**\n * Returns the L2 token address equivalent for a L1 token address as they are not equal.\n * ETH address is set to zero address.\n *\n * @remarks Only works for tokens bridged on default ZKsync Era bridges.\n *\n * @param client - Client to use\n * @param parameters - {@link GetL2TokenAddressParameters}\n * @returns The L2 token address equivalent for a L1 token address.\n *\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { zksync } from 'viem/chains'\n * import { publicActionsL2 } from 'viem/zksync'\n *\n * const client = createPublicClient({\n *   chain: zksync,\n *   transport: http(),\n * }).extend(publicActionsL2())\n *\n * const address = await getL2TokenAddress(client, {token: '0x...'});\n */\nexport async function getL2TokenAddress(client, parameters) {\n  let {\n    token,\n    bridgeAddress\n  } = parameters;\n  if (isAddressEqual(token, legacyEthAddress)) token = ethAddressInContracts;\n  const baseToken = await getBaseTokenL1Address(client);\n  if (isAddressEqual(token, baseToken)) return l2BaseTokenAddress;\n  bridgeAddress !== null && bridgeAddress !== void 0 ? bridgeAddress : bridgeAddress = (await getDefaultBridgeAddresses(client)).sharedL2;\n  return await readContract(client, {\n    address: bridgeAddress,\n    abi: l2SharedBridgeAbi,\n    functionName: 'l2TokenAddress',\n    args: [token]\n  });\n}","map":{"version":3,"names":["readContract","isAddressEqual","l2SharedBridgeAbi","ethAddressInContracts","l2BaseTokenAddress","legacyEthAddress","getBaseTokenL1Address","getDefaultBridgeAddresses","getL2TokenAddress","client","parameters","token","bridgeAddress","baseToken","sharedL2","address","abi","functionName","args"],"sources":["/home/user/Arbitrage/frontend/node_modules/viem/zksync/actions/getL2TokenAddress.ts"],"sourcesContent":["import type { Address } from '../../accounts/index.js'\nimport { readContract } from '../../actions/public/readContract.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport { isAddressEqual } from '../../utils/index.js'\nimport { l2SharedBridgeAbi } from '../constants/abis.js'\nimport {\n  ethAddressInContracts,\n  l2BaseTokenAddress,\n  legacyEthAddress,\n} from '../constants/address.js'\nimport { getBaseTokenL1Address } from './getBaseTokenL1Address.js'\nimport { getDefaultBridgeAddresses } from './getDefaultBridgeAddresses.js'\n\nexport type GetL2TokenAddressParameters = {\n  /** The address of the token on L1. */\n  token: Address\n  /** The address of custom bridge, which will be used to get l2 token address. */\n  bridgeAddress?: Address | undefined\n}\n\nexport type GetL2TokenAddressReturnType = Address\n\n/**\n * Returns the L2 token address equivalent for a L1 token address as they are not equal.\n * ETH address is set to zero address.\n *\n * @remarks Only works for tokens bridged on default ZKsync Era bridges.\n *\n * @param client - Client to use\n * @param parameters - {@link GetL2TokenAddressParameters}\n * @returns The L2 token address equivalent for a L1 token address.\n *\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { zksync } from 'viem/chains'\n * import { publicActionsL2 } from 'viem/zksync'\n *\n * const client = createPublicClient({\n *   chain: zksync,\n *   transport: http(),\n * }).extend(publicActionsL2())\n *\n * const address = await getL2TokenAddress(client, {token: '0x...'});\n */\nexport async function getL2TokenAddress<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: GetL2TokenAddressParameters,\n): Promise<Address> {\n  let { token, bridgeAddress } = parameters\n  if (isAddressEqual(token, legacyEthAddress)) token = ethAddressInContracts\n\n  const baseToken = await getBaseTokenL1Address(client)\n  if (isAddressEqual(token, baseToken)) return l2BaseTokenAddress\n\n  bridgeAddress ??= (await getDefaultBridgeAddresses(client)).sharedL2\n\n  return await readContract(client, {\n    address: bridgeAddress,\n    abi: l2SharedBridgeAbi,\n    functionName: 'l2TokenAddress',\n    args: [token],\n  })\n}\n"],"mappings":"AACA,SAASA,YAAY,QAAQ,sCAAsC;AAKnE,SAASC,cAAc,QAAQ,sBAAsB;AACrD,SAASC,iBAAiB,QAAQ,sBAAsB;AACxD,SACEC,qBAAqB,EACrBC,kBAAkB,EAClBC,gBAAgB,QACX,yBAAyB;AAChC,SAASC,qBAAqB,QAAQ,4BAA4B;AAClE,SAASC,yBAAyB,QAAQ,gCAAgC;AAW1E;;;;;;;;;;;;;;;;;;;;;;;AAuBA,OAAO,eAAeC,iBAAiBA,CAIrCC,MAAyC,EACzCC,UAAuC;EAEvC,IAAI;IAAEC,KAAK;IAAEC;EAAa,CAAE,GAAGF,UAAU;EACzC,IAAIT,cAAc,CAACU,KAAK,EAAEN,gBAAgB,CAAC,EAAEM,KAAK,GAAGR,qBAAqB;EAE1E,MAAMU,SAAS,GAAG,MAAMP,qBAAqB,CAACG,MAAM,CAAC;EACrD,IAAIR,cAAc,CAACU,KAAK,EAAEE,SAAS,CAAC,EAAE,OAAOT,kBAAkB;EAE/DQ,aAAa,aAAbA,aAAa,cAAbA,aAAa,GAAbA,aAAa,GAAK,CAAC,MAAML,yBAAyB,CAACE,MAAM,CAAC,EAAEK,QAAQ;EAEpE,OAAO,MAAMd,YAAY,CAACS,MAAM,EAAE;IAChCM,OAAO,EAAEH,aAAa;IACtBI,GAAG,EAAEd,iBAAiB;IACtBe,YAAY,EAAE,gBAAgB;IAC9BC,IAAI,EAAE,CAACP,KAAK;GACb,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}