{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { eth_getTransactionReceipt } from \"../../../../rpc/actions/eth_getTransactionReceipt.js\";\nimport { getRpcClient } from \"../../../../rpc/rpc.js\";\nimport { sendAndConfirmTransaction } from \"../../../../transaction/actions/send-and-confirm-transaction.js\";\nimport { sendBatchTransaction } from \"../../../../transaction/actions/send-batch-transaction.js\";\nimport { LruMap } from \"../../../../utils/caching/lru.js\";\nimport { randomBytesHex } from \"../../../../utils/random.js\";\nconst bundlesToTransactions = new LruMap(1000);\n/**\n * @internal\n */\nexport async function inAppWalletSendCalls(args) {\n  const {\n    account,\n    calls\n  } = args;\n  const transactions = calls.map(call => _objectSpread(_objectSpread({}, call), {}, {\n    chain: args.chain\n  }));\n  const hashes = [];\n  const id = randomBytesHex(65);\n  bundlesToTransactions.set(id, hashes);\n  if (account.sendBatchTransaction) {\n    const receipt = await sendBatchTransaction({\n      account,\n      transactions\n    });\n    hashes.push(receipt.transactionHash);\n    bundlesToTransactions.set(id, hashes);\n  } else {\n    for (const tx of transactions) {\n      const receipt = await sendAndConfirmTransaction({\n        account,\n        transaction: tx\n      });\n      hashes.push(receipt.transactionHash);\n      bundlesToTransactions.set(id, hashes);\n    }\n  }\n  return id;\n}\n/**\n * @internal\n */\nexport async function inAppWalletGetCallsStatus(args) {\n  const {\n    chain,\n    client,\n    id\n  } = args;\n  const bundle = bundlesToTransactions.get(id);\n  if (!bundle) {\n    throw new Error(\"Failed to get calls status, unknown bundle id\");\n  }\n  const request = getRpcClient({\n    chain,\n    client\n  });\n  let status = \"success\";\n  const receipts = await Promise.all(bundle.map(hash => eth_getTransactionReceipt(request, {\n    hash\n  }).then(receipt => ({\n    blockHash: receipt.blockHash,\n    blockNumber: receipt.blockNumber,\n    gasUsed: receipt.gasUsed,\n    logs: receipt.logs.map(l => ({\n      address: l.address,\n      data: l.data,\n      topics: l.topics\n    })),\n    status: receipt.status,\n    transactionHash: receipt.transactionHash\n  })).catch(() => {\n    status = \"pending\";\n    return null; // Return null if there's an error to filter out later\n  })));\n  return {\n    atomic: false,\n    chainId: chain.id,\n    id,\n    receipts: receipts.filter(r => r !== null),\n    status,\n    statusCode: 200,\n    version: \"2.0.0\"\n  };\n}","map":{"version":3,"names":["eth_getTransactionReceipt","getRpcClient","sendAndConfirmTransaction","sendBatchTransaction","LruMap","randomBytesHex","bundlesToTransactions","inAppWalletSendCalls","args","account","calls","transactions","map","call","_objectSpread","chain","hashes","id","set","receipt","push","transactionHash","tx","transaction","inAppWalletGetCallsStatus","client","bundle","get","Error","request","status","receipts","Promise","all","hash","then","blockHash","blockNumber","gasUsed","logs","l","address","data","topics","catch","atomic","chainId","filter","r","statusCode","version"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/wallets/in-app/core/eip5792/in-app-wallet-calls.ts"],"sourcesContent":["import type { Chain } from \"../../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { eth_getTransactionReceipt } from \"../../../../rpc/actions/eth_getTransactionReceipt.js\";\nimport { getRpcClient } from \"../../../../rpc/rpc.js\";\nimport { sendAndConfirmTransaction } from \"../../../../transaction/actions/send-and-confirm-transaction.js\";\nimport { sendBatchTransaction } from \"../../../../transaction/actions/send-batch-transaction.js\";\nimport type { SendTransactionOptions } from \"../../../../transaction/actions/send-transaction.js\";\nimport { LruMap } from \"../../../../utils/caching/lru.js\";\nimport type { Hex } from \"../../../../utils/encoding/hex.js\";\nimport { randomBytesHex } from \"../../../../utils/random.js\";\nimport type { PreparedSendCall } from \"../../../eip5792/send-calls.js\";\nimport type {\n  GetCallsStatusResponse,\n  WalletCallReceipt,\n} from \"../../../eip5792/types.js\";\nimport type { Account } from \"../../../interfaces/wallet.js\";\n\nconst bundlesToTransactions = new LruMap<Hex[]>(1000);\n\n/**\n * @internal\n */\nexport async function inAppWalletSendCalls(args: {\n  account: Account;\n  calls: PreparedSendCall[];\n  chain: Chain;\n}): Promise<string> {\n  const { account, calls } = args;\n\n  const transactions: SendTransactionOptions[\"transaction\"][] = calls.map(\n    (call) => ({\n      ...call,\n      chain: args.chain,\n    }),\n  );\n\n  const hashes: Hex[] = [];\n  const id = randomBytesHex(65);\n  bundlesToTransactions.set(id, hashes);\n  if (account.sendBatchTransaction) {\n    const receipt = await sendBatchTransaction({\n      account,\n      transactions,\n    });\n    hashes.push(receipt.transactionHash);\n    bundlesToTransactions.set(id, hashes);\n  } else {\n    for (const tx of transactions) {\n      const receipt = await sendAndConfirmTransaction({\n        account,\n        transaction: tx,\n      });\n      hashes.push(receipt.transactionHash);\n      bundlesToTransactions.set(id, hashes);\n    }\n  }\n\n  return id;\n}\n\n/**\n * @internal\n */\nexport async function inAppWalletGetCallsStatus(args: {\n  chain: Chain;\n  client: ThirdwebClient;\n  id: string;\n}): Promise<GetCallsStatusResponse> {\n  const { chain, client, id } = args;\n\n  const bundle = bundlesToTransactions.get(id);\n  if (!bundle) {\n    throw new Error(\"Failed to get calls status, unknown bundle id\");\n  }\n\n  const request = getRpcClient({ chain, client });\n  let status: \"pending\" | \"success\" | \"failure\" = \"success\";\n  const receipts: (WalletCallReceipt<bigint, \"success\" | \"reverted\"> | null)[] =\n    await Promise.all(\n      bundle.map((hash) =>\n        eth_getTransactionReceipt(request, { hash })\n          .then((receipt) => ({\n            blockHash: receipt.blockHash,\n            blockNumber: receipt.blockNumber,\n            gasUsed: receipt.gasUsed,\n            logs: receipt.logs.map((l) => ({\n              address: l.address,\n              data: l.data,\n              topics: l.topics,\n            })),\n            status: receipt.status,\n            transactionHash: receipt.transactionHash,\n          }))\n          .catch(() => {\n            status = \"pending\";\n            return null; // Return null if there's an error to filter out later\n          }),\n      ),\n    );\n\n  return {\n    atomic: false,\n    chainId: chain.id,\n    id,\n    receipts: receipts.filter((r) => r !== null),\n    status,\n    statusCode: 200,\n    version: \"2.0.0\",\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}