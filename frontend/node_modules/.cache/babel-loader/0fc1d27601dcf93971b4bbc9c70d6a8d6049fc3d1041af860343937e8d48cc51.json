{"ast":null,"code":"\"use client\";\n\nimport _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"loadingComponent\", \"fallbackComponent\", \"queryOptions\", \"nameResolver\"];\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { getFunctionId } from \"../../../../../utils/function-id.js\";\nimport { useNFTContext } from \"./provider.js\";\nimport { getNFTInfo } from \"./utils.js\";\n/**\n * This component fetches and displays an NFT's name. It takes in a `className` and `style` props\n * so you can style it just like how you would style a <span> element.\n * @returns A <span> element containing the name of the NFT\n *\n * @example\n * ### Basic usage\n * ```tsx\n * import { NFTProvider, NFTName } from \"thirdweb/react\";\n *\n * <NFTProvider>\n *   <NFTName />\n * </NFTProvider>\n * ```\n *\n * ### Show a loading sign while the name is being fetched\n * ```tsx\n * import { NFTProvider, NFTName } from \"thirdweb/react\";\n *\n * <NFTProvider>\n *   <NFTName loadingComponent={<YourLoadingSign />} />\n * </NFTProvider>\n * ```\n *\n * ### Show something in case the name failed to resolve\n * ```tsx\n * import { NFTProvider, NFTName } from \"thirdweb/react\";\n *\n * <NFTProvider>\n *   <NFTName fallbackComponent={<span>Failed to load name</span>} />\n * </NFTProvider>\n * ```\n *\n * ### Custom query options for useQuery (tanstack-query)\n * ```tsx\n * import { NFTProvider, NFTName } from \"thirdweb/react\";\n *\n * <NFTProvider>\n *   <NFTName queryOptions={{ retry: 3, enabled: false, }} />\n * </NFTProvider>\n * ```\n *\n * ### Override the name with the `nameResolver` prop\n * If you already have the name, you can skip the network requests and pass it directly to the NFTName\n * ```tsx\n * <NFTName nameResolver=\"Doodles #1\" />\n * ```\n *\n * You can also pass in your own custom (async) function that retrieves the name\n * ```tsx\n * const getName = async () => {\n *   // ...\n *   return name;\n * };\n *\n * <NFTName nameResolver={getName} />\n * ```\n *\n * @nft\n * @component\n * @beta\n */\nexport function NFTName(_ref) {\n  let {\n      loadingComponent,\n      fallbackComponent,\n      queryOptions,\n      nameResolver\n    } = _ref,\n    restProps = _objectWithoutProperties(_ref, _excluded);\n  const {\n    contract,\n    tokenId\n  } = useNFTContext();\n  const nameQuery = useQuery(_objectSpread({\n    queryFn: async () => fetchNftName({\n      contract,\n      nameResolver,\n      tokenId\n    }),\n    queryKey: getQueryKey({\n      chainId: contract.chain.id,\n      contractAddress: contract.address,\n      nameResolver,\n      tokenId\n    })\n  }, queryOptions));\n  if (nameQuery.isLoading) {\n    return loadingComponent || null;\n  }\n  if (!nameQuery.data) {\n    return fallbackComponent || null;\n  }\n  return _jsx(\"span\", _objectSpread(_objectSpread({}, restProps), {}, {\n    children: nameQuery.data\n  }));\n}\n/**\n * @internal\n */\nexport function getQueryKey(props) {\n  const {\n    chainId,\n    tokenId,\n    nameResolver,\n    contractAddress\n  } = props;\n  return [\"_internal_nft_name_\", chainId, contractAddress, tokenId.toString(), {\n    resolver: typeof nameResolver === \"string\" ? nameResolver : typeof nameResolver === \"function\" ? getFunctionId(nameResolver) : undefined\n  }];\n}\n/**\n * @internal Exported for tests\n */\nexport async function fetchNftName(props) {\n  const {\n    nameResolver,\n    contract,\n    tokenId\n  } = props;\n  if (typeof nameResolver === \"string\") {\n    return nameResolver;\n  }\n  if (typeof nameResolver === \"function\") {\n    return nameResolver();\n  }\n  const nft = await getNFTInfo({\n    contract,\n    tokenId\n  }).catch(() => undefined);\n  if (!nft) {\n    throw new Error(\"Failed to resolve NFT info\");\n  }\n  if (typeof nft.metadata.name !== \"string\") {\n    throw new Error(\"Failed to resolve NFT name\");\n  }\n  return nft.metadata.name;\n}","map":{"version":3,"names":["_objectSpread","_objectWithoutProperties","_excluded","useQuery","getFunctionId","useNFTContext","getNFTInfo","NFTName","_ref","loadingComponent","fallbackComponent","queryOptions","nameResolver","restProps","contract","tokenId","nameQuery","queryFn","fetchNftName","queryKey","getQueryKey","chainId","chain","id","contractAddress","address","isLoading","data","_jsx","children","props","toString","resolver","undefined","nft","catch","Error","metadata","name"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/react/web/ui/prebuilt/NFT/name.tsx"],"sourcesContent":["\"use client\";\n\nimport { type UseQueryOptions, useQuery } from \"@tanstack/react-query\";\nimport type { JSX } from \"react\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { getFunctionId } from \"../../../../../utils/function-id.js\";\nimport { useNFTContext } from \"./provider.js\";\nimport { getNFTInfo } from \"./utils.js\";\n\nexport interface NFTNameProps\n  extends Omit<React.HTMLAttributes<HTMLSpanElement>, \"children\"> {\n  loadingComponent?: JSX.Element;\n  fallbackComponent?: JSX.Element;\n  /**\n   * Optional `useQuery` params\n   */\n  queryOptions?: Omit<UseQueryOptions<string>, \"queryFn\" | \"queryKey\">;\n  /**\n   * This prop can be a string or a (async) function that resolves to a string, representing the name of the NFT\n   * This is particularly useful if you already have a way to fetch the name of the NFT.\n   */\n  nameResolver?: string | (() => string) | (() => Promise<string>);\n}\n\n/**\n * This component fetches and displays an NFT's name. It takes in a `className` and `style` props\n * so you can style it just like how you would style a <span> element.\n * @returns A <span> element containing the name of the NFT\n *\n * @example\n * ### Basic usage\n * ```tsx\n * import { NFTProvider, NFTName } from \"thirdweb/react\";\n *\n * <NFTProvider>\n *   <NFTName />\n * </NFTProvider>\n * ```\n *\n * ### Show a loading sign while the name is being fetched\n * ```tsx\n * import { NFTProvider, NFTName } from \"thirdweb/react\";\n *\n * <NFTProvider>\n *   <NFTName loadingComponent={<YourLoadingSign />} />\n * </NFTProvider>\n * ```\n *\n * ### Show something in case the name failed to resolve\n * ```tsx\n * import { NFTProvider, NFTName } from \"thirdweb/react\";\n *\n * <NFTProvider>\n *   <NFTName fallbackComponent={<span>Failed to load name</span>} />\n * </NFTProvider>\n * ```\n *\n * ### Custom query options for useQuery (tanstack-query)\n * ```tsx\n * import { NFTProvider, NFTName } from \"thirdweb/react\";\n *\n * <NFTProvider>\n *   <NFTName queryOptions={{ retry: 3, enabled: false, }} />\n * </NFTProvider>\n * ```\n *\n * ### Override the name with the `nameResolver` prop\n * If you already have the name, you can skip the network requests and pass it directly to the NFTName\n * ```tsx\n * <NFTName nameResolver=\"Doodles #1\" />\n * ```\n *\n * You can also pass in your own custom (async) function that retrieves the name\n * ```tsx\n * const getName = async () => {\n *   // ...\n *   return name;\n * };\n *\n * <NFTName nameResolver={getName} />\n * ```\n *\n * @nft\n * @component\n * @beta\n */\nexport function NFTName({\n  loadingComponent,\n  fallbackComponent,\n  queryOptions,\n  nameResolver,\n  ...restProps\n}: NFTNameProps) {\n  const { contract, tokenId } = useNFTContext();\n\n  const nameQuery = useQuery({\n    queryFn: async (): Promise<string> =>\n      fetchNftName({ contract, nameResolver, tokenId }),\n    queryKey: getQueryKey({\n      chainId: contract.chain.id,\n      contractAddress: contract.address,\n      nameResolver,\n      tokenId,\n    }),\n    ...queryOptions,\n  });\n\n  if (nameQuery.isLoading) {\n    return loadingComponent || null;\n  }\n\n  if (!nameQuery.data) {\n    return fallbackComponent || null;\n  }\n  return <span {...restProps}>{nameQuery.data}</span>;\n}\n\n/**\n * @internal\n */\nexport function getQueryKey(props: {\n  contractAddress: string;\n  chainId: number;\n  tokenId: bigint;\n  nameResolver?: string | (() => string) | (() => Promise<string>);\n}) {\n  const { chainId, tokenId, nameResolver, contractAddress } = props;\n  return [\n    \"_internal_nft_name_\",\n    chainId,\n    contractAddress,\n    tokenId.toString(),\n    {\n      resolver:\n        typeof nameResolver === \"string\"\n          ? nameResolver\n          : typeof nameResolver === \"function\"\n            ? getFunctionId(nameResolver)\n            : undefined,\n    },\n  ] as const;\n}\n\n/**\n * @internal Exported for tests\n */\nexport async function fetchNftName(props: {\n  nameResolver?: string | (() => string) | (() => Promise<string>);\n  contract: ThirdwebContract;\n  tokenId: bigint;\n}): Promise<string> {\n  const { nameResolver, contract, tokenId } = props;\n  if (typeof nameResolver === \"string\") {\n    return nameResolver;\n  }\n  if (typeof nameResolver === \"function\") {\n    return nameResolver();\n  }\n  const nft = await getNFTInfo({ contract, tokenId }).catch(() => undefined);\n  if (!nft) {\n    throw new Error(\"Failed to resolve NFT info\");\n  }\n  if (typeof nft.metadata.name !== \"string\") {\n    throw new Error(\"Failed to resolve NFT name\");\n  }\n  return nft.metadata.name;\n}\n"],"mappings":"AAAA,YAAY;;AAAC,OAAAA,aAAA;AAAA,OAAAC,wBAAA;AAAA,MAAAC,SAAA;;AAEb,SAA+BC,QAAQ,QAAQ,uBAAuB;AAGtE,SAASC,aAAa,QAAQ,qCAAqC;AACnE,SAASC,aAAa,QAAQ,eAAe;AAC7C,SAASC,UAAU,QAAQ,YAAY;AAiBvC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8DA,OAAM,SAAUC,OAAOA,CAAAC,IAAA,EAMR;EAAA,IANS;MACtBC,gBAAgB;MAChBC,iBAAiB;MACjBC,YAAY;MACZC;IACY,CACC,GAAAJ,IAAA;IADVK,SAAS,GAAAZ,wBAAA,CAAAO,IAAA,EAAAN,SAAA;EAEZ,MAAM;IAAEY,QAAQ;IAAEC;EAAO,CAAE,GAAGV,aAAa,EAAE;EAE7C,MAAMW,SAAS,GAAGb,QAAQ,CAAAH,aAAA;IACxBiB,OAAO,EAAE,MAAAA,CAAA,KACPC,YAAY,CAAC;MAAEJ,QAAQ;MAAEF,YAAY;MAAEG;IAAO,CAAE,CAAC;IACnDI,QAAQ,EAAEC,WAAW,CAAC;MACpBC,OAAO,EAAEP,QAAQ,CAACQ,KAAK,CAACC,EAAE;MAC1BC,eAAe,EAAEV,QAAQ,CAACW,OAAO;MACjCb,YAAY;MACZG;KACD;EAAC,GACCJ,YAAY,CAChB,CAAC;EAEF,IAAIK,SAAS,CAACU,SAAS,EAAE;IACvB,OAAOjB,gBAAgB,IAAI,IAAI;EACjC;EAEA,IAAI,CAACO,SAAS,CAACW,IAAI,EAAE;IACnB,OAAOjB,iBAAiB,IAAI,IAAI;EAClC;EACA,OAAOkB,IAAA,SAAA5B,aAAA,CAAAA,aAAA,KAAUa,SAAS;IAAAgB,QAAA,EAAGb,SAAS,CAACW;EAAI,GAAQ;AACrD;AAEA;;;AAGA,OAAM,SAAUP,WAAWA,CAACU,KAK3B;EACC,MAAM;IAAET,OAAO;IAAEN,OAAO;IAAEH,YAAY;IAAEY;EAAe,CAAE,GAAGM,KAAK;EACjE,OAAO,CACL,qBAAqB,EACrBT,OAAO,EACPG,eAAe,EACfT,OAAO,CAACgB,QAAQ,EAAE,EAClB;IACEC,QAAQ,EACN,OAAOpB,YAAY,KAAK,QAAQ,GAC5BA,YAAY,GACZ,OAAOA,YAAY,KAAK,UAAU,GAChCR,aAAa,CAACQ,YAAY,CAAC,GAC3BqB;GACT,CACO;AACZ;AAEA;;;AAGA,OAAO,eAAef,YAAYA,CAACY,KAIlC;EACC,MAAM;IAAElB,YAAY;IAAEE,QAAQ;IAAEC;EAAO,CAAE,GAAGe,KAAK;EACjD,IAAI,OAAOlB,YAAY,KAAK,QAAQ,EAAE;IACpC,OAAOA,YAAY;EACrB;EACA,IAAI,OAAOA,YAAY,KAAK,UAAU,EAAE;IACtC,OAAOA,YAAY,EAAE;EACvB;EACA,MAAMsB,GAAG,GAAG,MAAM5B,UAAU,CAAC;IAAEQ,QAAQ;IAAEC;EAAO,CAAE,CAAC,CAACoB,KAAK,CAAC,MAAMF,SAAS,CAAC;EAC1E,IAAI,CAACC,GAAG,EAAE;IACR,MAAM,IAAIE,KAAK,CAAC,4BAA4B,CAAC;EAC/C;EACA,IAAI,OAAOF,GAAG,CAACG,QAAQ,CAACC,IAAI,KAAK,QAAQ,EAAE;IACzC,MAAM,IAAIF,KAAK,CAAC,4BAA4B,CAAC;EAC/C;EACA,OAAOF,GAAG,CAACG,QAAQ,CAACC,IAAI;AAC1B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}