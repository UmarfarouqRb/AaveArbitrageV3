{"ast":null,"code":"// copy of: https://github.com/wevm/viem/blob/6cf2c3b5fe608bce9c828af867dfaa65103753a6/src/utils/promise/withCache.ts\n// with slight adjustments made to comply with our linting rules\n// TODO: explore extracting this from viem and instead having a separate general purpose library for this kind of thing\n// alternatively viem could maybe export this helpful util\n// TODO: explore using a LRU cache instead of a Map\nconst promiseCache = /*#__PURE__*/new Map();\nconst responseCache = /*#__PURE__*/new Map();\n/**\n *@internal\n */\nexport function getCache(cacheKey) {\n  const buildCache = (cacheKey_, cache) => ({\n    clear: () => cache.delete(cacheKey_),\n    get: () => cache.get(cacheKey_),\n    set: data => cache.set(cacheKey_, data)\n  });\n  const promise = buildCache(cacheKey, promiseCache);\n  const response = buildCache(cacheKey, responseCache);\n  return {\n    clear: () => {\n      promise.clear();\n      response.clear();\n    },\n    promise,\n    response\n  };\n}\n/**\n * Returns the result of a given promise, and caches the result for\n * subsequent invocations against a provided cache key.\n * @internal\n */\nexport async function withCache(fn, _ref) {\n  let {\n    cacheKey,\n    cacheTime = Number.POSITIVE_INFINITY\n  } = _ref;\n  const cache = getCache(cacheKey);\n  // If a response exists in the cache, and it's not expired, return it\n  // and do not invoke the promise.\n  // If the max age is 0, the cache is disabled.\n  const response = cache.response.get();\n  if (response && cacheTime > 0) {\n    const age = Date.now() - response.created.getTime();\n    if (age < cacheTime) {\n      return response.data;\n    }\n  }\n  let promise = cache.promise.get();\n  if (!promise) {\n    promise = fn();\n    // Store the promise in the cache so that subsequent invocations\n    // will wait for the same promise to resolve (deduping).\n    cache.promise.set(promise);\n  }\n  try {\n    const data = await promise;\n    // Store the response in the cache so that subsequent invocations\n    // will return the same response.\n    cache.response.set({\n      created: new Date(),\n      data\n    });\n    return data;\n  } finally {\n    // Clear the promise cache so that subsequent invocations will\n    // invoke the promise again.\n    cache.promise.clear();\n  }\n}","map":{"version":3,"names":["promiseCache","Map","responseCache","getCache","cacheKey","buildCache","cacheKey_","cache","clear","delete","get","set","data","promise","response","withCache","fn","_ref","cacheTime","Number","POSITIVE_INFINITY","age","Date","now","created","getTime"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/utils/promise/withCache.ts"],"sourcesContent":["// copy of: https://github.com/wevm/viem/blob/6cf2c3b5fe608bce9c828af867dfaa65103753a6/src/utils/promise/withCache.ts\n// with slight adjustments made to comply with our linting rules\n// TODO: explore extracting this from viem and instead having a separate general purpose library for this kind of thing\n// alternatively viem could maybe export this helpful util\n// TODO: explore using a LRU cache instead of a Map\n\nconst promiseCache = /*#__PURE__*/ new Map();\nconst responseCache = /*#__PURE__*/ new Map();\n\n/**\n *@internal\n */\nexport function getCache<TData>(cacheKey: string) {\n  const buildCache = <TData>(cacheKey_: string, cache: Map<string, TData>) => ({\n    clear: () => cache.delete(cacheKey_),\n    get: () => cache.get(cacheKey_),\n    set: (data: TData) => cache.set(cacheKey_, data),\n  });\n\n  const promise = buildCache<Promise<TData>>(cacheKey, promiseCache);\n  const response = buildCache<{ created: Date; data: TData }>(\n    cacheKey,\n    responseCache,\n  );\n\n  return {\n    clear: () => {\n      promise.clear();\n      response.clear();\n    },\n    promise,\n    response,\n  };\n}\n\ntype WithCacheParameters = {\n  /** The key to cache the data against. */\n  cacheKey: string;\n  /** The time that cached data will remain in memory. Default: Infinity (no expiry) */\n  cacheTime?: number;\n};\n\n/**\n * Returns the result of a given promise, and caches the result for\n * subsequent invocations against a provided cache key.\n * @internal\n */\nexport async function withCache<TData>(\n  fn: () => Promise<TData>,\n  { cacheKey, cacheTime = Number.POSITIVE_INFINITY }: WithCacheParameters,\n) {\n  const cache = getCache<TData>(cacheKey);\n\n  // If a response exists in the cache, and it's not expired, return it\n  // and do not invoke the promise.\n  // If the max age is 0, the cache is disabled.\n  const response = cache.response.get();\n  if (response && cacheTime > 0) {\n    const age = Date.now() - response.created.getTime();\n    if (age < cacheTime) {\n      return response.data;\n    }\n  }\n\n  let promise = cache.promise.get();\n  if (!promise) {\n    promise = fn();\n\n    // Store the promise in the cache so that subsequent invocations\n    // will wait for the same promise to resolve (deduping).\n    cache.promise.set(promise);\n  }\n\n  try {\n    const data = await promise;\n\n    // Store the response in the cache so that subsequent invocations\n    // will return the same response.\n    cache.response.set({ created: new Date(), data });\n\n    return data;\n  } finally {\n    // Clear the promise cache so that subsequent invocations will\n    // invoke the promise again.\n    cache.promise.clear();\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA,MAAMA,YAAY,GAAG,aAAc,IAAIC,GAAG,EAAE;AAC5C,MAAMC,aAAa,GAAG,aAAc,IAAID,GAAG,EAAE;AAE7C;;;AAGA,OAAM,SAAUE,QAAQA,CAAQC,QAAgB;EAC9C,MAAMC,UAAU,GAAGA,CAAQC,SAAiB,EAAEC,KAAyB,MAAM;IAC3EC,KAAK,EAAEA,CAAA,KAAMD,KAAK,CAACE,MAAM,CAACH,SAAS,CAAC;IACpCI,GAAG,EAAEA,CAAA,KAAMH,KAAK,CAACG,GAAG,CAACJ,SAAS,CAAC;IAC/BK,GAAG,EAAGC,IAAW,IAAKL,KAAK,CAACI,GAAG,CAACL,SAAS,EAAEM,IAAI;GAChD,CAAC;EAEF,MAAMC,OAAO,GAAGR,UAAU,CAAiBD,QAAQ,EAAEJ,YAAY,CAAC;EAClE,MAAMc,QAAQ,GAAGT,UAAU,CACzBD,QAAQ,EACRF,aAAa,CACd;EAED,OAAO;IACLM,KAAK,EAAEA,CAAA,KAAK;MACVK,OAAO,CAACL,KAAK,EAAE;MACfM,QAAQ,CAACN,KAAK,EAAE;IAClB,CAAC;IACDK,OAAO;IACPC;GACD;AACH;AASA;;;;;AAKA,OAAO,eAAeC,SAASA,CAC7BC,EAAwB,EAAAC,IAAA,EAC+C;EAAA,IAAvE;IAAEb,QAAQ;IAAEc,SAAS,GAAGC,MAAM,CAACC;EAAiB,CAAuB,GAAAH,IAAA;EAEvE,MAAMV,KAAK,GAAGJ,QAAQ,CAAQC,QAAQ,CAAC;EAEvC;EACA;EACA;EACA,MAAMU,QAAQ,GAAGP,KAAK,CAACO,QAAQ,CAACJ,GAAG,EAAE;EACrC,IAAII,QAAQ,IAAII,SAAS,GAAG,CAAC,EAAE;IAC7B,MAAMG,GAAG,GAAGC,IAAI,CAACC,GAAG,EAAE,GAAGT,QAAQ,CAACU,OAAO,CAACC,OAAO,EAAE;IACnD,IAAIJ,GAAG,GAAGH,SAAS,EAAE;MACnB,OAAOJ,QAAQ,CAACF,IAAI;IACtB;EACF;EAEA,IAAIC,OAAO,GAAGN,KAAK,CAACM,OAAO,CAACH,GAAG,EAAE;EACjC,IAAI,CAACG,OAAO,EAAE;IACZA,OAAO,GAAGG,EAAE,EAAE;IAEd;IACA;IACAT,KAAK,CAACM,OAAO,CAACF,GAAG,CAACE,OAAO,CAAC;EAC5B;EAEA,IAAI;IACF,MAAMD,IAAI,GAAG,MAAMC,OAAO;IAE1B;IACA;IACAN,KAAK,CAACO,QAAQ,CAACH,GAAG,CAAC;MAAEa,OAAO,EAAE,IAAIF,IAAI,EAAE;MAAEV;IAAI,CAAE,CAAC;IAEjD,OAAOA,IAAI;EACb,CAAC,SAAS;IACR;IACA;IACAL,KAAK,CAACM,OAAO,CAACL,KAAK,EAAE;EACvB;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}