{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"account\", \"chain\", \"token\", \"to\", \"amount\", \"bridgeAddress\"];\nimport { parseAbi } from 'abitype';\nimport { readContract } from '../../actions/public/readContract.js';\nimport { AccountNotFoundError } from '../../errors/account.js';\nimport { ClientChainNotConfiguredError } from '../../errors/chain.js';\nimport { encodeAbiParameters, encodeFunctionData, isAddressEqual, keccak256, parseAccount } from '../../utils/index.js';\nimport { ethTokenAbi, l2SharedBridgeAbi } from '../constants/abis.js';\nimport { ethAddressInContracts, l2AssetRouterAddress, l2BaseTokenAddress, l2NativeTokenVaultAddress, legacyEthAddress } from '../constants/address.js';\nimport { getDefaultBridgeAddresses } from './getDefaultBridgeAddresses.js';\nimport { getL1ChainId } from './getL1ChainId.js';\nimport { getL2TokenAddress } from './getL2TokenAddress.js';\nimport { sendTransaction } from './sendTransaction.js';\n/**\n * Initiates the withdrawal process which withdraws ETH or any ERC20 token\n * from the associated account on L2 network to the target account on L1 network.\n *\n * @param client - Client to use\n * @param parameters - {@link WithdrawParameters}\n * @returns hash - The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link WithdrawReturnType}\n *\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { zksync } from 'viem/chains'\n * import { withdraw, legacyEthAddress } from 'viem/zksync'\n *\n * const client = createPublicClient({\n *   chain: zksync,\n *   transport: http(),\n * })\n *\n * const hash = await withdraw(client, {\n *     account: privateKeyToAccount('0x…'),\n *     amount: 1_000_000_000_000_000_000n,\n *     token: legacyEthAddress,\n * })\n *\n * @example Account Hoisting\n * import { createPublicClient, createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { zksync } from 'viem/chains'\n * import { withdraw, legacyEthAddress } from 'viem/zksync'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: zksync,\n *   transport: http(),\n * })\n *\n * const hash = await withdraw(client, {\n *     amount: 1_000_000_000_000_000_000n,\n *     token: legacyEthAddress,\n * })\n *\n * @example Paymaster\n * import { createPublicClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { zksync } from 'viem/chains'\n * import {\n *   withdraw,\n *   legacyEthAddress,\n *   getApprovalBasedPaymasterInput\n * } from 'viem/zksync'\n *\n * const client = createPublicClient({\n *   chain: zksync,\n *   transport: http(),\n * })\n *\n * const hash = await withdraw(client, {\n *     account: privateKeyToAccount('0x…'),\n *     amount: 1_000_000_000_000_000_000n,\n *     token: legacyEthAddress,\n *     paymaster: '0x0EEc6f45108B4b806e27B81d9002e162BD910670',\n *     paymasterInput: getApprovalBasedPaymasterInput({\n *       minAllowance: 1n,\n *       token: '0x2dc3685cA34163952CF4A5395b0039c00DFa851D',\n *       innerInput: new Uint8Array(),\n *     }),\n * })\n */\nexport async function withdraw(client, parameters) {\n  let {\n      account: account_ = client.account,\n      chain: chain_ = client.chain,\n      token = l2BaseTokenAddress,\n      to,\n      amount,\n      bridgeAddress\n    } = parameters,\n    rest = _objectWithoutProperties(parameters, _excluded);\n  const account = account_ ? parseAccount(account_) : client.account;\n  if (!account) throw new AccountNotFoundError({\n    docsPath: '/docs/actions/wallet/sendTransaction'\n  });\n  if (!to) to = account.address;\n  let data;\n  let contract;\n  let value = 0n;\n  if (isAddressEqual(token, legacyEthAddress) || isAddressEqual(token, ethAddressInContracts)) token = await getL2TokenAddress(client, {\n    token: ethAddressInContracts\n  });\n  if (isAddressEqual(token, l2BaseTokenAddress)) {\n    data = encodeFunctionData({\n      abi: ethTokenAbi,\n      functionName: 'withdraw',\n      args: [to]\n    });\n    value = amount;\n    contract = l2BaseTokenAddress;\n  } else {\n    const assetId = await readContract(client, {\n      address: l2NativeTokenVaultAddress,\n      abi: parseAbi(['function assetId(address token) view returns (bytes32)']),\n      functionName: 'assetId',\n      args: [token]\n    });\n    const originChainId = await readContract(client, {\n      address: l2NativeTokenVaultAddress,\n      abi: parseAbi(['function originChainId(bytes32 assetId) view returns (uint256)']),\n      functionName: 'originChainId',\n      args: [assetId]\n    });\n    const l1ChainId = await getL1ChainId(client);\n    const isTokenL1Native = originChainId === BigInt(l1ChainId) || token === ethAddressInContracts;\n    if (!bridgeAddress) {\n      // If the legacy L2SharedBridge is deployed we use it for l1 native tokens.\n      bridgeAddress = isTokenL1Native ? (await getDefaultBridgeAddresses(client)).sharedL2 : l2AssetRouterAddress;\n    }\n    // For non L1 native tokens we need to use the AssetRouter.\n    // For L1 native tokens we can use the legacy withdraw method.\n    if (!isTokenL1Native) {\n      contract = l2AssetRouterAddress;\n      if (!chain_) throw new ClientChainNotConfiguredError();\n      const chainId = chain_.id;\n      const assetId = keccak256(encodeAbiParameters([{\n        type: 'uint256'\n      }, {\n        type: 'address'\n      }, {\n        type: 'address'\n      }], [BigInt(chainId), l2NativeTokenVaultAddress, token]));\n      const assetData = encodeAbiParameters([{\n        type: 'uint256'\n      }, {\n        type: 'address'\n      }, {\n        type: 'address'\n      }], [BigInt(amount), to, token]);\n      data = encodeFunctionData({\n        abi: parseAbi(['function withdraw(bytes32 _assetId, bytes _transferData)']),\n        functionName: 'withdraw',\n        args: [assetId, assetData]\n      });\n    } else {\n      contract = bridgeAddress;\n      data = encodeFunctionData({\n        abi: l2SharedBridgeAbi,\n        functionName: 'withdraw',\n        args: [to, token, amount]\n      });\n    }\n  }\n  return await sendTransaction(client, _objectSpread({\n    chain: chain_,\n    account,\n    to: contract,\n    data,\n    value\n  }, rest));\n}","map":{"version":3,"names":["parseAbi","readContract","AccountNotFoundError","ClientChainNotConfiguredError","encodeAbiParameters","encodeFunctionData","isAddressEqual","keccak256","parseAccount","ethTokenAbi","l2SharedBridgeAbi","ethAddressInContracts","l2AssetRouterAddress","l2BaseTokenAddress","l2NativeTokenVaultAddress","legacyEthAddress","getDefaultBridgeAddresses","getL1ChainId","getL2TokenAddress","sendTransaction","withdraw","client","parameters","account","account_","chain","chain_","token","to","amount","bridgeAddress","rest","_objectWithoutProperties","_excluded","docsPath","address","data","contract","value","abi","functionName","args","assetId","originChainId","l1ChainId","isTokenL1Native","BigInt","sharedL2","chainId","id","type","assetData","_objectSpread"],"sources":["/home/user/Arbitrage/frontend/node_modules/viem/zksync/actions/withdraw.ts"],"sourcesContent":["import { type Address, parseAbi } from 'abitype'\nimport type { Account } from '../../accounts/types.js'\nimport { readContract } from '../../actions/public/readContract.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../errors/account.js'\nimport { ClientChainNotConfiguredError } from '../../errors/chain.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type { GetChainParameter } from '../../types/chain.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport type { EncodeFunctionDataReturnType } from '../../utils/abi/encodeFunctionData.js'\nimport {\n  encodeAbiParameters,\n  encodeFunctionData,\n  isAddressEqual,\n  keccak256,\n  parseAccount,\n} from '../../utils/index.js'\nimport { ethTokenAbi, l2SharedBridgeAbi } from '../constants/abis.js'\nimport {\n  ethAddressInContracts,\n  l2AssetRouterAddress,\n  l2BaseTokenAddress,\n  l2NativeTokenVaultAddress,\n  legacyEthAddress,\n} from '../constants/address.js'\nimport type { ChainEIP712 } from '../types/chain.js'\nimport type { ZksyncTransactionRequest } from '../types/transaction.js'\nimport { getDefaultBridgeAddresses } from './getDefaultBridgeAddresses.js'\nimport { getL1ChainId } from './getL1ChainId.js'\nimport { getL2TokenAddress } from './getL2TokenAddress.js'\nimport {\n  type SendTransactionErrorType,\n  type SendTransactionParameters,\n  type SendTransactionReturnType,\n  sendTransaction,\n} from './sendTransaction.js'\n\nexport type WithdrawParameters<\n  chain extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n> = UnionOmit<\n  ZksyncTransactionRequest,\n  'from' | 'type' | 'value' | 'data' | 'to' | 'factoryDeps' | 'maxFeePerBlobGas'\n> &\n  Partial<GetAccountParameter<account>> &\n  Partial<GetChainParameter<chain, chainOverride>> & {\n    /** The address of the recipient on L1. Defaults to the sender address. */\n    to?: Address | undefined\n    /** The address of the token. */\n    token: Address\n    /** The amount of the token to withdraw. */\n    amount: bigint\n    /** The address of the bridge contract to be used. */\n    bridgeAddress?: Address | undefined\n  }\n\nexport type WithdrawReturnType = SendTransactionReturnType\n\nexport type WithdrawErrorType = SendTransactionErrorType\n\n/**\n * Initiates the withdrawal process which withdraws ETH or any ERC20 token\n * from the associated account on L2 network to the target account on L1 network.\n *\n * @param client - Client to use\n * @param parameters - {@link WithdrawParameters}\n * @returns hash - The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link WithdrawReturnType}\n *\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { zksync } from 'viem/chains'\n * import { withdraw, legacyEthAddress } from 'viem/zksync'\n *\n * const client = createPublicClient({\n *   chain: zksync,\n *   transport: http(),\n * })\n *\n * const hash = await withdraw(client, {\n *     account: privateKeyToAccount('0x…'),\n *     amount: 1_000_000_000_000_000_000n,\n *     token: legacyEthAddress,\n * })\n *\n * @example Account Hoisting\n * import { createPublicClient, createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { zksync } from 'viem/chains'\n * import { withdraw, legacyEthAddress } from 'viem/zksync'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: zksync,\n *   transport: http(),\n * })\n *\n * const hash = await withdraw(client, {\n *     amount: 1_000_000_000_000_000_000n,\n *     token: legacyEthAddress,\n * })\n *\n * @example Paymaster\n * import { createPublicClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { zksync } from 'viem/chains'\n * import {\n *   withdraw,\n *   legacyEthAddress,\n *   getApprovalBasedPaymasterInput\n * } from 'viem/zksync'\n *\n * const client = createPublicClient({\n *   chain: zksync,\n *   transport: http(),\n * })\n *\n * const hash = await withdraw(client, {\n *     account: privateKeyToAccount('0x…'),\n *     amount: 1_000_000_000_000_000_000n,\n *     token: legacyEthAddress,\n *     paymaster: '0x0EEc6f45108B4b806e27B81d9002e162BD910670',\n *     paymasterInput: getApprovalBasedPaymasterInput({\n *       minAllowance: 1n,\n *       token: '0x2dc3685cA34163952CF4A5395b0039c00DFa851D',\n *       innerInput: new Uint8Array(),\n *     }),\n * })\n */\nexport async function withdraw<\n  chain extends ChainEIP712 | undefined,\n  account extends Account | undefined,\n  chainOverride extends ChainEIP712 | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: WithdrawParameters<chain, account, chainOverride>,\n): Promise<WithdrawReturnType> {\n  let {\n    account: account_ = client.account,\n    chain: chain_ = client.chain,\n    token = l2BaseTokenAddress,\n    to,\n    amount,\n    bridgeAddress,\n    ...rest\n  } = parameters\n  const account = account_ ? parseAccount(account_) : client.account\n  if (!account)\n    throw new AccountNotFoundError({\n      docsPath: '/docs/actions/wallet/sendTransaction',\n    })\n\n  if (!to) to = account.address\n  let data: EncodeFunctionDataReturnType\n  let contract: Address\n  let value = 0n\n\n  if (\n    isAddressEqual(token, legacyEthAddress) ||\n    isAddressEqual(token, ethAddressInContracts)\n  )\n    token = await getL2TokenAddress(client, { token: ethAddressInContracts })\n\n  if (isAddressEqual(token, l2BaseTokenAddress)) {\n    data = encodeFunctionData({\n      abi: ethTokenAbi,\n      functionName: 'withdraw',\n      args: [to],\n    })\n    value = amount\n    contract = l2BaseTokenAddress\n  } else {\n    const assetId = await readContract(client, {\n      address: l2NativeTokenVaultAddress,\n      abi: parseAbi(['function assetId(address token) view returns (bytes32)']),\n      functionName: 'assetId',\n      args: [token],\n    })\n    const originChainId = await readContract(client, {\n      address: l2NativeTokenVaultAddress,\n      abi: parseAbi([\n        'function originChainId(bytes32 assetId) view returns (uint256)',\n      ]),\n      functionName: 'originChainId',\n      args: [assetId],\n    })\n    const l1ChainId = await getL1ChainId(client)\n\n    const isTokenL1Native =\n      originChainId === BigInt(l1ChainId) || token === ethAddressInContracts\n    if (!bridgeAddress) {\n      // If the legacy L2SharedBridge is deployed we use it for l1 native tokens.\n      bridgeAddress = isTokenL1Native\n        ? (await getDefaultBridgeAddresses(client)).sharedL2\n        : l2AssetRouterAddress\n    }\n    // For non L1 native tokens we need to use the AssetRouter.\n    // For L1 native tokens we can use the legacy withdraw method.\n    if (!isTokenL1Native) {\n      contract = l2AssetRouterAddress\n      if (!chain_) throw new ClientChainNotConfiguredError()\n      const chainId = chain_.id\n      const assetId = keccak256(\n        encodeAbiParameters(\n          [{ type: 'uint256' }, { type: 'address' }, { type: 'address' }],\n          [BigInt(chainId), l2NativeTokenVaultAddress, token],\n        ),\n      )\n      const assetData = encodeAbiParameters(\n        [{ type: 'uint256' }, { type: 'address' }, { type: 'address' }],\n        [BigInt(amount), to, token],\n      )\n      data = encodeFunctionData({\n        abi: parseAbi([\n          'function withdraw(bytes32 _assetId, bytes _transferData)',\n        ]),\n        functionName: 'withdraw',\n        args: [assetId, assetData],\n      })\n    } else {\n      contract = bridgeAddress\n      data = encodeFunctionData({\n        abi: l2SharedBridgeAbi,\n        functionName: 'withdraw',\n        args: [to, token, amount],\n      })\n    }\n  }\n\n  return await sendTransaction(client, {\n    chain: chain_,\n    account,\n    to: contract,\n    data,\n    value,\n    ...rest,\n  } as SendTransactionParameters)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}