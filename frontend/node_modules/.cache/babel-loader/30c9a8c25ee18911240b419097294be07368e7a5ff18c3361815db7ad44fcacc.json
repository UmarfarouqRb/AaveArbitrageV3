{"ast":null,"code":"import _objectWithoutProperties from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nconst _excluded = [\"contract\", \"extra_metadata\", \"collection\", \"metadata_url\", \"chain_id\", \"token_id\", \"status\", \"balance\", \"token_type\"],\n  _excluded2 = [\"owner_addresses\"];\nimport { getCachedChain } from \"../chains/utils.js\";\nimport { getContract } from \"../contract/contract.js\";\nimport { getAddress } from \"../utils/address.js\";\n/**\n * Get NFTs owned by an address\n * @example\n * ```ts\n * import { Insight } from \"thirdweb\";\n *\n * const nfts = await Insight.getOwnedNFTs({\n *   client,\n *   chains: [sepolia],\n *   ownerAddress: \"0x1234567890123456789012345678901234567890\",\n * });\n * ```\n * @insight\n */\nexport async function getOwnedNFTs(args) {\n  var _result$data$data, _result$data;\n  const [{\n    getV1Nfts\n  }, {\n    getThirdwebDomains\n  }, {\n    getClientFetch\n  }, {\n    assertInsightEnabled\n  }, {\n    stringify\n  }] = await Promise.all([import(\"@thirdweb-dev/insight\"), import(\"../utils/domains.js\"), import(\"../utils/fetch.js\"), import(\"./common.js\"), import(\"viem\")]);\n  const {\n    client,\n    chains,\n    ownerAddress,\n    contractAddresses,\n    queryOptions\n  } = args;\n  await assertInsightEnabled(chains);\n  const defaultQueryOptions = {\n    chain: chains.map(chain => chain.id),\n    // metadata: includeMetadata ? \"true\" : \"false\", TODO (insight): add support for this\n    limit: 50,\n    owner_address: [ownerAddress],\n    contract_address: contractAddresses ? contractAddresses : undefined\n  };\n  const result = await getV1Nfts({\n    baseUrl: \"https://\".concat(getThirdwebDomains().insight),\n    fetch: getClientFetch(client),\n    query: _objectSpread(_objectSpread({}, defaultQueryOptions), queryOptions)\n  });\n  if (result.error) {\n    throw new Error(\"\".concat(result.response.status, \" \").concat(result.response.statusText, \" - \").concat(result.error ? stringify(result.error) : \"Unknown error\"));\n  }\n  const transformedNfts = await transformNFTModel((_result$data$data = (_result$data = result.data) === null || _result$data === void 0 ? void 0 : _result$data.data) !== null && _result$data$data !== void 0 ? _result$data$data : [], client, ownerAddress);\n  return transformedNfts.map(nft => {\n    var _nft$quantityOwned;\n    return _objectSpread(_objectSpread({}, nft), {}, {\n      quantityOwned: (_nft$quantityOwned = nft.quantityOwned) !== null && _nft$quantityOwned !== void 0 ? _nft$quantityOwned : 1n\n    });\n  });\n}\n/**\n * Get all NFTs from a contract\n * @example\n * ```ts\n * import { Insight } from \"thirdweb\";\n *\n * const nfts = await Insight.getContractNFTs({\n *   client,\n *   chains: [sepolia],\n *   contractAddress: \"0x1234567890123456789012345678901234567890\",\n * });\n * ```\n * @insight\n */\nexport async function getContractNFTs(args) {\n  var _result$data$data2, _result$data2;\n  const [{\n    getV1NftsByContractAddress\n  }, {\n    getThirdwebDomains\n  }, {\n    getClientFetch\n  }, {\n    assertInsightEnabled\n  }, {\n    stringify\n  }] = await Promise.all([import(\"@thirdweb-dev/insight\"), import(\"../utils/domains.js\"), import(\"../utils/fetch.js\"), import(\"./common.js\"), import(\"../utils/json.js\")]);\n  const {\n    client,\n    chains,\n    contractAddress,\n    includeOwners = true,\n    queryOptions\n  } = args;\n  const defaultQueryOptions = {\n    chain: chains.map(chain => chain.id),\n    include_owners: includeOwners === true ? \"true\" : \"false\",\n    // metadata: includeMetadata ? \"true\" : \"false\", TODO (insight): add support for this\n    limit: 50\n  };\n  await assertInsightEnabled(chains);\n  const result = await getV1NftsByContractAddress({\n    baseUrl: \"https://\".concat(getThirdwebDomains().insight),\n    fetch: getClientFetch(client),\n    path: {\n      contract_address: contractAddress\n    },\n    query: _objectSpread(_objectSpread({}, defaultQueryOptions), queryOptions)\n  });\n  if (result.error) {\n    throw new Error(\"\".concat(result.response.status, \" \").concat(result.response.statusText, \" - \").concat(result.error ? stringify(result.error) : \"Unknown error\"));\n  }\n  return transformNFTModel((_result$data$data2 = (_result$data2 = result.data) === null || _result$data2 === void 0 ? void 0 : _result$data2.data) !== null && _result$data$data2 !== void 0 ? _result$data$data2 : [], client);\n}\n/**\n * Get NFT metadata by contract address and token id\n * @example\n * ```ts\n * import { Insight } from \"thirdweb\";\n *\n * const nft = await Insight.getNFT({\n *   client,\n *   chain: sepolia,\n *   contractAddress: \"0x1234567890123456789012345678901234567890\",\n *   tokenId: 1n,\n * });\n * ```\n * @insight\n */\nexport async function getNFT(args) {\n  var _result$data$data3, _result$data3;\n  const [{\n    getV1NftsByContractAddressByTokenId\n  }, {\n    getThirdwebDomains\n  }, {\n    getClientFetch\n  }, {\n    assertInsightEnabled\n  }, {\n    stringify\n  }] = await Promise.all([import(\"@thirdweb-dev/insight\"), import(\"../utils/domains.js\"), import(\"../utils/fetch.js\"), import(\"./common.js\"), import(\"../utils/json.js\")]);\n  const {\n    client,\n    chain,\n    contractAddress,\n    tokenId,\n    includeOwners = true,\n    queryOptions\n  } = args;\n  await assertInsightEnabled([chain]);\n  const defaultQueryOptions = {\n    chain_id: [chain.id],\n    include_owners: includeOwners === true ? \"true\" : \"false\"\n  };\n  const result = await getV1NftsByContractAddressByTokenId({\n    baseUrl: \"https://\".concat(getThirdwebDomains().insight),\n    fetch: getClientFetch(client),\n    path: {\n      contract_address: contractAddress,\n      token_id: tokenId.toString()\n    },\n    query: _objectSpread(_objectSpread({}, defaultQueryOptions), queryOptions)\n  });\n  if (result.error) {\n    throw new Error(\"\".concat(result.response.status, \" \").concat(result.response.statusText, \" - \").concat(result.error ? stringify(result.error) : \"Unknown error\"));\n  }\n  const transformedNfts = await transformNFTModel((_result$data$data3 = (_result$data3 = result.data) === null || _result$data3 === void 0 ? void 0 : _result$data3.data) !== null && _result$data$data3 !== void 0 ? _result$data$data3 : [], client);\n  return transformedNfts === null || transformedNfts === void 0 ? void 0 : transformedNfts[0];\n}\nasync function transformNFTModel(nfts, client, ownerAddress) {\n  const [{\n    parseNFT\n  }, {\n    totalSupply\n  }] = await Promise.all([import(\"../utils/nft/parseNft.js\"), import(\"../extensions/erc1155/__generated__/IERC1155/read/totalSupply.js\")]);\n  return await Promise.all(nfts.map(async nft => {\n    var _nft$extra_metadata$a, _nft$extra_metadata, _nft$metadata_url;\n    let parsedNft;\n    const {\n        contract,\n        // biome-ignore lint/correctness/noUnusedVariables: explicitly unused to not include it in the resulting metadata\n        extra_metadata,\n        // biome-ignore lint/correctness/noUnusedVariables: explicitly unused to not include it in the resulting metadata\n        collection,\n        metadata_url,\n        // biome-ignore lint/correctness/noUnusedVariables: explicitly unused to not include it in the resulting metadata\n        chain_id,\n        token_id,\n        // biome-ignore lint/correctness/noUnusedVariables: explicitly unused to not include it in the resulting metadata\n        status,\n        balance,\n        // biome-ignore lint/correctness/noUnusedVariables: explicitly unused to not include it in the resulting metadata\n        token_type\n      } = nft,\n      rest = _objectWithoutProperties(nft, _excluded);\n    let metadataToUse = rest;\n    let owners = ownerAddress ? [getAddress(ownerAddress)] : undefined;\n    if (\"owner_addresses\" in rest) {\n      const {\n          owner_addresses\n        } = rest,\n        restWithoutOwnerAddresses = _objectWithoutProperties(rest, _excluded2);\n      metadataToUse = restWithoutOwnerAddresses;\n      owners = owners !== null && owners !== void 0 ? owners : owner_addresses === null || owner_addresses === void 0 ? void 0 : owner_addresses.map(o => getAddress(o));\n    }\n    const metadata = replaceIPFSGatewayRecursively(_objectSpread({\n      attributes: (_nft$extra_metadata$a = (_nft$extra_metadata = nft.extra_metadata) === null || _nft$extra_metadata === void 0 ? void 0 : _nft$extra_metadata.attributes) !== null && _nft$extra_metadata$a !== void 0 ? _nft$extra_metadata$a : undefined,\n      image: nft.image_url,\n      uri: (_nft$metadata_url = nft.metadata_url) !== null && _nft$metadata_url !== void 0 ? _nft$metadata_url : \"\"\n    }, metadataToUse));\n    if ((contract === null || contract === void 0 ? void 0 : contract.type) === \"erc1155\") {\n      var _contract$chain_id, _owners, _contract$address, _replaceIPFSGateway;\n      // TODO (insight): this needs to be added in the API\n      const supply = await totalSupply({\n        contract: getContract({\n          address: contract.address,\n          chain: getCachedChain(contract.chain_id),\n          client: client\n        }),\n        id: BigInt(token_id)\n      }).catch(() => 0n);\n      parsedNft = parseNFT(metadata, {\n        chainId: (_contract$chain_id = contract === null || contract === void 0 ? void 0 : contract.chain_id) !== null && _contract$chain_id !== void 0 ? _contract$chain_id : 0,\n        owner: (_owners = owners) === null || _owners === void 0 ? void 0 : _owners[0],\n        supply: supply,\n        tokenAddress: (_contract$address = contract === null || contract === void 0 ? void 0 : contract.address) !== null && _contract$address !== void 0 ? _contract$address : \"\",\n        tokenId: BigInt(token_id),\n        tokenUri: (_replaceIPFSGateway = replaceIPFSGateway(metadata_url)) !== null && _replaceIPFSGateway !== void 0 ? _replaceIPFSGateway : \"\",\n        type: \"ERC1155\"\n      });\n    } else {\n      var _contract$chain_id2, _owners2, _contract$address2, _replaceIPFSGateway2;\n      parsedNft = parseNFT(metadata, {\n        chainId: (_contract$chain_id2 = contract === null || contract === void 0 ? void 0 : contract.chain_id) !== null && _contract$chain_id2 !== void 0 ? _contract$chain_id2 : 0,\n        owner: (_owners2 = owners) === null || _owners2 === void 0 ? void 0 : _owners2[0],\n        tokenAddress: (_contract$address2 = contract === null || contract === void 0 ? void 0 : contract.address) !== null && _contract$address2 !== void 0 ? _contract$address2 : \"\",\n        tokenId: BigInt(token_id),\n        tokenUri: (_replaceIPFSGateway2 = replaceIPFSGateway(metadata_url)) !== null && _replaceIPFSGateway2 !== void 0 ? _replaceIPFSGateway2 : \"\",\n        type: \"ERC721\"\n      });\n    }\n    return _objectSpread(_objectSpread({}, parsedNft), (contract === null || contract === void 0 ? void 0 : contract.type) === \"erc1155\" ? {\n      quantityOwned: balance ? BigInt(balance) : undefined\n    } : {});\n  }));\n}\n// biome-ignore lint/suspicious/noExplicitAny: this should be fixed in the API\nfunction replaceIPFSGatewayRecursively(obj) {\n  if (typeof obj !== \"object\" || obj === null) {\n    return obj;\n  }\n  for (const key in obj) {\n    if (typeof obj[key] === \"string\") {\n      obj[key] = replaceIPFSGateway(obj[key]);\n    } else {\n      replaceIPFSGatewayRecursively(obj[key]);\n    }\n  }\n  return obj;\n}\nfunction replaceIPFSGateway(url) {\n  if (!url || typeof url !== \"string\") {\n    return url;\n  }\n  try {\n    const parsedUrl = new URL(url);\n    if (parsedUrl.host.endsWith(\".ipfscdn.io\")) {\n      const paths = parsedUrl.pathname.split(\"/\");\n      const index = paths.findIndex(path => path === \"ipfs\");\n      if (index === -1) {\n        return url;\n      }\n      const ipfsHash = paths.slice(index + 1).join(\"/\");\n      if (ipfsHash) {\n        return \"ipfs://\".concat(ipfsHash);\n      }\n      return url;\n    }\n  } catch (_unused) {\n    // If the URL is invalid, return it as is\n    return url;\n  }\n  return url;\n}","map":{"version":3,"names":["getCachedChain","getContract","getAddress","getOwnedNFTs","args","_result$data$data","_result$data","getV1Nfts","getThirdwebDomains","getClientFetch","assertInsightEnabled","stringify","Promise","all","client","chains","ownerAddress","contractAddresses","queryOptions","defaultQueryOptions","chain","map","id","limit","owner_address","contract_address","undefined","result","baseUrl","concat","insight","fetch","query","_objectSpread","error","Error","response","status","statusText","transformedNfts","transformNFTModel","data","nft","_nft$quantityOwned","quantityOwned","getContractNFTs","_result$data$data2","_result$data2","getV1NftsByContractAddress","contractAddress","includeOwners","include_owners","path","getNFT","_result$data$data3","_result$data3","getV1NftsByContractAddressByTokenId","tokenId","chain_id","token_id","toString","nfts","parseNFT","totalSupply","_nft$extra_metadata$a","_nft$extra_metadata","_nft$metadata_url","parsedNft","contract","extra_metadata","collection","metadata_url","balance","token_type","rest","_objectWithoutProperties","_excluded","metadataToUse","owners","owner_addresses","restWithoutOwnerAddresses","_excluded2","o","metadata","replaceIPFSGatewayRecursively","attributes","image","image_url","uri","type","_contract$chain_id","_owners","_contract$address","_replaceIPFSGateway","supply","address","BigInt","catch","chainId","owner","tokenAddress","tokenUri","replaceIPFSGateway","_contract$chain_id2","_owners2","_contract$address2","_replaceIPFSGateway2","obj","key","url","parsedUrl","URL","host","endsWith","paths","pathname","split","index","findIndex","ipfsHash","slice","join","_unused"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/insight/get-nfts.ts"],"sourcesContent":["import type {\n  GetV1NftsByContractAddressByTokenIdData,\n  GetV1NftsByContractAddressData,\n  GetV1NftsByContractAddressResponse,\n  GetV1NftsData,\n  GetV1NftsResponse,\n} from \"@thirdweb-dev/insight\";\nimport type { Chain } from \"../chains/types.js\";\nimport { getCachedChain } from \"../chains/utils.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { getContract } from \"../contract/contract.js\";\nimport { getAddress } from \"../utils/address.js\";\nimport type { NFT } from \"../utils/nft/parseNft.js\";\n\ntype OwnedNFT = GetV1NftsResponse[\"data\"][number];\ntype ContractNFT = GetV1NftsByContractAddressResponse[\"data\"][number];\n\n/**\n * Get NFTs owned by an address\n * @example\n * ```ts\n * import { Insight } from \"thirdweb\";\n *\n * const nfts = await Insight.getOwnedNFTs({\n *   client,\n *   chains: [sepolia],\n *   ownerAddress: \"0x1234567890123456789012345678901234567890\",\n * });\n * ```\n * @insight\n */\nexport async function getOwnedNFTs(args: {\n  client: ThirdwebClient;\n  chains: Chain[];\n  ownerAddress: string;\n  contractAddresses?: string[];\n  includeMetadata?: boolean;\n  queryOptions?: Omit<GetV1NftsData[\"query\"], \"owner_address\" | \"chain\">;\n}): Promise<(NFT & { quantityOwned: bigint })[]> {\n  const [\n    { getV1Nfts },\n    { getThirdwebDomains },\n    { getClientFetch },\n    { assertInsightEnabled },\n    { stringify },\n  ] = await Promise.all([\n    import(\"@thirdweb-dev/insight\"),\n    import(\"../utils/domains.js\"),\n    import(\"../utils/fetch.js\"),\n    import(\"./common.js\"),\n    import(\"viem\"),\n  ]);\n\n  const { client, chains, ownerAddress, contractAddresses, queryOptions } =\n    args;\n\n  await assertInsightEnabled(chains);\n\n  const defaultQueryOptions: GetV1NftsData[\"query\"] = {\n    chain: chains.map((chain) => chain.id),\n    // metadata: includeMetadata ? \"true\" : \"false\", TODO (insight): add support for this\n    limit: 50,\n    owner_address: [ownerAddress],\n    contract_address: contractAddresses ? contractAddresses : undefined,\n  };\n\n  const result = await getV1Nfts({\n    baseUrl: `https://${getThirdwebDomains().insight}`,\n    fetch: getClientFetch(client),\n    query: {\n      ...defaultQueryOptions,\n      ...queryOptions,\n    },\n  });\n\n  if (result.error) {\n    throw new Error(\n      `${result.response.status} ${result.response.statusText} - ${result.error ? stringify(result.error) : \"Unknown error\"}`,\n    );\n  }\n\n  const transformedNfts = await transformNFTModel(\n    result.data?.data ?? [],\n    client,\n    ownerAddress,\n  );\n  return transformedNfts.map((nft) => ({\n    ...nft,\n    quantityOwned: nft.quantityOwned ?? 1n,\n  }));\n}\n\n/**\n * Get all NFTs from a contract\n * @example\n * ```ts\n * import { Insight } from \"thirdweb\";\n *\n * const nfts = await Insight.getContractNFTs({\n *   client,\n *   chains: [sepolia],\n *   contractAddress: \"0x1234567890123456789012345678901234567890\",\n * });\n * ```\n * @insight\n */\nexport async function getContractNFTs(args: {\n  client: ThirdwebClient;\n  chains: Chain[];\n  contractAddress: string;\n  includeMetadata?: boolean;\n  includeOwners?: boolean;\n  queryOptions?: Omit<GetV1NftsByContractAddressData[\"query\"], \"chain\">;\n}): Promise<NFT[]> {\n  const [\n    { getV1NftsByContractAddress },\n    { getThirdwebDomains },\n    { getClientFetch },\n    { assertInsightEnabled },\n    { stringify },\n  ] = await Promise.all([\n    import(\"@thirdweb-dev/insight\"),\n    import(\"../utils/domains.js\"),\n    import(\"../utils/fetch.js\"),\n    import(\"./common.js\"),\n    import(\"../utils/json.js\"),\n  ]);\n\n  const {\n    client,\n    chains,\n    contractAddress,\n    includeOwners = true,\n    queryOptions,\n  } = args;\n\n  const defaultQueryOptions: GetV1NftsByContractAddressData[\"query\"] = {\n    chain: chains.map((chain) => chain.id),\n    include_owners:\n      includeOwners === true ? (\"true\" as const) : (\"false\" as const),\n    // metadata: includeMetadata ? \"true\" : \"false\", TODO (insight): add support for this\n    limit: 50,\n  };\n\n  await assertInsightEnabled(chains);\n\n  const result = await getV1NftsByContractAddress({\n    baseUrl: `https://${getThirdwebDomains().insight}`,\n    fetch: getClientFetch(client),\n    path: {\n      contract_address: contractAddress,\n    },\n    query: {\n      ...defaultQueryOptions,\n      ...queryOptions,\n    },\n  });\n\n  if (result.error) {\n    throw new Error(\n      `${result.response.status} ${result.response.statusText} - ${result.error ? stringify(result.error) : \"Unknown error\"}`,\n    );\n  }\n\n  return transformNFTModel(result.data?.data ?? [], client);\n}\n\n/**\n * Get NFT metadata by contract address and token id\n * @example\n * ```ts\n * import { Insight } from \"thirdweb\";\n *\n * const nft = await Insight.getNFT({\n *   client,\n *   chain: sepolia,\n *   contractAddress: \"0x1234567890123456789012345678901234567890\",\n *   tokenId: 1n,\n * });\n * ```\n * @insight\n */\nexport async function getNFT(args: {\n  client: ThirdwebClient;\n  chain: Chain;\n  contractAddress: string;\n  tokenId: bigint | number | string;\n  includeOwners?: boolean;\n  queryOptions?: GetV1NftsByContractAddressByTokenIdData[\"query\"];\n}): Promise<NFT | undefined> {\n  const [\n    { getV1NftsByContractAddressByTokenId },\n    { getThirdwebDomains },\n    { getClientFetch },\n    { assertInsightEnabled },\n    { stringify },\n  ] = await Promise.all([\n    import(\"@thirdweb-dev/insight\"),\n    import(\"../utils/domains.js\"),\n    import(\"../utils/fetch.js\"),\n    import(\"./common.js\"),\n    import(\"../utils/json.js\"),\n  ]);\n\n  const {\n    client,\n    chain,\n    contractAddress,\n    tokenId,\n    includeOwners = true,\n    queryOptions,\n  } = args;\n\n  await assertInsightEnabled([chain]);\n\n  const defaultQueryOptions: GetV1NftsByContractAddressByTokenIdData[\"query\"] =\n    {\n      chain_id: [chain.id],\n      include_owners:\n        includeOwners === true ? (\"true\" as const) : (\"false\" as const),\n    };\n\n  const result = await getV1NftsByContractAddressByTokenId({\n    baseUrl: `https://${getThirdwebDomains().insight}`,\n    fetch: getClientFetch(client),\n    path: {\n      contract_address: contractAddress,\n      token_id: tokenId.toString(),\n    },\n    query: {\n      ...defaultQueryOptions,\n      ...queryOptions,\n    },\n  });\n\n  if (result.error) {\n    throw new Error(\n      `${result.response.status} ${result.response.statusText} - ${result.error ? stringify(result.error) : \"Unknown error\"}`,\n    );\n  }\n\n  const transformedNfts = await transformNFTModel(\n    result.data?.data ?? [],\n    client,\n  );\n  return transformedNfts?.[0];\n}\n\nasync function transformNFTModel(\n  nfts: (ContractNFT | OwnedNFT)[],\n  client: ThirdwebClient,\n  ownerAddress?: string,\n): Promise<(NFT & { quantityOwned?: bigint })[]> {\n  const [{ parseNFT }, { totalSupply }] = await Promise.all([\n    import(\"../utils/nft/parseNft.js\"),\n    import(\"../extensions/erc1155/__generated__/IERC1155/read/totalSupply.js\"),\n  ]);\n\n  return await Promise.all(\n    nfts.map(async (nft) => {\n      let parsedNft: NFT;\n      const {\n        contract,\n\n        // biome-ignore lint/correctness/noUnusedVariables: explicitly unused to not include it in the resulting metadata\n        extra_metadata,\n        // biome-ignore lint/correctness/noUnusedVariables: explicitly unused to not include it in the resulting metadata\n        collection,\n        metadata_url,\n        // biome-ignore lint/correctness/noUnusedVariables: explicitly unused to not include it in the resulting metadata\n        chain_id,\n        token_id,\n        // biome-ignore lint/correctness/noUnusedVariables: explicitly unused to not include it in the resulting metadata\n        status,\n        balance,\n        // biome-ignore lint/correctness/noUnusedVariables: explicitly unused to not include it in the resulting metadata\n        token_type,\n        ...rest\n      } = nft;\n\n      let metadataToUse = rest;\n      let owners: string[] | undefined = ownerAddress\n        ? [getAddress(ownerAddress)]\n        : undefined;\n\n      if (\"owner_addresses\" in rest) {\n        const { owner_addresses, ...restWithoutOwnerAddresses } = rest;\n        metadataToUse = restWithoutOwnerAddresses;\n        owners = owners ?? owner_addresses?.map((o) => getAddress(o));\n      }\n\n      const metadata = replaceIPFSGatewayRecursively({\n        attributes: nft.extra_metadata?.attributes ?? undefined,\n        image: nft.image_url,\n        uri: nft.metadata_url ?? \"\",\n        ...metadataToUse,\n      });\n\n      if (contract?.type === \"erc1155\") {\n        // TODO (insight): this needs to be added in the API\n        const supply = await totalSupply({\n          contract: getContract({\n            address: contract.address,\n            chain: getCachedChain(contract.chain_id),\n            client: client,\n          }),\n          id: BigInt(token_id),\n        }).catch(() => 0n);\n\n        parsedNft = parseNFT(metadata, {\n          chainId: contract?.chain_id ?? 0,\n          owner: owners?.[0],\n          supply: supply,\n          tokenAddress: contract?.address ?? \"\",\n          tokenId: BigInt(token_id),\n          tokenUri: replaceIPFSGateway(metadata_url) ?? \"\",\n          type: \"ERC1155\",\n        });\n      } else {\n        parsedNft = parseNFT(metadata, {\n          chainId: contract?.chain_id ?? 0,\n          owner: owners?.[0],\n          tokenAddress: contract?.address ?? \"\",\n          tokenId: BigInt(token_id),\n          tokenUri: replaceIPFSGateway(metadata_url) ?? \"\",\n          type: \"ERC721\",\n        });\n      }\n\n      return {\n        ...parsedNft,\n        ...(contract?.type === \"erc1155\"\n          ? { quantityOwned: balance ? BigInt(balance) : undefined }\n          : {}),\n      };\n    }),\n  );\n}\n\n// biome-ignore lint/suspicious/noExplicitAny: this should be fixed in the API\nfunction replaceIPFSGatewayRecursively(obj: any) {\n  if (typeof obj !== \"object\" || obj === null) {\n    return obj;\n  }\n  for (const key in obj) {\n    if (typeof obj[key] === \"string\") {\n      obj[key] = replaceIPFSGateway(obj[key]);\n    } else {\n      replaceIPFSGatewayRecursively(obj[key]);\n    }\n  }\n  return obj;\n}\n\nfunction replaceIPFSGateway(url?: string) {\n  if (!url || typeof url !== \"string\") {\n    return url;\n  }\n  try {\n    const parsedUrl = new URL(url);\n    if (parsedUrl.host.endsWith(\".ipfscdn.io\")) {\n      const paths = parsedUrl.pathname.split(\"/\");\n      const index = paths.findIndex((path) => path === \"ipfs\");\n      if (index === -1) {\n        return url;\n      }\n      const ipfsHash = paths.slice(index + 1).join(\"/\");\n      if (ipfsHash) {\n        return `ipfs://${ipfsHash}`;\n      }\n      return url;\n    }\n  } catch {\n    // If the URL is invalid, return it as is\n    return url;\n  }\n  return url;\n}\n"],"mappings":";;;;AAQA,SAASA,cAAc,QAAQ,oBAAoB;AAEnD,SAASC,WAAW,QAAQ,yBAAyB;AACrD,SAASC,UAAU,QAAQ,qBAAqB;AAMhD;;;;;;;;;;;;;;AAcA,OAAO,eAAeC,YAAYA,CAACC,IAOlC;EAAA,IAAAC,iBAAA,EAAAC,YAAA;EACC,MAAM,CACJ;IAAEC;EAAS,CAAE,EACb;IAAEC;EAAkB,CAAE,EACtB;IAAEC;EAAc,CAAE,EAClB;IAAEC;EAAoB,CAAE,EACxB;IAAEC;EAAS,CAAE,CACd,GAAG,MAAMC,OAAO,CAACC,GAAG,CAAC,CACpB,MAAM,CAAC,uBAAuB,CAAC,EAC/B,MAAM,CAAC,qBAAqB,CAAC,EAC7B,MAAM,CAAC,mBAAmB,CAAC,EAC3B,MAAM,CAAC,aAAa,CAAC,EACrB,MAAM,CAAC,MAAM,CAAC,CACf,CAAC;EAEF,MAAM;IAAEC,MAAM;IAAEC,MAAM;IAAEC,YAAY;IAAEC,iBAAiB;IAAEC;EAAY,CAAE,GACrEd,IAAI;EAEN,MAAMM,oBAAoB,CAACK,MAAM,CAAC;EAElC,MAAMI,mBAAmB,GAA2B;IAClDC,KAAK,EAAEL,MAAM,CAACM,GAAG,CAAED,KAAK,IAAKA,KAAK,CAACE,EAAE,CAAC;IACtC;IACAC,KAAK,EAAE,EAAE;IACTC,aAAa,EAAE,CAACR,YAAY,CAAC;IAC7BS,gBAAgB,EAAER,iBAAiB,GAAGA,iBAAiB,GAAGS;GAC3D;EAED,MAAMC,MAAM,GAAG,MAAMpB,SAAS,CAAC;IAC7BqB,OAAO,aAAAC,MAAA,CAAarB,kBAAkB,EAAE,CAACsB,OAAO,CAAE;IAClDC,KAAK,EAAEtB,cAAc,CAACK,MAAM,CAAC;IAC7BkB,KAAK,EAAAC,aAAA,CAAAA,aAAA,KACAd,mBAAmB,GACnBD,YAAY;GAElB,CAAC;EAEF,IAAIS,MAAM,CAACO,KAAK,EAAE;IAChB,MAAM,IAAIC,KAAK,IAAAN,MAAA,CACVF,MAAM,CAACS,QAAQ,CAACC,MAAM,OAAAR,MAAA,CAAIF,MAAM,CAACS,QAAQ,CAACE,UAAU,SAAAT,MAAA,CAAMF,MAAM,CAACO,KAAK,GAAGvB,SAAS,CAACgB,MAAM,CAACO,KAAK,CAAC,GAAG,eAAe,CAAE,CACxH;EACH;EAEA,MAAMK,eAAe,GAAG,MAAMC,iBAAiB,EAAAnC,iBAAA,IAAAC,YAAA,GAC7CqB,MAAM,CAACc,IAAI,cAAAnC,YAAA,uBAAXA,YAAA,CAAamC,IAAI,cAAApC,iBAAA,cAAAA,iBAAA,GAAI,EAAE,EACvBS,MAAM,EACNE,YAAY,CACb;EACD,OAAOuB,eAAe,CAAClB,GAAG,CAAEqB,GAAG;IAAA,IAAAC,kBAAA;IAAA,OAAAV,aAAA,CAAAA,aAAA,KAC1BS,GAAG;MACNE,aAAa,GAAAD,kBAAA,GAAED,GAAG,CAACE,aAAa,cAAAD,kBAAA,cAAAA,kBAAA,GAAI;IAAE;EAAA,CACtC,CAAC;AACL;AAEA;;;;;;;;;;;;;;AAcA,OAAO,eAAeE,eAAeA,CAACzC,IAOrC;EAAA,IAAA0C,kBAAA,EAAAC,aAAA;EACC,MAAM,CACJ;IAAEC;EAA0B,CAAE,EAC9B;IAAExC;EAAkB,CAAE,EACtB;IAAEC;EAAc,CAAE,EAClB;IAAEC;EAAoB,CAAE,EACxB;IAAEC;EAAS,CAAE,CACd,GAAG,MAAMC,OAAO,CAACC,GAAG,CAAC,CACpB,MAAM,CAAC,uBAAuB,CAAC,EAC/B,MAAM,CAAC,qBAAqB,CAAC,EAC7B,MAAM,CAAC,mBAAmB,CAAC,EAC3B,MAAM,CAAC,aAAa,CAAC,EACrB,MAAM,CAAC,kBAAkB,CAAC,CAC3B,CAAC;EAEF,MAAM;IACJC,MAAM;IACNC,MAAM;IACNkC,eAAe;IACfC,aAAa,GAAG,IAAI;IACpBhC;EAAY,CACb,GAAGd,IAAI;EAER,MAAMe,mBAAmB,GAA4C;IACnEC,KAAK,EAAEL,MAAM,CAACM,GAAG,CAAED,KAAK,IAAKA,KAAK,CAACE,EAAE,CAAC;IACtC6B,cAAc,EACZD,aAAa,KAAK,IAAI,GAAI,MAAgB,GAAI,OAAiB;IACjE;IACA3B,KAAK,EAAE;GACR;EAED,MAAMb,oBAAoB,CAACK,MAAM,CAAC;EAElC,MAAMY,MAAM,GAAG,MAAMqB,0BAA0B,CAAC;IAC9CpB,OAAO,aAAAC,MAAA,CAAarB,kBAAkB,EAAE,CAACsB,OAAO,CAAE;IAClDC,KAAK,EAAEtB,cAAc,CAACK,MAAM,CAAC;IAC7BsC,IAAI,EAAE;MACJ3B,gBAAgB,EAAEwB;KACnB;IACDjB,KAAK,EAAAC,aAAA,CAAAA,aAAA,KACAd,mBAAmB,GACnBD,YAAY;GAElB,CAAC;EAEF,IAAIS,MAAM,CAACO,KAAK,EAAE;IAChB,MAAM,IAAIC,KAAK,IAAAN,MAAA,CACVF,MAAM,CAACS,QAAQ,CAACC,MAAM,OAAAR,MAAA,CAAIF,MAAM,CAACS,QAAQ,CAACE,UAAU,SAAAT,MAAA,CAAMF,MAAM,CAACO,KAAK,GAAGvB,SAAS,CAACgB,MAAM,CAACO,KAAK,CAAC,GAAG,eAAe,CAAE,CACxH;EACH;EAEA,OAAOM,iBAAiB,EAAAM,kBAAA,IAAAC,aAAA,GAACpB,MAAM,CAACc,IAAI,cAAAM,aAAA,uBAAXA,aAAA,CAAaN,IAAI,cAAAK,kBAAA,cAAAA,kBAAA,GAAI,EAAE,EAAEhC,MAAM,CAAC;AAC3D;AAEA;;;;;;;;;;;;;;;AAeA,OAAO,eAAeuC,MAAMA,CAACjD,IAO5B;EAAA,IAAAkD,kBAAA,EAAAC,aAAA;EACC,MAAM,CACJ;IAAEC;EAAmC,CAAE,EACvC;IAAEhD;EAAkB,CAAE,EACtB;IAAEC;EAAc,CAAE,EAClB;IAAEC;EAAoB,CAAE,EACxB;IAAEC;EAAS,CAAE,CACd,GAAG,MAAMC,OAAO,CAACC,GAAG,CAAC,CACpB,MAAM,CAAC,uBAAuB,CAAC,EAC/B,MAAM,CAAC,qBAAqB,CAAC,EAC7B,MAAM,CAAC,mBAAmB,CAAC,EAC3B,MAAM,CAAC,aAAa,CAAC,EACrB,MAAM,CAAC,kBAAkB,CAAC,CAC3B,CAAC;EAEF,MAAM;IACJC,MAAM;IACNM,KAAK;IACL6B,eAAe;IACfQ,OAAO;IACPP,aAAa,GAAG,IAAI;IACpBhC;EAAY,CACb,GAAGd,IAAI;EAER,MAAMM,oBAAoB,CAAC,CAACU,KAAK,CAAC,CAAC;EAEnC,MAAMD,mBAAmB,GACvB;IACEuC,QAAQ,EAAE,CAACtC,KAAK,CAACE,EAAE,CAAC;IACpB6B,cAAc,EACZD,aAAa,KAAK,IAAI,GAAI,MAAgB,GAAI;GACjD;EAEH,MAAMvB,MAAM,GAAG,MAAM6B,mCAAmC,CAAC;IACvD5B,OAAO,aAAAC,MAAA,CAAarB,kBAAkB,EAAE,CAACsB,OAAO,CAAE;IAClDC,KAAK,EAAEtB,cAAc,CAACK,MAAM,CAAC;IAC7BsC,IAAI,EAAE;MACJ3B,gBAAgB,EAAEwB,eAAe;MACjCU,QAAQ,EAAEF,OAAO,CAACG,QAAQ;KAC3B;IACD5B,KAAK,EAAAC,aAAA,CAAAA,aAAA,KACAd,mBAAmB,GACnBD,YAAY;GAElB,CAAC;EAEF,IAAIS,MAAM,CAACO,KAAK,EAAE;IAChB,MAAM,IAAIC,KAAK,IAAAN,MAAA,CACVF,MAAM,CAACS,QAAQ,CAACC,MAAM,OAAAR,MAAA,CAAIF,MAAM,CAACS,QAAQ,CAACE,UAAU,SAAAT,MAAA,CAAMF,MAAM,CAACO,KAAK,GAAGvB,SAAS,CAACgB,MAAM,CAACO,KAAK,CAAC,GAAG,eAAe,CAAE,CACxH;EACH;EAEA,MAAMK,eAAe,GAAG,MAAMC,iBAAiB,EAAAc,kBAAA,IAAAC,aAAA,GAC7C5B,MAAM,CAACc,IAAI,cAAAc,aAAA,uBAAXA,aAAA,CAAad,IAAI,cAAAa,kBAAA,cAAAA,kBAAA,GAAI,EAAE,EACvBxC,MAAM,CACP;EACD,OAAOyB,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAG,CAAC,CAAC;AAC7B;AAEA,eAAeC,iBAAiBA,CAC9BqB,IAAgC,EAChC/C,MAAsB,EACtBE,YAAqB;EAErB,MAAM,CAAC;IAAE8C;EAAQ,CAAE,EAAE;IAAEC;EAAW,CAAE,CAAC,GAAG,MAAMnD,OAAO,CAACC,GAAG,CAAC,CACxD,MAAM,CAAC,0BAA0B,CAAC,EAClC,MAAM,CAAC,kEAAkE,CAAC,CAC3E,CAAC;EAEF,OAAO,MAAMD,OAAO,CAACC,GAAG,CACtBgD,IAAI,CAACxC,GAAG,CAAC,MAAOqB,GAAG,IAAI;IAAA,IAAAsB,qBAAA,EAAAC,mBAAA,EAAAC,iBAAA;IACrB,IAAIC,SAAc;IAClB,MAAM;QACJC,QAAQ;QAER;QACAC,cAAc;QACd;QACAC,UAAU;QACVC,YAAY;QACZ;QACAb,QAAQ;QACRC,QAAQ;QACR;QACAtB,MAAM;QACNmC,OAAO;QACP;QACAC;MACO,CACR,GAAG/B,GAAG;MADFgC,IAAI,GAAAC,wBAAA,CACLjC,GAAG,EAAAkC,SAAA;IAEP,IAAIC,aAAa,GAAGH,IAAI;IACxB,IAAII,MAAM,GAAyB9D,YAAY,GAC3C,CAACd,UAAU,CAACc,YAAY,CAAC,CAAC,GAC1BU,SAAS;IAEb,IAAI,iBAAiB,IAAIgD,IAAI,EAAE;MAC7B,MAAM;UAAEK;QAA6C,CAAE,GAAGL,IAAI;QAAlCM,yBAAyB,GAAAL,wBAAA,CAAKD,IAAI,EAAAO,UAAA;MAC9DJ,aAAa,GAAGG,yBAAyB;MACzCF,MAAM,GAAGA,MAAM,aAANA,MAAM,cAANA,MAAM,GAAIC,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAE1D,GAAG,CAAE6D,CAAC,IAAKhF,UAAU,CAACgF,CAAC,CAAC,CAAC;IAC/D;IAEA,MAAMC,QAAQ,GAAGC,6BAA6B,CAAAnD,aAAA;MAC5CoD,UAAU,GAAArB,qBAAA,IAAAC,mBAAA,GAAEvB,GAAG,CAAC2B,cAAc,cAAAJ,mBAAA,uBAAlBA,mBAAA,CAAoBoB,UAAU,cAAArB,qBAAA,cAAAA,qBAAA,GAAItC,SAAS;MACvD4D,KAAK,EAAE5C,GAAG,CAAC6C,SAAS;MACpBC,GAAG,GAAAtB,iBAAA,GAAExB,GAAG,CAAC6B,YAAY,cAAAL,iBAAA,cAAAA,iBAAA,GAAI;IAAE,GACxBW,aAAa,CACjB,CAAC;IAEF,IAAI,CAAAT,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEqB,IAAI,MAAK,SAAS,EAAE;MAAA,IAAAC,kBAAA,EAAAC,OAAA,EAAAC,iBAAA,EAAAC,mBAAA;MAChC;MACA,MAAMC,MAAM,GAAG,MAAM/B,WAAW,CAAC;QAC/BK,QAAQ,EAAEnE,WAAW,CAAC;UACpB8F,OAAO,EAAE3B,QAAQ,CAAC2B,OAAO;UACzB3E,KAAK,EAAEpB,cAAc,CAACoE,QAAQ,CAACV,QAAQ,CAAC;UACxC5C,MAAM,EAAEA;SACT,CAAC;QACFQ,EAAE,EAAE0E,MAAM,CAACrC,QAAQ;OACpB,CAAC,CAACsC,KAAK,CAAC,MAAM,EAAE,CAAC;MAElB9B,SAAS,GAAGL,QAAQ,CAACqB,QAAQ,EAAE;QAC7Be,OAAO,GAAAR,kBAAA,GAAEtB,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEV,QAAQ,cAAAgC,kBAAA,cAAAA,kBAAA,GAAI,CAAC;QAChCS,KAAK,GAAAR,OAAA,GAAEb,MAAM,cAAAa,OAAA,uBAANA,OAAA,CAAS,CAAC,CAAC;QAClBG,MAAM,EAAEA,MAAM;QACdM,YAAY,GAAAR,iBAAA,GAAExB,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAE2B,OAAO,cAAAH,iBAAA,cAAAA,iBAAA,GAAI,EAAE;QACrCnC,OAAO,EAAEuC,MAAM,CAACrC,QAAQ,CAAC;QACzB0C,QAAQ,GAAAR,mBAAA,GAAES,kBAAkB,CAAC/B,YAAY,CAAC,cAAAsB,mBAAA,cAAAA,mBAAA,GAAI,EAAE;QAChDJ,IAAI,EAAE;OACP,CAAC;IACJ,CAAC,MAAM;MAAA,IAAAc,mBAAA,EAAAC,QAAA,EAAAC,kBAAA,EAAAC,oBAAA;MACLvC,SAAS,GAAGL,QAAQ,CAACqB,QAAQ,EAAE;QAC7Be,OAAO,GAAAK,mBAAA,GAAEnC,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEV,QAAQ,cAAA6C,mBAAA,cAAAA,mBAAA,GAAI,CAAC;QAChCJ,KAAK,GAAAK,QAAA,GAAE1B,MAAM,cAAA0B,QAAA,uBAANA,QAAA,CAAS,CAAC,CAAC;QAClBJ,YAAY,GAAAK,kBAAA,GAAErC,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAE2B,OAAO,cAAAU,kBAAA,cAAAA,kBAAA,GAAI,EAAE;QACrChD,OAAO,EAAEuC,MAAM,CAACrC,QAAQ,CAAC;QACzB0C,QAAQ,GAAAK,oBAAA,GAAEJ,kBAAkB,CAAC/B,YAAY,CAAC,cAAAmC,oBAAA,cAAAA,oBAAA,GAAI,EAAE;QAChDjB,IAAI,EAAE;OACP,CAAC;IACJ;IAEA,OAAAxD,aAAA,CAAAA,aAAA,KACKkC,SAAS,GACR,CAAAC,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEqB,IAAI,MAAK,SAAS,GAC5B;MAAE7C,aAAa,EAAE4B,OAAO,GAAGwB,MAAM,CAACxB,OAAO,CAAC,GAAG9C;IAAS,CAAE,GACxD,EAAE;EAEV,CAAC,CAAC,CACH;AACH;AAEA;AACA,SAAS0D,6BAA6BA,CAACuB,GAAQ;EAC7C,IAAI,OAAOA,GAAG,KAAK,QAAQ,IAAIA,GAAG,KAAK,IAAI,EAAE;IAC3C,OAAOA,GAAG;EACZ;EACA,KAAK,MAAMC,GAAG,IAAID,GAAG,EAAE;IACrB,IAAI,OAAOA,GAAG,CAACC,GAAG,CAAC,KAAK,QAAQ,EAAE;MAChCD,GAAG,CAACC,GAAG,CAAC,GAAGN,kBAAkB,CAACK,GAAG,CAACC,GAAG,CAAC,CAAC;IACzC,CAAC,MAAM;MACLxB,6BAA6B,CAACuB,GAAG,CAACC,GAAG,CAAC,CAAC;IACzC;EACF;EACA,OAAOD,GAAG;AACZ;AAEA,SAASL,kBAAkBA,CAACO,GAAY;EACtC,IAAI,CAACA,GAAG,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;IACnC,OAAOA,GAAG;EACZ;EACA,IAAI;IACF,MAAMC,SAAS,GAAG,IAAIC,GAAG,CAACF,GAAG,CAAC;IAC9B,IAAIC,SAAS,CAACE,IAAI,CAACC,QAAQ,CAAC,aAAa,CAAC,EAAE;MAC1C,MAAMC,KAAK,GAAGJ,SAAS,CAACK,QAAQ,CAACC,KAAK,CAAC,GAAG,CAAC;MAC3C,MAAMC,KAAK,GAAGH,KAAK,CAACI,SAAS,CAAElE,IAAI,IAAKA,IAAI,KAAK,MAAM,CAAC;MACxD,IAAIiE,KAAK,KAAK,CAAC,CAAC,EAAE;QAChB,OAAOR,GAAG;MACZ;MACA,MAAMU,QAAQ,GAAGL,KAAK,CAACM,KAAK,CAACH,KAAK,GAAG,CAAC,CAAC,CAACI,IAAI,CAAC,GAAG,CAAC;MACjD,IAAIF,QAAQ,EAAE;QACZ,iBAAA1F,MAAA,CAAiB0F,QAAQ;MAC3B;MACA,OAAOV,GAAG;IACZ;EACF,CAAC,CAAC,OAAAa,OAAA,EAAM;IACN;IACA,OAAOb,GAAG;EACZ;EACA,OAAOA,GAAG;AACZ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}