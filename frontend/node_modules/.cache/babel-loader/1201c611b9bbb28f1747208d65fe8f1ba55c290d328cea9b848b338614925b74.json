{"ast":null,"code":"import { ethereum } from \"../../chains/chain-definitions/ethereum.js\";\nimport { getContract } from \"../../contract/contract.js\";\nimport { toHex } from \"../../utils/encoding/hex.js\";\nimport { namehash } from \"../../utils/ens/namehash.js\";\nimport { packetToBytes } from \"../../utils/ens/packetToBytes.js\";\nimport { withCache } from \"../../utils/promise/withCache.js\";\nimport { decodeTextResult, encodeText } from \"./__generated__/AddressResolver/read/text.js\";\nimport { resolve } from \"./__generated__/UniversalResolver/read/resolve.js\";\nimport { UNIVERSAL_RESOLVER_ADDRESS } from \"./constants.js\";\n/**\n * Resolves an ENS name and key to the specified record.\n * @param options - The options for resolving an ENS address.\n * @example\n * ```ts\n * import { resolveText } from \"thirdweb/extensions/ens\";\n * const twitterUsername = await resolveText({\n *    client,\n *    name: \"vitalik.eth\",\n *    key: \"com.twitter\"\n * });\n * ```\n * @extension ENS\n * @returns A promise that resolves to the text record.\n */\nexport async function resolveText(options) {\n  const {\n    client,\n    name,\n    key,\n    resolverAddress,\n    resolverChain\n  } = options;\n  return withCache(async () => {\n    const contract = getContract({\n      address: resolverAddress || UNIVERSAL_RESOLVER_ADDRESS,\n      chain: resolverChain || ethereum,\n      client\n    });\n    const data = encodeText({\n      key,\n      name: namehash(name)\n    });\n    const result = await resolve({\n      contract,\n      data,\n      name: toHex(packetToBytes(name))\n    });\n    if (result[0] === \"0x\") {\n      return null;\n    }\n    const record = decodeTextResult(result[0]);\n    return record === \"\" ? null : record;\n  }, {\n    cacheKey: \"ens:text:\".concat(name, \":\").concat(key),\n    // 1min cache\n    cacheTime: 60 * 1000\n  });\n}","map":{"version":3,"names":["ethereum","getContract","toHex","namehash","packetToBytes","withCache","decodeTextResult","encodeText","resolve","UNIVERSAL_RESOLVER_ADDRESS","resolveText","options","client","name","key","resolverAddress","resolverChain","contract","address","chain","data","result","record","cacheKey","concat","cacheTime"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/extensions/ens/resolve-text.ts"],"sourcesContent":["import { ethereum } from \"../../chains/chain-definitions/ethereum.js\";\nimport type { Chain } from \"../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { getContract } from \"../../contract/contract.js\";\nimport { toHex } from \"../../utils/encoding/hex.js\";\nimport { namehash } from \"../../utils/ens/namehash.js\";\nimport { packetToBytes } from \"../../utils/ens/packetToBytes.js\";\nimport { withCache } from \"../../utils/promise/withCache.js\";\nimport {\n  decodeTextResult,\n  encodeText,\n} from \"./__generated__/AddressResolver/read/text.js\";\nimport { resolve } from \"./__generated__/UniversalResolver/read/resolve.js\";\nimport { UNIVERSAL_RESOLVER_ADDRESS } from \"./constants.js\";\n\n/**\n * @extension ENS\n */\nexport type ResolveTextOptions = {\n  client: ThirdwebClient;\n  name: string;\n  key: string;\n  resolverAddress?: string;\n  resolverChain?: Chain;\n};\n\n/**\n * Resolves an ENS name and key to the specified record.\n * @param options - The options for resolving an ENS address.\n * @example\n * ```ts\n * import { resolveText } from \"thirdweb/extensions/ens\";\n * const twitterUsername = await resolveText({\n *    client,\n *    name: \"vitalik.eth\",\n *    key: \"com.twitter\"\n * });\n * ```\n * @extension ENS\n * @returns A promise that resolves to the text record.\n */\nexport async function resolveText(options: ResolveTextOptions) {\n  const { client, name, key, resolverAddress, resolverChain } = options;\n  return withCache(\n    async () => {\n      const contract = getContract({\n        address: resolverAddress || UNIVERSAL_RESOLVER_ADDRESS,\n        chain: resolverChain || ethereum,\n        client,\n      });\n\n      const data = encodeText({ key, name: namehash(name) });\n\n      const result = await resolve({\n        contract,\n        data,\n        name: toHex(packetToBytes(name)),\n      });\n\n      if (result[0] === \"0x\") {\n        return null;\n      }\n\n      const record = decodeTextResult(result[0]);\n\n      return record === \"\" ? null : record;\n    },\n    {\n      cacheKey: `ens:text:${name}:${key}`,\n      // 1min cache\n      cacheTime: 60 * 1000,\n    },\n  );\n}\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,4CAA4C;AAGrE,SAASC,WAAW,QAAQ,4BAA4B;AACxD,SAASC,KAAK,QAAQ,6BAA6B;AACnD,SAASC,QAAQ,QAAQ,6BAA6B;AACtD,SAASC,aAAa,QAAQ,kCAAkC;AAChE,SAASC,SAAS,QAAQ,kCAAkC;AAC5D,SACEC,gBAAgB,EAChBC,UAAU,QACL,8CAA8C;AACrD,SAASC,OAAO,QAAQ,mDAAmD;AAC3E,SAASC,0BAA0B,QAAQ,gBAAgB;AAa3D;;;;;;;;;;;;;;;AAeA,OAAO,eAAeC,WAAWA,CAACC,OAA2B;EAC3D,MAAM;IAAEC,MAAM;IAAEC,IAAI;IAAEC,GAAG;IAAEC,eAAe;IAAEC;EAAa,CAAE,GAAGL,OAAO;EACrE,OAAON,SAAS,CACd,YAAW;IACT,MAAMY,QAAQ,GAAGhB,WAAW,CAAC;MAC3BiB,OAAO,EAAEH,eAAe,IAAIN,0BAA0B;MACtDU,KAAK,EAAEH,aAAa,IAAIhB,QAAQ;MAChCY;KACD,CAAC;IAEF,MAAMQ,IAAI,GAAGb,UAAU,CAAC;MAAEO,GAAG;MAAED,IAAI,EAAEV,QAAQ,CAACU,IAAI;IAAC,CAAE,CAAC;IAEtD,MAAMQ,MAAM,GAAG,MAAMb,OAAO,CAAC;MAC3BS,QAAQ;MACRG,IAAI;MACJP,IAAI,EAAEX,KAAK,CAACE,aAAa,CAACS,IAAI,CAAC;KAChC,CAAC;IAEF,IAAIQ,MAAM,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;MACtB,OAAO,IAAI;IACb;IAEA,MAAMC,MAAM,GAAGhB,gBAAgB,CAACe,MAAM,CAAC,CAAC,CAAC,CAAC;IAE1C,OAAOC,MAAM,KAAK,EAAE,GAAG,IAAI,GAAGA,MAAM;EACtC,CAAC,EACD;IACEC,QAAQ,cAAAC,MAAA,CAAcX,IAAI,OAAAW,MAAA,CAAIV,GAAG,CAAE;IACnC;IACAW,SAAS,EAAE,EAAE,GAAG;GACjB,CACF;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}