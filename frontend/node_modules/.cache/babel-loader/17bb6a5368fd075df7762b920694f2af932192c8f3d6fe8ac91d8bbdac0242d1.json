{"ast":null,"code":"import { getContract } from \"../../../../contract/contract.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nimport { readContract } from \"../../../read-contract.js\";\nimport { waitForReceipt } from \"../../wait-for-tx-receipt.js\";\n/**\n * @internal - only exported for testing\n */\nexport async function prepareEngineTransaction(_ref) {\n  let {\n    account,\n    serializableTransaction,\n    transaction,\n    gasless\n  } = _ref;\n  const forrwaderContract = getContract({\n    address: gasless.relayerForwarderAddress,\n    chain: transaction.chain,\n    client: transaction.client\n  });\n  const nonce = await readContract({\n    contract: forrwaderContract,\n    method: \"function getNonce(address) view returns (uint256)\",\n    params: [account.address]\n  });\n  const [signature, message] = await (async (_gasless$domainName, _gasless$domainVersio) => {\n    // TODO: handle special case for `approve` -> `permit` transactions\n    if (!serializableTransaction.to) {\n      throw new Error(\"engine transactions must have a 'to' address\");\n    }\n    if (!serializableTransaction.gas) {\n      throw new Error(\"engine transactions must have a 'gas' value\");\n    }\n    if (!serializableTransaction.data) {\n      throw new Error(\"engine transactions must have a 'data' value\");\n    }\n    // chainless support!\n    if (gasless.experimentalChainlessSupport) {\n      const message = {\n        chainid: BigInt(transaction.chain.id),\n        data: serializableTransaction.data,\n        from: account.address,\n        gas: serializableTransaction.gas,\n        nonce: nonce,\n        to: serializableTransaction.to,\n        value: 0n\n      };\n      return [await account.signTypedData({\n        domain: {\n          name: \"GSNv2 Forwarder\",\n          verifyingContract: forrwaderContract.address,\n          version: \"0.0.1\"\n        },\n        message,\n        primaryType: \"ForwardRequest\",\n        types: {\n          ForwardRequest: ChainAwareForwardRequest\n        }\n      }), message];\n    }\n    // else non-chainless support\n    const message = {\n      data: serializableTransaction.data,\n      from: account.address,\n      gas: serializableTransaction.gas,\n      nonce: nonce,\n      to: serializableTransaction.to,\n      value: 0n\n    };\n    return [await account.signTypedData({\n      domain: {\n        chainId: transaction.chain.id,\n        name: (_gasless$domainName = gasless.domainName) !== null && _gasless$domainName !== void 0 ? _gasless$domainName : \"GSNv2 Forwarder\",\n        verifyingContract: forrwaderContract.address,\n        version: (_gasless$domainVersio = gasless.domainVersion) !== null && _gasless$domainVersio !== void 0 ? _gasless$domainVersio : \"0.0.1\"\n      },\n      message,\n      primaryType: \"ForwardRequest\",\n      types: {\n        ForwardRequest\n      }\n    }), message];\n  })();\n  // TODO: handle special case for `approve` -> `permit`\n  const messageType = \"forward\";\n  return {\n    message,\n    messageType,\n    signature\n  };\n}\nconst ForwardRequest = [{\n  name: \"from\",\n  type: \"address\"\n}, {\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"value\",\n  type: \"uint256\"\n}, {\n  name: \"gas\",\n  type: \"uint256\"\n}, {\n  name: \"nonce\",\n  type: \"uint256\"\n}, {\n  name: \"data\",\n  type: \"bytes\"\n}];\nconst ChainAwareForwardRequest = [{\n  name: \"from\",\n  type: \"address\"\n}, {\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"value\",\n  type: \"uint256\"\n}, {\n  name: \"gas\",\n  type: \"uint256\"\n}, {\n  name: \"nonce\",\n  type: \"uint256\"\n}, {\n  name: \"data\",\n  type: \"bytes\"\n}, {\n  name: \"chainid\",\n  type: \"uint256\"\n}];\n/**\n * @internal\n */\nexport async function relayEngineTransaction(options) {\n  const {\n    message,\n    messageType,\n    signature\n  } = await prepareEngineTransaction(options);\n  const response = await fetch(options.gasless.relayerUrl, {\n    body: stringify({\n      forwarderAddress: options.gasless.relayerForwarderAddress,\n      request: message,\n      signature,\n      type: messageType\n    }),\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    method: \"POST\"\n  });\n  if (!response.ok) {\n    throw new Error(\"Failed to send transaction: \".concat(await response.text()));\n  }\n  const json = await response.json();\n  if (!json.result) {\n    throw new Error(\"Relay transaction failed: \".concat(json.message));\n  }\n  const queueId = json.result.queueId;\n  // poll for transactionHash\n  const timeout = 60000;\n  const interval = 1000;\n  const endtime = Date.now() + timeout;\n  while (Date.now() < endtime) {\n    const receipt = await fetchReceipt({\n      options,\n      queueId\n    });\n    if (receipt) {\n      return {\n        chain: options.transaction.chain,\n        client: options.transaction.client,\n        transactionHash: receipt.transactionHash\n      };\n    }\n    await new Promise(resolve => setTimeout(resolve, interval));\n  }\n  throw new Error(\"Failed to find relayed transaction after \".concat(timeout, \"ms\"));\n}\nasync function fetchReceipt(args) {\n  const {\n    options,\n    queueId\n  } = args;\n  const url = options.gasless.relayerUrl.split(\"/relayer/\")[0];\n  const res = await fetch(\"\".concat(url, \"/transaction/status/\").concat(queueId), {\n    method: \"GET\"\n  });\n  const resJson = await res.json();\n  if (!res.ok) {\n    return null;\n  }\n  const result = resJson.result;\n  if (!result) {\n    return null;\n  }\n  switch (result.status) {\n    case \"errored\":\n      throw new Error(\"Transaction errored with reason: \".concat(result.errorMessage));\n    case \"cancelled\":\n      throw new Error(\"Transaction execution cancelled.\");\n    case \"mined\":\n      {\n        const receipt = await waitForReceipt({\n          chain: options.transaction.chain,\n          client: options.transaction.client,\n          transactionHash: result.transactionHash\n        });\n        return receipt;\n      }\n    default:\n      {\n        return null;\n      }\n  }\n}","map":{"version":3,"names":["getContract","stringify","readContract","waitForReceipt","prepareEngineTransaction","_ref","account","serializableTransaction","transaction","gasless","forrwaderContract","address","relayerForwarderAddress","chain","client","nonce","contract","method","params","signature","message","_gasless$domainName","_gasless$domainVersio","to","Error","gas","data","experimentalChainlessSupport","chainid","BigInt","id","from","value","signTypedData","domain","name","verifyingContract","version","primaryType","types","ForwardRequest","ChainAwareForwardRequest","chainId","domainName","domainVersion","messageType","type","relayEngineTransaction","options","response","fetch","relayerUrl","body","forwarderAddress","request","headers","ok","concat","text","json","result","queueId","timeout","interval","endtime","Date","now","receipt","fetchReceipt","transactionHash","Promise","resolve","setTimeout","args","url","split","res","resJson","status","errorMessage"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/transaction/actions/gasless/providers/engine.ts"],"sourcesContent":["import type { Address } from \"abitype\";\nimport { getContract } from \"../../../../contract/contract.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nimport type { Account } from \"../../../../wallets/interfaces/wallet.js\";\nimport type { PreparedTransaction } from \"../../../prepare-transaction.js\";\nimport { readContract } from \"../../../read-contract.js\";\nimport type { SerializableTransaction } from \"../../../serialize-transaction.js\";\nimport {\n  type WaitForReceiptOptions,\n  waitForReceipt,\n} from \"../../wait-for-tx-receipt.js\";\n\n/**\n * @transaction\n */\nexport type EngineOptions = {\n  provider: \"engine\";\n  relayerUrl: string;\n  relayerForwarderAddress: Address;\n  domainName?: string; // default: \"GSNv2 Forwarder\"\n  domainVersion?: string; // default: \"0.0.1\"\n  domainSeparatorVersion?: string; // default: \"1\"\n  experimentalChainlessSupport?: boolean; // default: false\n};\n\ntype SendengineTransactionOptions = {\n  account: Account;\n  // TODO: update this to `Transaction<\"prepared\">` once the type is available to ensure only prepared transactions are accepted\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any prepared transaction type\n  transaction: PreparedTransaction<any>;\n  serializableTransaction: SerializableTransaction;\n  gasless: EngineOptions;\n};\n\n/**\n * @internal - only exported for testing\n */\nexport async function prepareEngineTransaction({\n  account,\n  serializableTransaction,\n  transaction,\n  gasless,\n}: SendengineTransactionOptions) {\n  const forrwaderContract = getContract({\n    address: gasless.relayerForwarderAddress,\n    chain: transaction.chain,\n    client: transaction.client,\n  });\n\n  const nonce = await readContract({\n    contract: forrwaderContract,\n    method: \"function getNonce(address) view returns (uint256)\",\n    params: [account.address],\n  });\n\n  const [signature, message] = await (async () => {\n    // TODO: handle special case for `approve` -> `permit` transactions\n\n    if (!serializableTransaction.to) {\n      throw new Error(\"engine transactions must have a 'to' address\");\n    }\n    if (!serializableTransaction.gas) {\n      throw new Error(\"engine transactions must have a 'gas' value\");\n    }\n    if (!serializableTransaction.data) {\n      throw new Error(\"engine transactions must have a 'data' value\");\n    }\n    // chainless support!\n    if (gasless.experimentalChainlessSupport) {\n      const message = {\n        chainid: BigInt(transaction.chain.id),\n        data: serializableTransaction.data,\n        from: account.address,\n        gas: serializableTransaction.gas,\n        nonce: nonce,\n        to: serializableTransaction.to,\n        value: 0n,\n      } as const;\n      return [\n        await account.signTypedData({\n          domain: {\n            name: \"GSNv2 Forwarder\",\n            verifyingContract: forrwaderContract.address,\n            version: \"0.0.1\",\n          },\n          message,\n          primaryType: \"ForwardRequest\",\n          types: { ForwardRequest: ChainAwareForwardRequest },\n        }),\n        message,\n      ] as const;\n    }\n    // else non-chainless support\n    const message = {\n      data: serializableTransaction.data,\n      from: account.address,\n      gas: serializableTransaction.gas,\n      nonce: nonce,\n      to: serializableTransaction.to,\n      value: 0n,\n    } as const;\n    return [\n      await account.signTypedData({\n        domain: {\n          chainId: transaction.chain.id,\n          name: gasless.domainName ?? \"GSNv2 Forwarder\",\n          verifyingContract: forrwaderContract.address,\n          version: gasless.domainVersion ?? \"0.0.1\",\n        },\n        message,\n        primaryType: \"ForwardRequest\",\n        types: { ForwardRequest },\n      }),\n      message,\n    ] as const;\n  })();\n  // TODO: handle special case for `approve` -> `permit`\n  const messageType = \"forward\";\n\n  return { message, messageType, signature } as const;\n}\n\nconst ForwardRequest = [\n  { name: \"from\", type: \"address\" },\n  { name: \"to\", type: \"address\" },\n  { name: \"value\", type: \"uint256\" },\n  { name: \"gas\", type: \"uint256\" },\n  { name: \"nonce\", type: \"uint256\" },\n  { name: \"data\", type: \"bytes\" },\n] as const;\n\nconst ChainAwareForwardRequest = [\n  { name: \"from\", type: \"address\" },\n  { name: \"to\", type: \"address\" },\n  { name: \"value\", type: \"uint256\" },\n  { name: \"gas\", type: \"uint256\" },\n  { name: \"nonce\", type: \"uint256\" },\n  { name: \"data\", type: \"bytes\" },\n  { name: \"chainid\", type: \"uint256\" },\n] as const;\n\n/**\n * @internal\n */\nexport async function relayEngineTransaction(\n  options: SendengineTransactionOptions,\n): Promise<WaitForReceiptOptions> {\n  const { message, messageType, signature } =\n    await prepareEngineTransaction(options);\n\n  const response = await fetch(options.gasless.relayerUrl, {\n    body: stringify({\n      forwarderAddress: options.gasless.relayerForwarderAddress,\n      request: message,\n      signature,\n      type: messageType,\n    }),\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    method: \"POST\",\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to send transaction: ${await response.text()}`);\n  }\n  const json = await response.json();\n  if (!json.result) {\n    throw new Error(`Relay transaction failed: ${json.message}`);\n  }\n  const queueId = json.result.queueId;\n  // poll for transactionHash\n  const timeout = 60000;\n  const interval = 1000;\n  const endtime = Date.now() + timeout;\n  while (Date.now() < endtime) {\n    const receipt = await fetchReceipt({ options, queueId });\n    if (receipt) {\n      return {\n        chain: options.transaction.chain,\n        client: options.transaction.client,\n        transactionHash: receipt.transactionHash,\n      };\n    }\n    await new Promise((resolve) => setTimeout(resolve, interval));\n  }\n  throw new Error(`Failed to find relayed transaction after ${timeout}ms`);\n}\n\nasync function fetchReceipt(args: {\n  options: SendengineTransactionOptions;\n  queueId: string;\n}) {\n  const { options, queueId } = args;\n  const url = options.gasless.relayerUrl.split(\"/relayer/\")[0];\n  const res = await fetch(`${url}/transaction/status/${queueId}`, {\n    method: \"GET\",\n  });\n  const resJson = await res.json();\n  if (!res.ok) {\n    return null;\n  }\n  const result = resJson.result;\n  if (!result) {\n    return null;\n  }\n  switch (result.status) {\n    case \"errored\":\n      throw new Error(\n        `Transaction errored with reason: ${result.errorMessage}`,\n      );\n    case \"cancelled\":\n      throw new Error(\"Transaction execution cancelled.\");\n    case \"mined\": {\n      const receipt = await waitForReceipt({\n        chain: options.transaction.chain,\n        client: options.transaction.client,\n        transactionHash: result.transactionHash,\n      });\n      return receipt;\n    }\n    default: {\n      return null;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}