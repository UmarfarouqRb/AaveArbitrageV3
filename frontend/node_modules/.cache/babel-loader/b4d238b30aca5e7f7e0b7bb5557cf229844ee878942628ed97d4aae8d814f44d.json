{"ast":null,"code":"import { ALPHABET } from \"./alphabet.js\";\nconst BASE = ALPHABET.length;\nconst LEADER = /* @__PURE__ */(() => ALPHABET.charAt(0))();\nconst iFACTOR = /* @__PURE__ */(() => Math.log(256) / Math.log(BASE))(); // log(256) / log(BASE), rounded up\n/**\n * Encodes a Uint8Array into a base58 string.\n * @param source - The Uint8Array to encode.\n * @returns The base58 encoded string.\n * @throws {TypeError} If the source is not a Uint8Array.\n * @throws {Error} If there is a non-zero carry during the encoding process.\n * @example\n * ```ts\n * import { base58Encode } from \"thirdweb/utils;\n * const source = new Uint8Array([0, 1, 2, 3, 4, 5]);\n * const encoded = base58Encode(source);\n * console.log(encoded);\n * ```\n */\nexport function base58Encode(source) {\n  if (!(source instanceof Uint8Array)) {\n    throw new TypeError(\"Expected Uint8Array\");\n  }\n  if (source.length === 0) {\n    return \"\";\n  }\n  // Skip & count leading zeroes.\n  let zeroes = 0;\n  let length = 0;\n  let pbegin = 0;\n  const pend = source.length;\n  while (pbegin !== pend && source[pbegin] === 0) {\n    pbegin++;\n    zeroes++;\n  }\n  // Allocate enough space in big-endian base58 representation.\n  const size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n  const b58 = new Uint8Array(size);\n  // Process the bytes.\n  while (pbegin !== pend) {\n    let carry = source[pbegin] || 0;\n    // Apply \"b58 = b58 * 256 + ch\".\n    let i = 0;\n    for (let it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {\n      carry += 256 * (b58[it1] || 0) >>> 0;\n      b58[it1] = carry % BASE >>> 0;\n      carry = carry / BASE >>> 0;\n    }\n    if (carry !== 0) {\n      throw new Error(\"Non-zero carry\");\n    }\n    length = i;\n    pbegin++;\n  }\n  // Skip leading zeroes in base58 result.\n  let it2 = size - length;\n  while (it2 !== size && b58[it2] === 0) {\n    it2++;\n  }\n  // Translate the result into a string.\n  let str = LEADER.repeat(zeroes);\n  for (; it2 < size; ++it2) {\n    str += ALPHABET.charAt(b58[it2] || 0);\n  }\n  return str;\n}","map":{"version":3,"names":["ALPHABET","BASE","length","LEADER","charAt","iFACTOR","Math","log","base58Encode","source","Uint8Array","TypeError","zeroes","pbegin","pend","size","b58","carry","i","it1","Error","it2","str","repeat"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/utils/base58/encode.ts"],"sourcesContent":["import { ALPHABET } from \"./alphabet.js\";\n\nconst BASE = ALPHABET.length;\nconst LEADER = /* @__PURE__ */ (() => ALPHABET.charAt(0))();\nconst iFACTOR = /* @__PURE__ */ (() => Math.log(256) / Math.log(BASE))(); // log(256) / log(BASE), rounded up\n\n/**\n * Encodes a Uint8Array into a base58 string.\n * @param source - The Uint8Array to encode.\n * @returns The base58 encoded string.\n * @throws {TypeError} If the source is not a Uint8Array.\n * @throws {Error} If there is a non-zero carry during the encoding process.\n * @example\n * ```ts\n * import { base58Encode } from \"thirdweb/utils;\n * const source = new Uint8Array([0, 1, 2, 3, 4, 5]);\n * const encoded = base58Encode(source);\n * console.log(encoded);\n * ```\n */\nexport function base58Encode(source: Uint8Array): string {\n  if (!(source instanceof Uint8Array)) {\n    throw new TypeError(\"Expected Uint8Array\");\n  }\n  if (source.length === 0) {\n    return \"\";\n  }\n  // Skip & count leading zeroes.\n  let zeroes = 0;\n  let length = 0;\n  let pbegin = 0;\n  const pend = source.length;\n  while (pbegin !== pend && source[pbegin] === 0) {\n    pbegin++;\n    zeroes++;\n  }\n  // Allocate enough space in big-endian base58 representation.\n  const size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n  const b58 = new Uint8Array(size);\n  // Process the bytes.\n  while (pbegin !== pend) {\n    let carry = source[pbegin] || 0;\n    // Apply \"b58 = b58 * 256 + ch\".\n    let i = 0;\n    for (\n      let it1 = size - 1;\n      (carry !== 0 || i < length) && it1 !== -1;\n      it1--, i++\n    ) {\n      carry += (256 * (b58[it1] || 0)) >>> 0;\n      b58[it1] = (carry % BASE) >>> 0;\n      carry = (carry / BASE) >>> 0;\n    }\n    if (carry !== 0) {\n      throw new Error(\"Non-zero carry\");\n    }\n    length = i;\n    pbegin++;\n  }\n  // Skip leading zeroes in base58 result.\n  let it2 = size - length;\n  while (it2 !== size && b58[it2] === 0) {\n    it2++;\n  }\n  // Translate the result into a string.\n  let str = LEADER.repeat(zeroes);\n  for (; it2 < size; ++it2) {\n    str += ALPHABET.charAt(b58[it2] || 0);\n  }\n  return str;\n}\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,eAAe;AAExC,MAAMC,IAAI,GAAGD,QAAQ,CAACE,MAAM;AAC5B,MAAMC,MAAM,GAAG,eAAgB,CAAC,MAAMH,QAAQ,CAACI,MAAM,CAAC,CAAC,CAAC,EAAC,CAAE;AAC3D,MAAMC,OAAO,GAAG,eAAgB,CAAC,MAAMC,IAAI,CAACC,GAAG,CAAC,GAAG,CAAC,GAAGD,IAAI,CAACC,GAAG,CAACN,IAAI,CAAC,EAAC,CAAE,CAAC,CAAC;AAE1E;;;;;;;;;;;;;;AAcA,OAAM,SAAUO,YAAYA,CAACC,MAAkB;EAC7C,IAAI,EAAEA,MAAM,YAAYC,UAAU,CAAC,EAAE;IACnC,MAAM,IAAIC,SAAS,CAAC,qBAAqB,CAAC;EAC5C;EACA,IAAIF,MAAM,CAACP,MAAM,KAAK,CAAC,EAAE;IACvB,OAAO,EAAE;EACX;EACA;EACA,IAAIU,MAAM,GAAG,CAAC;EACd,IAAIV,MAAM,GAAG,CAAC;EACd,IAAIW,MAAM,GAAG,CAAC;EACd,MAAMC,IAAI,GAAGL,MAAM,CAACP,MAAM;EAC1B,OAAOW,MAAM,KAAKC,IAAI,IAAIL,MAAM,CAACI,MAAM,CAAC,KAAK,CAAC,EAAE;IAC9CA,MAAM,EAAE;IACRD,MAAM,EAAE;EACV;EACA;EACA,MAAMG,IAAI,GAAI,CAACD,IAAI,GAAGD,MAAM,IAAIR,OAAO,GAAG,CAAC,KAAM,CAAC;EAClD,MAAMW,GAAG,GAAG,IAAIN,UAAU,CAACK,IAAI,CAAC;EAChC;EACA,OAAOF,MAAM,KAAKC,IAAI,EAAE;IACtB,IAAIG,KAAK,GAAGR,MAAM,CAACI,MAAM,CAAC,IAAI,CAAC;IAC/B;IACA,IAAIK,CAAC,GAAG,CAAC;IACT,KACE,IAAIC,GAAG,GAAGJ,IAAI,GAAG,CAAC,EAClB,CAACE,KAAK,KAAK,CAAC,IAAIC,CAAC,GAAGhB,MAAM,KAAKiB,GAAG,KAAK,CAAC,CAAC,EACzCA,GAAG,EAAE,EAAED,CAAC,EAAE,EACV;MACAD,KAAK,IAAK,GAAG,IAAID,GAAG,CAACG,GAAG,CAAC,IAAI,CAAC,CAAC,KAAM,CAAC;MACtCH,GAAG,CAACG,GAAG,CAAC,GAAIF,KAAK,GAAGhB,IAAI,KAAM,CAAC;MAC/BgB,KAAK,GAAIA,KAAK,GAAGhB,IAAI,KAAM,CAAC;IAC9B;IACA,IAAIgB,KAAK,KAAK,CAAC,EAAE;MACf,MAAM,IAAIG,KAAK,CAAC,gBAAgB,CAAC;IACnC;IACAlB,MAAM,GAAGgB,CAAC;IACVL,MAAM,EAAE;EACV;EACA;EACA,IAAIQ,GAAG,GAAGN,IAAI,GAAGb,MAAM;EACvB,OAAOmB,GAAG,KAAKN,IAAI,IAAIC,GAAG,CAACK,GAAG,CAAC,KAAK,CAAC,EAAE;IACrCA,GAAG,EAAE;EACP;EACA;EACA,IAAIC,GAAG,GAAGnB,MAAM,CAACoB,MAAM,CAACX,MAAM,CAAC;EAC/B,OAAOS,GAAG,GAAGN,IAAI,EAAE,EAAEM,GAAG,EAAE;IACxBC,GAAG,IAAItB,QAAQ,CAACI,MAAM,CAACY,GAAG,CAACK,GAAG,CAAC,IAAI,CAAC,CAAC;EACvC;EACA,OAAOC,GAAG;AACZ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}