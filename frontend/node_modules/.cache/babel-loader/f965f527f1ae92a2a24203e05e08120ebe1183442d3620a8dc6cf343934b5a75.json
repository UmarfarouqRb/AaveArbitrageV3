{"ast":null,"code":"import { getClientFetch } from \"../fetch.js\";\nimport { resolveScheme } from \"../ipfs.js\";\nimport { parseNftUri } from \"../nft/parseNft.js\";\n/**\n * Parses an ENS or similar avatar record. Supports NFT URIs, IPFS scheme, and HTTPS URIs.\n * @param options - The options for parsing an ENS avatar record.\n * @param options.client - The Thirdweb client.\n * @param options.uri - The URI to parse.\n * @returns A promise that resolves to the avatar URL, or null if the URI could not be parsed.\n * @example\n * ```ts\n * import { parseAvatarRecord } from \"thirdweb/utils/ens\";\n * const avatarUrl = await parseAvatarRecord({\n *    client,\n *    uri: \"ipfs://bafybeiemxf5abjwjbikoz4mc3a3dla6ual3jsgpdr4cjr3oz3evfyavhwq/\",\n * });\n *\n * console.log(avatarUrl); // \"https://ipfs.io/ipfs/bafybeiemxf5abjwjbikoz4mc3a3dla6ual3jsgpdr4cjr3oz3evfyavhwq/\"\n *\n * const avatarUrl2 = await parseAvatarRecord({\n *    client,\n *    uri: \"eip155:1/erc1155:0xb32979486938aa9694bfc898f35dbed459f44424/10063\",\n * });\n *\n * console.log(avatarUrl2); // \"https://opensea.io/assets/0xb32979486938aa9694bfc898f35dbed459f44424/10063\"\n * ```\n * @extension ENS\n */\nexport async function parseAvatarRecord(options) {\n  let uri = options.uri;\n  if (/eip155:/i.test(options.uri)) {\n    // do nft uri parsing\n    uri = await parseNftUri(options);\n  }\n  if (!uri) {\n    return null;\n  }\n  const resolvedScheme = resolveScheme({\n    client: options.client,\n    uri\n  });\n  // check if it's an image\n  if (await isImageUri({\n    client: options.client,\n    uri: resolvedScheme\n  })) {\n    return resolvedScheme;\n  }\n  return null;\n}\nasync function isImageUri(options) {\n  try {\n    const res = await getClientFetch(options.client)(options.uri, {\n      method: \"HEAD\"\n    });\n    // retrieve content type header to check if content is image\n    if (res.status === 200) {\n      const contentType = res.headers.get(\"content-type\");\n      return !!(contentType !== null && contentType !== void 0 && contentType.startsWith(\"image/\"));\n    }\n    return false;\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  } catch (error) {\n    // if error is not cors related then fail\n    if (typeof error === \"object\" && typeof error.response !== \"undefined\") {\n      return false;\n    }\n    // fail in NodeJS, since the error is not cors but any other network issue\n    if (!Object.hasOwn(globalThis, \"Image\")) {\n      return false;\n    }\n    // in case of cors, use image api to validate if given url is an actual image\n    return new Promise(resolve => {\n      const img = new Image();\n      img.onload = () => {\n        resolve(true);\n      };\n      img.onerror = () => {\n        resolve(false);\n      };\n      img.src = options.uri;\n    });\n  }\n}","map":{"version":3,"names":["getClientFetch","resolveScheme","parseNftUri","parseAvatarRecord","options","uri","test","resolvedScheme","client","isImageUri","res","method","status","contentType","headers","get","startsWith","error","response","Object","hasOwn","globalThis","Promise","resolve","img","Image","onload","onerror","src"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/utils/ens/avatar.ts"],"sourcesContent":["import type { ThirdwebClient } from \"../../client/client.js\";\nimport { getClientFetch } from \"../fetch.js\";\nimport { resolveScheme } from \"../ipfs.js\";\nimport { parseNftUri } from \"../nft/parseNft.js\";\n\nexport type ParseAvatarOptions = {\n  client: ThirdwebClient;\n  uri: string;\n};\n\n/**\n * Parses an ENS or similar avatar record. Supports NFT URIs, IPFS scheme, and HTTPS URIs.\n * @param options - The options for parsing an ENS avatar record.\n * @param options.client - The Thirdweb client.\n * @param options.uri - The URI to parse.\n * @returns A promise that resolves to the avatar URL, or null if the URI could not be parsed.\n * @example\n * ```ts\n * import { parseAvatarRecord } from \"thirdweb/utils/ens\";\n * const avatarUrl = await parseAvatarRecord({\n *    client,\n *    uri: \"ipfs://bafybeiemxf5abjwjbikoz4mc3a3dla6ual3jsgpdr4cjr3oz3evfyavhwq/\",\n * });\n *\n * console.log(avatarUrl); // \"https://ipfs.io/ipfs/bafybeiemxf5abjwjbikoz4mc3a3dla6ual3jsgpdr4cjr3oz3evfyavhwq/\"\n *\n * const avatarUrl2 = await parseAvatarRecord({\n *    client,\n *    uri: \"eip155:1/erc1155:0xb32979486938aa9694bfc898f35dbed459f44424/10063\",\n * });\n *\n * console.log(avatarUrl2); // \"https://opensea.io/assets/0xb32979486938aa9694bfc898f35dbed459f44424/10063\"\n * ```\n * @extension ENS\n */\nexport async function parseAvatarRecord(\n  options: ParseAvatarOptions,\n): Promise<string | null> {\n  let uri: string | null = options.uri;\n  if (/eip155:/i.test(options.uri)) {\n    // do nft uri parsing\n    uri = await parseNftUri(options);\n  }\n  if (!uri) {\n    return null;\n  }\n  const resolvedScheme = resolveScheme({\n    client: options.client,\n    uri,\n  });\n\n  // check if it's an image\n  if (await isImageUri({ client: options.client, uri: resolvedScheme })) {\n    return resolvedScheme;\n  }\n  return null;\n}\n\nasync function isImageUri(options: ParseAvatarOptions): Promise<boolean> {\n  try {\n    const res = await getClientFetch(options.client)(options.uri, {\n      method: \"HEAD\",\n    });\n    // retrieve content type header to check if content is image\n    if (res.status === 200) {\n      const contentType = res.headers.get(\"content-type\");\n      return !!contentType?.startsWith(\"image/\");\n    }\n    return false;\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  } catch (error: any) {\n    // if error is not cors related then fail\n    if (typeof error === \"object\" && typeof error.response !== \"undefined\") {\n      return false;\n    }\n    // fail in NodeJS, since the error is not cors but any other network issue\n    if (!Object.hasOwn(globalThis, \"Image\")) {\n      return false;\n    }\n    // in case of cors, use image api to validate if given url is an actual image\n    return new Promise((resolve) => {\n      const img = new Image();\n      img.onload = () => {\n        resolve(true);\n      };\n      img.onerror = () => {\n        resolve(false);\n      };\n      img.src = options.uri;\n    });\n  }\n}\n"],"mappings":"AACA,SAASA,cAAc,QAAQ,aAAa;AAC5C,SAASC,aAAa,QAAQ,YAAY;AAC1C,SAASC,WAAW,QAAQ,oBAAoB;AAOhD;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,OAAO,eAAeC,iBAAiBA,CACrCC,OAA2B;EAE3B,IAAIC,GAAG,GAAkBD,OAAO,CAACC,GAAG;EACpC,IAAI,UAAU,CAACC,IAAI,CAACF,OAAO,CAACC,GAAG,CAAC,EAAE;IAChC;IACAA,GAAG,GAAG,MAAMH,WAAW,CAACE,OAAO,CAAC;EAClC;EACA,IAAI,CAACC,GAAG,EAAE;IACR,OAAO,IAAI;EACb;EACA,MAAME,cAAc,GAAGN,aAAa,CAAC;IACnCO,MAAM,EAAEJ,OAAO,CAACI,MAAM;IACtBH;GACD,CAAC;EAEF;EACA,IAAI,MAAMI,UAAU,CAAC;IAAED,MAAM,EAAEJ,OAAO,CAACI,MAAM;IAAEH,GAAG,EAAEE;EAAc,CAAE,CAAC,EAAE;IACrE,OAAOA,cAAc;EACvB;EACA,OAAO,IAAI;AACb;AAEA,eAAeE,UAAUA,CAACL,OAA2B;EACnD,IAAI;IACF,MAAMM,GAAG,GAAG,MAAMV,cAAc,CAACI,OAAO,CAACI,MAAM,CAAC,CAACJ,OAAO,CAACC,GAAG,EAAE;MAC5DM,MAAM,EAAE;KACT,CAAC;IACF;IACA,IAAID,GAAG,CAACE,MAAM,KAAK,GAAG,EAAE;MACtB,MAAMC,WAAW,GAAGH,GAAG,CAACI,OAAO,CAACC,GAAG,CAAC,cAAc,CAAC;MACnD,OAAO,CAAC,EAACF,WAAW,aAAXA,WAAW,eAAXA,WAAW,CAAEG,UAAU,CAAC,QAAQ,CAAC;IAC5C;IACA,OAAO,KAAK;IACZ;EACF,CAAC,CAAC,OAAOC,KAAU,EAAE;IACnB;IACA,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAI,OAAOA,KAAK,CAACC,QAAQ,KAAK,WAAW,EAAE;MACtE,OAAO,KAAK;IACd;IACA;IACA,IAAI,CAACC,MAAM,CAACC,MAAM,CAACC,UAAU,EAAE,OAAO,CAAC,EAAE;MACvC,OAAO,KAAK;IACd;IACA;IACA,OAAO,IAAIC,OAAO,CAAEC,OAAO,IAAI;MAC7B,MAAMC,GAAG,GAAG,IAAIC,KAAK,EAAE;MACvBD,GAAG,CAACE,MAAM,GAAG,MAAK;QAChBH,OAAO,CAAC,IAAI,CAAC;MACf,CAAC;MACDC,GAAG,CAACG,OAAO,GAAG,MAAK;QACjBJ,OAAO,CAAC,KAAK,CAAC;MAChB,CAAC;MACDC,GAAG,CAACI,GAAG,GAAGxB,OAAO,CAACC,GAAG;IACvB,CAAC,CAAC;EACJ;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}