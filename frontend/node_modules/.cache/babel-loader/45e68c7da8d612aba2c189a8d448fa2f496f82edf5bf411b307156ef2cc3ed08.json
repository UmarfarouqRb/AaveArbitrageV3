{"ast":null,"code":"import { parseAccount } from '../../accounts/utils/parseAccount.js';\nimport { readContract } from '../../actions/index.js';\nimport { erc20Abi } from '../../constants/abis.js';\nimport { TokenIsEthError } from '../errors/token-is-eth.js';\nimport { isEth } from '../utils/isEth.js';\nexport async function getL1TokenBalance(client, parameters) {\n  const {\n    account: account_ = client.account,\n    blockTag,\n    blockNumber,\n    token\n  } = parameters;\n  if (isEth(token)) throw new TokenIsEthError();\n  const account = account_ ? parseAccount(account_) : client.account;\n  return await readContract(client, {\n    abi: erc20Abi,\n    address: token,\n    functionName: 'balanceOf',\n    args: [account.address],\n    blockNumber: blockNumber,\n    blockTag: blockTag\n  });\n}","map":{"version":3,"names":["parseAccount","readContract","erc20Abi","TokenIsEthError","isEth","getL1TokenBalance","client","parameters","account","account_","blockTag","blockNumber","token","abi","address","functionName","args"],"sources":["/home/user/Arbitrage/frontend/node_modules/viem/zksync/actions/getL1TokenBalance.ts"],"sourcesContent":["import type { Address } from '../../accounts/index.js'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport { readContract } from '../../actions/index.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { erc20Abi } from '../../constants/abis.js'\nimport type { AccountNotFoundErrorType } from '../../errors/account.js'\nimport type { BaseErrorType } from '../../errors/base.js'\nimport type { Account, GetAccountParameter } from '../../types/account.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport {\n  TokenIsEthError,\n  type TokenIsEthErrorType,\n} from '../errors/token-is-eth.js'\nimport { isEth } from '../utils/isEth.js'\n\nexport type GetL1TokenBalanceParameters<\n  account extends Account | undefined = Account | undefined,\n> = GetAccountParameter<account> & { token: Address } & (\n    | {\n        /** The balance of the account at a block number. */\n        blockNumber?: bigint | undefined\n        blockTag?: undefined\n      }\n    | {\n        blockNumber?: undefined\n        /** The balance of the account at a block tag. */\n        blockTag?: BlockTag | undefined\n      }\n  )\n\nexport type GetL1TokenBalanceReturnType = bigint\n\nexport type GetL1TokenBalanceErrorType =\n  | AccountNotFoundErrorType\n  | TokenIsEthErrorType\n  | BaseErrorType\n\nexport async function getL1TokenBalance<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: GetL1TokenBalanceParameters<account>,\n): Promise<GetL1TokenBalanceReturnType> {\n  const {\n    account: account_ = client.account,\n    blockTag,\n    blockNumber,\n    token,\n  } = parameters\n\n  if (isEth(token!)) throw new TokenIsEthError()\n\n  const account = account_ ? parseAccount(account_) : client.account\n\n  return await readContract(client, {\n    abi: erc20Abi,\n    address: token!,\n    functionName: 'balanceOf',\n    args: [account!.address],\n    blockNumber: blockNumber,\n    blockTag: blockTag,\n  })\n}\n"],"mappings":"AACA,SAASA,YAAY,QAAQ,sCAAsC;AACnE,SAASC,YAAY,QAAQ,wBAAwB;AAGrD,SAASC,QAAQ,QAAQ,yBAAyB;AAMlD,SACEC,eAAe,QAEV,2BAA2B;AAClC,SAASC,KAAK,QAAQ,mBAAmB;AAwBzC,OAAO,eAAeC,iBAAiBA,CAIrCC,MAAyC,EACzCC,UAAgD;EAEhD,MAAM;IACJC,OAAO,EAAEC,QAAQ,GAAGH,MAAM,CAACE,OAAO;IAClCE,QAAQ;IACRC,WAAW;IACXC;EAAK,CACN,GAAGL,UAAU;EAEd,IAAIH,KAAK,CAACQ,KAAM,CAAC,EAAE,MAAM,IAAIT,eAAe,EAAE;EAE9C,MAAMK,OAAO,GAAGC,QAAQ,GAAGT,YAAY,CAACS,QAAQ,CAAC,GAAGH,MAAM,CAACE,OAAO;EAElE,OAAO,MAAMP,YAAY,CAACK,MAAM,EAAE;IAChCO,GAAG,EAAEX,QAAQ;IACbY,OAAO,EAAEF,KAAM;IACfG,YAAY,EAAE,WAAW;IACzBC,IAAI,EAAE,CAACR,OAAQ,CAACM,OAAO,CAAC;IACxBH,WAAW,EAAEA,WAAW;IACxBD,QAAQ,EAAEA;GACX,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}