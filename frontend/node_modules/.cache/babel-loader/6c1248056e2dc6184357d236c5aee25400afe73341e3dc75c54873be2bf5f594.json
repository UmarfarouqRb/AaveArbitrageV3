{"ast":null,"code":"import { isNativeTokenAddress, ZERO_ADDRESS } from \"../../../constants/addresses.js\";\nimport { MerkleTree } from \"../../../merkletree/MerkleTree.js\";\nimport { download } from \"../../../storage/download.js\";\nimport { convertQuantity } from \"./convert-quantity.js\";\nimport { hashEntry } from \"./hash-entry.js\";\nexport async function fetchProofsForClaimer(options) {\n  const {\n    contract,\n    merkleTreeUri,\n    claimer\n  } = options;\n  const hashEntryFn = options.hashEntry || hashEntry;\n  // 2. download snapshot data\n  const response = await download({\n    client: contract.client,\n    uri: merkleTreeUri\n  });\n  const merkleInfo = await response.json();\n  // 3. download shard data based off the user address\n  const shardId = claimer.slice(2, 2 + merkleInfo.shardNybbles).toLowerCase();\n  const uri = merkleInfo.baseUri.endsWith(\"/\") ? merkleInfo.baseUri : \"\".concat(merkleInfo.baseUri, \"/\");\n  let shardData;\n  try {\n    const constructedShardUri = \"\".concat(uri).concat(shardId, \".json\");\n    const shard = await download({\n      client: contract.client,\n      uri: constructedShardUri\n    });\n    shardData = await shard.json();\n  } catch (_unused) {\n    // if the file can't be fetched it means claimer not in merkle tree\n    return null;\n  }\n  // 4. hash all the entries in that shard and construct the sub merkle tree\n  const hashedEntries = await Promise.all(shardData.entries.map(async entry => {\n    return hashEntryFn({\n      chain: contract.chain,\n      client: contract.client,\n      entry,\n      tokenDecimals: options.tokenDecimals\n    });\n  }));\n  // 5. get the proof for the claimer + the sub merkle tree root\n  const tree = new MerkleTree(hashedEntries);\n  const entry = shardData.entries.find(i => i.address.toLowerCase() === claimer.toLowerCase());\n  if (!entry) {\n    return null;\n  }\n  const proof = tree.getHexProof(await hashEntryFn({\n    chain: contract.chain,\n    client: contract.client,\n    entry,\n    tokenDecimals: options.tokenDecimals\n  })).concat(shardData.proofs);\n  // 6. return the proof and the entry data for the contract call\n  const currencyAddress = entry.currencyAddress || ZERO_ADDRESS;\n  const currencyDecimals = await (async () => {\n    if (isNativeTokenAddress(currencyAddress) || currencyAddress === ZERO_ADDRESS) {\n      return 18;\n    }\n    const [{\n      getContract\n    }, {\n      decimals: getDecimals\n    }] = await Promise.all([import(\"../../../contract/contract.js\"), import(\"../../../extensions/erc20/read/decimals.js\")]);\n    const currencyContract = getContract({\n      address: currencyAddress,\n      chain: contract.chain,\n      client: contract.client\n    });\n    return await getDecimals({\n      contract: currencyContract\n    });\n  })();\n  return {\n    currency: currencyAddress,\n    pricePerToken: convertQuantity({\n      quantity: entry.price || \"unlimited\",\n      tokenDecimals: currencyDecimals\n    }),\n    proof,\n    quantityLimitPerWallet: convertQuantity({\n      quantity: entry.maxClaimable || \"unlimited\",\n      tokenDecimals: options.tokenDecimals\n    })\n  };\n}","map":{"version":3,"names":["isNativeTokenAddress","ZERO_ADDRESS","MerkleTree","download","convertQuantity","hashEntry","fetchProofsForClaimer","options","contract","merkleTreeUri","claimer","hashEntryFn","response","client","uri","merkleInfo","json","shardId","slice","shardNybbles","toLowerCase","baseUri","endsWith","concat","shardData","constructedShardUri","shard","_unused","hashedEntries","Promise","all","entries","map","entry","chain","tokenDecimals","tree","find","i","address","proof","getHexProof","proofs","currencyAddress","currencyDecimals","getContract","decimals","getDecimals","currencyContract","currency","pricePerToken","quantity","price","quantityLimitPerWallet","maxClaimable"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/utils/extensions/drops/fetch-proofs-for-claimers.ts"],"sourcesContent":["import type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport {\n  isNativeTokenAddress,\n  ZERO_ADDRESS,\n} from \"../../../constants/addresses.js\";\nimport type { ThirdwebContract } from \"../../../contract/contract.js\";\nimport { MerkleTree } from \"../../../merkletree/MerkleTree.js\";\nimport { download } from \"../../../storage/download.js\";\nimport type { Address } from \"../../address.js\";\nimport type { Hex } from \"../../encoding/hex.js\";\nimport { convertQuantity } from \"./convert-quantity.js\";\nimport { hashEntry } from \"./hash-entry.js\";\nimport type {\n  OverrideEntry,\n  OverrideProof,\n  ShardData,\n  ShardedMerkleTreeInfo,\n} from \"./types.js\";\n\nexport async function fetchProofsForClaimer(options: {\n  contract: ThirdwebContract;\n  claimer: string;\n  merkleTreeUri: string;\n  tokenDecimals: number;\n  hashEntry?: (options: {\n    entry: OverrideEntry;\n    chain: Chain;\n    client: ThirdwebClient;\n    tokenDecimals: number;\n  }) => Promise<Hex>;\n}): Promise<OverrideProof | null> {\n  const { contract, merkleTreeUri, claimer } = options;\n  const hashEntryFn = options.hashEntry || hashEntry;\n\n  // 2. download snapshot data\n  const response = await download({\n    client: contract.client,\n    uri: merkleTreeUri,\n  });\n  const merkleInfo: ShardedMerkleTreeInfo = await response.json();\n\n  // 3. download shard data based off the user address\n  const shardId = claimer.slice(2, 2 + merkleInfo.shardNybbles).toLowerCase();\n  const uri = merkleInfo.baseUri.endsWith(\"/\")\n    ? merkleInfo.baseUri\n    : `${merkleInfo.baseUri}/`;\n  let shardData: ShardData;\n\n  try {\n    const constructedShardUri = `${uri}${shardId}.json`;\n    const shard = await download({\n      client: contract.client,\n      uri: constructedShardUri,\n    });\n    shardData = await shard.json();\n  } catch {\n    // if the file can't be fetched it means claimer not in merkle tree\n    return null;\n  }\n\n  // 4. hash all the entries in that shard and construct the sub merkle tree\n  const hashedEntries = await Promise.all(\n    shardData.entries.map(async (entry) => {\n      return hashEntryFn({\n        chain: contract.chain,\n        client: contract.client,\n        entry,\n        tokenDecimals: options.tokenDecimals,\n      });\n    }),\n  );\n  // 5. get the proof for the claimer + the sub merkle tree root\n  const tree = new MerkleTree(hashedEntries);\n  const entry = shardData.entries.find(\n    (i) => i.address.toLowerCase() === claimer.toLowerCase(),\n  );\n  if (!entry) {\n    return null;\n  }\n  const proof = tree\n    .getHexProof(\n      await hashEntryFn({\n        chain: contract.chain,\n        client: contract.client,\n        entry,\n        tokenDecimals: options.tokenDecimals,\n      }),\n    )\n    .concat(shardData.proofs);\n  // 6. return the proof and the entry data for the contract call\n  const currencyAddress = (entry.currencyAddress || ZERO_ADDRESS) as Address;\n  const currencyDecimals = await (async () => {\n    if (\n      isNativeTokenAddress(currencyAddress) ||\n      currencyAddress === ZERO_ADDRESS\n    ) {\n      return 18;\n    }\n    const [{ getContract }, { decimals: getDecimals }] = await Promise.all([\n      import(\"../../../contract/contract.js\"),\n      import(\"../../../extensions/erc20/read/decimals.js\"),\n    ]);\n    const currencyContract = getContract({\n      address: currencyAddress,\n      chain: contract.chain,\n      client: contract.client,\n    });\n    return await getDecimals({ contract: currencyContract });\n  })();\n\n  return {\n    currency: currencyAddress,\n    pricePerToken: convertQuantity({\n      quantity: entry.price || \"unlimited\",\n      tokenDecimals: currencyDecimals,\n    }),\n    proof,\n    quantityLimitPerWallet: convertQuantity({\n      quantity: entry.maxClaimable || \"unlimited\",\n      tokenDecimals: options.tokenDecimals,\n    }),\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}