{"ast":null,"code":"import { isBase64JSON, parseBase64String } from \"../base64/base64.js\";\nimport { numberToHex } from \"../encoding/hex.js\";\n/**\n * Fetches the metadata for a token.\n *\n * @param options - The options for fetching the token metadata.\n * @returns The token metadata.\n * @internal\n */\nexport async function fetchTokenMetadata(options) {\n  const {\n    client,\n    tokenId,\n    tokenUri\n  } = options;\n  // handle case where the URI is a base64 encoded JSON (onchain nft)\n  if (isBase64JSON(tokenUri)) {\n    try {\n      return JSON.parse(parseBase64String(tokenUri));\n    } catch (e) {\n      console.error(\"Failed to fetch base64 encoded NFT\", {\n        tokenId,\n        tokenUri\n      }, e);\n      throw e;\n    }\n  }\n  // in all other cases we will need the `download` function from storage\n  const {\n    download\n  } = await import(\"../../storage/download.js\");\n  // handle non-dynamic uris (most common case -> skip the other checks)\n  try {\n    if (!tokenUri.includes(\"{id}\")) {\n      return await (await download({\n        client,\n        uri: tokenUri\n      })).json();\n    }\n  } catch (e) {\n    console.error(\"Failed to fetch non-dynamic NFT\", {\n      tokenId,\n      tokenUri\n    }, e);\n    throw e;\n  }\n  // DYNAMIC NFT FORMATS (2 options, sadly has to be waterfall)\n  try {\n    try {\n      // try first dynamic id format\n      return await (await download({\n        client,\n        uri: tokenUri.replace(\"{id}\", numberToHex(tokenId, {\n          size: 32\n        }).slice(2))\n      })).json();\n    } catch (_unused) {\n      // otherwise attempt the second format\n      return await (await download({\n        client,\n        uri: tokenUri.replace(\"{id}\", tokenId.toString())\n      })).json();\n    }\n  } catch (e) {\n    console.error(\"Failed to fetch dynamic NFT\", {\n      tokenId,\n      tokenUri\n    }, e);\n    throw e;\n  }\n}","map":{"version":3,"names":["isBase64JSON","parseBase64String","numberToHex","fetchTokenMetadata","options","client","tokenId","tokenUri","JSON","parse","e","console","error","download","includes","uri","json","replace","size","slice","_unused","toString"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/utils/nft/fetchTokenMetadata.ts"],"sourcesContent":["import type { ThirdwebClient } from \"../../client/client.js\";\nimport { isBase64JSON, parseBase64String } from \"../base64/base64.js\";\nimport { numberToHex } from \"../encoding/hex.js\";\nimport type { NFTMetadata } from \"./parseNft.js\";\n\n/**\n * @internal\n */\nexport type FetchTokenMetadataOptions = {\n  client: ThirdwebClient;\n  tokenId: bigint;\n  tokenUri: string;\n};\n\n/**\n * Fetches the metadata for a token.\n *\n * @param options - The options for fetching the token metadata.\n * @returns The token metadata.\n * @internal\n */\nexport async function fetchTokenMetadata(\n  options: FetchTokenMetadataOptions,\n): Promise<NFTMetadata> {\n  const { client, tokenId, tokenUri } = options;\n  // handle case where the URI is a base64 encoded JSON (onchain nft)\n  if (isBase64JSON(tokenUri)) {\n    try {\n      return JSON.parse(parseBase64String(tokenUri));\n    } catch (e) {\n      console.error(\n        \"Failed to fetch base64 encoded NFT\",\n        { tokenId, tokenUri },\n        e,\n      );\n      throw e;\n    }\n  }\n\n  // in all other cases we will need the `download` function from storage\n  const { download } = await import(\"../../storage/download.js\");\n\n  // handle non-dynamic uris (most common case -> skip the other checks)\n  try {\n    if (!tokenUri.includes(\"{id}\")) {\n      return await (await download({ client, uri: tokenUri })).json();\n    }\n  } catch (e) {\n    console.error(\"Failed to fetch non-dynamic NFT\", { tokenId, tokenUri }, e);\n    throw e;\n  }\n\n  // DYNAMIC NFT FORMATS (2 options, sadly has to be waterfall)\n  try {\n    try {\n      // try first dynamic id format\n      return await (\n        await download({\n          client,\n          uri: tokenUri.replace(\n            \"{id}\",\n            numberToHex(tokenId, { size: 32 }).slice(2),\n          ),\n        })\n      ).json();\n    } catch {\n      // otherwise attempt the second format\n      return await (\n        await download({\n          client,\n          uri: tokenUri.replace(\"{id}\", tokenId.toString()),\n        })\n      ).json();\n    }\n  } catch (e) {\n    console.error(\"Failed to fetch dynamic NFT\", { tokenId, tokenUri }, e);\n    throw e;\n  }\n}\n"],"mappings":"AACA,SAASA,YAAY,EAAEC,iBAAiB,QAAQ,qBAAqB;AACrE,SAASC,WAAW,QAAQ,oBAAoB;AAYhD;;;;;;;AAOA,OAAO,eAAeC,kBAAkBA,CACtCC,OAAkC;EAElC,MAAM;IAAEC,MAAM;IAAEC,OAAO;IAAEC;EAAQ,CAAE,GAAGH,OAAO;EAC7C;EACA,IAAIJ,YAAY,CAACO,QAAQ,CAAC,EAAE;IAC1B,IAAI;MACF,OAAOC,IAAI,CAACC,KAAK,CAACR,iBAAiB,CAACM,QAAQ,CAAC,CAAC;IAChD,CAAC,CAAC,OAAOG,CAAC,EAAE;MACVC,OAAO,CAACC,KAAK,CACX,oCAAoC,EACpC;QAAEN,OAAO;QAAEC;MAAQ,CAAE,EACrBG,CAAC,CACF;MACD,MAAMA,CAAC;IACT;EACF;EAEA;EACA,MAAM;IAAEG;EAAQ,CAAE,GAAG,MAAM,MAAM,CAAC,2BAA2B,CAAC;EAE9D;EACA,IAAI;IACF,IAAI,CAACN,QAAQ,CAACO,QAAQ,CAAC,MAAM,CAAC,EAAE;MAC9B,OAAO,MAAM,CAAC,MAAMD,QAAQ,CAAC;QAAER,MAAM;QAAEU,GAAG,EAAER;MAAQ,CAAE,CAAC,EAAES,IAAI,EAAE;IACjE;EACF,CAAC,CAAC,OAAON,CAAC,EAAE;IACVC,OAAO,CAACC,KAAK,CAAC,iCAAiC,EAAE;MAAEN,OAAO;MAAEC;IAAQ,CAAE,EAAEG,CAAC,CAAC;IAC1E,MAAMA,CAAC;EACT;EAEA;EACA,IAAI;IACF,IAAI;MACF;MACA,OAAO,MAAM,CACX,MAAMG,QAAQ,CAAC;QACbR,MAAM;QACNU,GAAG,EAAER,QAAQ,CAACU,OAAO,CACnB,MAAM,EACNf,WAAW,CAACI,OAAO,EAAE;UAAEY,IAAI,EAAE;QAAE,CAAE,CAAC,CAACC,KAAK,CAAC,CAAC,CAAC;OAE9C,CAAC,EACFH,IAAI,EAAE;IACV,CAAC,CAAC,OAAAI,OAAA,EAAM;MACN;MACA,OAAO,MAAM,CACX,MAAMP,QAAQ,CAAC;QACbR,MAAM;QACNU,GAAG,EAAER,QAAQ,CAACU,OAAO,CAAC,MAAM,EAAEX,OAAO,CAACe,QAAQ,EAAE;OACjD,CAAC,EACFL,IAAI,EAAE;IACV;EACF,CAAC,CAAC,OAAON,CAAC,EAAE;IACVC,OAAO,CAACC,KAAK,CAAC,6BAA6B,EAAE;MAAEN,OAAO;MAAEC;IAAQ,CAAE,EAAEG,CAAC,CAAC;IACtE,MAAMA,CAAC;EACT;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}