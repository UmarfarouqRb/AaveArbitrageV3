{"ast":null,"code":"import { useQuery, useQueryClient } from \"@tanstack/react-query\";\nimport { useEffect, useMemo, useRef } from \"react\";\nimport { getContractEvents } from \"../../../../event/actions/get-events.js\";\nimport { watchContractEvents } from \"../../../../event/actions/watch-events.js\";\nimport { eth_blockNumber } from \"../../../../rpc/actions/eth_blockNumber.js\";\nimport { getRpcClient } from \"../../../../rpc/rpc.js\";\n/**\n * Watches contract events and returns the parsed logs.\n * @param options - The options for watching contract events.\n * @param options.contract - The contract to watch events for.\n * @param options.events - The events to watch. Shuould be an array of [prepared events](https://portal.thirdweb.com/references/typescript/v5/prepareEvent).\n * @param options.blockRange - The number of blocks to search for events.\n * @param options.enabled - Whether to enable the query.\n * @param options.watch - Whether to watch for new events.\n * @returns The contract events of the watched contract events.\n * @example\n *\n * ### Using event extensions\n *\n * The `thirdweb/extensions` export contains event definitions for many popular contracts.\n * You can use these event definitions to watch for specific events with a type-safe API.\n *\n * ```jsx\n * import { useContractEvents } from \"thirdweb/react\";\n * import { tokensClaimedEvent } from \"thirdweb/extensions/erc721\";\n *\n * const account = useActiveAccount();\n * const contractEvents = useContractEvents({\n *  contract,\n *  events: [tokensClaimedEvent({ claimer: account?.address })],\n * });\n * ```\n *\n * ### Using custom events\n *\n * You can also watch for custom events by passing an array of [prepared events](https://portal.thirdweb.com/references/typescript/v5/prepareEvent).\n *\n * ```jsx\n * import { useContractEvents } from \"thirdweb/react\";\n * import { prepareEvent } from \"thirdweb\";\n *\n * const myEvent = prepareEvent({\n *  signature: \"event MyEvent(uint256 myArg)\",\n * });\n *\n * const contractEvents = useContractEvents({\n *  contract,\n *  events: [myEvent],\n * });\n * ```\n *\n * @contract\n */\nexport function useContractEvents(options) {\n  const {\n    contract,\n    events,\n    blockRange = 2000,\n    enabled = true,\n    watch = true\n  } = options;\n  const latestBlockNumber = useRef(undefined); // We use this to keep track of the latest block number when new pollers are spawned\n  const queryClient = useQueryClient();\n  const eventsKey = useMemo(() => (events === null || events === void 0 ? void 0 : events.reduce((acc, curr) => {\n    // we can use the event hash as a unique identifier?\n    return \"\".concat(acc).concat(curr.hash).concat(curr.topics.join(\"\"), \"_\");\n  }, \"\")) || \"__all__\", [events]);\n  const queryKey = useMemo(() => [contract.chain.id, contract.address, \"logs\", eventsKey], [contract.address, contract.chain, eventsKey]);\n  const query = useQuery({\n    enabled,\n    queryFn: async () => {\n      const rpcRequest = getRpcClient(contract);\n      const currentBlockNumber = await eth_blockNumber(rpcRequest);\n      latestBlockNumber.current = currentBlockNumber;\n      const initialEvents = await getContractEvents({\n        contract,\n        events: events,\n        fromBlock: currentBlockNumber - BigInt(blockRange)\n      });\n      return initialEvents;\n    },\n    queryKey\n  });\n  useEffect(() => {\n    if (!enabled || !watch) {\n      // don't watch if not enabled or if watch is false\n      return;\n    }\n    // the return is important here because it will unwatch the events\n    return watchContractEvents({\n      contract,\n      events,\n      latestBlockNumber: latestBlockNumber.current,\n      onEvents: newEvents => {\n        if (newEvents.length > 0 && newEvents[0]) {\n          latestBlockNumber.current = newEvents[0].blockNumber; // Update the latest block number to avoid duplicate events if a new poller is spawned during this block\n        }\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n        queryClient.setQueryData(queryKey, function () {\n          let oldEvents = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n          return [...oldEvents, ...newEvents];\n        });\n      }\n    });\n  }, [contract, enabled, events, queryClient, queryKey, watch]);\n  return query;\n}","map":{"version":3,"names":["useQuery","useQueryClient","useEffect","useMemo","useRef","getContractEvents","watchContractEvents","eth_blockNumber","getRpcClient","useContractEvents","options","contract","events","blockRange","enabled","watch","latestBlockNumber","undefined","queryClient","eventsKey","reduce","acc","curr","concat","hash","topics","join","queryKey","chain","id","address","query","queryFn","rpcRequest","currentBlockNumber","current","initialEvents","fromBlock","BigInt","onEvents","newEvents","length","blockNumber","setQueryData","oldEvents","arguments"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/react/core/hooks/contract/useContractEvents.ts"],"sourcesContent":["import {\n  type UseQueryResult,\n  useQuery,\n  useQueryClient,\n} from \"@tanstack/react-query\";\nimport type { Abi, AbiEvent } from \"abitype\";\nimport { useEffect, useMemo, useRef } from \"react\";\nimport { getContractEvents } from \"../../../../event/actions/get-events.js\";\nimport type { ParseEventLogsResult } from \"../../../../event/actions/parse-logs.js\";\nimport {\n  type WatchContractEventsOptions,\n  watchContractEvents,\n} from \"../../../../event/actions/watch-events.js\";\nimport type { PreparedEvent } from \"../../../../event/prepare-event.js\";\nimport { eth_blockNumber } from \"../../../../rpc/actions/eth_blockNumber.js\";\nimport { getRpcClient } from \"../../../../rpc/rpc.js\";\n\ntype UseContractEventsOptions<\n  abi extends Abi,\n  abiEvents extends PreparedEvent<AbiEvent>[],\n> = Omit<WatchContractEventsOptions<abi, abiEvents, true>, \"onEvents\"> & {\n  blockRange?: number;\n  enabled?: boolean;\n  watch?: boolean;\n};\n\n/**\n * Watches contract events and returns the parsed logs.\n * @param options - The options for watching contract events.\n * @param options.contract - The contract to watch events for.\n * @param options.events - The events to watch. Shuould be an array of [prepared events](https://portal.thirdweb.com/references/typescript/v5/prepareEvent).\n * @param options.blockRange - The number of blocks to search for events.\n * @param options.enabled - Whether to enable the query.\n * @param options.watch - Whether to watch for new events.\n * @returns The contract events of the watched contract events.\n * @example\n *\n * ### Using event extensions\n *\n * The `thirdweb/extensions` export contains event definitions for many popular contracts.\n * You can use these event definitions to watch for specific events with a type-safe API.\n *\n * ```jsx\n * import { useContractEvents } from \"thirdweb/react\";\n * import { tokensClaimedEvent } from \"thirdweb/extensions/erc721\";\n *\n * const account = useActiveAccount();\n * const contractEvents = useContractEvents({\n *  contract,\n *  events: [tokensClaimedEvent({ claimer: account?.address })],\n * });\n * ```\n *\n * ### Using custom events\n *\n * You can also watch for custom events by passing an array of [prepared events](https://portal.thirdweb.com/references/typescript/v5/prepareEvent).\n *\n * ```jsx\n * import { useContractEvents } from \"thirdweb/react\";\n * import { prepareEvent } from \"thirdweb\";\n *\n * const myEvent = prepareEvent({\n *  signature: \"event MyEvent(uint256 myArg)\",\n * });\n *\n * const contractEvents = useContractEvents({\n *  contract,\n *  events: [myEvent],\n * });\n * ```\n *\n * @contract\n */\nexport function useContractEvents<\n  const abi extends Abi,\n  const abiEvents extends PreparedEvent<AbiEvent>[],\n>(\n  options: UseContractEventsOptions<abi, abiEvents>,\n): UseQueryResult<ParseEventLogsResult<abiEvents, true>, Error> {\n  const {\n    contract,\n    events,\n    blockRange = 2000,\n    enabled = true,\n    watch = true,\n  } = options;\n  const latestBlockNumber = useRef<bigint>(undefined); // We use this to keep track of the latest block number when new pollers are spawned\n\n  const queryClient = useQueryClient();\n\n  const eventsKey = useMemo(\n    () =>\n      events?.reduce((acc, curr) => {\n        // we can use the event hash as a unique identifier?\n        return `${acc}${curr.hash}${curr.topics.join(\"\")}_`;\n      }, \"\") || \"__all__\",\n    [events],\n  );\n\n  const queryKey = useMemo(\n    () => [contract.chain.id, contract.address, \"logs\", eventsKey] as const,\n    [contract.address, contract.chain, eventsKey],\n  );\n\n  const query = useQuery({\n    enabled,\n    queryFn: async () => {\n      const rpcRequest = getRpcClient(contract);\n      const currentBlockNumber = await eth_blockNumber(rpcRequest);\n      latestBlockNumber.current = currentBlockNumber;\n      const initialEvents = await getContractEvents({\n        contract,\n        events: events,\n        fromBlock: currentBlockNumber - BigInt(blockRange),\n      });\n      return initialEvents;\n    },\n    queryKey,\n  });\n\n  useEffect(() => {\n    if (!enabled || !watch) {\n      // don't watch if not enabled or if watch is false\n      return;\n    }\n\n    // the return is important here because it will unwatch the events\n    return watchContractEvents<abi, abiEvents>({\n      contract,\n      events,\n      latestBlockNumber: latestBlockNumber.current,\n      onEvents: (newEvents) => {\n        if (newEvents.length > 0 && newEvents[0]) {\n          latestBlockNumber.current = newEvents[0].blockNumber; // Update the latest block number to avoid duplicate events if a new poller is spawned during this block\n        }\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n        queryClient.setQueryData(queryKey, (oldEvents: any = []) => [\n          ...oldEvents,\n          ...newEvents,\n        ]);\n      },\n    });\n  }, [contract, enabled, events, queryClient, queryKey, watch]);\n\n  return query;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}