{"ast":null,"code":"import * as ox__Hex from \"ox/Hex\";\nimport * as ox__Signature from \"ox/Signature\";\nimport * as ox__TransactionEnvelopeEip1559 from \"ox/TransactionEnvelopeEip1559\";\nimport * as ox__TransactionEnvelopeEip2930 from \"ox/TransactionEnvelopeEip2930\";\nimport * as ox__TransactionEnvelopeEip7702 from \"ox/TransactionEnvelopeEip7702\";\nimport * as ox__TransactionEnvelopeLegacy from \"ox/TransactionEnvelopeLegacy\";\n/**\n * Serializes a legacy, EIP-1559, EIP-2930, EIP-4844, or EIP-7702 transaction object.\n *\n * @param options - The serialization options.\n * @param options.transaction - The transaction object to be serialized.\n * @param [options.signature] - The signature to include with the transaction, if necessary.\n * @returns The serialized transaction.\n * @throws An error if the provided transaction object is invalid.\n * @transaction\n * @example\n * ```ts\n * import { serializeTransaction } from \"thirdweb\";\n *\n * const serializedTransaction = serializeTransaction({ transaction: {\n *    to: \"0x\",\n *    value: 0n,\n *  }\n * });\n * ```\n */\nexport function serializeTransaction(options) {\n  const {\n    transaction\n  } = options;\n  const type = getTransactionEnvelopeType(transaction);\n  // This is to maintain compatibility with our old interface (including the signature in the transaction object)\n  const signature = (() => {\n    if (options.signature) {\n      if (\"v\" in options.signature && typeof options.signature.v !== \"undefined\") {\n        return ox__Signature.fromLegacy({\n          r: ox__Hex.toBigInt(options.signature.r),\n          s: ox__Hex.toBigInt(options.signature.s),\n          v: Number(options.signature.v)\n        });\n      }\n      return {\n        r: ox__Hex.toBigInt(options.signature.r),\n        s: ox__Hex.toBigInt(options.signature.s),\n        // We force the Signature type here because we filter for legacy type above\n        yParity: options.signature.yParity\n      };\n    }\n    if (typeof transaction.v === \"undefined\" && typeof transaction.yParity === \"undefined\") {\n      return undefined;\n    }\n    if (transaction.r === undefined || transaction.s === undefined) {\n      throw new Error(\"Invalid signature provided with transaction\");\n    }\n    return {\n      r: typeof transaction.r === \"bigint\" ? transaction.r : ox__Hex.toBigInt(transaction.r),\n      s: typeof transaction.s === \"bigint\" ? transaction.s : ox__Hex.toBigInt(transaction.s),\n      yParity: typeof transaction.v !== \"undefined\" && typeof transaction.yParity === \"undefined\" ? ox__Signature.vToYParity(Number(transaction.v)) : Number(transaction.yParity)\n    };\n  })();\n  if (type === \"eip1559\") {\n    const typedTransaction = transaction;\n    ox__TransactionEnvelopeEip1559.assert(typedTransaction);\n    return ox__TransactionEnvelopeEip1559.serialize(typedTransaction, {\n      signature\n    });\n  }\n  if (type === \"legacy\") {\n    const typedTransaction = transaction;\n    ox__TransactionEnvelopeLegacy.assert(typedTransaction);\n    return ox__TransactionEnvelopeLegacy.serialize(typedTransaction, {\n      signature\n    });\n  }\n  if (type === \"eip2930\") {\n    const typedTransaction = transaction;\n    ox__TransactionEnvelopeEip2930.assert(typedTransaction);\n    return ox__TransactionEnvelopeEip2930.serialize(typedTransaction, {\n      signature\n    });\n  }\n  if (type === \"eip7702\") {\n    const typedTransaction = transaction;\n    ox__TransactionEnvelopeEip7702.assert(typedTransaction);\n    return ox__TransactionEnvelopeEip7702.serialize(typedTransaction, {\n      signature\n    });\n  }\n  throw new Error(\"Invalid transaction type\");\n}\n/**\n * @internal\n */\nfunction getTransactionEnvelopeType(transactionEnvelope) {\n  if (typeof transactionEnvelope.type !== \"undefined\") {\n    return transactionEnvelope.type;\n  }\n  if (typeof transactionEnvelope.authorizationList !== \"undefined\") {\n    return \"eip7702\";\n  }\n  if (typeof transactionEnvelope.maxFeePerGas !== \"undefined\" || typeof transactionEnvelope.maxPriorityFeePerGas !== \"undefined\") {\n    return \"eip1559\";\n  }\n  if (typeof transactionEnvelope.gasPrice !== \"undefined\") {\n    if (typeof transactionEnvelope.accessList !== \"undefined\") {\n      return \"eip2930\";\n    }\n    return \"legacy\";\n  }\n  throw new Error(\"Invalid transaction type\");\n}","map":{"version":3,"names":["ox__Hex","ox__Signature","ox__TransactionEnvelopeEip1559","ox__TransactionEnvelopeEip2930","ox__TransactionEnvelopeEip7702","ox__TransactionEnvelopeLegacy","serializeTransaction","options","transaction","type","getTransactionEnvelopeType","signature","v","fromLegacy","r","toBigInt","s","Number","yParity","undefined","Error","vToYParity","typedTransaction","assert","serialize","transactionEnvelope","authorizationList","maxFeePerGas","maxPriorityFeePerGas","gasPrice","accessList"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/transaction/serialize-transaction.ts"],"sourcesContent":["import * as ox__Hex from \"ox/Hex\";\nimport * as ox__Signature from \"ox/Signature\";\nimport * as ox__TransactionEnvelopeEip1559 from \"ox/TransactionEnvelopeEip1559\";\nimport * as ox__TransactionEnvelopeEip2930 from \"ox/TransactionEnvelopeEip2930\";\nimport * as ox__TransactionEnvelopeEip7702 from \"ox/TransactionEnvelopeEip7702\";\nimport * as ox__TransactionEnvelopeLegacy from \"ox/TransactionEnvelopeLegacy\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\n\nexport type SerializableTransaction = {\n  type?: string | undefined;\n  r?: Hex | bigint;\n  s?: Hex | bigint;\n  v?: bigint | number;\n  yParity?: bigint | number;\n  accessList?:\n    | ox__TransactionEnvelopeEip2930.TransactionEnvelopeEip2930[\"accessList\"]\n    | undefined;\n  chainId?: number | undefined;\n  gasPrice?: bigint | undefined;\n  maxFeePerGas?: bigint | undefined;\n  maxPriorityFeePerGas?: bigint | undefined;\n  data?: Hex | undefined;\n  to?: string | null | undefined; // Must allow null for backwards compatibility\n  nonce?: number | bigint | undefined;\n  value?: bigint | undefined;\n  gas?: bigint | undefined;\n  gasLimit?: bigint | undefined;\n  authorizationList?:\n    | ox__TransactionEnvelopeEip7702.TransactionEnvelopeEip7702[\"authorizationList\"]\n    | undefined;\n};\n\nexport type SerializeTransactionOptions = {\n  transaction: SerializableTransaction;\n  signature?:\n    | ox__Signature.Signature<true, Hex>\n    | ox__Signature.Legacy<Hex, bigint>\n    | undefined;\n};\n\n/**\n * Serializes a legacy, EIP-1559, EIP-2930, EIP-4844, or EIP-7702 transaction object.\n *\n * @param options - The serialization options.\n * @param options.transaction - The transaction object to be serialized.\n * @param [options.signature] - The signature to include with the transaction, if necessary.\n * @returns The serialized transaction.\n * @throws An error if the provided transaction object is invalid.\n * @transaction\n * @example\n * ```ts\n * import { serializeTransaction } from \"thirdweb\";\n *\n * const serializedTransaction = serializeTransaction({ transaction: {\n *    to: \"0x\",\n *    value: 0n,\n *  }\n * });\n * ```\n */\nexport function serializeTransaction(\n  options: SerializeTransactionOptions,\n): Hex {\n  const { transaction } = options;\n\n  const type = getTransactionEnvelopeType(transaction);\n\n  // This is to maintain compatibility with our old interface (including the signature in the transaction object)\n  const signature = (() => {\n    if (options.signature) {\n      if (\n        \"v\" in options.signature &&\n        typeof options.signature.v !== \"undefined\"\n      ) {\n        return ox__Signature.fromLegacy({\n          r: ox__Hex.toBigInt(options.signature.r),\n          s: ox__Hex.toBigInt(options.signature.s),\n          v: Number(options.signature.v),\n        });\n      }\n\n      return {\n        r: ox__Hex.toBigInt(options.signature.r),\n        s: ox__Hex.toBigInt(options.signature.s),\n        // We force the Signature type here because we filter for legacy type above\n        yParity: (options.signature as unknown as ox__Signature.Signature)\n          .yParity,\n      };\n    }\n    if (\n      typeof transaction.v === \"undefined\" &&\n      typeof transaction.yParity === \"undefined\"\n    ) {\n      return undefined;\n    }\n\n    if (transaction.r === undefined || transaction.s === undefined) {\n      throw new Error(\"Invalid signature provided with transaction\");\n    }\n\n    return {\n      r:\n        typeof transaction.r === \"bigint\"\n          ? transaction.r\n          : ox__Hex.toBigInt(transaction.r),\n      s:\n        typeof transaction.s === \"bigint\"\n          ? transaction.s\n          : ox__Hex.toBigInt(transaction.s),\n      yParity:\n        typeof transaction.v !== \"undefined\" &&\n        typeof transaction.yParity === \"undefined\"\n          ? ox__Signature.vToYParity(Number(transaction.v))\n          : Number(transaction.yParity),\n    };\n  })();\n\n  if (type === \"eip1559\") {\n    const typedTransaction =\n      transaction as ox__TransactionEnvelopeEip1559.TransactionEnvelopeEip1559;\n    ox__TransactionEnvelopeEip1559.assert(typedTransaction);\n\n    return ox__TransactionEnvelopeEip1559.serialize(typedTransaction, {\n      signature,\n    });\n  }\n\n  if (type === \"legacy\") {\n    const typedTransaction =\n      transaction as ox__TransactionEnvelopeLegacy.TransactionEnvelopeLegacy;\n    ox__TransactionEnvelopeLegacy.assert(typedTransaction);\n\n    return ox__TransactionEnvelopeLegacy.serialize(typedTransaction, {\n      signature,\n    });\n  }\n\n  if (type === \"eip2930\") {\n    const typedTransaction =\n      transaction as ox__TransactionEnvelopeEip2930.TransactionEnvelopeEip2930;\n    ox__TransactionEnvelopeEip2930.assert(typedTransaction);\n\n    return ox__TransactionEnvelopeEip2930.serialize(typedTransaction, {\n      signature,\n    });\n  }\n\n  if (type === \"eip7702\") {\n    const typedTransaction =\n      transaction as ox__TransactionEnvelopeEip7702.TransactionEnvelopeEip7702;\n    ox__TransactionEnvelopeEip7702.assert(typedTransaction);\n\n    return ox__TransactionEnvelopeEip7702.serialize(typedTransaction, {\n      signature,\n    });\n  }\n\n  throw new Error(\"Invalid transaction type\");\n}\n\n/**\n * @internal\n */\nfunction getTransactionEnvelopeType(\n  transactionEnvelope: SerializableTransaction,\n) {\n  if (typeof transactionEnvelope.type !== \"undefined\") {\n    return transactionEnvelope.type;\n  }\n\n  if (typeof transactionEnvelope.authorizationList !== \"undefined\") {\n    return \"eip7702\";\n  }\n\n  if (\n    typeof transactionEnvelope.maxFeePerGas !== \"undefined\" ||\n    typeof transactionEnvelope.maxPriorityFeePerGas !== \"undefined\"\n  ) {\n    return \"eip1559\";\n  }\n\n  if (typeof transactionEnvelope.gasPrice !== \"undefined\") {\n    if (typeof transactionEnvelope.accessList !== \"undefined\") {\n      return \"eip2930\";\n    }\n    return \"legacy\";\n  }\n\n  throw new Error(\"Invalid transaction type\");\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}