{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { trackTransaction } from \"../../../../analytics/track/transaction.js\";\nimport { getCachedChain } from \"../../../../chains/utils.js\";\nimport { eth_sendRawTransaction } from \"../../../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../../../rpc/rpc.js\";\nimport { getAddress } from \"../../../../utils/address.js\";\nimport { getThirdwebDomains } from \"../../../../utils/domains.js\";\nimport { hexToString } from \"../../../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../../../utils/signatures/helpers/parse-typed-data.js\";\n/**\n *\n */\nexport class IFrameWallet {\n  /**\n   * Not meant to be initialized directly. Call {@link initializeUser} to get an instance\n   * @internal\n   */\n  constructor(_ref) {\n    let {\n      client,\n      ecosystem,\n      querier,\n      localStorage\n    } = _ref;\n    Object.defineProperty(this, \"client\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"ecosystem\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"walletManagerQuerier\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"localStorage\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.client = client;\n    this.ecosystem = ecosystem;\n    this.walletManagerQuerier = querier;\n    this.localStorage = localStorage;\n  }\n  /**\n   * Used to set-up the user device in the case that they are using incognito\n   * @returns `{walletAddress : string }` The user's wallet details\n   * @internal\n   */\n  async postWalletSetUp(authResult) {\n    if (authResult.deviceShareStored) {\n      await this.localStorage.saveDeviceShare(authResult.deviceShareStored, authResult.storedToken.authDetails.userWalletId);\n    }\n  }\n  /**\n   * Gets the various status states of the user\n   * @example\n   * ```typescript\n   *  const userStatus = await Paper.getUserWalletStatus();\n   *  switch (userStatus.status) {\n   *  case UserWalletStatus.LOGGED_OUT: {\n   *    // User is logged out, call one of the auth methods on Paper.auth to authenticate the user\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED: {\n   *    // User is logged in, but does not have a wallet associated with it\n   *    // you also have access to the user's details\n   *    userStatus.user.authDetails;\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_NEW_DEVICE: {\n   *    // User is logged in and created a wallet already, but is missing the device shard\n   *    // You have access to:\n   *    userStatus.user.authDetails;\n   *    userStatus.user.walletAddress;\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {\n   *    // user is logged in and wallet is all set up.\n   *    // You have access to:\n   *    userStatus.user.authDetails;\n   *    userStatus.user.walletAddress;\n   *    userStatus.user.wallet;\n   *    break;\n   *  }\n   *}\n   *```\n   * @returns `{GetUserWalletStatusFnReturnType}` an object to containing various information on the user statuses\n   * @internal\n   */\n  async getUserWalletStatus() {\n    const userStatus = await this.walletManagerQuerier.call({\n      params: undefined,\n      procedureName: \"getUserStatus\"\n    });\n    if (userStatus.status === \"Logged In, Wallet Initialized\") {\n      return _objectSpread(_objectSpread({\n        status: \"Logged In, Wallet Initialized\"\n      }, userStatus.user), {}, {\n        account: await this.getAccount()\n      });\n    }\n    if (userStatus.status === \"Logged In, New Device\") {\n      return _objectSpread({\n        status: \"Logged In, New Device\"\n      }, userStatus.user);\n    }\n    if (userStatus.status === \"Logged In, Wallet Uninitialized\") {\n      return _objectSpread({\n        status: \"Logged In, Wallet Uninitialized\"\n      }, userStatus.user);\n    }\n    // Logged out\n    return {\n      status: userStatus.status\n    };\n  }\n  /**\n   * Returns an account that communicates with the iFrame for signing operations\n   * @internal\n   */\n  async getAccount() {\n    var _this$ecosystem;\n    const querier = this.walletManagerQuerier;\n    const client = this.client;\n    const partnerId = (_this$ecosystem = this.ecosystem) === null || _this$ecosystem === void 0 ? void 0 : _this$ecosystem.partnerId;\n    const {\n      address\n    } = await querier.call({\n      params: undefined,\n      procedureName: \"getAddress\"\n    });\n    const _signTransaction = async tx => {\n      var _tx$to;\n      // biome-ignore lint/suspicious/noExplicitAny: ethers tx transformation\n      const transaction = {\n        chainId: tx.chainId,\n        data: tx.data,\n        gasLimit: tx.gas,\n        nonce: tx.nonce,\n        to: (_tx$to = tx.to) !== null && _tx$to !== void 0 ? _tx$to : undefined,\n        value: tx.value\n      };\n      if (tx.maxFeePerGas) {\n        // ethers (in the iframe) rejects any type 0 transaction with unknown keys\n        // TODO remove this once iframe is upgraded to v5\n        transaction.accessList = tx.accessList;\n        transaction.maxFeePerGas = tx.maxFeePerGas;\n        transaction.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n        transaction.type = 2;\n      } else {\n        transaction.gasPrice = tx.gasPrice;\n        transaction.type = 0;\n      }\n      const RPC_URL = getThirdwebDomains().rpc;\n      const {\n        signedTransaction\n      } = await querier.call({\n        params: {\n          chainId: tx.chainId,\n          partnerId,\n          rpcEndpoint: \"https://\".concat(tx.chainId, \".\").concat(RPC_URL),\n          transaction // TODO (ew) shouldnt be needed\n        },\n        procedureName: \"signTransaction\"\n      });\n      return signedTransaction;\n    };\n    return {\n      address: getAddress(address),\n      async sendTransaction(tx) {\n        var _tx$to2;\n        const rpcRequest = getRpcClient({\n          chain: getCachedChain(tx.chainId),\n          client\n        });\n        const signedTx = await _signTransaction(tx);\n        const transactionHash = await eth_sendRawTransaction(rpcRequest, signedTx);\n        trackTransaction({\n          chainId: tx.chainId,\n          client,\n          contractAddress: (_tx$to2 = tx.to) !== null && _tx$to2 !== void 0 ? _tx$to2 : undefined,\n          gasPrice: tx.gasPrice,\n          transactionHash,\n          walletAddress: address,\n          walletType: \"inApp\"\n        });\n        return {\n          transactionHash\n        };\n      },\n      async signMessage(_ref2) {\n        let {\n          message\n        } = _ref2;\n        // in-app wallets use ethers to sign messages, which always expects a string (or bytes maybe but string is safest)\n        const messageDecoded = (() => {\n          if (typeof message === \"string\") {\n            return message;\n          }\n          if (message.raw instanceof Uint8Array) {\n            return message.raw;\n          }\n          return hexToString(message.raw);\n        })();\n        const {\n          signedMessage\n        } = await querier.call({\n          params: {\n            chainId: 1,\n            // needs bytes or string\n            // biome-ignore lint/suspicious/noExplicitAny: ethers tx transformation\n            message: messageDecoded,\n            partnerId // TODO check if we need this\n          },\n          procedureName: \"signMessage\"\n        });\n        return signedMessage;\n      },\n      async signTransaction(tx) {\n        if (!tx.chainId) {\n          throw new Error(\"chainId required in tx to sign\");\n        }\n        return _signTransaction(_objectSpread(_objectSpread({}, tx), {}, {\n          chainId: tx.chainId\n        }));\n      },\n      async signTypedData(_typedData) {\n        var _parsedTypedData$type;\n        const parsedTypedData = parseTypedData(_typedData);\n        // deleting EIP712 Domain as it results in ambiguous primary type on some cases\n        // this happens when going from viem to ethers via the iframe\n        if ((_parsedTypedData$type = parsedTypedData.types) !== null && _parsedTypedData$type !== void 0 && _parsedTypedData$type.EIP712Domain) {\n          parsedTypedData.types.EIP712Domain = undefined;\n        }\n        const domain = parsedTypedData.domain;\n        const chainId = domain === null || domain === void 0 ? void 0 : domain.chainId;\n        const verifyingContract = domain !== null && domain !== void 0 && domain.verifyingContract ? {\n          verifyingContract: domain === null || domain === void 0 ? void 0 : domain.verifyingContract\n        } : {};\n        const domainData = _objectSpread(_objectSpread({}, verifyingContract), {}, {\n          name: domain === null || domain === void 0 ? void 0 : domain.name,\n          version: domain === null || domain === void 0 ? void 0 : domain.version\n        });\n        // chain id can't be included if it wasn't explicitly specified\n        if (chainId) {\n          domainData.chainId = chainId;\n        }\n        const RPC_URL = getThirdwebDomains().rpc;\n        const {\n          signedTypedData\n        } = await querier.call({\n          params: {\n            chainId: Number.parseInt(BigInt(chainId || 1).toString()),\n            domain: domainData,\n            message: parsedTypedData.message,\n            partnerId,\n            rpcEndpoint: \"https://\".concat(chainId, \".\").concat(RPC_URL),\n            types: parsedTypedData.types // TODO (ew) shouldnt be needed\n          },\n          procedureName: \"signTypedDataV4\"\n        });\n        return signedTypedData;\n      }\n    };\n  }\n}","map":{"version":3,"names":["trackTransaction","getCachedChain","eth_sendRawTransaction","getRpcClient","getAddress","getThirdwebDomains","hexToString","parseTypedData","IFrameWallet","constructor","_ref","client","ecosystem","querier","localStorage","Object","defineProperty","walletManagerQuerier","postWalletSetUp","authResult","deviceShareStored","saveDeviceShare","storedToken","authDetails","userWalletId","getUserWalletStatus","userStatus","call","params","undefined","procedureName","status","_objectSpread","user","account","getAccount","_this$ecosystem","partnerId","address","_signTransaction","tx","_tx$to","transaction","chainId","data","gasLimit","gas","nonce","to","value","maxFeePerGas","accessList","maxPriorityFeePerGas","type","gasPrice","RPC_URL","rpc","signedTransaction","rpcEndpoint","concat","sendTransaction","_tx$to2","rpcRequest","chain","signedTx","transactionHash","contractAddress","walletAddress","walletType","signMessage","_ref2","message","messageDecoded","raw","Uint8Array","signedMessage","signTransaction","Error","signTypedData","_typedData","_parsedTypedData$type","parsedTypedData","types","EIP712Domain","domain","verifyingContract","domainData","name","version","signedTypedData","Number","parseInt","BigInt","toString"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/wallets/in-app/web/lib/iframe-wallet.ts"],"sourcesContent":["import type * as ethers5 from \"ethers5\";\nimport type { TypedDataDefinition } from \"viem\";\nimport { trackTransaction } from \"../../../../analytics/track/transaction.js\";\nimport { getCachedChain } from \"../../../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { eth_sendRawTransaction } from \"../../../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../../../rpc/rpc.js\";\nimport { getAddress } from \"../../../../utils/address.js\";\nimport { getThirdwebDomains } from \"../../../../utils/domains.js\";\nimport { type Hex, hexToString } from \"../../../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../../../utils/signatures/helpers/parse-typed-data.js\";\nimport type { Prettify } from \"../../../../utils/type-utils.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n} from \"../../../interfaces/wallet.js\";\nimport type { ClientScopedStorage } from \"../../core/authentication/client-scoped-storage.js\";\nimport type {\n  AuthResultAndRecoveryCode,\n  GetUser,\n  GetUserWalletStatusRpcReturnType,\n} from \"../../core/authentication/types.js\";\nimport type { Ecosystem } from \"../../core/wallet/types.js\";\nimport type { IWebWallet } from \"../../core/wallet/web-wallet.js\";\nimport type {\n  ClientIdWithQuerierType,\n  GetAddressReturnType,\n  SignedTypedDataReturnType,\n  SignMessageReturnType,\n  SignTransactionReturnType,\n} from \"../types.js\";\nimport type { InAppWalletIframeCommunicator } from \"../utils/iFrameCommunication/InAppWalletIframeCommunicator.js\";\n\ntype WalletManagementTypes = {\n  createWallet: undefined;\n  setUpNewDevice: undefined;\n  getUserStatus: undefined;\n};\ntype WalletManagementUiTypes = {\n  createWalletUi: undefined;\n  setUpNewDeviceUi: undefined;\n};\n\ntype SignerProcedureTypes = {\n  getAddress: undefined;\n  signMessage: {\n    message: string | Hex;\n    chainId: number;\n    rpcEndpoint?: string;\n    partnerId?: string;\n  };\n  signTransaction: {\n    transaction: ethers5.ethers.providers.TransactionRequest;\n    chainId: number;\n    rpcEndpoint?: string;\n    partnerId?: string;\n  };\n  signTypedDataV4: {\n    domain: TypedDataDefinition[\"domain\"];\n    types: TypedDataDefinition[\"types\"];\n    message: TypedDataDefinition[\"message\"];\n    chainId: number;\n    rpcEndpoint?: string;\n    partnerId?: string;\n  };\n  //connect: { provider: Provider };\n};\n\n/**\n *\n */\nexport class IFrameWallet implements IWebWallet {\n  public client: ThirdwebClient;\n  public ecosystem?: Ecosystem;\n  protected walletManagerQuerier: InAppWalletIframeCommunicator<\n    WalletManagementTypes & WalletManagementUiTypes\n  >;\n  protected localStorage: ClientScopedStorage;\n\n  /**\n   * Not meant to be initialized directly. Call {@link initializeUser} to get an instance\n   * @internal\n   */\n  constructor({\n    client,\n    ecosystem,\n    querier,\n    localStorage,\n  }: Prettify<\n    ClientIdWithQuerierType & {\n      ecosystem?: Ecosystem;\n      localStorage: ClientScopedStorage;\n    }\n  >) {\n    this.client = client;\n    this.ecosystem = ecosystem;\n    this.walletManagerQuerier = querier;\n    this.localStorage = localStorage;\n  }\n\n  /**\n   * Used to set-up the user device in the case that they are using incognito\n   * @returns `{walletAddress : string }` The user's wallet details\n   * @internal\n   */\n  async postWalletSetUp(authResult: AuthResultAndRecoveryCode): Promise<void> {\n    if (authResult.deviceShareStored) {\n      await this.localStorage.saveDeviceShare(\n        authResult.deviceShareStored,\n        authResult.storedToken.authDetails.userWalletId,\n      );\n    }\n  }\n\n  /**\n   * Gets the various status states of the user\n   * @example\n   * ```typescript\n   *  const userStatus = await Paper.getUserWalletStatus();\n   *  switch (userStatus.status) {\n   *  case UserWalletStatus.LOGGED_OUT: {\n   *    // User is logged out, call one of the auth methods on Paper.auth to authenticate the user\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED: {\n   *    // User is logged in, but does not have a wallet associated with it\n   *    // you also have access to the user's details\n   *    userStatus.user.authDetails;\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_NEW_DEVICE: {\n   *    // User is logged in and created a wallet already, but is missing the device shard\n   *    // You have access to:\n   *    userStatus.user.authDetails;\n   *    userStatus.user.walletAddress;\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {\n   *    // user is logged in and wallet is all set up.\n   *    // You have access to:\n   *    userStatus.user.authDetails;\n   *    userStatus.user.walletAddress;\n   *    userStatus.user.wallet;\n   *    break;\n   *  }\n   *}\n   *```\n   * @returns `{GetUserWalletStatusFnReturnType}` an object to containing various information on the user statuses\n   * @internal\n   */\n  async getUserWalletStatus(): Promise<GetUser> {\n    const userStatus =\n      await this.walletManagerQuerier.call<GetUserWalletStatusRpcReturnType>({\n        params: undefined,\n        procedureName: \"getUserStatus\",\n      });\n    if (userStatus.status === \"Logged In, Wallet Initialized\") {\n      return {\n        status: \"Logged In, Wallet Initialized\",\n        ...userStatus.user,\n        account: await this.getAccount(),\n      };\n    }\n    if (userStatus.status === \"Logged In, New Device\") {\n      return {\n        status: \"Logged In, New Device\",\n        ...userStatus.user,\n      };\n    }\n    if (userStatus.status === \"Logged In, Wallet Uninitialized\") {\n      return {\n        status: \"Logged In, Wallet Uninitialized\",\n        ...userStatus.user,\n      };\n    }\n    // Logged out\n    return { status: userStatus.status };\n  }\n\n  /**\n   * Returns an account that communicates with the iFrame for signing operations\n   * @internal\n   */\n  async getAccount(): Promise<Account> {\n    const querier = this\n      .walletManagerQuerier as unknown as InAppWalletIframeCommunicator<SignerProcedureTypes>;\n    const client = this.client;\n    const partnerId = this.ecosystem?.partnerId;\n\n    const { address } = await querier.call<GetAddressReturnType>({\n      params: undefined,\n      procedureName: \"getAddress\",\n    });\n    const _signTransaction = async (tx: SendTransactionOption) => {\n      // biome-ignore lint/suspicious/noExplicitAny: ethers tx transformation\n      const transaction: Record<string, any> = {\n        chainId: tx.chainId,\n        data: tx.data,\n        gasLimit: tx.gas,\n        nonce: tx.nonce,\n        to: tx.to ?? undefined,\n        value: tx.value,\n      };\n\n      if (tx.maxFeePerGas) {\n        // ethers (in the iframe) rejects any type 0 transaction with unknown keys\n        // TODO remove this once iframe is upgraded to v5\n        transaction.accessList = tx.accessList;\n        transaction.maxFeePerGas = tx.maxFeePerGas;\n        transaction.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n        transaction.type = 2;\n      } else {\n        transaction.gasPrice = tx.gasPrice;\n        transaction.type = 0;\n      }\n      const RPC_URL = getThirdwebDomains().rpc;\n      const { signedTransaction } =\n        await querier.call<SignTransactionReturnType>({\n          params: {\n            chainId: tx.chainId,\n            partnerId,\n            rpcEndpoint: `https://${tx.chainId}.${RPC_URL}`,\n            transaction, // TODO (ew) shouldnt be needed\n          },\n          procedureName: \"signTransaction\",\n        });\n      return signedTransaction as Hex;\n    };\n    return {\n      address: getAddress(address),\n      async sendTransaction(tx) {\n        const rpcRequest = getRpcClient({\n          chain: getCachedChain(tx.chainId),\n          client,\n        });\n        const signedTx = await _signTransaction(tx);\n\n        const transactionHash = await eth_sendRawTransaction(\n          rpcRequest,\n          signedTx,\n        );\n\n        trackTransaction({\n          chainId: tx.chainId,\n          client,\n          contractAddress: tx.to ?? undefined,\n          gasPrice: tx.gasPrice,\n          transactionHash,\n          walletAddress: address,\n          walletType: \"inApp\",\n        });\n\n        return { transactionHash };\n      },\n      async signMessage({ message }) {\n        // in-app wallets use ethers to sign messages, which always expects a string (or bytes maybe but string is safest)\n        const messageDecoded = (() => {\n          if (typeof message === \"string\") {\n            return message;\n          }\n          if (message.raw instanceof Uint8Array) {\n            return message.raw;\n          }\n          return hexToString(message.raw);\n        })();\n\n        const { signedMessage } = await querier.call<SignMessageReturnType>({\n          params: {\n            chainId: 1, // needs bytes or string\n            // biome-ignore lint/suspicious/noExplicitAny: ethers tx transformation\n            message: messageDecoded as any,\n            partnerId, // TODO check if we need this\n          },\n          procedureName: \"signMessage\",\n        });\n        return signedMessage as Hex;\n      },\n      async signTransaction(tx) {\n        if (!tx.chainId) {\n          throw new Error(\"chainId required in tx to sign\");\n        }\n        return _signTransaction({\n          ...tx,\n          chainId: tx.chainId,\n        });\n      },\n      async signTypedData(_typedData) {\n        const parsedTypedData = parseTypedData(_typedData);\n        // deleting EIP712 Domain as it results in ambiguous primary type on some cases\n        // this happens when going from viem to ethers via the iframe\n        if (parsedTypedData.types?.EIP712Domain) {\n          parsedTypedData.types.EIP712Domain = undefined;\n        }\n        const domain = parsedTypedData.domain as TypedDataDefinition[\"domain\"];\n        const chainId = domain?.chainId;\n        const verifyingContract = domain?.verifyingContract\n          ? { verifyingContract: domain?.verifyingContract }\n          : {};\n        const domainData = {\n          ...verifyingContract,\n          name: domain?.name,\n          version: domain?.version,\n        };\n        // chain id can't be included if it wasn't explicitly specified\n        if (chainId) {\n          (domainData as Record<string, unknown>).chainId = chainId;\n        }\n\n        const RPC_URL = getThirdwebDomains().rpc;\n        const { signedTypedData } =\n          await querier.call<SignedTypedDataReturnType>({\n            params: {\n              chainId: Number.parseInt(BigInt(chainId || 1).toString()),\n              domain: domainData,\n              message:\n                parsedTypedData.message as SignerProcedureTypes[\"signTypedDataV4\"][\"message\"],\n              partnerId,\n              rpcEndpoint: `https://${chainId}.${RPC_URL}`,\n              types:\n                parsedTypedData.types as SignerProcedureTypes[\"signTypedDataV4\"][\"types\"], // TODO (ew) shouldnt be needed\n            },\n            procedureName: \"signTypedDataV4\",\n          });\n        return signedTypedData as Hex;\n      },\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}