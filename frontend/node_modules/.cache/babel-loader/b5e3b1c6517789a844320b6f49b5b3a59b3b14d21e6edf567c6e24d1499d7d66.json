{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"enabled\", \"type\"];\nimport { useQuery } from \"@tanstack/react-query\";\nimport * as Bridge from \"../../../bridge/index.js\";\nimport { ApiError } from \"../../../bridge/types/Errors.js\";\nimport { stringify } from \"../../../utils/json.js\";\nimport { mapBridgeError } from \"../errors/mapBridgeError.js\";\n/**\n * Hook that prepares bridge transactions with caching and retry logic\n *\n * @param params - Parameters for preparing bridge transactions including type and specific options\n * @returns React Query result with prepared transaction data, loading state, and error handling\n *\n * @example\n * ```tsx\n * // Buy preparation\n * const { data: preparedBuy, isLoading, error } = useBridgePrepare({\n *   type: \"buy\",\n *   client: thirdwebClient,\n *   originChainId: 1,\n *   originTokenAddress: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *   destinationChainId: 137,\n *   destinationTokenAddress: \"0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619\",\n *   amount: parseEther(\"1\"),\n *   sender: \"0x...\",\n *   receiver: \"0x...\"\n * });\n *\n * // Transfer preparation\n * const { data: preparedTransfer } = useBridgePrepare({\n *   type: \"transfer\",\n *   client: thirdwebClient,\n *   originChainId: 1,\n *   originTokenAddress: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n *   destinationChainId: 137,\n *   destinationTokenAddress: \"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\",\n *   amount: 1000000n,\n *   sender: \"0x...\",\n *   receiver: \"0x...\"\n * });\n * ```\n */\nexport function useBridgePrepare(params) {\n  const {\n      enabled = true,\n      type\n    } = params,\n    prepareParams = _objectWithoutProperties(params, _excluded);\n  return useQuery({\n    enabled: enabled && !!prepareParams.client,\n    gcTime: 5 * 60 * 1000,\n    queryFn: async () => {\n      switch (type) {\n        case \"buy\":\n          {\n            const result = await Bridge.Buy.prepare(prepareParams);\n            return _objectSpread({\n              type: \"buy\"\n            }, result);\n          }\n        case \"sell\":\n          {\n            const result = await Bridge.Sell.prepare(prepareParams);\n            return _objectSpread({\n              type: \"sell\"\n            }, result);\n          }\n        case \"transfer\":\n          {\n            const result = await Bridge.Transfer.prepare(prepareParams);\n            return _objectSpread({\n              type: \"transfer\"\n            }, result);\n          }\n        case \"onramp\":\n          {\n            const result = await Bridge.Onramp.prepare(prepareParams);\n            return _objectSpread({\n              type: \"onramp\"\n            }, result);\n          }\n        default:\n          throw new Error(\"Unsupported bridge prepare type: \".concat(type));\n      }\n    },\n    queryKey: [\"bridge-prepare\", type, stringify(prepareParams)],\n    // 2 minutes - prepared quotes have shorter validity\n    retry: (failureCount, error) => {\n      // Handle both ApiError and generic Error instances\n      if (error instanceof ApiError) {\n        const bridgeError = mapBridgeError(error);\n        // Don't retry on client-side errors (4xx)\n        if (bridgeError.statusCode && bridgeError.statusCode >= 400 && bridgeError.statusCode < 500) {\n          return false;\n        }\n      }\n      // Retry up to 2 times for prepared quotes (they're more time-sensitive)\n      return failureCount < 2;\n    },\n    // 5 minutes garbage collection\n    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 10000),\n    staleTime: 2 * 60 * 1000 // Exponential backoff, max 10s\n  });\n}","map":{"version":3,"names":["useQuery","Bridge","ApiError","stringify","mapBridgeError","useBridgePrepare","params","enabled","type","prepareParams","_objectWithoutProperties","_excluded","client","gcTime","queryFn","result","Buy","prepare","_objectSpread","Sell","Transfer","Onramp","Error","concat","queryKey","retry","failureCount","error","bridgeError","statusCode","retryDelay","attemptIndex","Math","min","staleTime"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/react/core/hooks/useBridgePrepare.ts"],"sourcesContent":["import { useQuery } from \"@tanstack/react-query\";\nimport type { prepare as BuyPrepare } from \"../../../bridge/Buy.js\";\nimport * as Bridge from \"../../../bridge/index.js\";\nimport type { prepare as OnrampPrepare } from \"../../../bridge/Onramp.js\";\nimport type { prepare as SellPrepare } from \"../../../bridge/Sell.js\";\nimport type { prepare as TransferPrepare } from \"../../../bridge/Transfer.js\";\nimport { ApiError } from \"../../../bridge/types/Errors.js\";\nimport { stringify } from \"../../../utils/json.js\";\nimport { mapBridgeError } from \"../errors/mapBridgeError.js\";\n\n/**\n * Union type for different Bridge prepare request types\n */\nexport type BridgePrepareRequest =\n  | ({ type: \"buy\" } & BuyPrepare.Options)\n  | ({ type: \"sell\" } & SellPrepare.Options)\n  | ({ type: \"transfer\" } & TransferPrepare.Options)\n  | ({ type: \"onramp\" } & OnrampPrepare.Options);\n\n/**\n * Union type for different Bridge prepare result types\n */\nexport type BridgePrepareResult =\n  | ({ type: \"buy\" } & BuyPrepare.Result)\n  | ({ type: \"sell\" } & SellPrepare.Result)\n  | ({ type: \"transfer\" } & TransferPrepare.Result)\n  | ({ type: \"onramp\" } & OnrampPrepare.Result);\n\n/**\n * Parameters for the useBridgePrepare hook\n */\nexport type UseBridgePrepareParams = BridgePrepareRequest & {\n  /**\n   * Whether to enable the query. Useful for conditional fetching.\n   * @default true\n   */\n  enabled?: boolean;\n};\n\n/**\n * Hook that prepares bridge transactions with caching and retry logic\n *\n * @param params - Parameters for preparing bridge transactions including type and specific options\n * @returns React Query result with prepared transaction data, loading state, and error handling\n *\n * @example\n * ```tsx\n * // Buy preparation\n * const { data: preparedBuy, isLoading, error } = useBridgePrepare({\n *   type: \"buy\",\n *   client: thirdwebClient,\n *   originChainId: 1,\n *   originTokenAddress: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *   destinationChainId: 137,\n *   destinationTokenAddress: \"0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619\",\n *   amount: parseEther(\"1\"),\n *   sender: \"0x...\",\n *   receiver: \"0x...\"\n * });\n *\n * // Transfer preparation\n * const { data: preparedTransfer } = useBridgePrepare({\n *   type: \"transfer\",\n *   client: thirdwebClient,\n *   originChainId: 1,\n *   originTokenAddress: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n *   destinationChainId: 137,\n *   destinationTokenAddress: \"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\",\n *   amount: 1000000n,\n *   sender: \"0x...\",\n *   receiver: \"0x...\"\n * });\n * ```\n */\nexport function useBridgePrepare(params: UseBridgePrepareParams) {\n  const { enabled = true, type, ...prepareParams } = params;\n\n  return useQuery({\n    enabled: enabled && !!prepareParams.client,\n    gcTime: 5 * 60 * 1000,\n    queryFn: async (): Promise<BridgePrepareResult> => {\n      switch (type) {\n        case \"buy\": {\n          const result = await Bridge.Buy.prepare(\n            prepareParams as BuyPrepare.Options,\n          );\n          return { type: \"buy\", ...result };\n        }\n        case \"sell\": {\n          const result = await Bridge.Sell.prepare(\n            prepareParams as SellPrepare.Options,\n          );\n          return { type: \"sell\", ...result };\n        }\n        case \"transfer\": {\n          const result = await Bridge.Transfer.prepare(\n            prepareParams as TransferPrepare.Options,\n          );\n          return { type: \"transfer\", ...result };\n        }\n        case \"onramp\": {\n          const result = await Bridge.Onramp.prepare(\n            prepareParams as OnrampPrepare.Options,\n          );\n          return { type: \"onramp\", ...result };\n        }\n        default:\n          throw new Error(`Unsupported bridge prepare type: ${type}`);\n      }\n    },\n    queryKey: [\"bridge-prepare\", type, stringify(prepareParams)], // 2 minutes - prepared quotes have shorter validity\n    retry: (failureCount, error) => {\n      // Handle both ApiError and generic Error instances\n      if (error instanceof ApiError) {\n        const bridgeError = mapBridgeError(error);\n\n        // Don't retry on client-side errors (4xx)\n        if (\n          bridgeError.statusCode &&\n          bridgeError.statusCode >= 400 &&\n          bridgeError.statusCode < 500\n        ) {\n          return false;\n        }\n      }\n\n      // Retry up to 2 times for prepared quotes (they're more time-sensitive)\n      return failureCount < 2;\n    }, // 5 minutes garbage collection\n    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 10000),\n    staleTime: 2 * 60 * 1000, // Exponential backoff, max 10s\n  });\n}\n"],"mappings":";;;AAAA,SAASA,QAAQ,QAAQ,uBAAuB;AAEhD,OAAO,KAAKC,MAAM,MAAM,0BAA0B;AAIlD,SAASC,QAAQ,QAAQ,iCAAiC;AAC1D,SAASC,SAAS,QAAQ,wBAAwB;AAClD,SAASC,cAAc,QAAQ,6BAA6B;AA+B5D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA,OAAM,SAAUC,gBAAgBA,CAACC,MAA8B;EAC7D,MAAM;MAAEC,OAAO,GAAG,IAAI;MAAEC;IAAsB,CAAE,GAAGF,MAAM;IAAxBG,aAAa,GAAAC,wBAAA,CAAKJ,MAAM,EAAAK,SAAA;EAEzD,OAAOX,QAAQ,CAAC;IACdO,OAAO,EAAEA,OAAO,IAAI,CAAC,CAACE,aAAa,CAACG,MAAM;IAC1CC,MAAM,EAAE,CAAC,GAAG,EAAE,GAAG,IAAI;IACrBC,OAAO,EAAE,MAAAA,CAAA,KAAyC;MAChD,QAAQN,IAAI;QACV,KAAK,KAAK;UAAE;YACV,MAAMO,MAAM,GAAG,MAAMd,MAAM,CAACe,GAAG,CAACC,OAAO,CACrCR,aAAmC,CACpC;YACD,OAAAS,aAAA;cAASV,IAAI,EAAE;YAAK,GAAKO,MAAM;UACjC;QACA,KAAK,MAAM;UAAE;YACX,MAAMA,MAAM,GAAG,MAAMd,MAAM,CAACkB,IAAI,CAACF,OAAO,CACtCR,aAAoC,CACrC;YACD,OAAAS,aAAA;cAASV,IAAI,EAAE;YAAM,GAAKO,MAAM;UAClC;QACA,KAAK,UAAU;UAAE;YACf,MAAMA,MAAM,GAAG,MAAMd,MAAM,CAACmB,QAAQ,CAACH,OAAO,CAC1CR,aAAwC,CACzC;YACD,OAAAS,aAAA;cAASV,IAAI,EAAE;YAAU,GAAKO,MAAM;UACtC;QACA,KAAK,QAAQ;UAAE;YACb,MAAMA,MAAM,GAAG,MAAMd,MAAM,CAACoB,MAAM,CAACJ,OAAO,CACxCR,aAAsC,CACvC;YACD,OAAAS,aAAA;cAASV,IAAI,EAAE;YAAQ,GAAKO,MAAM;UACpC;QACA;UACE,MAAM,IAAIO,KAAK,qCAAAC,MAAA,CAAqCf,IAAI,CAAE,CAAC;MAC/D;IACF,CAAC;IACDgB,QAAQ,EAAE,CAAC,gBAAgB,EAAEhB,IAAI,EAAEL,SAAS,CAACM,aAAa,CAAC,CAAC;IAAE;IAC9DgB,KAAK,EAAEA,CAACC,YAAY,EAAEC,KAAK,KAAI;MAC7B;MACA,IAAIA,KAAK,YAAYzB,QAAQ,EAAE;QAC7B,MAAM0B,WAAW,GAAGxB,cAAc,CAACuB,KAAK,CAAC;QAEzC;QACA,IACEC,WAAW,CAACC,UAAU,IACtBD,WAAW,CAACC,UAAU,IAAI,GAAG,IAC7BD,WAAW,CAACC,UAAU,GAAG,GAAG,EAC5B;UACA,OAAO,KAAK;QACd;MACF;MAEA;MACA,OAAOH,YAAY,GAAG,CAAC;IACzB,CAAC;IAAE;IACHI,UAAU,EAAGC,YAAY,IAAKC,IAAI,CAACC,GAAG,CAAC,IAAI,GAAG,CAAC,IAAIF,YAAY,EAAE,KAAK,CAAC;IACvEG,SAAS,EAAE,CAAC,GAAG,EAAE,GAAG,IAAI,CAAE;GAC3B,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}