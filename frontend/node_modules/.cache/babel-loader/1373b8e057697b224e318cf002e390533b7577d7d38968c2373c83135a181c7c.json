{"ast":null,"code":"import { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { getContract } from \"../../../../contract/contract.js\";\nimport { resolveAddress } from \"../../../../extensions/ens/resolve-address.js\";\nimport { transfer } from \"../../../../extensions/erc20/write/transfer.js\";\nimport { estimateGas } from \"../../../../transaction/actions/estimate-gas.js\";\nimport { sendTransaction } from \"../../../../transaction/actions/send-transaction.js\";\nimport { waitForReceipt } from \"../../../../transaction/actions/wait-for-tx-receipt.js\";\nimport { prepareTransaction } from \"../../../../transaction/prepare-transaction.js\";\nimport { isAddress } from \"../../../../utils/address.js\";\nimport { isValidENSName } from \"../../../../utils/ens/isValidENSName.js\";\nimport { toWei } from \"../../../../utils/units.js\";\nimport { getWalletBalance } from \"../../../../wallets/utils/getWalletBalance.js\";\nimport { invalidateWalletBalance } from \"../../providers/invalidateWalletBalance.js\";\nimport { useActiveWallet } from \"./useActiveWallet.js\";\n/**\n * Send Native or ERC20 tokens from active wallet to given address.\n * @example\n * ```tsx\n * const { mutate: sendToken } = useSendToken(client);\n *\n * // send native currency\n * sendToken({\n *    receiverAddress: \"0x...\",\n *    amount: \"0.1\",\n * });\n *\n * // send ERC20\n * sendToken({\n *   tokenAddress,\n *   receiverAddress: \"0x...\",\n *   amount: \"0.5\",\n * });\n * ```\n * @wallet\n */\nexport function useSendToken(client) {\n  const wallet = useActiveWallet();\n  const queryClient = useQueryClient();\n  return useMutation({\n    async mutationFn(option) {\n      const {\n        tokenAddress,\n        receiverAddress,\n        amount\n      } = option;\n      const activeChain = wallet === null || wallet === void 0 ? void 0 : wallet.getChain();\n      const account = wallet === null || wallet === void 0 ? void 0 : wallet.getAccount();\n      // state validation\n      if (!activeChain) {\n        throw new Error(\"No active chain\");\n      }\n      if (!account) {\n        throw new Error(\"No active account\");\n      }\n      // input validation\n      if (!receiverAddress || !isValidENSName(receiverAddress) && !isAddress(receiverAddress)) {\n        throw new Error(\"Invalid receiver address\");\n      }\n      if (!amount || Number.isNaN(Number(amount)) || Number(amount) < 0) {\n        throw new Error(\"Invalid amount\");\n      }\n      let to = receiverAddress;\n      // resolve ENS if needed\n      try {\n        to = await resolveAddress({\n          client,\n          name: receiverAddress\n        });\n      } catch (_unused) {\n        throw new Error(\"Failed to resolve address\");\n      }\n      // native token transfer\n      if (!tokenAddress) {\n        const sendNativeTokenTx = prepareTransaction({\n          chain: activeChain,\n          client,\n          to,\n          value: toWei(amount)\n        });\n        const gasEstimate = await estimateGas({\n          account,\n          transaction: sendNativeTokenTx\n        });\n        const balance = await getWalletBalance({\n          address: account.address,\n          chain: activeChain,\n          client\n        });\n        if (toWei(amount) + gasEstimate > balance.value) {\n          throw new Error(\"Insufficient balance for transfer amount and gas\");\n        }\n        return await sendTransaction({\n          account,\n          transaction: sendNativeTokenTx\n        });\n      }\n      // erc20 token transfer\n      else {\n        const contract = getContract({\n          address: tokenAddress,\n          chain: activeChain,\n          client\n        });\n        const tx = transfer({\n          amount,\n          contract,\n          to\n        });\n        return await sendTransaction({\n          account,\n          transaction: tx\n        });\n      }\n    },\n    onSettled: async (data, error) => {\n      if (error) {\n        return;\n      }\n      if (data !== null && data !== void 0 && data.transactionHash) {\n        await waitForReceipt({\n          chain: data.chain,\n          client,\n          maxBlocksWaitTime: 10000,\n          transactionHash: data.transactionHash\n        });\n      }\n      invalidateWalletBalance(queryClient);\n    }\n  });\n}","map":{"version":3,"names":["useMutation","useQueryClient","getContract","resolveAddress","transfer","estimateGas","sendTransaction","waitForReceipt","prepareTransaction","isAddress","isValidENSName","toWei","getWalletBalance","invalidateWalletBalance","useActiveWallet","useSendToken","client","wallet","queryClient","mutationFn","option","tokenAddress","receiverAddress","amount","activeChain","getChain","account","getAccount","Error","Number","isNaN","to","name","_unused","sendNativeTokenTx","chain","value","gasEstimate","transaction","balance","address","contract","tx","onSettled","data","error","transactionHash","maxBlocksWaitTime"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/react/core/hooks/wallets/useSendToken.ts"],"sourcesContent":["import { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { getContract } from \"../../../../contract/contract.js\";\nimport { resolveAddress } from \"../../../../extensions/ens/resolve-address.js\";\nimport { transfer } from \"../../../../extensions/erc20/write/transfer.js\";\nimport { estimateGas } from \"../../../../transaction/actions/estimate-gas.js\";\nimport { sendTransaction } from \"../../../../transaction/actions/send-transaction.js\";\nimport { waitForReceipt } from \"../../../../transaction/actions/wait-for-tx-receipt.js\";\nimport { prepareTransaction } from \"../../../../transaction/prepare-transaction.js\";\nimport { isAddress } from \"../../../../utils/address.js\";\nimport { isValidENSName } from \"../../../../utils/ens/isValidENSName.js\";\nimport { toWei } from \"../../../../utils/units.js\";\nimport { getWalletBalance } from \"../../../../wallets/utils/getWalletBalance.js\";\nimport { invalidateWalletBalance } from \"../../providers/invalidateWalletBalance.js\";\nimport { useActiveWallet } from \"./useActiveWallet.js\";\n\n/**\n * Send Native or ERC20 tokens from active wallet to given address.\n * @example\n * ```tsx\n * const { mutate: sendToken } = useSendToken(client);\n *\n * // send native currency\n * sendToken({\n *    receiverAddress: \"0x...\",\n *    amount: \"0.1\",\n * });\n *\n * // send ERC20\n * sendToken({\n *   tokenAddress,\n *   receiverAddress: \"0x...\",\n *   amount: \"0.5\",\n * });\n * ```\n * @wallet\n */\nexport function useSendToken(client: ThirdwebClient) {\n  const wallet = useActiveWallet();\n  const queryClient = useQueryClient();\n  return useMutation({\n    async mutationFn(option: {\n      tokenAddress?: string;\n      receiverAddress: string;\n      amount: string;\n    }) {\n      const { tokenAddress, receiverAddress, amount } = option;\n      const activeChain = wallet?.getChain();\n      const account = wallet?.getAccount();\n\n      // state validation\n      if (!activeChain) {\n        throw new Error(\"No active chain\");\n      }\n      if (!account) {\n        throw new Error(\"No active account\");\n      }\n\n      // input validation\n      if (\n        !receiverAddress ||\n        (!isValidENSName(receiverAddress) && !isAddress(receiverAddress))\n      ) {\n        throw new Error(\"Invalid receiver address\");\n      }\n\n      if (!amount || Number.isNaN(Number(amount)) || Number(amount) < 0) {\n        throw new Error(\"Invalid amount\");\n      }\n\n      let to = receiverAddress;\n      // resolve ENS if needed\n      try {\n        to = await resolveAddress({\n          client,\n          name: receiverAddress,\n        });\n      } catch {\n        throw new Error(\"Failed to resolve address\");\n      }\n\n      // native token transfer\n      if (!tokenAddress) {\n        const sendNativeTokenTx = prepareTransaction({\n          chain: activeChain,\n          client,\n          to,\n          value: toWei(amount),\n        });\n        const gasEstimate = await estimateGas({\n          account,\n          transaction: sendNativeTokenTx,\n        });\n        const balance = await getWalletBalance({\n          address: account.address,\n          chain: activeChain,\n          client,\n        });\n        if (toWei(amount) + gasEstimate > balance.value) {\n          throw new Error(\"Insufficient balance for transfer amount and gas\");\n        }\n\n        return await sendTransaction({\n          account,\n          transaction: sendNativeTokenTx,\n        });\n      }\n      // erc20 token transfer\n      else {\n        const contract = getContract({\n          address: tokenAddress,\n          chain: activeChain,\n          client,\n        });\n\n        const tx = transfer({\n          amount,\n          contract,\n          to,\n        });\n\n        return await sendTransaction({\n          account,\n          transaction: tx,\n        });\n      }\n    },\n    onSettled: async (data, error) => {\n      if (error) {\n        return;\n      }\n      if (data?.transactionHash) {\n        await waitForReceipt({\n          chain: data.chain,\n          client,\n          maxBlocksWaitTime: 10_000,\n          transactionHash: data.transactionHash,\n        });\n      }\n      invalidateWalletBalance(queryClient);\n    },\n  });\n}\n"],"mappings":"AAAA,SAASA,WAAW,EAAEC,cAAc,QAAQ,uBAAuB;AAEnE,SAASC,WAAW,QAAQ,kCAAkC;AAC9D,SAASC,cAAc,QAAQ,+CAA+C;AAC9E,SAASC,QAAQ,QAAQ,gDAAgD;AACzE,SAASC,WAAW,QAAQ,iDAAiD;AAC7E,SAASC,eAAe,QAAQ,qDAAqD;AACrF,SAASC,cAAc,QAAQ,wDAAwD;AACvF,SAASC,kBAAkB,QAAQ,gDAAgD;AACnF,SAASC,SAAS,QAAQ,8BAA8B;AACxD,SAASC,cAAc,QAAQ,yCAAyC;AACxE,SAASC,KAAK,QAAQ,4BAA4B;AAClD,SAASC,gBAAgB,QAAQ,+CAA+C;AAChF,SAASC,uBAAuB,QAAQ,4CAA4C;AACpF,SAASC,eAAe,QAAQ,sBAAsB;AAEtD;;;;;;;;;;;;;;;;;;;;;AAqBA,OAAM,SAAUC,YAAYA,CAACC,MAAsB;EACjD,MAAMC,MAAM,GAAGH,eAAe,EAAE;EAChC,MAAMI,WAAW,GAAGjB,cAAc,EAAE;EACpC,OAAOD,WAAW,CAAC;IACjB,MAAMmB,UAAUA,CAACC,MAIhB;MACC,MAAM;QAAEC,YAAY;QAAEC,eAAe;QAAEC;MAAM,CAAE,GAAGH,MAAM;MACxD,MAAMI,WAAW,GAAGP,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEQ,QAAQ,EAAE;MACtC,MAAMC,OAAO,GAAGT,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEU,UAAU,EAAE;MAEpC;MACA,IAAI,CAACH,WAAW,EAAE;QAChB,MAAM,IAAII,KAAK,CAAC,iBAAiB,CAAC;MACpC;MACA,IAAI,CAACF,OAAO,EAAE;QACZ,MAAM,IAAIE,KAAK,CAAC,mBAAmB,CAAC;MACtC;MAEA;MACA,IACE,CAACN,eAAe,IACf,CAACZ,cAAc,CAACY,eAAe,CAAC,IAAI,CAACb,SAAS,CAACa,eAAe,CAAE,EACjE;QACA,MAAM,IAAIM,KAAK,CAAC,0BAA0B,CAAC;MAC7C;MAEA,IAAI,CAACL,MAAM,IAAIM,MAAM,CAACC,KAAK,CAACD,MAAM,CAACN,MAAM,CAAC,CAAC,IAAIM,MAAM,CAACN,MAAM,CAAC,GAAG,CAAC,EAAE;QACjE,MAAM,IAAIK,KAAK,CAAC,gBAAgB,CAAC;MACnC;MAEA,IAAIG,EAAE,GAAGT,eAAe;MACxB;MACA,IAAI;QACFS,EAAE,GAAG,MAAM5B,cAAc,CAAC;UACxBa,MAAM;UACNgB,IAAI,EAAEV;SACP,CAAC;MACJ,CAAC,CAAC,OAAAW,OAAA,EAAM;QACN,MAAM,IAAIL,KAAK,CAAC,2BAA2B,CAAC;MAC9C;MAEA;MACA,IAAI,CAACP,YAAY,EAAE;QACjB,MAAMa,iBAAiB,GAAG1B,kBAAkB,CAAC;UAC3C2B,KAAK,EAAEX,WAAW;UAClBR,MAAM;UACNe,EAAE;UACFK,KAAK,EAAEzB,KAAK,CAACY,MAAM;SACpB,CAAC;QACF,MAAMc,WAAW,GAAG,MAAMhC,WAAW,CAAC;UACpCqB,OAAO;UACPY,WAAW,EAAEJ;SACd,CAAC;QACF,MAAMK,OAAO,GAAG,MAAM3B,gBAAgB,CAAC;UACrC4B,OAAO,EAAEd,OAAO,CAACc,OAAO;UACxBL,KAAK,EAAEX,WAAW;UAClBR;SACD,CAAC;QACF,IAAIL,KAAK,CAACY,MAAM,CAAC,GAAGc,WAAW,GAAGE,OAAO,CAACH,KAAK,EAAE;UAC/C,MAAM,IAAIR,KAAK,CAAC,kDAAkD,CAAC;QACrE;QAEA,OAAO,MAAMtB,eAAe,CAAC;UAC3BoB,OAAO;UACPY,WAAW,EAAEJ;SACd,CAAC;MACJ;MACA;MAAA,KACK;QACH,MAAMO,QAAQ,GAAGvC,WAAW,CAAC;UAC3BsC,OAAO,EAAEnB,YAAY;UACrBc,KAAK,EAAEX,WAAW;UAClBR;SACD,CAAC;QAEF,MAAM0B,EAAE,GAAGtC,QAAQ,CAAC;UAClBmB,MAAM;UACNkB,QAAQ;UACRV;SACD,CAAC;QAEF,OAAO,MAAMzB,eAAe,CAAC;UAC3BoB,OAAO;UACPY,WAAW,EAAEI;SACd,CAAC;MACJ;IACF,CAAC;IACDC,SAAS,EAAE,MAAAA,CAAOC,IAAI,EAAEC,KAAK,KAAI;MAC/B,IAAIA,KAAK,EAAE;QACT;MACF;MACA,IAAID,IAAI,aAAJA,IAAI,eAAJA,IAAI,CAAEE,eAAe,EAAE;QACzB,MAAMvC,cAAc,CAAC;UACnB4B,KAAK,EAAES,IAAI,CAACT,KAAK;UACjBnB,MAAM;UACN+B,iBAAiB,EAAE,KAAM;UACzBD,eAAe,EAAEF,IAAI,CAACE;SACvB,CAAC;MACJ;MACAjC,uBAAuB,CAACK,WAAW,CAAC;IACtC;GACD,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}