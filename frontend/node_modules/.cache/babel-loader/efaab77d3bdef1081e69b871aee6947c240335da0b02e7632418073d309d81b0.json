{"ast":null,"code":"import _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { balanceOfBatch } from \"../__generated__/IERC1155/read/balanceOfBatch.js\";\nimport { nextTokenIdToMint } from \"../__generated__/IERC1155Enumerable/read/nextTokenIdToMint.js\";\nimport { nextTokenId } from \"../__generated__/Zora1155/read/nextTokenId.js\";\nconst DEFAULT_QUERY_ALL_COUNT = 100;\n/**\n * Retrieves the owned ERC1155 tokenIds & the owned balance of each tokenId for a given wallet address.\n * @param options - The transaction options and parameters.\n * @returns A promise that resolves to an array of ERC1155 NFTs owned by the wallet address, along with the quantity owned.\n * @extension ERC1155\n * @example\n * ```ts\n * import { getOwnedNFTs } from \"thirdweb/extensions/erc1155\";\n * const ownedTokenIds = await getOwnedTokenIds({\n *  contract,\n *  start: 0,\n *  count: 10,\n *  address: \"0x123...\",\n * });\n * ```\n */\nexport async function getOwnedTokenIds(options) {\n  const maxId = await Promise.allSettled([nextTokenIdToMint(options), nextTokenId(options)]).then(_ref => {\n    let [_nextToMint, _next] = _ref;\n    if (_nextToMint.status === \"fulfilled\") {\n      return _nextToMint.value;\n    }\n    if (_next.status === \"fulfilled\") {\n      return _next.value;\n    }\n    throw Error(\"Contract doesn't have required extension\");\n  });\n  // approach is naieve, likely can be improved\n  const owners = [];\n  const tokenIds = [];\n  for (let i = 0n; i < maxId; i++) {\n    owners.push(options.address);\n    tokenIds.push(i);\n  }\n  const balances = await balanceOfBatch(_objectSpread(_objectSpread({}, options), {}, {\n    owners,\n    tokenIds\n  }));\n  let ownedBalances = balances.map((b, i) => {\n    return {\n      balance: b,\n      tokenId: BigInt(i)\n    };\n  }).filter(b => b.balance > 0);\n  if (options.start || options.count) {\n    const start = (options === null || options === void 0 ? void 0 : options.start) || 0;\n    const count = (options === null || options === void 0 ? void 0 : options.count) || DEFAULT_QUERY_ALL_COUNT;\n    ownedBalances = ownedBalances.slice(start, start + count);\n  }\n  return ownedBalances;\n}","map":{"version":3,"names":["balanceOfBatch","nextTokenIdToMint","nextTokenId","DEFAULT_QUERY_ALL_COUNT","getOwnedTokenIds","options","maxId","Promise","allSettled","then","_ref","_nextToMint","_next","status","value","Error","owners","tokenIds","i","push","address","balances","_objectSpread","ownedBalances","map","b","balance","tokenId","BigInt","filter","start","count","slice"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/extensions/erc1155/read/getOwnedTokenIds.ts"],"sourcesContent":["import type { Address } from \"abitype\";\nimport type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { balanceOfBatch } from \"../__generated__/IERC1155/read/balanceOfBatch.js\";\nimport { nextTokenIdToMint } from \"../__generated__/IERC1155Enumerable/read/nextTokenIdToMint.js\";\nimport { nextTokenId } from \"../__generated__/Zora1155/read/nextTokenId.js\";\n\nconst DEFAULT_QUERY_ALL_COUNT = 100;\n\n/**\n * Parameters for retrieving owned tokenIds of an ERC1155 contract.\n * @extension ERC1155\n */\nexport type GetOwnedTokenIdsParams = {\n  /**\n   * Which tokenId to start at.\n   */\n  start?: number;\n  /**\n   * The number of NFTs to retrieve.\n   */\n  count?: number;\n  /**\n   * The address of the wallet to get the NFTs of.\n   */\n  address: string;\n};\n\n/**\n * Retrieves the owned ERC1155 tokenIds & the owned balance of each tokenId for a given wallet address.\n * @param options - The transaction options and parameters.\n * @returns A promise that resolves to an array of ERC1155 NFTs owned by the wallet address, along with the quantity owned.\n * @extension ERC1155\n * @example\n * ```ts\n * import { getOwnedNFTs } from \"thirdweb/extensions/erc1155\";\n * const ownedTokenIds = await getOwnedTokenIds({\n *  contract,\n *  start: 0,\n *  count: 10,\n *  address: \"0x123...\",\n * });\n * ```\n */\nexport async function getOwnedTokenIds(\n  options: BaseTransactionOptions<GetOwnedTokenIdsParams>,\n): Promise<{ tokenId: bigint; balance: bigint }[]> {\n  const maxId = await Promise.allSettled([\n    nextTokenIdToMint(options),\n    nextTokenId(options),\n  ]).then(([_nextToMint, _next]) => {\n    if (_nextToMint.status === \"fulfilled\") {\n      return _nextToMint.value;\n    }\n    if (_next.status === \"fulfilled\") {\n      return _next.value;\n    }\n    throw Error(\"Contract doesn't have required extension\");\n  });\n\n  // approach is naieve, likely can be improved\n  const owners: Address[] = [];\n  const tokenIds: bigint[] = [];\n  for (let i = 0n; i < maxId; i++) {\n    owners.push(options.address);\n    tokenIds.push(i);\n  }\n\n  const balances = await balanceOfBatch({\n    ...options,\n    owners,\n    tokenIds,\n  });\n\n  let ownedBalances = balances\n    .map((b, i) => {\n      return {\n        balance: b,\n        tokenId: BigInt(i),\n      };\n    })\n    .filter((b) => b.balance > 0);\n\n  if (options.start || options.count) {\n    const start = options?.start || 0;\n    const count = options?.count || DEFAULT_QUERY_ALL_COUNT;\n    ownedBalances = ownedBalances.slice(start, start + count);\n  }\n\n  return ownedBalances;\n}\n"],"mappings":";AAEA,SAASA,cAAc,QAAQ,kDAAkD;AACjF,SAASC,iBAAiB,QAAQ,+DAA+D;AACjG,SAASC,WAAW,QAAQ,+CAA+C;AAE3E,MAAMC,uBAAuB,GAAG,GAAG;AAqBnC;;;;;;;;;;;;;;;;AAgBA,OAAO,eAAeC,gBAAgBA,CACpCC,OAAuD;EAEvD,MAAMC,KAAK,GAAG,MAAMC,OAAO,CAACC,UAAU,CAAC,CACrCP,iBAAiB,CAACI,OAAO,CAAC,EAC1BH,WAAW,CAACG,OAAO,CAAC,CACrB,CAAC,CAACI,IAAI,CAACC,IAAA,IAAyB;IAAA,IAAxB,CAACC,WAAW,EAAEC,KAAK,CAAC,GAAAF,IAAA;IAC3B,IAAIC,WAAW,CAACE,MAAM,KAAK,WAAW,EAAE;MACtC,OAAOF,WAAW,CAACG,KAAK;IAC1B;IACA,IAAIF,KAAK,CAACC,MAAM,KAAK,WAAW,EAAE;MAChC,OAAOD,KAAK,CAACE,KAAK;IACpB;IACA,MAAMC,KAAK,CAAC,0CAA0C,CAAC;EACzD,CAAC,CAAC;EAEF;EACA,MAAMC,MAAM,GAAc,EAAE;EAC5B,MAAMC,QAAQ,GAAa,EAAE;EAC7B,KAAK,IAAIC,CAAC,GAAG,EAAE,EAAEA,CAAC,GAAGZ,KAAK,EAAEY,CAAC,EAAE,EAAE;IAC/BF,MAAM,CAACG,IAAI,CAACd,OAAO,CAACe,OAAO,CAAC;IAC5BH,QAAQ,CAACE,IAAI,CAACD,CAAC,CAAC;EAClB;EAEA,MAAMG,QAAQ,GAAG,MAAMrB,cAAc,CAAAsB,aAAA,CAAAA,aAAA,KAChCjB,OAAO;IACVW,MAAM;IACNC;EAAQ,EACT,CAAC;EAEF,IAAIM,aAAa,GAAGF,QAAQ,CACzBG,GAAG,CAAC,CAACC,CAAC,EAAEP,CAAC,KAAI;IACZ,OAAO;MACLQ,OAAO,EAAED,CAAC;MACVE,OAAO,EAAEC,MAAM,CAACV,CAAC;KAClB;EACH,CAAC,CAAC,CACDW,MAAM,CAAEJ,CAAC,IAAKA,CAAC,CAACC,OAAO,GAAG,CAAC,CAAC;EAE/B,IAAIrB,OAAO,CAACyB,KAAK,IAAIzB,OAAO,CAAC0B,KAAK,EAAE;IAClC,MAAMD,KAAK,GAAG,CAAAzB,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEyB,KAAK,KAAI,CAAC;IACjC,MAAMC,KAAK,GAAG,CAAA1B,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAE0B,KAAK,KAAI5B,uBAAuB;IACvDoB,aAAa,GAAGA,aAAa,CAACS,KAAK,CAACF,KAAK,EAAEA,KAAK,GAAGC,KAAK,CAAC;EAC3D;EAEA,OAAOR,aAAa;AACtB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}