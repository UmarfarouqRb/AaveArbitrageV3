{"ast":null,"code":"import _objectWithoutProperties from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"/home/user/Arbitrage/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nconst _excluded = [\"account\", \"chain\", \"client\", \"token\", \"amount\", \"to\", \"operatorTip\", \"l2GasLimit\", \"gasPerPubdataByte\", \"refundRecipient\", \"bridgeAddress\", \"customBridgeData\", \"value\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"approveToken\", \"approveBaseToken\"];\nimport { parseAbi } from 'abitype';\nimport { estimateGas } from '../../actions/public/estimateGas.js';\nimport { readContract } from '../../actions/public/readContract.js';\nimport { waitForTransactionReceipt } from '../../actions/public/waitForTransactionReceipt.js';\nimport { sendTransaction } from '../../actions/wallet/sendTransaction.js';\nimport { writeContract } from '../../actions/wallet/writeContract.js';\nimport { publicActions } from '../../clients/decorators/public.js';\nimport { erc20Abi } from '../../constants/abis.js';\nimport { zeroAddress } from '../../constants/address.js';\nimport { zeroHash } from '../../constants/bytes.js';\nimport { AccountNotFoundError } from '../../errors/account.js';\nimport { ClientChainNotConfiguredError } from '../../errors/chain.js';\nimport { concatHex, encodeAbiParameters, encodeFunctionData, isAddressEqual, keccak256, parseAccount } from '../../utils/index.js';\nimport { bridgehubAbi } from '../constants/abis.js';\nimport { ethAddressInContracts, l2NativeTokenVaultAddress, legacyEthAddress } from '../constants/address.js';\nimport { requiredL1ToL2GasPerPubdataLimit } from '../constants/number.js';\nimport { BaseFeeHigherThanValueError } from '../errors/bridge.js';\nimport { applyL1ToL2Alias } from '../utils/bridge/applyL1ToL2Alias.js';\nimport { estimateGasL1ToL2 } from './estimateGasL1ToL2.js';\nimport { getBridgehubContractAddress } from './getBridgehubContractAddress.js';\nimport { getDefaultBridgeAddresses } from './getDefaultBridgeAddresses.js';\nimport { getL1Allowance } from './getL1Allowance.js';\n/**\n * Transfers the specified token from the associated account on the L1 network to the target account on the L2 network.\n * The token can be either ETH or any ERC20 token. For ERC20 tokens, enough approved tokens must be associated with\n * the specified L1 bridge (default one or the one defined in `bridgeAddress`).\n * In this case, depending on is the chain ETH-based or not `approveToken` or `approveBaseToken`\n * can be enabled to perform token approval. If there are already enough approved tokens for the L1 bridge,\n * token approval will be skipped.\n *\n * @param client - Client to use\n * @param parameters - {@link DepositParameters}\n * @returns hash - The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link DepositReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { zksync, mainnet } from 'viem/chains'\n * import { deposit, legacyEthAddress, publicActionsL2 } from 'viem/zksync'\n *\n * const client = createPublicClient({\n *     chain: mainnet,\n *     transport: http(),\n * })\n *\n * const clientL2 = createPublicClient({\n *   chain: zksync,\n *   transport: http(),\n * }).extend(publicActionsL2())\n *\n * const account = privateKeyToAccount('0x…')\n *\n * const hash = await deposit(client, {\n *     client: clientL2,\n *     account,\n *     token: legacyEthAddress,\n *     to: account.address,\n *     amount: 1_000_000_000_000_000_000n,\n *     refundRecipient: account.address,\n * })\n *\n * @example Account Hoisting\n * import { createPublicClient, createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { zksync, mainnet } from 'viem/chains'\n * import { legacyEthAddress, publicActionsL2 } from 'viem/zksync'\n *\n * const walletClient = createWalletClient({\n *   chain: mainnet,\n *   transport: http(),\n *   account: privateKeyToAccount('0x…'),\n * })\n *\n * const clientL2 = createPublicClient({\n *   chain: zksync,\n *   transport: http(),\n * }).extend(publicActionsL2())\n *\n * const hash = await deposit(walletClient, {\n *     client: clientL2,\n *     token: legacyEthAddress,\n *     to: walletClient.account.address,\n *     amount: 1_000_000_000_000_000_000n,\n *     refundRecipient: walletClient.account.address,\n * })\n */\nexport async function deposit(client, parameters) {\n  let {\n    account: account_ = client.account,\n    chain: chain_ = client.chain,\n    client: l2Client,\n    token,\n    amount,\n    approveToken,\n    approveBaseToken,\n    gas\n  } = parameters;\n  const account = account_ ? parseAccount(account_) : client.account;\n  if (!account) throw new AccountNotFoundError({\n    docsPath: '/docs/actions/wallet/sendTransaction'\n  });\n  if (!l2Client.chain) throw new ClientChainNotConfiguredError();\n  if (isAddressEqual(token, legacyEthAddress)) token = ethAddressInContracts;\n  const bridgeAddresses = await getBridgeAddresses(client, l2Client);\n  const bridgehub = await getBridgehubContractAddress(l2Client);\n  const baseToken = await readContract(client, {\n    address: bridgehub,\n    abi: bridgehubAbi,\n    functionName: 'baseToken',\n    args: [BigInt(l2Client.chain.id)]\n  });\n  const {\n    mintValue,\n    tx\n  } = await getL1DepositTx(client, account, _objectSpread(_objectSpread({}, parameters), {}, {\n    token\n  }), bridgeAddresses, bridgehub, baseToken);\n  await approveTokens(client, chain_, tx.bridgeAddress, baseToken, mintValue, account, token, amount, approveToken, approveBaseToken);\n  if (!gas) {\n    const baseGasLimit = await estimateGas(client, {\n      account: account.address,\n      to: bridgehub,\n      value: tx.value,\n      data: tx.data\n    });\n    gas = scaleGasLimit(baseGasLimit);\n  }\n  return await sendTransaction(client, _objectSpread({\n    chain: chain_,\n    account,\n    gas\n  }, tx));\n}\nasync function getL1DepositTx(client, account, parameters, bridgeAddresses, bridgehub, baseToken) {\n  let {\n      account: _account,\n      chain: _chain,\n      client: l2Client,\n      token,\n      amount,\n      to,\n      operatorTip = 0n,\n      l2GasLimit,\n      gasPerPubdataByte = requiredL1ToL2GasPerPubdataLimit,\n      refundRecipient = zeroAddress,\n      bridgeAddress,\n      customBridgeData,\n      value,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      approveToken: _approveToken,\n      approveBaseToken: _approveBaseToken\n    } = parameters,\n    rest = _objectWithoutProperties(parameters, _excluded);\n  if (!l2Client.chain) throw new ClientChainNotConfiguredError();\n  to !== null && to !== void 0 ? to : to = account.address;\n  let gasPriceForEstimation = maxFeePerGas || gasPrice;\n  if (!gasPriceForEstimation) {\n    const estimatedFee = await getFeePrice(client);\n    gasPriceForEstimation = estimatedFee.maxFeePerGas;\n    maxFeePerGas = estimatedFee.maxFeePerGas;\n    maxPriorityFeePerGas !== null && maxPriorityFeePerGas !== void 0 ? maxPriorityFeePerGas : maxPriorityFeePerGas = estimatedFee.maxPriorityFeePerGas;\n  }\n  const {\n    l2GasLimit_,\n    baseCost\n  } = await getL2BridgeTxFeeParams(client, l2Client, bridgehub, gasPriceForEstimation, account.address, token, amount, to, gasPerPubdataByte, baseToken, l2GasLimit, bridgeAddress, customBridgeData);\n  l2GasLimit = l2GasLimit_;\n  let mintValue;\n  let data;\n  const isETHBasedChain = isAddressEqual(baseToken, ethAddressInContracts);\n  if (isETHBasedChain && isAddressEqual(token, ethAddressInContracts) ||\n  // ETH on ETH-based chain\n  isAddressEqual(token, baseToken) // base token on custom chain\n  ) {\n    // Deposit base token\n    mintValue = baseCost + operatorTip + amount;\n    let providedValue = isETHBasedChain ? value : mintValue;\n    if (!providedValue || providedValue === 0n) providedValue = mintValue;\n    if (baseCost > providedValue) throw new BaseFeeHigherThanValueError(baseCost, providedValue);\n    value = isETHBasedChain ? providedValue : 0n;\n    bridgeAddress = bridgeAddresses.sharedL1; // required for approval of base token on custom chain\n    data = encodeFunctionData({\n      abi: bridgehubAbi,\n      functionName: 'requestL2TransactionDirect',\n      args: [{\n        chainId: BigInt(l2Client.chain.id),\n        mintValue: providedValue,\n        l2Contract: to,\n        l2Value: amount,\n        l2Calldata: '0x',\n        l2GasLimit,\n        l2GasPerPubdataByteLimit: gasPerPubdataByte,\n        factoryDeps: [],\n        refundRecipient\n      }]\n    });\n  } else if (isAddressEqual(baseToken, ethAddressInContracts)) {\n    // Deposit token on ETH-based chain\n    mintValue = baseCost + BigInt(operatorTip);\n    value = mintValue;\n    if (baseCost > mintValue) throw new BaseFeeHigherThanValueError(baseCost, mintValue);\n    bridgeAddress !== null && bridgeAddress !== void 0 ? bridgeAddress : bridgeAddress = bridgeAddresses.sharedL1;\n    data = encodeFunctionData({\n      abi: bridgehubAbi,\n      functionName: 'requestL2TransactionTwoBridges',\n      args: [{\n        chainId: BigInt(l2Client.chain.id),\n        mintValue,\n        l2Value: 0n,\n        l2GasLimit,\n        l2GasPerPubdataByteLimit: gasPerPubdataByte,\n        refundRecipient,\n        secondBridgeAddress: bridgeAddress,\n        secondBridgeValue: 0n,\n        secondBridgeCalldata: await getSecondBridgeCalldata(client, bridgeAddresses.l1NativeTokenVault, token, amount, to)\n      }]\n    });\n  } else if (isAddressEqual(token, ethAddressInContracts)) {\n    // Deposit ETH on custom chain\n    mintValue = baseCost + operatorTip;\n    value = amount;\n    if (baseCost > mintValue) throw new BaseFeeHigherThanValueError(baseCost, mintValue);\n    bridgeAddress = bridgeAddresses.sharedL1;\n    data = encodeFunctionData({\n      abi: bridgehubAbi,\n      functionName: 'requestL2TransactionTwoBridges',\n      args: [{\n        chainId: BigInt(l2Client.chain.id),\n        mintValue,\n        l2Value: 0n,\n        l2GasLimit,\n        l2GasPerPubdataByteLimit: gasPerPubdataByte,\n        refundRecipient,\n        secondBridgeAddress: bridgeAddress,\n        secondBridgeValue: amount,\n        secondBridgeCalldata: await getSecondBridgeCalldata(client, bridgeAddresses.l1NativeTokenVault, ethAddressInContracts, amount, to)\n      }]\n    });\n  } else {\n    // Deposit token on custom chain\n    mintValue = baseCost + operatorTip;\n    value !== null && value !== void 0 ? value : value = 0n;\n    if (baseCost > mintValue) throw new BaseFeeHigherThanValueError(baseCost, mintValue);\n    bridgeAddress !== null && bridgeAddress !== void 0 ? bridgeAddress : bridgeAddress = bridgeAddresses.sharedL1;\n    data = encodeFunctionData({\n      abi: bridgehubAbi,\n      functionName: 'requestL2TransactionTwoBridges',\n      args: [{\n        chainId: BigInt(l2Client.chain.id),\n        mintValue,\n        l2Value: 0n,\n        l2GasLimit,\n        l2GasPerPubdataByteLimit: gasPerPubdataByte,\n        refundRecipient,\n        secondBridgeAddress: bridgeAddress,\n        secondBridgeValue: 0n,\n        secondBridgeCalldata: await getSecondBridgeCalldata(client, bridgeAddresses.l1NativeTokenVault, token, amount, to)\n      }]\n    });\n  }\n  return {\n    mintValue,\n    tx: _objectSpread({\n      bridgeAddress,\n      to: bridgehub,\n      data,\n      value,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas\n    }, rest)\n  };\n}\nasync function approveTokens(client, chain, bridgeAddress, baseToken, mintValue, account, token, amount, approveToken, approveBaseToken) {\n  if (isAddressEqual(baseToken, ethAddressInContracts)) {\n    // Deposit token on ETH-based chain\n    if (approveToken) {\n      const overrides = typeof approveToken === 'boolean' ? {} : approveToken;\n      const allowance = await getL1Allowance(client, {\n        token,\n        bridgeAddress,\n        account\n      });\n      if (allowance < amount) {\n        const hash = await writeContract(client, _objectSpread({\n          chain,\n          account,\n          address: token,\n          abi: erc20Abi,\n          functionName: 'approve',\n          args: [bridgeAddress, amount]\n        }, overrides));\n        await waitForTransactionReceipt(client, {\n          hash\n        });\n      }\n    }\n    return;\n  }\n  if (isAddressEqual(token, ethAddressInContracts)) {\n    // Deposit ETH on custom chain\n    if (approveBaseToken) {\n      const overrides = typeof approveToken === 'boolean' ? {} : approveToken;\n      const allowance = await getL1Allowance(client, {\n        token: baseToken,\n        bridgeAddress,\n        account\n      });\n      if (allowance < mintValue) {\n        const hash = await writeContract(client, _objectSpread({\n          chain,\n          account,\n          address: baseToken,\n          abi: erc20Abi,\n          functionName: 'approve',\n          args: [bridgeAddress, mintValue]\n        }, overrides));\n        await waitForTransactionReceipt(client, {\n          hash\n        });\n      }\n      return;\n    }\n  }\n  if (isAddressEqual(token, baseToken)) {\n    // Deposit base token on custom chain\n    if (approveToken || approveBaseToken) {\n      const overrides = typeof approveToken === 'boolean' ? {} : (approveToken !== null && approveToken !== void 0 ? approveToken : typeof approveBaseToken === 'boolean') ? {} : approveBaseToken;\n      const allowance = await getL1Allowance(client, {\n        token: baseToken,\n        bridgeAddress,\n        account\n      });\n      if (allowance < mintValue) {\n        const hash = await writeContract(client, _objectSpread({\n          chain,\n          account,\n          address: baseToken,\n          abi: erc20Abi,\n          functionName: 'approve',\n          args: [bridgeAddress, mintValue]\n        }, overrides));\n        await waitForTransactionReceipt(client, {\n          hash\n        });\n      }\n    }\n    return;\n  }\n  // Deposit token on custom chain\n  if (approveBaseToken) {\n    const overrides = typeof approveToken === 'boolean' ? {} : approveToken;\n    const allowance = await getL1Allowance(client, {\n      token: baseToken,\n      bridgeAddress,\n      account\n    });\n    if (allowance < mintValue) {\n      const hash = await writeContract(client, _objectSpread({\n        chain,\n        account,\n        address: baseToken,\n        abi: erc20Abi,\n        functionName: 'approve',\n        args: [bridgeAddress, mintValue]\n      }, overrides));\n      await waitForTransactionReceipt(client, {\n        hash\n      });\n    }\n  }\n  if (approveToken) {\n    const overrides = typeof approveToken === 'boolean' ? {} : approveToken;\n    const allowance = await getL1Allowance(client, {\n      token,\n      bridgeAddress,\n      account\n    });\n    if (allowance < amount) {\n      const hash = await writeContract(client, _objectSpread({\n        chain,\n        account,\n        address: token,\n        abi: erc20Abi,\n        functionName: 'approve',\n        args: [bridgeAddress, amount]\n      }, overrides));\n      await waitForTransactionReceipt(client, {\n        hash\n      });\n    }\n  }\n}\nasync function getL2BridgeTxFeeParams(client, l2Client, bridgehub, gasPrice, from, token, amount, to, gasPerPubdataByte, baseToken, l2GasLimit, bridgeAddress, customBridgeData) {\n  if (!l2Client.chain) throw new ClientChainNotConfiguredError();\n  let l2GasLimit_ = l2GasLimit;\n  if (!l2GasLimit_) l2GasLimit_ = bridgeAddress ? await getL2GasLimitFromCustomBridge(client, l2Client, from, token, amount, to, gasPerPubdataByte, bridgeAddress, customBridgeData) : await getL2GasLimitFromDefaultBridge(client, l2Client, from, token, amount, to, gasPerPubdataByte, baseToken);\n  const baseCost = await readContract(client, {\n    address: bridgehub,\n    abi: bridgehubAbi,\n    functionName: 'l2TransactionBaseCost',\n    args: [BigInt(l2Client.chain.id), gasPrice, l2GasLimit_, gasPerPubdataByte]\n  });\n  return {\n    l2GasLimit_,\n    baseCost\n  };\n}\nasync function getL2GasLimitFromDefaultBridge(client, l2Client, from, token, amount, to, gasPerPubdataByte, baseToken) {\n  if (isAddressEqual(token, baseToken)) {\n    return await estimateGasL1ToL2(l2Client, {\n      chain: l2Client.chain,\n      account: from,\n      from,\n      to,\n      value: amount,\n      data: '0x',\n      gasPerPubdata: gasPerPubdataByte\n    });\n  }\n  const value = 0n;\n  const bridgeAddresses = await getDefaultBridgeAddresses(l2Client);\n  const l1BridgeAddress = bridgeAddresses.sharedL1;\n  const l2BridgeAddress = bridgeAddresses.sharedL2;\n  const bridgeData = await encodeDefaultBridgeData(client, token);\n  const calldata = encodeFunctionData({\n    abi: parseAbi(['function finalizeDeposit(address _l1Sender, address _l2Receiver, address _l1Token, uint256 _amount, bytes _data)']),\n    functionName: 'finalizeDeposit',\n    args: [from, to, isAddressEqual(token, legacyEthAddress) ? ethAddressInContracts : token, amount, bridgeData]\n  });\n  return await estimateGasL1ToL2(l2Client, {\n    chain: l2Client.chain,\n    account: applyL1ToL2Alias(l1BridgeAddress),\n    to: l2BridgeAddress,\n    data: calldata,\n    gasPerPubdata: gasPerPubdataByte,\n    value\n  });\n}\nasync function getL2GasLimitFromCustomBridge(client, l2Client, from, token, amount, to, gasPerPubdataByte, bridgeAddress, customBridgeData) {\n  let customBridgeData_ = customBridgeData;\n  if (!customBridgeData_ || customBridgeData_ === '0x') customBridgeData_ = await encodeDefaultBridgeData(client, token);\n  const l2BridgeAddress = await readContract(client, {\n    address: token,\n    abi: parseAbi(['function l2BridgeAddress(uint256 _chainId) view returns (address)']),\n    functionName: 'l2BridgeAddress',\n    args: [BigInt(l2Client.chain.id)]\n  });\n  const calldata = encodeFunctionData({\n    abi: parseAbi(['function finalizeDeposit(address _l1Sender, address _l2Receiver, address _l1Token, uint256 _amount, bytes _data)']),\n    functionName: 'finalizeDeposit',\n    args: [from, to, token, amount, customBridgeData_]\n  });\n  return await estimateGasL1ToL2(l2Client, {\n    chain: l2Client.chain,\n    account: from,\n    from: applyL1ToL2Alias(bridgeAddress),\n    to: l2BridgeAddress,\n    data: calldata,\n    gasPerPubdata: gasPerPubdataByte\n  });\n}\nasync function encodeDefaultBridgeData(client, token) {\n  let token_ = token;\n  if (isAddressEqual(token, legacyEthAddress)) token_ = ethAddressInContracts;\n  let name = 'Ether';\n  let symbol = 'ETH';\n  let decimals = 18n;\n  if (!isAddressEqual(token_, ethAddressInContracts)) {\n    name = await readContract(client, {\n      address: token_,\n      abi: erc20Abi,\n      functionName: 'name',\n      args: []\n    });\n    symbol = await readContract(client, {\n      address: token_,\n      abi: erc20Abi,\n      functionName: 'symbol',\n      args: []\n    });\n    decimals = BigInt(await readContract(client, {\n      address: token_,\n      abi: erc20Abi,\n      functionName: 'decimals',\n      args: []\n    }));\n  }\n  const nameBytes = encodeAbiParameters([{\n    type: 'string'\n  }], [name]);\n  const symbolBytes = encodeAbiParameters([{\n    type: 'string'\n  }], [symbol]);\n  const decimalsBytes = encodeAbiParameters([{\n    type: 'uint256'\n  }], [decimals]);\n  return encodeAbiParameters([{\n    type: 'bytes'\n  }, {\n    type: 'bytes'\n  }, {\n    type: 'bytes'\n  }], [nameBytes, symbolBytes, decimalsBytes]);\n}\nasync function getSecondBridgeCalldata(client, l1NativeTokenVault, token, amount, to) {\n  let assetId;\n  let token_ = token;\n  if (isAddressEqual(token, legacyEthAddress)) token_ = ethAddressInContracts;\n  const assetIdFromNTV = await readContract(client, {\n    address: l1NativeTokenVault,\n    abi: parseAbi(['function assetId(address token) view returns (bytes32)']),\n    functionName: 'assetId',\n    args: [token_]\n  });\n  if (assetIdFromNTV && assetIdFromNTV !== zeroHash) assetId = assetIdFromNTV;else {\n    // Okay, the token have not been registered within the Native token vault.\n    // There are two cases when it is possible:\n    // - The token is native to L1 (it may or may not be bridged), but it has not been\n    // registered within NTV after the Gateway upgrade. We assume that this is not the case\n    // as the SDK is expected to work only after the full migration is done.\n    // - The token is native to the current chain and it has never been bridged.\n    if (!client.chain) throw new ClientChainNotConfiguredError();\n    assetId = keccak256(encodeAbiParameters([{\n      type: 'uint256'\n    }, {\n      type: 'address'\n    }, {\n      type: 'address'\n    }], [BigInt(client.chain.id), l2NativeTokenVaultAddress, token_]));\n  }\n  const ntvData = encodeAbiParameters([{\n    type: 'uint256'\n  }, {\n    type: 'address'\n  }, {\n    type: 'address'\n  }], [BigInt(amount), to, token_]);\n  const data = encodeAbiParameters([{\n    type: 'bytes32'\n  }, {\n    type: 'bytes'\n  }], [assetId, ntvData]);\n  return concatHex(['0x01', data]);\n}\nasync function getBridgeAddresses(client, l2Client) {\n  const addresses = await getDefaultBridgeAddresses(l2Client);\n  let l1Nullifier = addresses.l1Nullifier;\n  let l1NativeTokenVault = addresses.l1NativeTokenVault;\n  if (!l1Nullifier) l1Nullifier = await readContract(client, {\n    address: addresses.sharedL1,\n    abi: parseAbi(['function L1_NULLIFIER() view returns (address)']),\n    functionName: 'L1_NULLIFIER',\n    args: []\n  });\n  if (!l1NativeTokenVault) l1NativeTokenVault = await readContract(client, {\n    address: addresses.sharedL1,\n    abi: parseAbi(['function nativeTokenVault() view returns (address)']),\n    functionName: 'nativeTokenVault',\n    args: []\n  });\n  return _objectSpread(_objectSpread({}, addresses), {}, {\n    l1Nullifier,\n    l1NativeTokenVault\n  });\n}\nfunction scaleGasLimit(gasLimit) {\n  return gasLimit * BigInt(12) / BigInt(10);\n}\nasync function getFeePrice(client) {\n  const client_ = client.extend(publicActions);\n  const block = await client_.getBlock();\n  const baseFee = typeof block.baseFeePerGas !== 'bigint' ? await client_.getGasPrice() : block.baseFeePerGas;\n  const maxPriorityFeePerGas = await client_.estimateMaxPriorityFeePerGas();\n  return {\n    maxFeePerGas: baseFee * 3n / 2n + maxPriorityFeePerGas,\n    maxPriorityFeePerGas: maxPriorityFeePerGas\n  };\n}","map":{"version":3,"names":["parseAbi","estimateGas","readContract","waitForTransactionReceipt","sendTransaction","writeContract","publicActions","erc20Abi","zeroAddress","zeroHash","AccountNotFoundError","ClientChainNotConfiguredError","concatHex","encodeAbiParameters","encodeFunctionData","isAddressEqual","keccak256","parseAccount","bridgehubAbi","ethAddressInContracts","l2NativeTokenVaultAddress","legacyEthAddress","requiredL1ToL2GasPerPubdataLimit","BaseFeeHigherThanValueError","applyL1ToL2Alias","estimateGasL1ToL2","getBridgehubContractAddress","getDefaultBridgeAddresses","getL1Allowance","deposit","client","parameters","account","account_","chain","chain_","l2Client","token","amount","approveToken","approveBaseToken","gas","docsPath","bridgeAddresses","getBridgeAddresses","bridgehub","baseToken","address","abi","functionName","args","BigInt","id","mintValue","tx","getL1DepositTx","_objectSpread","approveTokens","bridgeAddress","baseGasLimit","to","value","data","scaleGasLimit","_account","_chain","operatorTip","l2GasLimit","gasPerPubdataByte","refundRecipient","customBridgeData","gasPrice","maxFeePerGas","maxPriorityFeePerGas","_approveToken","_approveBaseToken","rest","_objectWithoutProperties","_excluded","gasPriceForEstimation","estimatedFee","getFeePrice","l2GasLimit_","baseCost","getL2BridgeTxFeeParams","isETHBasedChain","providedValue","sharedL1","chainId","l2Contract","l2Value","l2Calldata","l2GasPerPubdataByteLimit","factoryDeps","secondBridgeAddress","secondBridgeValue","secondBridgeCalldata","getSecondBridgeCalldata","l1NativeTokenVault","overrides","allowance","hash","from","getL2GasLimitFromCustomBridge","getL2GasLimitFromDefaultBridge","gasPerPubdata","l1BridgeAddress","l2BridgeAddress","sharedL2","bridgeData","encodeDefaultBridgeData","calldata","customBridgeData_","token_","name","symbol","decimals","nameBytes","type","symbolBytes","decimalsBytes","assetId","assetIdFromNTV","ntvData","addresses","l1Nullifier","gasLimit","client_","extend","block","getBlock","baseFee","baseFeePerGas","getGasPrice","estimateMaxPriorityFeePerGas"],"sources":["/home/user/Arbitrage/frontend/node_modules/viem/zksync/actions/deposit.ts"],"sourcesContent":["import { type Address, parseAbi } from 'abitype'\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type EstimateGasParameters,\n  estimateGas,\n} from '../../actions/public/estimateGas.js'\nimport { readContract } from '../../actions/public/readContract.js'\nimport { waitForTransactionReceipt } from '../../actions/public/waitForTransactionReceipt.js'\nimport {\n  type SendTransactionErrorType,\n  type SendTransactionParameters,\n  type SendTransactionReturnType,\n  sendTransaction,\n} from '../../actions/wallet/sendTransaction.js'\nimport {\n  type WriteContractParameters,\n  writeContract,\n} from '../../actions/wallet/writeContract.js'\nimport type { Client } from '../../clients/createClient.js'\nimport { publicActions } from '../../clients/decorators/public.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { erc20Abi } from '../../constants/abis.js'\nimport { zeroAddress } from '../../constants/address.js'\nimport { zeroHash } from '../../constants/bytes.js'\nimport { AccountNotFoundError } from '../../errors/account.js'\nimport { ClientChainNotConfiguredError } from '../../errors/chain.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { UnionEvaluate, UnionOmit } from '../../types/utils.js'\nimport {\n  concatHex,\n  encodeAbiParameters,\n  encodeFunctionData,\n  type FormattedTransactionRequest,\n  isAddressEqual,\n  keccak256,\n  parseAccount,\n} from '../../utils/index.js'\nimport { bridgehubAbi } from '../constants/abis.js'\nimport {\n  ethAddressInContracts,\n  l2NativeTokenVaultAddress,\n  legacyEthAddress,\n} from '../constants/address.js'\nimport { requiredL1ToL2GasPerPubdataLimit } from '../constants/number.js'\nimport {\n  BaseFeeHigherThanValueError,\n  type BaseFeeHigherThanValueErrorType,\n} from '../errors/bridge.js'\nimport type { ChainEIP712 } from '../types/chain.js'\nimport type { BridgeContractAddresses } from '../types/contract.js'\nimport { applyL1ToL2Alias } from '../utils/bridge/applyL1ToL2Alias.js'\nimport { estimateGasL1ToL2 } from './estimateGasL1ToL2.js'\nimport { getBridgehubContractAddress } from './getBridgehubContractAddress.js'\nimport { getDefaultBridgeAddresses } from './getDefaultBridgeAddresses.js'\nimport { getL1Allowance } from './getL1Allowance.js'\n\nexport type DepositParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  chainL2 extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  accountL2 extends Account | undefined = Account | undefined,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = UnionEvaluate<\n  UnionOmit<FormattedTransactionRequest<_derivedChain>, 'data' | 'to' | 'from'>\n> &\n  Partial<GetChainParameter<chain, chainOverride>> &\n  Partial<GetAccountParameter<account>> & {\n    /** L2 client. */\n    client: Client<Transport, chainL2, accountL2>\n    /** The address of the token to deposit. */\n    token: Address\n    /** The amount of the token to deposit. */\n    amount: bigint\n    /** The address that will receive the deposited tokens on L2.\n    Defaults to the sender address.*/\n    to?: Address | undefined\n    /** (currently not used) The tip the operator will receive on top of\n    the base cost of the transaction. */\n    operatorTip?: bigint | undefined\n    /** Maximum amount of L2 gas that transaction can consume during execution on L2. */\n    l2GasLimit?: bigint | undefined\n    /** The L2 gas price for each published L1 calldata byte. */\n    gasPerPubdataByte?: bigint | undefined\n    /** The address on L2 that will receive the refund for the transaction.\n    If the transaction fails, it will also be the address to receive `amount`. */\n    refundRecipient?: Address | undefined\n    /** The address of the bridge contract to be used.\n    Defaults to the default ZKsync L1 shared bridge. */\n    bridgeAddress?: Address | undefined\n    /** Additional data that can be sent to a bridge. */\n    customBridgeData?: Hex | undefined\n    /** Whether token approval should be performed under the hood.\n    Set this flag to true (or provide transaction overrides) if the bridge does\n    not have sufficient allowance. The approval transaction is executed only if\n    the bridge lacks sufficient allowance; otherwise, it is skipped. */\n    approveToken?:\n      | boolean\n      | UnionEvaluate<\n          UnionOmit<\n            FormattedTransactionRequest<_derivedChain>,\n            'data' | 'to' | 'from'\n          >\n        >\n      | undefined\n    /** Whether base token approval should be performed under the hood.\n    Set this flag to true (or provide transaction overrides) if the bridge does\n    not have sufficient allowance. The approval transaction is executed only if\n    the bridge lacks sufficient allowance; otherwise, it is skipped. */\n    approveBaseToken?:\n      | boolean\n      | UnionEvaluate<\n          UnionOmit<\n            FormattedTransactionRequest<_derivedChain>,\n            'data' | 'to' | 'from'\n          >\n        >\n      | undefined\n  }\n\nexport type DepositReturnType = SendTransactionReturnType\n\nexport type DepositErrorType =\n  | SendTransactionErrorType\n  | BaseFeeHigherThanValueErrorType\n\n/**\n * Transfers the specified token from the associated account on the L1 network to the target account on the L2 network.\n * The token can be either ETH or any ERC20 token. For ERC20 tokens, enough approved tokens must be associated with\n * the specified L1 bridge (default one or the one defined in `bridgeAddress`).\n * In this case, depending on is the chain ETH-based or not `approveToken` or `approveBaseToken`\n * can be enabled to perform token approval. If there are already enough approved tokens for the L1 bridge,\n * token approval will be skipped.\n *\n * @param client - Client to use\n * @param parameters - {@link DepositParameters}\n * @returns hash - The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link DepositReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { zksync, mainnet } from 'viem/chains'\n * import { deposit, legacyEthAddress, publicActionsL2 } from 'viem/zksync'\n *\n * const client = createPublicClient({\n *     chain: mainnet,\n *     transport: http(),\n * })\n *\n * const clientL2 = createPublicClient({\n *   chain: zksync,\n *   transport: http(),\n * }).extend(publicActionsL2())\n *\n * const account = privateKeyToAccount('0x…')\n *\n * const hash = await deposit(client, {\n *     client: clientL2,\n *     account,\n *     token: legacyEthAddress,\n *     to: account.address,\n *     amount: 1_000_000_000_000_000_000n,\n *     refundRecipient: account.address,\n * })\n *\n * @example Account Hoisting\n * import { createPublicClient, createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { zksync, mainnet } from 'viem/chains'\n * import { legacyEthAddress, publicActionsL2 } from 'viem/zksync'\n *\n * const walletClient = createWalletClient({\n *   chain: mainnet,\n *   transport: http(),\n *   account: privateKeyToAccount('0x…'),\n * })\n *\n * const clientL2 = createPublicClient({\n *   chain: zksync,\n *   transport: http(),\n * }).extend(publicActionsL2())\n *\n * const hash = await deposit(walletClient, {\n *     client: clientL2,\n *     token: legacyEthAddress,\n *     to: walletClient.account.address,\n *     amount: 1_000_000_000_000_000_000n,\n *     refundRecipient: walletClient.account.address,\n * })\n */\nexport async function deposit<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  chainL2 extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  accountL2 extends Account | undefined = Account | undefined,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: DepositParameters<\n    chain,\n    account,\n    chainOverride,\n    chainL2,\n    accountL2\n  >,\n): Promise<DepositReturnType> {\n  let {\n    account: account_ = client.account,\n    chain: chain_ = client.chain,\n    client: l2Client,\n    token,\n    amount,\n    approveToken,\n    approveBaseToken,\n    gas,\n  } = parameters\n\n  const account = account_ ? parseAccount(account_) : client.account\n  if (!account)\n    throw new AccountNotFoundError({\n      docsPath: '/docs/actions/wallet/sendTransaction',\n    })\n  if (!l2Client.chain) throw new ClientChainNotConfiguredError()\n\n  if (isAddressEqual(token, legacyEthAddress)) token = ethAddressInContracts\n\n  const bridgeAddresses = await getBridgeAddresses(client, l2Client)\n  const bridgehub = await getBridgehubContractAddress(l2Client)\n  const baseToken = await readContract(client, {\n    address: bridgehub,\n    abi: bridgehubAbi,\n    functionName: 'baseToken',\n    args: [BigInt(l2Client.chain.id)],\n  })\n\n  const { mintValue, tx } = await getL1DepositTx(\n    client,\n    account,\n    { ...parameters, token },\n    bridgeAddresses,\n    bridgehub,\n    baseToken,\n  )\n\n  await approveTokens(\n    client,\n    chain_,\n    tx.bridgeAddress,\n    baseToken,\n    mintValue,\n    account,\n    token,\n    amount,\n    approveToken,\n    approveBaseToken,\n  )\n\n  if (!gas) {\n    const baseGasLimit = await estimateGas(client, {\n      account: account.address,\n      to: bridgehub,\n      value: tx.value,\n      data: tx.data,\n    } as EstimateGasParameters)\n    gas = scaleGasLimit(baseGasLimit)\n  }\n\n  return await sendTransaction(client, {\n    chain: chain_,\n    account,\n    gas,\n    ...tx,\n  } as SendTransactionParameters)\n}\n\nasync function getL1DepositTx<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  chainL2 extends ChainEIP712 | undefined = ChainEIP712 | undefined,\n  accountL2 extends Account | undefined = Account | undefined,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n>(\n  client: Client<Transport, chain, account>,\n  account: Account,\n  parameters: DepositParameters<\n    chain,\n    account,\n    chainOverride,\n    chainL2,\n    accountL2,\n    _derivedChain\n  >,\n  bridgeAddresses: BridgeContractAddresses & {\n    l1Nullifier: Address\n    l1NativeTokenVault: Address\n  },\n  bridgehub: Address,\n  baseToken: Address,\n) {\n  let {\n    account: _account,\n    chain: _chain,\n    client: l2Client,\n    token,\n    amount,\n    to,\n    operatorTip = 0n,\n    l2GasLimit,\n    gasPerPubdataByte = requiredL1ToL2GasPerPubdataLimit,\n    refundRecipient = zeroAddress,\n    bridgeAddress,\n    customBridgeData,\n    value,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    approveToken: _approveToken,\n    approveBaseToken: _approveBaseToken,\n    ...rest\n  } = parameters\n\n  if (!l2Client.chain) throw new ClientChainNotConfiguredError()\n\n  to ??= account.address\n  let gasPriceForEstimation = maxFeePerGas || gasPrice\n  if (!gasPriceForEstimation) {\n    const estimatedFee = await getFeePrice(client)\n    gasPriceForEstimation = estimatedFee.maxFeePerGas\n    maxFeePerGas = estimatedFee.maxFeePerGas\n    maxPriorityFeePerGas ??= estimatedFee.maxPriorityFeePerGas\n  }\n\n  const { l2GasLimit_, baseCost } = await getL2BridgeTxFeeParams(\n    client,\n    l2Client,\n    bridgehub,\n    gasPriceForEstimation,\n    account.address,\n    token,\n    amount,\n    to,\n    gasPerPubdataByte,\n    baseToken,\n    l2GasLimit,\n    bridgeAddress,\n    customBridgeData,\n  )\n  l2GasLimit = l2GasLimit_\n  let mintValue: bigint\n  let data: Hex\n\n  const isETHBasedChain = isAddressEqual(baseToken, ethAddressInContracts)\n  if (\n    (isETHBasedChain && isAddressEqual(token, ethAddressInContracts)) || // ETH on ETH-based chain\n    isAddressEqual(token, baseToken) // base token on custom chain\n  ) {\n    // Deposit base token\n    mintValue = baseCost + operatorTip + amount\n    let providedValue = isETHBasedChain ? value : mintValue\n    if (!providedValue || providedValue === 0n) providedValue = mintValue\n    if (baseCost > providedValue)\n      throw new BaseFeeHigherThanValueError(baseCost, providedValue)\n\n    value = isETHBasedChain ? providedValue : 0n\n    bridgeAddress = bridgeAddresses.sharedL1 // required for approval of base token on custom chain\n\n    data = encodeFunctionData({\n      abi: bridgehubAbi,\n      functionName: 'requestL2TransactionDirect',\n      args: [\n        {\n          chainId: BigInt(l2Client.chain.id),\n          mintValue: providedValue,\n          l2Contract: to,\n          l2Value: amount,\n          l2Calldata: '0x',\n          l2GasLimit,\n          l2GasPerPubdataByteLimit: gasPerPubdataByte,\n          factoryDeps: [],\n          refundRecipient,\n        },\n      ],\n    })\n  } else if (isAddressEqual(baseToken, ethAddressInContracts)) {\n    // Deposit token on ETH-based chain\n    mintValue = baseCost + BigInt(operatorTip)\n    value = mintValue\n    if (baseCost > mintValue)\n      throw new BaseFeeHigherThanValueError(baseCost, mintValue)\n\n    bridgeAddress ??= bridgeAddresses.sharedL1\n\n    data = encodeFunctionData({\n      abi: bridgehubAbi,\n      functionName: 'requestL2TransactionTwoBridges',\n      args: [\n        {\n          chainId: BigInt(l2Client.chain.id),\n          mintValue,\n          l2Value: 0n,\n          l2GasLimit,\n          l2GasPerPubdataByteLimit: gasPerPubdataByte,\n          refundRecipient,\n          secondBridgeAddress: bridgeAddress,\n          secondBridgeValue: 0n,\n          secondBridgeCalldata: await getSecondBridgeCalldata(\n            client,\n            bridgeAddresses.l1NativeTokenVault,\n            token,\n            amount,\n            to,\n          ),\n        },\n      ],\n    })\n  } else if (isAddressEqual(token, ethAddressInContracts)) {\n    // Deposit ETH on custom chain\n    mintValue = baseCost + operatorTip\n    value = amount\n    if (baseCost > mintValue)\n      throw new BaseFeeHigherThanValueError(baseCost, mintValue)\n\n    bridgeAddress = bridgeAddresses.sharedL1\n\n    data = encodeFunctionData({\n      abi: bridgehubAbi,\n      functionName: 'requestL2TransactionTwoBridges',\n      args: [\n        {\n          chainId: BigInt(l2Client.chain.id),\n          mintValue,\n          l2Value: 0n,\n          l2GasLimit,\n          l2GasPerPubdataByteLimit: gasPerPubdataByte,\n          refundRecipient,\n          secondBridgeAddress: bridgeAddress,\n          secondBridgeValue: amount,\n          secondBridgeCalldata: await getSecondBridgeCalldata(\n            client,\n            bridgeAddresses.l1NativeTokenVault,\n            ethAddressInContracts,\n            amount,\n            to,\n          ),\n        },\n      ],\n    })\n  } else {\n    // Deposit token on custom chain\n    mintValue = baseCost + operatorTip\n    value ??= 0n\n    if (baseCost > mintValue)\n      throw new BaseFeeHigherThanValueError(baseCost, mintValue)\n\n    bridgeAddress ??= bridgeAddresses.sharedL1\n\n    data = encodeFunctionData({\n      abi: bridgehubAbi,\n      functionName: 'requestL2TransactionTwoBridges',\n      args: [\n        {\n          chainId: BigInt(l2Client.chain.id),\n          mintValue,\n          l2Value: 0n,\n          l2GasLimit,\n          l2GasPerPubdataByteLimit: gasPerPubdataByte,\n          refundRecipient,\n          secondBridgeAddress: bridgeAddress,\n          secondBridgeValue: 0n,\n          secondBridgeCalldata: await getSecondBridgeCalldata(\n            client,\n            bridgeAddresses.l1NativeTokenVault,\n            token,\n            amount,\n            to,\n          ),\n        },\n      ],\n    })\n  }\n\n  return {\n    mintValue,\n    tx: {\n      bridgeAddress,\n      to: bridgehub,\n      data,\n      value,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      ...rest,\n    },\n  }\n}\n\nasync function approveTokens<\n  chain extends Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n>(\n  client: Client<Transport, chain>,\n  chain: Chain | null | undefined,\n  bridgeAddress: Address,\n  baseToken: Address,\n  mintValue: bigint,\n  account: Account,\n  token: Address,\n  amount: bigint,\n  approveToken?:\n    | boolean\n    | UnionEvaluate<\n        UnionOmit<\n          FormattedTransactionRequest<_derivedChain>,\n          'data' | 'to' | 'from'\n        >\n      >\n    | undefined,\n  approveBaseToken?:\n    | boolean\n    | UnionEvaluate<\n        UnionOmit<\n          FormattedTransactionRequest<_derivedChain>,\n          'data' | 'to' | 'from'\n        >\n      >\n    | undefined,\n) {\n  if (isAddressEqual(baseToken, ethAddressInContracts)) {\n    // Deposit token on ETH-based chain\n    if (approveToken) {\n      const overrides = typeof approveToken === 'boolean' ? {} : approveToken\n      const allowance = await getL1Allowance(client, {\n        token,\n        bridgeAddress,\n        account,\n      })\n      if (allowance < amount) {\n        const hash = await writeContract(client, {\n          chain,\n          account,\n          address: token,\n          abi: erc20Abi,\n          functionName: 'approve',\n          args: [bridgeAddress, amount],\n          ...overrides,\n        } satisfies WriteContractParameters as any)\n        await waitForTransactionReceipt(client, { hash })\n      }\n    }\n    return\n  }\n\n  if (isAddressEqual(token, ethAddressInContracts)) {\n    // Deposit ETH on custom chain\n    if (approveBaseToken) {\n      const overrides = typeof approveToken === 'boolean' ? {} : approveToken\n      const allowance = await getL1Allowance(client, {\n        token: baseToken,\n        bridgeAddress,\n        account,\n      })\n      if (allowance < mintValue) {\n        const hash = await writeContract(client, {\n          chain,\n          account,\n          address: baseToken,\n          abi: erc20Abi,\n          functionName: 'approve',\n          args: [bridgeAddress, mintValue],\n          ...overrides,\n        } satisfies WriteContractParameters as any)\n        await waitForTransactionReceipt(client, { hash })\n      }\n      return\n    }\n  }\n\n  if (isAddressEqual(token, baseToken)) {\n    // Deposit base token on custom chain\n    if (approveToken || approveBaseToken) {\n      const overrides =\n        typeof approveToken === 'boolean'\n          ? {}\n          : (approveToken ?? typeof approveBaseToken === 'boolean')\n            ? {}\n            : approveBaseToken\n      const allowance = await getL1Allowance(client, {\n        token: baseToken,\n        bridgeAddress,\n        account,\n      })\n      if (allowance < mintValue) {\n        const hash = await writeContract(client, {\n          chain,\n          account,\n          address: baseToken,\n          abi: erc20Abi,\n          functionName: 'approve',\n          args: [bridgeAddress, mintValue],\n          ...overrides,\n        } satisfies WriteContractParameters as any)\n        await waitForTransactionReceipt(client, { hash })\n      }\n    }\n    return\n  }\n\n  // Deposit token on custom chain\n  if (approveBaseToken) {\n    const overrides = typeof approveToken === 'boolean' ? {} : approveToken\n    const allowance = await getL1Allowance(client, {\n      token: baseToken,\n      bridgeAddress,\n      account,\n    })\n    if (allowance < mintValue) {\n      const hash = await writeContract(client, {\n        chain,\n        account,\n        address: baseToken,\n        abi: erc20Abi,\n        functionName: 'approve',\n        args: [bridgeAddress, mintValue],\n        ...overrides,\n      } satisfies WriteContractParameters as any)\n      await waitForTransactionReceipt(client, { hash })\n    }\n  }\n\n  if (approveToken) {\n    const overrides = typeof approveToken === 'boolean' ? {} : approveToken\n    const allowance = await getL1Allowance(client, {\n      token,\n      bridgeAddress,\n      account,\n    })\n    if (allowance < amount) {\n      const hash = await writeContract(client, {\n        chain,\n        account,\n        address: token,\n        abi: erc20Abi,\n        functionName: 'approve',\n        args: [bridgeAddress, amount],\n        ...overrides,\n      } satisfies WriteContractParameters as any)\n      await waitForTransactionReceipt(client, { hash })\n    }\n  }\n}\n\nasync function getL2BridgeTxFeeParams<\n  chain extends Chain | undefined,\n  chainL2 extends ChainEIP712 | undefined,\n>(\n  client: Client<Transport, chain>,\n  l2Client: Client<Transport, chainL2>,\n  bridgehub: Address,\n  gasPrice: bigint,\n  from: Address,\n  token: Address,\n  amount: bigint,\n  to: Address,\n  gasPerPubdataByte: bigint,\n  baseToken: Address,\n  l2GasLimit?: bigint | undefined,\n  bridgeAddress?: Address | undefined,\n  customBridgeData?: Hex | undefined,\n) {\n  if (!l2Client.chain) throw new ClientChainNotConfiguredError()\n\n  let l2GasLimit_ = l2GasLimit\n  if (!l2GasLimit_)\n    l2GasLimit_ = bridgeAddress\n      ? await getL2GasLimitFromCustomBridge(\n          client,\n          l2Client,\n          from,\n          token,\n          amount,\n          to,\n          gasPerPubdataByte,\n          bridgeAddress,\n          customBridgeData,\n        )\n      : await getL2GasLimitFromDefaultBridge(\n          client,\n          l2Client,\n          from,\n          token,\n          amount,\n          to,\n          gasPerPubdataByte,\n          baseToken,\n        )\n\n  const baseCost = await readContract(client, {\n    address: bridgehub,\n    abi: bridgehubAbi,\n    functionName: 'l2TransactionBaseCost',\n    args: [BigInt(l2Client.chain.id), gasPrice, l2GasLimit_, gasPerPubdataByte],\n  })\n  return { l2GasLimit_, baseCost }\n}\n\nasync function getL2GasLimitFromDefaultBridge<\n  chain extends Chain | undefined,\n  chainL2 extends ChainEIP712 | undefined,\n>(\n  client: Client<Transport, chain>,\n  l2Client: Client<Transport, chainL2>,\n  from: Address,\n  token: Address,\n  amount: bigint,\n  to: Address,\n  gasPerPubdataByte: bigint,\n  baseToken: Address,\n) {\n  if (isAddressEqual(token, baseToken)) {\n    return await estimateGasL1ToL2(l2Client, {\n      chain: l2Client.chain,\n      account: from,\n      from,\n      to,\n      value: amount,\n      data: '0x',\n      gasPerPubdata: gasPerPubdataByte,\n    })\n  }\n  const value = 0n\n  const bridgeAddresses = await getDefaultBridgeAddresses(l2Client)\n  const l1BridgeAddress = bridgeAddresses.sharedL1\n  const l2BridgeAddress = bridgeAddresses.sharedL2\n  const bridgeData = await encodeDefaultBridgeData(client, token)\n\n  const calldata = encodeFunctionData({\n    abi: parseAbi([\n      'function finalizeDeposit(address _l1Sender, address _l2Receiver, address _l1Token, uint256 _amount, bytes _data)',\n    ]),\n    functionName: 'finalizeDeposit',\n    args: [\n      from,\n      to,\n      isAddressEqual(token, legacyEthAddress) ? ethAddressInContracts : token,\n      amount,\n      bridgeData,\n    ],\n  })\n\n  return await estimateGasL1ToL2(l2Client, {\n    chain: l2Client.chain,\n    account: applyL1ToL2Alias(l1BridgeAddress),\n    to: l2BridgeAddress,\n    data: calldata,\n    gasPerPubdata: gasPerPubdataByte,\n    value,\n  })\n}\n\nasync function getL2GasLimitFromCustomBridge<\n  chain extends Chain | undefined,\n  chainL2 extends ChainEIP712 | undefined,\n>(\n  client: Client<Transport, chain>,\n  l2Client: Client<Transport, chainL2>,\n  from: Address,\n  token: Address,\n  amount: bigint,\n  to: Address,\n  gasPerPubdataByte: bigint,\n  bridgeAddress: Address,\n  customBridgeData?: Hex,\n) {\n  let customBridgeData_ = customBridgeData\n  if (!customBridgeData_ || customBridgeData_ === '0x')\n    customBridgeData_ = await encodeDefaultBridgeData(client, token)\n\n  const l2BridgeAddress = await readContract(client, {\n    address: token,\n    abi: parseAbi([\n      'function l2BridgeAddress(uint256 _chainId) view returns (address)',\n    ]),\n    functionName: 'l2BridgeAddress',\n    args: [BigInt(l2Client.chain!.id)],\n  })\n\n  const calldata = encodeFunctionData({\n    abi: parseAbi([\n      'function finalizeDeposit(address _l1Sender, address _l2Receiver, address _l1Token, uint256 _amount, bytes _data)',\n    ]),\n    functionName: 'finalizeDeposit',\n    args: [from, to, token, amount, customBridgeData_],\n  })\n\n  return await estimateGasL1ToL2(l2Client, {\n    chain: l2Client.chain,\n    account: from,\n    from: applyL1ToL2Alias(bridgeAddress),\n    to: l2BridgeAddress,\n    data: calldata,\n    gasPerPubdata: gasPerPubdataByte,\n  })\n}\n\nasync function encodeDefaultBridgeData<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  token: Address,\n) {\n  let token_ = token\n  if (isAddressEqual(token, legacyEthAddress)) token_ = ethAddressInContracts\n  let name = 'Ether'\n  let symbol = 'ETH'\n  let decimals = 18n\n  if (!isAddressEqual(token_, ethAddressInContracts)) {\n    name = await readContract(client, {\n      address: token_,\n      abi: erc20Abi,\n      functionName: 'name',\n      args: [],\n    })\n    symbol = await readContract(client, {\n      address: token_,\n      abi: erc20Abi,\n      functionName: 'symbol',\n      args: [],\n    })\n    decimals = BigInt(\n      await readContract(client, {\n        address: token_,\n        abi: erc20Abi,\n        functionName: 'decimals',\n        args: [],\n      }),\n    )\n  }\n\n  const nameBytes = encodeAbiParameters([{ type: 'string' }], [name])\n  const symbolBytes = encodeAbiParameters([{ type: 'string' }], [symbol])\n  const decimalsBytes = encodeAbiParameters([{ type: 'uint256' }], [decimals])\n\n  return encodeAbiParameters(\n    [{ type: 'bytes' }, { type: 'bytes' }, { type: 'bytes' }],\n    [nameBytes, symbolBytes, decimalsBytes],\n  )\n}\n\nasync function getSecondBridgeCalldata<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  l1NativeTokenVault: Address,\n  token: Address,\n  amount: bigint,\n  to: Address,\n): Promise<Hex> {\n  let assetId: Hex\n  let token_ = token\n  if (isAddressEqual(token, legacyEthAddress)) token_ = ethAddressInContracts\n\n  const assetIdFromNTV = await readContract(client, {\n    address: l1NativeTokenVault,\n    abi: parseAbi(['function assetId(address token) view returns (bytes32)']),\n    functionName: 'assetId',\n    args: [token_],\n  })\n\n  if (assetIdFromNTV && assetIdFromNTV !== zeroHash) assetId = assetIdFromNTV\n  else {\n    // Okay, the token have not been registered within the Native token vault.\n    // There are two cases when it is possible:\n    // - The token is native to L1 (it may or may not be bridged), but it has not been\n    // registered within NTV after the Gateway upgrade. We assume that this is not the case\n    // as the SDK is expected to work only after the full migration is done.\n    // - The token is native to the current chain and it has never been bridged.\n\n    if (!client.chain) throw new ClientChainNotConfiguredError()\n    assetId = keccak256(\n      encodeAbiParameters(\n        [{ type: 'uint256' }, { type: 'address' }, { type: 'address' }],\n        [BigInt(client.chain.id), l2NativeTokenVaultAddress, token_],\n      ),\n    )\n  }\n\n  const ntvData = encodeAbiParameters(\n    [{ type: 'uint256' }, { type: 'address' }, { type: 'address' }],\n    [BigInt(amount), to, token_],\n  )\n\n  const data = encodeAbiParameters(\n    [{ type: 'bytes32' }, { type: 'bytes' }],\n    [assetId, ntvData],\n  )\n\n  return concatHex(['0x01', data])\n}\n\nasync function getBridgeAddresses<\n  chain extends Chain | undefined,\n  chainL2 extends ChainEIP712 | undefined,\n>(\n  client: Client<Transport, chain>,\n  l2Client: Client<Transport, chainL2>,\n): Promise<\n  BridgeContractAddresses & {\n    l1Nullifier: Address\n    l1NativeTokenVault: Address\n  }\n> {\n  const addresses = await getDefaultBridgeAddresses(l2Client)\n  let l1Nullifier = addresses.l1Nullifier\n  let l1NativeTokenVault = addresses.l1NativeTokenVault\n\n  if (!l1Nullifier)\n    l1Nullifier = await readContract(client, {\n      address: addresses.sharedL1,\n      abi: parseAbi(['function L1_NULLIFIER() view returns (address)']),\n      functionName: 'L1_NULLIFIER',\n      args: [],\n    })\n  if (!l1NativeTokenVault)\n    l1NativeTokenVault = await readContract(client, {\n      address: addresses.sharedL1,\n      abi: parseAbi(['function nativeTokenVault() view returns (address)']),\n      functionName: 'nativeTokenVault',\n      args: [],\n    })\n\n  return {\n    ...addresses,\n    l1Nullifier,\n    l1NativeTokenVault,\n  }\n}\n\nfunction scaleGasLimit(gasLimit: bigint): bigint {\n  return (gasLimit * BigInt(12)) / BigInt(10)\n}\n\nasync function getFeePrice<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n) {\n  const client_ = client.extend(publicActions)\n  const block = await client_.getBlock()\n  const baseFee =\n    typeof block.baseFeePerGas !== 'bigint'\n      ? await client_.getGasPrice()\n      : block.baseFeePerGas\n  const maxPriorityFeePerGas = await client_.estimateMaxPriorityFeePerGas()\n\n  return {\n    maxFeePerGas: (baseFee * 3n) / 2n + maxPriorityFeePerGas,\n    maxPriorityFeePerGas: maxPriorityFeePerGas,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}