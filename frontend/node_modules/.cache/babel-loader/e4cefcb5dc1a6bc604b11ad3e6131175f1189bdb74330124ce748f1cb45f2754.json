{"ast":null,"code":"import { parseAbiItem } from \"abitype\";\nimport { toFunctionSelector } from \"viem\";\nimport { LruMap } from \"../caching/lru.js\";\nimport { stringify } from \"../json.js\";\nconst prepareMethodCache = new LruMap(4096);\n/**\n * Prepares a method for usage by converting it into a prepared method object.\n * @param method The method to prepare.\n * @returns The prepared method object.\n * @example\n * ```ts\n * import { prepareMethod } from \"thirdweb/utils\";\n * const method = \"function transfer(address to, uint256 value)\";\n * const preparedMethod = prepareMethod(method);\n * ```\n * @contract\n */\nexport function prepareMethod(method) {\n  const key = typeof method === \"string\" ? method : stringify(method);\n  if (prepareMethodCache.has(key)) {\n    return prepareMethodCache.get(key);\n  }\n  const abiFn = typeof method === \"string\" ?\n  // @ts-expect-error - we're sure it's a string...\n  parseAbiItem(method) : method;\n  // encode the method signature\n  const sig = toFunctionSelector(abiFn);\n  const ret = [sig, abiFn.inputs, abiFn.outputs];\n  prepareMethodCache.set(key, ret);\n  return ret;\n}","map":{"version":3,"names":["parseAbiItem","toFunctionSelector","LruMap","stringify","prepareMethodCache","prepareMethod","method","key","has","get","abiFn","sig","ret","inputs","outputs","set"],"sources":["/home/user/Arbitrage/frontend/node_modules/thirdweb/src/utils/abi/prepare-method.ts"],"sourcesContent":["import { type AbiFunction, type ParseAbiItem, parseAbiItem } from \"abitype\";\nimport { toFunctionSelector } from \"viem\";\nimport { LruMap } from \"../caching/lru.js\";\nimport type { Hex } from \"../encoding/hex.js\";\nimport { stringify } from \"../json.js\";\n\ntype ParseMethod<method extends AbiFunction | `function ${string}`> =\n  // if the method IS an AbiFunction, return it\n  method extends AbiFunction\n    ? method\n    : method extends `function ${string}`\n      ? ParseAbiItem<method> extends AbiFunction\n        ? ParseAbiItem<method>\n        : never\n      : never;\n\nexport type PreparedMethod<TMethod extends AbiFunction | `function ${string}`> =\n  // [\"fn signature\", \"inputs\", \"outputs\"]\n  [Hex, ParseMethod<TMethod>[\"inputs\"], ParseMethod<TMethod>[\"outputs\"]];\n\nconst prepareMethodCache = new LruMap<PreparedMethod<AbiFunction>>(4096);\n\n/**\n * Prepares a method for usage by converting it into a prepared method object.\n * @param method The method to prepare.\n * @returns The prepared method object.\n * @example\n * ```ts\n * import { prepareMethod } from \"thirdweb/utils\";\n * const method = \"function transfer(address to, uint256 value)\";\n * const preparedMethod = prepareMethod(method);\n * ```\n * @contract\n */\nexport function prepareMethod<\n  const TMethod extends AbiFunction | `function ${string}`,\n>(method: TMethod): PreparedMethod<TMethod> {\n  const key = typeof method === \"string\" ? method : stringify(method);\n  if (prepareMethodCache.has(key)) {\n    return prepareMethodCache.get(key) as PreparedMethod<TMethod>;\n  }\n  type ParsedAbiFn = ParseMethod<TMethod>;\n\n  const abiFn =\n    typeof method === \"string\"\n      ? // @ts-expect-error - we're sure it's a string...\n        (parseAbiItem(method) as ParsedAbiFn)\n      : (method as ParsedAbiFn);\n\n  // encode the method signature\n  const sig = toFunctionSelector(abiFn);\n\n  const ret: PreparedMethod<TMethod> = [sig, abiFn.inputs, abiFn.outputs];\n  prepareMethodCache.set(key, ret);\n  return ret;\n}\n"],"mappings":"AAAA,SAA8CA,YAAY,QAAQ,SAAS;AAC3E,SAASC,kBAAkB,QAAQ,MAAM;AACzC,SAASC,MAAM,QAAQ,mBAAmB;AAE1C,SAASC,SAAS,QAAQ,YAAY;AAgBtC,MAAMC,kBAAkB,GAAG,IAAIF,MAAM,CAA8B,IAAI,CAAC;AAExE;;;;;;;;;;;;AAYA,OAAM,SAAUG,aAAaA,CAE3BC,MAAe;EACf,MAAMC,GAAG,GAAG,OAAOD,MAAM,KAAK,QAAQ,GAAGA,MAAM,GAAGH,SAAS,CAACG,MAAM,CAAC;EACnE,IAAIF,kBAAkB,CAACI,GAAG,CAACD,GAAG,CAAC,EAAE;IAC/B,OAAOH,kBAAkB,CAACK,GAAG,CAACF,GAAG,CAA4B;EAC/D;EAGA,MAAMG,KAAK,GACT,OAAOJ,MAAM,KAAK,QAAQ;EACtB;EACCN,YAAY,CAACM,MAAM,CAAiB,GACpCA,MAAsB;EAE7B;EACA,MAAMK,GAAG,GAAGV,kBAAkB,CAACS,KAAK,CAAC;EAErC,MAAME,GAAG,GAA4B,CAACD,GAAG,EAAED,KAAK,CAACG,MAAM,EAAEH,KAAK,CAACI,OAAO,CAAC;EACvEV,kBAAkB,CAACW,GAAG,CAACR,GAAG,EAAEK,GAAG,CAAC;EAChC,OAAOA,GAAG;AACZ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}