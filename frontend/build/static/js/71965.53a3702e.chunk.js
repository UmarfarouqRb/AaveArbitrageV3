"use strict";(self.webpackChunkfrontend=self.webpackChunkfrontend||[]).push([[71965],{71965:(t,e,n)=>{n.d(e,{smartAccountSignMessage:()=>D,smartAccountSignTypedData:()=>I});var a=n(71760),r=n(21299);const s="0x6492649264926492649264926492649264926492649264926492649264926492";function o(t){let{address:e,data:n,signature:o}=t;return(0,r.concatHex)([(0,a.hd)([{type:"address"},{type:"bytes"},{type:"bytes"}],[e,n,o]),s])}var c=n(86511);const i="0x1626ba7e",y=[{name:"hash",type:"bytes32"},{name:"signature",type:"bytes"}],d=[{type:"bytes4"}];const p="0x1626ba7e";async function u(t){let{hash:e,signature:n,contract:a}=t;try{return await async function(t){return(0,c.readContract)({contract:t.contract,method:[i,y,d],params:[t.hash,t.signature]})}({contract:a,hash:e,signature:n})===p}catch(r){return console.error("Error verifying EIP-1271 signature",r),!1}}var l=n(79002),m=n(69961),f=n(19736),v=n(42002),g=n(68098);const h="\x19Ethereum Signed Message:\n";var w=n(8),A=n(27916),b=n(3340);function C(t){let{data:e,primaryType:n,types:r}=t;const s=[{type:"bytes32"}],o=[T({primaryType:n,types:r})];if(!r[n])throw new Error("Invalid types");for(const a of r[n]){const[t,n]=x({name:a.name,type:a.type,types:r,value:e[a.name]});s.push(t),o.push(n)}return(0,a.hd)(s,o)}function T(t){let{primaryType:e,types:n}=t;const a=(0,b.nj)(function(t){let{primaryType:e,types:n}=t,a="";const r=S({primaryType:e,types:n});r.delete(e);const s=[e,...Array.from(r).sort()];for(const o of s){if(!n[o])throw new Error("Invalid types");a+="".concat(o,"(").concat(n[o].map(t=>{let{name:e,type:n}=t;return"".concat(n," ").concat(e)}).join(","),")")}return a}({primaryType:e,types:n}));return(0,g.S)(a)}function S(t){let{primaryType:e,types:n}=t,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Set;const r=e.match(/^[0-9A-Z_a-z]*/),s=null===r||void 0===r?void 0:r[0];if(a.has(s)||void 0===n[s])return a;a.add(s);for(const o of n[s])S({primaryType:o.type,types:n},a);return a}function x(t){let{types:e,name:n,type:r,value:s}=t;if(void 0!==e[r])return[{type:"bytes32"},(0,g.S)(C({data:s,primaryType:r,types:e}))];if("bytes"===r){const t=s.length%2?"0":"";return s="0x".concat(t+s.slice(2)),[{type:"bytes32"},(0,g.S)(s)]}if("string"===r)return[{type:"bytes32"},(0,g.S)((0,b.nj)(s))];if(r.lastIndexOf("]")===r.length-1){const t=r.slice(0,r.lastIndexOf("[")),o=s.map(a=>x({name:n,type:t,types:e,value:a}));return[{type:"bytes32"},(0,g.S)((0,a.hd)(o.map(t=>{let[e]=t;return e}),o.map(t=>{let[,e]=t;return e})))]}return[{type:r},s]}var E=n(92719);async function D(t){let{accountContract:e,factoryContract:n,options:r,message:s}=t;const c=function(t,e){const n="string"===typeof t?(0,v.Af)(t):t.raw instanceof Uint8Array?t.raw:(0,v.ZJ)(t.raw),a=(0,v.Af)("".concat(h).concat(n.length));return(0,g.S)(f.xW(a,n),e)}(s);let i;const y=(0,a.hd)([{type:"bytes32"}],[c]);i=await r.personalAccount.signTypedData({domain:{chainId:r.chain.id,name:"Account",verifyingContract:e.address,version:"1"},message:{message:y},primaryType:"AccountMessage",types:{AccountMessage:[{name:"message",type:"bytes"}]}});if(await(0,m.isContractDeployed)(e)){if(await u({contract:e,hash:c,signature:i}))return i;throw new Error("Failed to verify signature")}{var d,p;const t=(0,E.HM)({accountSalt:null===(d=r.overrides)||void 0===d?void 0:d.accountSalt,adminAddress:r.personalAccount.address,createAccountOverride:null===(p=r.overrides)||void 0===p?void 0:p.createAccount,factoryContract:n});if(!t)throw new Error("Create account override not provided");const e=await(0,l.encode)(t);return o({address:n.address,data:e,signature:i})}}async function I(t){var e,n;let{accountContract:r,factoryContract:s,options:c,typedData:i}=t;if((null===(e=i.domain)||void 0===e||null===(e=e.verifyingContract)||void 0===e?void 0:e.toLowerCase())===(null===(n=r.address)||void 0===n?void 0:n.toLowerCase()))return c.personalAccount.signTypedData(i);const y=function(t){const{domain:e={},message:n,primaryType:a}=t,r=(0,w.A)({EIP712Domain:A.HQ(e)},t.types);A.tf({domain:e,message:n,primaryType:a,types:r});const s=["0x1901"];if(e&&s.push(A.xy({domain:e,types:r})),"EIP712Domain"!==a){const t=(()=>{const t=C({data:n,primaryType:a,types:r});return(0,g.S)(t)})();s.push(t)}return(0,g.S)(f.xW(...s.map(t=>f.aD(t))))}(i);let d;const p=(0,a.hd)([{type:"bytes32"}],[y]);d=await c.personalAccount.signTypedData({domain:{chainId:c.chain.id,name:"Account",verifyingContract:r.address,version:"1"},message:{message:p},primaryType:"AccountMessage",types:{AccountMessage:[{name:"message",type:"bytes"}]}});if(await(0,m.isContractDeployed)(r)){if(await u({contract:r,hash:y,signature:d}))return d;throw new Error("Failed to verify signature")}{var v,h;const t=(0,E.HM)({accountSalt:null===(v=c.overrides)||void 0===v?void 0:v.accountSalt,adminAddress:c.personalAccount.address,createAccountOverride:null===(h=c.overrides)||void 0===h?void 0:h.createAccount,factoryContract:s});if(!t)throw new Error("Create account override not provided");const e=await(0,l.encode)(t);return o({address:s.address,data:e,signature:d})}}}}]);
//# sourceMappingURL=71965.53a3702e.chunk.js.map