{"version":3,"file":"static/js/55384.f5ece3a7.chunk.js","mappings":"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","sources":["../node_modules/thirdweb/src/transaction/actions/gasless/providers/engine.ts","../node_modules/thirdweb/src/utils/sleep.ts","../node_modules/viem/utils/formatters/transactionReceipt.ts","../node_modules/viem/utils/formatters/log.ts","../node_modules/thirdweb/src/rpc/actions/eth_getTransactionReceipt.ts","../node_modules/thirdweb/src/rpc/watchBlockNumber.ts","../node_modules/thirdweb/src/rpc/actions/eth_blockNumber.ts","../node_modules/thirdweb/src/transaction/actions/wait-for-tx-receipt.ts","../node_modules/thirdweb/src/transaction/read-contract.ts","../node_modules/thirdweb/src/rpc/actions/eth_call.ts"],"sourcesContent":["import type { Address } from \"abitype\";\nimport { getContract } from \"../../../../contract/contract.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nimport type { Account } from \"../../../../wallets/interfaces/wallet.js\";\nimport type { PreparedTransaction } from \"../../../prepare-transaction.js\";\nimport { readContract } from \"../../../read-contract.js\";\nimport type { SerializableTransaction } from \"../../../serialize-transaction.js\";\nimport {\n  type WaitForReceiptOptions,\n  waitForReceipt,\n} from \"../../wait-for-tx-receipt.js\";\n\n/**\n * @transaction\n */\nexport type EngineOptions = {\n  provider: \"engine\";\n  relayerUrl: string;\n  relayerForwarderAddress: Address;\n  domainName?: string; // default: \"GSNv2 Forwarder\"\n  domainVersion?: string; // default: \"0.0.1\"\n  domainSeparatorVersion?: string; // default: \"1\"\n  experimentalChainlessSupport?: boolean; // default: false\n};\n\ntype SendengineTransactionOptions = {\n  account: Account;\n  // TODO: update this to `Transaction<\"prepared\">` once the type is available to ensure only prepared transactions are accepted\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any prepared transaction type\n  transaction: PreparedTransaction<any>;\n  serializableTransaction: SerializableTransaction;\n  gasless: EngineOptions;\n};\n\n/**\n * @internal - only exported for testing\n */\nexport async function prepareEngineTransaction({\n  account,\n  serializableTransaction,\n  transaction,\n  gasless,\n}: SendengineTransactionOptions) {\n  const forrwaderContract = getContract({\n    address: gasless.relayerForwarderAddress,\n    chain: transaction.chain,\n    client: transaction.client,\n  });\n\n  const nonce = await readContract({\n    contract: forrwaderContract,\n    method: \"function getNonce(address) view returns (uint256)\",\n    params: [account.address],\n  });\n\n  const [signature, message] = await (async () => {\n    // TODO: handle special case for `approve` -> `permit` transactions\n\n    if (!serializableTransaction.to) {\n      throw new Error(\"engine transactions must have a 'to' address\");\n    }\n    if (!serializableTransaction.gas) {\n      throw new Error(\"engine transactions must have a 'gas' value\");\n    }\n    if (!serializableTransaction.data) {\n      throw new Error(\"engine transactions must have a 'data' value\");\n    }\n    // chainless support!\n    if (gasless.experimentalChainlessSupport) {\n      const message = {\n        chainid: BigInt(transaction.chain.id),\n        data: serializableTransaction.data,\n        from: account.address,\n        gas: serializableTransaction.gas,\n        nonce: nonce,\n        to: serializableTransaction.to,\n        value: 0n,\n      } as const;\n      return [\n        await account.signTypedData({\n          domain: {\n            name: \"GSNv2 Forwarder\",\n            verifyingContract: forrwaderContract.address,\n            version: \"0.0.1\",\n          },\n          message,\n          primaryType: \"ForwardRequest\",\n          types: { ForwardRequest: ChainAwareForwardRequest },\n        }),\n        message,\n      ] as const;\n    }\n    // else non-chainless support\n    const message = {\n      data: serializableTransaction.data,\n      from: account.address,\n      gas: serializableTransaction.gas,\n      nonce: nonce,\n      to: serializableTransaction.to,\n      value: 0n,\n    } as const;\n    return [\n      await account.signTypedData({\n        domain: {\n          chainId: transaction.chain.id,\n          name: gasless.domainName ?? \"GSNv2 Forwarder\",\n          verifyingContract: forrwaderContract.address,\n          version: gasless.domainVersion ?? \"0.0.1\",\n        },\n        message,\n        primaryType: \"ForwardRequest\",\n        types: { ForwardRequest },\n      }),\n      message,\n    ] as const;\n  })();\n  // TODO: handle special case for `approve` -> `permit`\n  const messageType = \"forward\";\n\n  return { message, messageType, signature } as const;\n}\n\nconst ForwardRequest = [\n  { name: \"from\", type: \"address\" },\n  { name: \"to\", type: \"address\" },\n  { name: \"value\", type: \"uint256\" },\n  { name: \"gas\", type: \"uint256\" },\n  { name: \"nonce\", type: \"uint256\" },\n  { name: \"data\", type: \"bytes\" },\n] as const;\n\nconst ChainAwareForwardRequest = [\n  { name: \"from\", type: \"address\" },\n  { name: \"to\", type: \"address\" },\n  { name: \"value\", type: \"uint256\" },\n  { name: \"gas\", type: \"uint256\" },\n  { name: \"nonce\", type: \"uint256\" },\n  { name: \"data\", type: \"bytes\" },\n  { name: \"chainid\", type: \"uint256\" },\n] as const;\n\n/**\n * @internal\n */\nexport async function relayEngineTransaction(\n  options: SendengineTransactionOptions,\n): Promise<WaitForReceiptOptions> {\n  const { message, messageType, signature } =\n    await prepareEngineTransaction(options);\n\n  const response = await fetch(options.gasless.relayerUrl, {\n    body: stringify({\n      forwarderAddress: options.gasless.relayerForwarderAddress,\n      request: message,\n      signature,\n      type: messageType,\n    }),\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    method: \"POST\",\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to send transaction: ${await response.text()}`);\n  }\n  const json = await response.json();\n  if (!json.result) {\n    throw new Error(`Relay transaction failed: ${json.message}`);\n  }\n  const queueId = json.result.queueId;\n  // poll for transactionHash\n  const timeout = 60000;\n  const interval = 1000;\n  const endtime = Date.now() + timeout;\n  while (Date.now() < endtime) {\n    const receipt = await fetchReceipt({ options, queueId });\n    if (receipt) {\n      return {\n        chain: options.transaction.chain,\n        client: options.transaction.client,\n        transactionHash: receipt.transactionHash,\n      };\n    }\n    await new Promise((resolve) => setTimeout(resolve, interval));\n  }\n  throw new Error(`Failed to find relayed transaction after ${timeout}ms`);\n}\n\nasync function fetchReceipt(args: {\n  options: SendengineTransactionOptions;\n  queueId: string;\n}) {\n  const { options, queueId } = args;\n  const url = options.gasless.relayerUrl.split(\"/relayer/\")[0];\n  const res = await fetch(`${url}/transaction/status/${queueId}`, {\n    method: \"GET\",\n  });\n  const resJson = await res.json();\n  if (!res.ok) {\n    return null;\n  }\n  const result = resJson.result;\n  if (!result) {\n    return null;\n  }\n  switch (result.status) {\n    case \"errored\":\n      throw new Error(\n        `Transaction errored with reason: ${result.errorMessage}`,\n      );\n    case \"cancelled\":\n      throw new Error(\"Transaction execution cancelled.\");\n    case \"mined\": {\n      const receipt = await waitForReceipt({\n        chain: options.transaction.chain,\n        client: options.transaction.client,\n        transactionHash: result.transactionHash,\n      });\n      return receipt;\n    }\n    default: {\n      return null;\n    }\n  }\n}\n","/**\n * Delay an async thread\n * @param ms Sleep time in millisecond\n * @internal\n */\nexport function sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type {\n  Chain,\n  ExtractChainFormatterReturnType,\n} from '../../types/chain.js'\nimport type { RpcTransactionReceipt } from '../../types/rpc.js'\nimport type { TransactionReceipt } from '../../types/transaction.js'\nimport type { ExactPartial } from '../../types/utils.js'\nimport { hexToNumber } from '../encoding/fromHex.js'\n\nimport { type DefineFormatterErrorType, defineFormatter } from './formatter.js'\nimport { formatLog } from './log.js'\nimport { transactionType } from './transaction.js'\n\nexport type FormattedTransactionReceipt<\n  chain extends Chain | undefined = undefined,\n> = ExtractChainFormatterReturnType<\n  chain,\n  'transactionReceipt',\n  TransactionReceipt\n>\n\nexport const receiptStatuses = {\n  '0x0': 'reverted',\n  '0x1': 'success',\n} as const\n\nexport type FormatTransactionReceiptErrorType = ErrorType\n\nexport function formatTransactionReceipt(\n  transactionReceipt: ExactPartial<RpcTransactionReceipt>,\n) {\n  const receipt = {\n    ...transactionReceipt,\n    blockNumber: transactionReceipt.blockNumber\n      ? BigInt(transactionReceipt.blockNumber)\n      : null,\n    contractAddress: transactionReceipt.contractAddress\n      ? transactionReceipt.contractAddress\n      : null,\n    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed\n      ? BigInt(transactionReceipt.cumulativeGasUsed)\n      : null,\n    effectiveGasPrice: transactionReceipt.effectiveGasPrice\n      ? BigInt(transactionReceipt.effectiveGasPrice)\n      : null,\n    gasUsed: transactionReceipt.gasUsed\n      ? BigInt(transactionReceipt.gasUsed)\n      : null,\n    logs: transactionReceipt.logs\n      ? transactionReceipt.logs.map((log) => formatLog(log))\n      : null,\n    to: transactionReceipt.to ? transactionReceipt.to : null,\n    transactionIndex: transactionReceipt.transactionIndex\n      ? hexToNumber(transactionReceipt.transactionIndex)\n      : null,\n    status: transactionReceipt.status\n      ? receiptStatuses[transactionReceipt.status]\n      : null,\n    type: transactionReceipt.type\n      ? transactionType[\n          transactionReceipt.type as keyof typeof transactionType\n        ] || transactionReceipt.type\n      : null,\n  } as TransactionReceipt\n\n  if (transactionReceipt.blobGasPrice)\n    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice)\n  if (transactionReceipt.blobGasUsed)\n    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed)\n\n  return receipt\n}\n\nexport type DefineTransactionReceiptErrorType =\n  | DefineFormatterErrorType\n  | ErrorType\n\nexport const defineTransactionReceipt = /*#__PURE__*/ defineFormatter(\n  'transactionReceipt',\n  formatTransactionReceipt,\n)\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Log } from '../../types/log.js'\nimport type { RpcLog } from '../../types/rpc.js'\nimport type { ExactPartial } from '../../types/utils.js'\n\nexport type FormatLogErrorType = ErrorType\n\nexport function formatLog(\n  log: ExactPartial<RpcLog>,\n  {\n    args,\n    eventName,\n  }: { args?: unknown | undefined; eventName?: string | undefined } = {},\n) {\n  return {\n    ...log,\n    blockHash: log.blockHash ? log.blockHash : null,\n    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,\n    logIndex: log.logIndex ? Number(log.logIndex) : null,\n    transactionHash: log.transactionHash ? log.transactionHash : null,\n    transactionIndex: log.transactionIndex\n      ? Number(log.transactionIndex)\n      : null,\n    ...(eventName ? { args, eventName } : {}),\n  } as Log\n}\n","import {\n  type EIP1193RequestFn,\n  type EIP1474Methods,\n  formatTransactionReceipt,\n  type GetTransactionReceiptParameters,\n  type TransactionReceipt,\n} from \"viem\";\n\n/**\n * Retrieves the transaction receipt for a given transaction hash.\n * Throws an error if the receipt is not found.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for retrieving the transaction receipt.\n * @returns A promise that resolves to the transaction receipt.\n * @throws An error if the transaction receipt is not found.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_getTransactionReceipt } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const transactionReceipt = await eth_getTransactionReceipt(rpcRequest, {\n *  hash: \"0x...\",\n * });\n * ```\n */\nexport async function eth_getTransactionReceipt(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: GetTransactionReceiptParameters,\n): Promise<TransactionReceipt> {\n  const receipt = await request({\n    method: \"eth_getTransactionReceipt\",\n    params: [params.hash],\n  });\n\n  if (!receipt) {\n    throw new Error(\"Transaction receipt not found.\");\n  }\n\n  return formatTransactionReceipt(receipt);\n}\n","import type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { sleep } from \"../utils/sleep.js\";\nimport { eth_blockNumber } from \"./actions/eth_blockNumber.js\";\nimport { getRpcClient } from \"./rpc.js\";\n\nconst MAX_POLL_DELAY = 5000; // 5 seconds\nconst DEFAULT_POLL_DELAY = 1000; // 1 second\nconst MIN_POLL_DELAY = 500; // 500 milliseconds\nconst DEFAULT_OVERPOLL_RATIO = 2; // poll twice as often as the average block time by default\n\nconst SLIDING_WINDOW_SIZE = 10; // always keep track of the last 10 block times\n\n/**\n * TODO: document\n * @internal\n */\nfunction getAverageBlockTime(blockTimes: number[]): number {\n  // left-pad the blocktimes Array with the DEFAULT_POLL_DELAY\n  while (blockTimes.length < SLIDING_WINDOW_SIZE) {\n    blockTimes.unshift(DEFAULT_POLL_DELAY);\n  }\n\n  const sum = blockTimes.reduce((acc, blockTime) => acc + blockTime, 0);\n  return sum / blockTimes.length;\n}\n\n/**\n * TODO: document\n * @internal\n */\nfunction createBlockNumberPoller(\n  client: ThirdwebClient,\n  chain: Chain,\n  overPollRatio?: number,\n  onError?: (error: Error) => void,\n) {\n  let subscribers: Array<(blockNumber: bigint) => void> = [];\n  let blockTimesWindow: number[] = [];\n\n  let isActive = false;\n  let lastBlockNumber: bigint | undefined;\n  let lastBlockAt: number | undefined;\n\n  const rpcRequest = getRpcClient({ chain, client });\n\n  /**\n   * TODO: document\n   * @internal\n   */\n  async function poll() {\n    // stop polling if there are no more subscriptions\n    if (!isActive) {\n      return;\n    }\n\n    try {\n      const blockNumber = await eth_blockNumber(rpcRequest);\n\n      if (!lastBlockNumber || blockNumber > lastBlockNumber) {\n        let newBlockNumbers = [];\n        if (lastBlockNumber) {\n          for (let i = lastBlockNumber + 1n; i <= blockNumber; i++) {\n            newBlockNumbers.push(BigInt(i));\n          }\n        } else {\n          newBlockNumbers = [blockNumber];\n        }\n        lastBlockNumber = blockNumber;\n        const currentTime = Date.now();\n        if (lastBlockAt) {\n          // if we skipped a block we need to adjust the block time down to that level\n          const blockTime =\n            (currentTime - lastBlockAt) / newBlockNumbers.length;\n\n          blockTimesWindow.push(blockTime);\n          blockTimesWindow = blockTimesWindow.slice(-SLIDING_WINDOW_SIZE);\n        }\n        lastBlockAt = currentTime;\n        // for all new blockNumbers...\n        for (const b of newBlockNumbers) {\n          // ... call all current subscribers\n          for (const subscriberCallback of subscribers) {\n            subscriberCallback(b);\n          }\n        }\n      }\n    } catch (err: unknown) {\n      if (onError) {\n        onError(err as Error);\n      } else {\n        console.error(\n          `[watchBlockNumber]: Failed to poll for latest block number: ${err}`,\n        );\n      }\n    }\n\n    const currentApproximateBlockTime = getAverageBlockTime(blockTimesWindow);\n\n    // make sure we never poll faster than our minimum poll delay or slower than our maximum poll delay\n    const pollDelay = Math.max(\n      MIN_POLL_DELAY,\n      Math.min(\n        MAX_POLL_DELAY,\n        Math.max(MIN_POLL_DELAY, currentApproximateBlockTime),\n      ),\n    );\n\n    // sleep for the pollDelay for this chain (divided by the overPollRatio, which defaults to 2)\n    await sleep(pollDelay / (overPollRatio ?? DEFAULT_OVERPOLL_RATIO));\n    // poll again\n    poll();\n  }\n\n  // return the \"subscribe\" function\n  return function subscribe(\n    callBack: (blockNumber: bigint) => void,\n    initialBlockNumber?: bigint,\n  ) {\n    subscribers.push(callBack);\n    // if we are currently not active -> start polling\n    if (!isActive) {\n      lastBlockNumber = initialBlockNumber;\n      isActive = true;\n      poll();\n    }\n\n    // return the \"unsubscribe\" function (meaning the caller can unsubscribe)\n    return function unSubscribe() {\n      // filter out the callback from the subscribers\n      subscribers = subscribers.filter((fn) => fn !== callBack);\n      // if the new subscribers Array is empty (aka we were the last subscriber) -> stop polling\n      if (subscribers.length === 0) {\n        lastBlockNumber = undefined;\n        lastBlockAt = undefined;\n        isActive = false;\n      }\n    };\n  };\n}\n\nconst existingPollers = new Map<\n  number,\n  ReturnType<typeof createBlockNumberPoller>\n>();\n\nexport type WatchBlockNumberOptions = {\n  client: ThirdwebClient;\n  chain: Chain;\n  onNewBlockNumber: (blockNumber: bigint) => void;\n  onError?: (error: Error) => void;\n  overPollRatio?: number;\n  latestBlockNumber?: bigint;\n};\n\n/**\n * Watches the block number for a specific chain.\n * @param opts - The options for watching the block number.\n * @returns The unwatch function.\n * @example\n * ```ts\n * import { watchBlockNumber } from \"thirdweb\";\n * const unwatch = watchBlockNumber({\n *  client,\n *  chainId,\n *  onNewBlockNumber: (blockNumber) => {\n *    // do something with the block number\n *  },\n *  onError: (err) => {\n *    // do something if getting the block number fails\n *  },\n * });\n *\n * // later stop watching\n * unwatch();\n * ```\n * @rpc\n */\nexport function watchBlockNumber(opts: WatchBlockNumberOptions) {\n  const {\n    client,\n    chain,\n    onNewBlockNumber,\n    overPollRatio,\n    latestBlockNumber,\n    onError,\n  } = opts;\n  const chainId = chain.id;\n  // if we already have a poller for this chainId -> use it.\n  let poller = existingPollers.get(chainId);\n  // otherwise create a new poller\n  if (!poller) {\n    poller = createBlockNumberPoller(client, chain, overPollRatio, onError);\n    // and store it for later use\n    existingPollers.set(chainId, poller);\n  }\n  // subscribe to the poller and return the unSubscribe function to the caller\n  return poller(onNewBlockNumber, latestBlockNumber);\n}\n","import type { EIP1193RequestFn, EIP1474Methods } from \"viem\";\nimport { hexToBigInt } from \"../../utils/encoding/hex.js\";\n\n/**\n * Retrieves the current block number from the Ethereum blockchain.\n * @param request - The EIP1193 request function.\n * @returns A promise that resolves to the current block number as a bigint.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_blockNumber } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const blockNumber = await eth_blockNumber(rpcRequest);\n * ```\n */\nexport async function eth_blockNumber(\n  request: EIP1193RequestFn<EIP1474Methods>,\n): Promise<bigint> {\n  const blockNumberHex = await request({\n    method: \"eth_blockNumber\",\n  });\n  return hexToBigInt(blockNumberHex);\n}\n","import type { Hex } from \"viem\";\nimport type { Chain } from \"../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { eth_getTransactionReceipt } from \"../../rpc/actions/eth_getTransactionReceipt.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { watchBlockNumber } from \"../../rpc/watchBlockNumber.js\";\nimport type { Prettify } from \"../../utils/type-utils.js\";\nimport type { SendTransactionResult, TransactionReceipt } from \"../types.js\";\n\nconst DEFAULT_MAX_BLOCKS_WAIT_TIME = 100;\n\nconst map = new Map<string, Promise<TransactionReceipt>>();\n\nexport type WaitForReceiptOptions = Prettify<\n  SendTransactionResult & {\n    client: ThirdwebClient;\n    chain: Chain;\n    maxBlocksWaitTime?: number;\n  }\n>;\n\n/**\n * Waits for the transaction receipt of a given transaction hash on a specific contract.\n * @param options - The options for waiting for the receipt.\n * By default, it's 100 blocks.\n * @returns A promise that resolves with the transaction receipt.\n * @transaction\n * @example\n * ```ts\n * import { waitForReceipt } from \"thirdweb\";\n * const receipt = await waitForReceipt({\n *   client,\n *   chain,\n *   transactionHash: \"0x123...\",\n * });\n * ```\n */\nexport function waitForReceipt(\n  options: WaitForReceiptOptions,\n): Promise<TransactionReceipt> {\n  const { transactionHash, chain, client } = options;\n\n  const chainId = chain.id;\n  const key = `${chainId}:tx_${transactionHash}`;\n  const maxBlocksWaitTime =\n    options.maxBlocksWaitTime ?? DEFAULT_MAX_BLOCKS_WAIT_TIME;\n\n  if (map.has(key)) {\n    // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set\n    return map.get(key)!;\n  }\n  const promise = new Promise<TransactionReceipt>((resolve, reject) => {\n    if (!transactionHash) {\n      reject(\n        new Error(\n          \"Transaction has no transactionHash to wait for, did you execute it?\",\n        ),\n      );\n    }\n\n    const request = getRpcClient({ chain, client });\n\n    // start at -1 because the first block doesn't count\n    let blocksWaited = -1;\n\n    const unwatch = watchBlockNumber({\n      chain: chain,\n      client: client,\n      onNewBlockNumber: async () => {\n        blocksWaited++;\n        if (blocksWaited >= maxBlocksWaitTime) {\n          unwatch();\n          reject(\n            new Error(\n              `Transaction receipt for ${transactionHash} not found after ${maxBlocksWaitTime} blocks`,\n            ),\n          );\n          return;\n        }\n        try {\n          const receipt = await eth_getTransactionReceipt(request, {\n            hash: transactionHash as Hex,\n          });\n\n          // stop the polling\n          unwatch();\n          // resolve the top level promise with the receipt\n          resolve(receipt);\n        } catch {\n          // noop, we'll try again on the next blocks\n        }\n      },\n    });\n    // remove the promise from the map when it's done (one way or the other)\n  }).finally(() => {\n    map.delete(key);\n  });\n\n  map.set(key, promise);\n  return promise;\n}\n","import {\n  type Abi,\n  type AbiFunction,\n  type AbiParameter,\n  type AbiParametersToPrimitiveTypes,\n  type ExtractAbiFunctionNames,\n  parseAbiItem,\n} from \"abitype\";\nimport { decodeAbiParameters, type TransactionRequest } from \"viem\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\nimport { eth_call } from \"../rpc/actions/eth_call.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport { encodeAbiParameters } from \"../utils/abi/encodeAbiParameters.js\";\nimport {\n  type PreparedMethod,\n  prepareMethod,\n} from \"../utils/abi/prepare-method.js\";\nimport { getAddress } from \"../utils/address.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\nimport type { PrepareTransactionOptions } from \"./prepare-transaction.js\";\nimport type {\n  BaseTransactionOptions,\n  ParamsOption,\n  ParseMethod,\n} from \"./types.js\";\nimport { isAbiFunction } from \"./utils.js\";\n\nexport type ReadContractResult<outputs extends readonly AbiParameter[]> = // if the outputs are 0 length, return never, invalid case\n  outputs extends { length: 0 }\n    ? never\n    : outputs extends { length: 1 }\n      ? // if the outputs are 1 length, we'll always return the first element\n        AbiParametersToPrimitiveTypes<outputs>[0]\n      : // otherwise we'll return the array\n        AbiParametersToPrimitiveTypes<outputs>;\n\nexport type ReadContractOptions<\n  TAbi extends Abi = [],\n  TMethod extends\n    | AbiFunction\n    | string\n    | ((\n        contract: ThirdwebContract<TAbi>,\n      ) => Promise<AbiFunction>) = TAbi extends { length: 0 }\n    ? AbiFunction | string\n    : ExtractAbiFunctionNames<TAbi>,\n  TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n> = BaseTransactionOptions<\n  Omit<\n    TransactionRequest,\n    | \"from\"\n    | \"to\"\n    | \"data\"\n    | \"value\"\n    | \"accessList\"\n    | \"gas\"\n    | \"gasPrice\"\n    | \"maxFeePerGas\"\n    | \"maxPriorityFeePerGas\"\n    | \"nonce\"\n  > & {\n    method: TMethod | TPreparedMethod;\n    from?: string;\n  } & ParamsOption<TPreparedMethod[1]> &\n    Omit<PrepareTransactionOptions, \"to\" | \"data\" | \"chain\" | \"client\">,\n  TAbi\n>;\n\n/**\n * ### Reads state from a deployed smart contract.\n *\n * Use this for raw read calls from a contract, but you can also use read [extensions](https://portal.thirdweb.com/typescript/v5/extensions/use) for predefined methods for common standards.\n *\n * @param options - The transaction options.\n * @returns A promise that resolves with the result of the read call.\n * @transaction\n * @example\n *\n * ### Raw contract call (recommended)\n *\n * You can read from any contract by using the solidity signature of the function you want to call.\n *\n * ```ts\n * import { getContract } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { useReadContract } from \"thirdweb/react\";\n *\n * const contract = getContract({\n *   client,\n *   address: \"0x...\",\n *   chain: sepolia,\n * });\n *\n * const { data, isLoading } = useReadContract({\n *   contract,\n *   method: \"function tokenURI(uint256 tokenId) returns (string)\",\n *   params: [1n],\n * });\n * ```\n *\n * Note that this is type safe, the params types will be enforced based on the signature.\n *\n * ### Raw contract call with `resolveMethod`\n *\n * If you don't have the solidity signature of the function you want to call, you can use the `resolveMethod` helper to resolve the method from any deployed contract.\n *\n * Note that this is not type safe, and will also have a 1 time overhead of resolving the contract ABI.\n *\n * ```ts\n * import { getContract, resolveMethod } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { useReadContract } from \"thirdweb/react\";\n *\n * const contract = getContract({\n *   client,\n *   address: \"0x...\",\n *   chain: sepolia,\n * });\n *\n * const { data, isLoading } = useReadContract({\n *   contract,\n *   method: resolveMethod(\"tokenURI\"),\n *   params: [1n],\n * });\n * ```\n */\nexport async function readContract<\n  const TAbi extends Abi,\n  const TMethod extends TAbi extends {\n    length: 0;\n  }\n    ?\n        | AbiFunction\n        | `function ${string}`\n        | ((contract: ThirdwebContract<TAbi>) => Promise<AbiFunction>)\n    : ExtractAbiFunctionNames<TAbi>,\n  const TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n>(\n  options: ReadContractOptions<TAbi, TMethod, TPreparedMethod>,\n): Promise<ReadContractResult<TPreparedMethod[2]>> {\n  type ParsedMethod_ = ParseMethod<TAbi, TMethod>;\n  type PreparedMethod_ = PreparedMethod<ParsedMethod_>;\n  const { contract, method, params } = options;\n\n  const resolvePreparedMethod = async () => {\n    if (Array.isArray(method)) {\n      return method as PreparedMethod_;\n    }\n    if (isAbiFunction(method)) {\n      return prepareMethod(method as ParsedMethod_) as PreparedMethod_;\n    }\n\n    if (typeof method === \"function\") {\n      return prepareMethod(\n        // @ts-expect-error - we're sure it's a function\n        (await method(contract)) as ParsedMethod_,\n      ) as PreparedMethod_;\n    }\n    // if the method starts with the string `function ` we always will want to try to parse it\n    if (typeof method === \"string\" && method.startsWith(\"function \")) {\n      // @ts-expect-error - method *is* string in this case\n      const abiItem = parseAbiItem(method);\n      if (abiItem.type === \"function\") {\n        return prepareMethod(abiItem as ParsedMethod_) as PreparedMethod_;\n      }\n      throw new Error(`\"method\" passed is not of type \"function\"`);\n    }\n    // check if we have a \"abi\" on the contract\n    if (contract.abi && contract.abi?.length > 0) {\n      // extract the abiFunction from it\n      const abiFunction = contract.abi?.find(\n        (item) => item.type === \"function\" && item.name === method,\n      );\n      // if we were able to find it -> return it\n      if (abiFunction) {\n        return prepareMethod(abiFunction as ParsedMethod_) as PreparedMethod_;\n      }\n    }\n    throw new Error(`Could not resolve method \"${method}\".`);\n  };\n\n  // resolve in parallel\n  const [resolvedPreparedMethod, resolvedParams] = await Promise.all([\n    resolvePreparedMethod(),\n    typeof params === \"function\" ? params() : params,\n  ]);\n\n  let encodedData: Hex;\n\n  // if we have no inputs, we know it's just the signature\n  if (resolvedPreparedMethod[1].length === 0) {\n    encodedData = resolvedPreparedMethod[0];\n  } else {\n    // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n    // we can do this because we know the specific formats of the values\n    encodedData = (resolvedPreparedMethod[0] +\n      encodeAbiParameters(\n        resolvedPreparedMethod[1],\n        // @ts-expect-error - TODO: fix this type issue\n        resolvedParams,\n      ).slice(2)) as `${(typeof resolvedPreparedMethod)[0]}${string}`;\n  }\n\n  const rpcRequest = getRpcClient({\n    chain: contract.chain,\n    client: contract.client,\n  });\n\n  const result = await eth_call(rpcRequest, {\n    data: encodedData,\n    from: options.from ? getAddress(options.from) : undefined,\n    to: contract.address,\n  });\n  // use the prepared method to decode the result\n  const decoded = decodeAbiParameters(resolvedPreparedMethod[2], result);\n  if (Array.isArray(decoded) && decoded.length === 1) {\n    return decoded[0];\n  }\n\n  return decoded as ReadContractResult<TPreparedMethod[2]>;\n}\n","import type {\n  BlockTag,\n  EIP1193RequestFn,\n  EIP1474Methods,\n  Hex,\n  RpcStateMapping,\n  RpcStateOverride,\n  RpcTransactionRequest,\n} from \"viem\";\nimport { numberToHex } from \"../../utils/encoding/hex.js\";\n\ntype StateOverride = Record<\n  string,\n  {\n    /**\n     * Fake balance to set for the account before executing the call.\n     */\n    balance?: bigint;\n    /**\n     * Fake nonce to set for the account before executing the call.\n     */\n    nonce?: number;\n    /**\n     * Fake EVM bytecode to inject into the account before executing the call.\n     */\n    code?: Hex;\n    /**\n     * Fake key-value mapping to override **all** slots in the account storage before executing the call.\n     */\n    state?: RpcStateMapping;\n    /**\n     * Fake key-value mapping to override **individual** slots in the account storage before executing the call.\n     */\n    stateDiff?: RpcStateMapping;\n  }\n>;\n\nfunction encodeStateOverrides(overrides: StateOverride): RpcStateOverride {\n  return Object.fromEntries(\n    Object.entries(overrides).map(([address, override]) => {\n      return [\n        address,\n        {\n          balance: override.balance ? numberToHex(override.balance) : undefined,\n          code: override.code,\n          nonce: override.nonce ? numberToHex(override.nonce) : undefined,\n          state: override.state,\n          stateDiff: override.stateDiff,\n        },\n      ];\n    }),\n  );\n}\n\n/**\n * Executes a call or a transaction on the Ethereum network.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for the call or transaction.\n * @returns A promise that resolves to the result of the call or transaction.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_call } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const result = await eth_call(rpcRequest, {\n *  to: \"0x...\",\n *  ...\n * });\n * ```\n */\nexport async function eth_call(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: Partial<RpcTransactionRequest> & {\n    blockNumber?: bigint | number;\n    blockTag?: BlockTag;\n    stateOverrides?: StateOverride;\n  },\n): Promise<Hex> {\n  const { blockNumber, blockTag, ...txRequest } = params;\n  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;\n  // default to \"latest\" if no block is provided\n  const block = blockNumberHex || blockTag || \"latest\";\n\n  return await request({\n    method: \"eth_call\",\n    params: params.stateOverrides\n      ? [\n          txRequest as Partial<RpcTransactionRequest>,\n          block,\n          encodeStateOverrides(params.stateOverrides),\n        ]\n      : [txRequest as Partial<RpcTransactionRequest>, block],\n  });\n}\n"],"names":["ForwardRequest","name","type","ChainAwareForwardRequest","async","relayEngineTransaction","options","message","messageType","signature","_ref","account","serializableTransaction","transaction","gasless","forrwaderContract","getContract","address","relayerForwarderAddress","chain","client","nonce","readContract","contract","method","params","_gasless$domainName","_gasless$domainVersio","to","Error","gas","data","experimentalChainlessSupport","chainid","BigInt","id","from","value","signTypedData","domain","verifyingContract","version","primaryType","types","chainId","domainName","domainVersion","prepareEngineTransaction","response","fetch","relayerUrl","body","stringify","forwarderAddress","request","headers","ok","concat","text","json","result","queueId","endtime","Date","now","receipt","fetchReceipt","transactionHash","Promise","resolve","setTimeout","args","url","split","res","resJson","status","errorMessage","waitForReceipt","sleep","ms","receiptStatuses","formatTransactionReceipt","transactionReceipt","_objectSpread","blockNumber","contractAddress","cumulativeGasUsed","effectiveGasPrice","gasUsed","logs","map","log","eventName","arguments","length","undefined","blockHash","logIndex","Number","transactionIndex","formatLog","hexToNumber","transactionType","blobGasPrice","blobGasUsed","eth_getTransactionReceipt","hash","MAX_POLL_DELAY","DEFAULT_POLL_DELAY","MIN_POLL_DELAY","DEFAULT_OVERPOLL_RATIO","SLIDING_WINDOW_SIZE","createBlockNumberPoller","overPollRatio","onError","lastBlockNumber","lastBlockAt","subscribers","blockTimesWindow","isActive","rpcRequest","getRpcClient","poll","blockNumberHex","hexToBigInt","eth_blockNumber","newBlockNumbers","i","push","currentTime","blockTime","slice","b","subscriberCallback","err","console","error","currentApproximateBlockTime","blockTimes","unshift","reduce","acc","getAverageBlockTime","pollDelay","Math","max","min","callBack","initialBlockNumber","filter","fn","existingPollers","Map","DEFAULT_MAX_BLOCKS_WAIT_TIME","_options$maxBlocksWai","key","maxBlocksWaitTime","has","get","promise","reject","blocksWaited","unwatch","opts","onNewBlockNumber","latestBlockNumber","poller","set","watchBlockNumber","_unused","finally","delete","resolvedPreparedMethod","resolvedParams","all","_contract$abi","Array","isArray","isAbiFunction","prepareMethod","startsWith","abiItem","parseAbiItem","abi","_contract$abi2","abiFunction","find","item","resolvePreparedMethod","encodedData","encodeAbiParameters","blockTag","txRequest","_objectWithoutProperties","_excluded","block","numberToHex","stateOverrides","overrides","Object","fromEntries","entries","override","balance","code","state","stateDiff","eth_call","getAddress","decoded","decodeAbiParameters"],"sourceRoot":""}