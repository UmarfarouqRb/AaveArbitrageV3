{"version":3,"file":"static/js/66101.92d6bff3.chunk.js","mappings":"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","sources":["../node_modules/thirdweb/src/extensions/modules/__generated__/IModularCore/read/getInstalledModules.ts","../node_modules/thirdweb/src/transaction/read-contract.ts","../node_modules/thirdweb/src/rpc/actions/eth_call.ts"],"sourcesContent":["import { decodeAbiParameters } from \"viem\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\n\nexport const FN_SELECTOR = \"0x3e429396\" as const;\nconst FN_INPUTS = [] as const;\nconst FN_OUTPUTS = [\n  {\n    components: [\n      {\n        name: \"implementation\",\n        type: \"address\",\n      },\n      {\n        components: [\n          {\n            name: \"registerInstallationCallback\",\n            type: \"bool\",\n          },\n          {\n            name: \"requiredInterfaces\",\n            type: \"bytes4[]\",\n          },\n          {\n            name: \"supportedInterfaces\",\n            type: \"bytes4[]\",\n          },\n          {\n            components: [\n              {\n                name: \"selector\",\n                type: \"bytes4\",\n              },\n            ],\n            name: \"callbackFunctions\",\n            type: \"tuple[]\",\n          },\n          {\n            components: [\n              {\n                name: \"selector\",\n                type: \"bytes4\",\n              },\n              {\n                name: \"permissionBits\",\n                type: \"uint256\",\n              },\n            ],\n            name: \"fallbackFunctions\",\n            type: \"tuple[]\",\n          },\n        ],\n        name: \"config\",\n        type: \"tuple\",\n      },\n    ],\n    type: \"tuple[]\",\n  },\n] as const;\n\n/**\n * Checks if the `getInstalledModules` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `getInstalledModules` method is supported.\n * @extension MODULES\n * @example\n * ```ts\n * import { isGetInstalledModulesSupported } from \"thirdweb/extensions/modules\";\n * const supported = isGetInstalledModulesSupported([\"0x...\"]);\n * ```\n */\nexport function isGetInstalledModulesSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Decodes the result of the getInstalledModules function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension MODULES\n * @example\n * ```ts\n * import { decodeGetInstalledModulesResult } from \"thirdweb/extensions/modules\";\n * const result = decodeGetInstalledModulesResultResult(\"...\");\n * ```\n */\nexport function decodeGetInstalledModulesResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"getInstalledModules\" function on the contract.\n * @param options - The options for the getInstalledModules function.\n * @returns The parsed result of the function call.\n * @extension MODULES\n * @example\n * ```ts\n * import { getInstalledModules } from \"thirdweb/extensions/modules\";\n *\n * const result = await getInstalledModules({\n *  contract,\n * });\n *\n * ```\n */\nexport async function getInstalledModules(options: BaseTransactionOptions) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [],\n  });\n}\n","import {\n  type Abi,\n  type AbiFunction,\n  type AbiParameter,\n  type AbiParametersToPrimitiveTypes,\n  type ExtractAbiFunctionNames,\n  parseAbiItem,\n} from \"abitype\";\nimport { decodeAbiParameters, type TransactionRequest } from \"viem\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\nimport { eth_call } from \"../rpc/actions/eth_call.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport { encodeAbiParameters } from \"../utils/abi/encodeAbiParameters.js\";\nimport {\n  type PreparedMethod,\n  prepareMethod,\n} from \"../utils/abi/prepare-method.js\";\nimport { getAddress } from \"../utils/address.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\nimport type { PrepareTransactionOptions } from \"./prepare-transaction.js\";\nimport type {\n  BaseTransactionOptions,\n  ParamsOption,\n  ParseMethod,\n} from \"./types.js\";\nimport { isAbiFunction } from \"./utils.js\";\n\nexport type ReadContractResult<outputs extends readonly AbiParameter[]> = // if the outputs are 0 length, return never, invalid case\n  outputs extends { length: 0 }\n    ? never\n    : outputs extends { length: 1 }\n      ? // if the outputs are 1 length, we'll always return the first element\n        AbiParametersToPrimitiveTypes<outputs>[0]\n      : // otherwise we'll return the array\n        AbiParametersToPrimitiveTypes<outputs>;\n\nexport type ReadContractOptions<\n  TAbi extends Abi = [],\n  TMethod extends\n    | AbiFunction\n    | string\n    | ((\n        contract: ThirdwebContract<TAbi>,\n      ) => Promise<AbiFunction>) = TAbi extends { length: 0 }\n    ? AbiFunction | string\n    : ExtractAbiFunctionNames<TAbi>,\n  TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n> = BaseTransactionOptions<\n  Omit<\n    TransactionRequest,\n    | \"from\"\n    | \"to\"\n    | \"data\"\n    | \"value\"\n    | \"accessList\"\n    | \"gas\"\n    | \"gasPrice\"\n    | \"maxFeePerGas\"\n    | \"maxPriorityFeePerGas\"\n    | \"nonce\"\n  > & {\n    method: TMethod | TPreparedMethod;\n    from?: string;\n  } & ParamsOption<TPreparedMethod[1]> &\n    Omit<PrepareTransactionOptions, \"to\" | \"data\" | \"chain\" | \"client\">,\n  TAbi\n>;\n\n/**\n * ### Reads state from a deployed smart contract.\n *\n * Use this for raw read calls from a contract, but you can also use read [extensions](https://portal.thirdweb.com/typescript/v5/extensions/use) for predefined methods for common standards.\n *\n * @param options - The transaction options.\n * @returns A promise that resolves with the result of the read call.\n * @transaction\n * @example\n *\n * ### Raw contract call (recommended)\n *\n * You can read from any contract by using the solidity signature of the function you want to call.\n *\n * ```ts\n * import { getContract } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { useReadContract } from \"thirdweb/react\";\n *\n * const contract = getContract({\n *   client,\n *   address: \"0x...\",\n *   chain: sepolia,\n * });\n *\n * const { data, isLoading } = useReadContract({\n *   contract,\n *   method: \"function tokenURI(uint256 tokenId) returns (string)\",\n *   params: [1n],\n * });\n * ```\n *\n * Note that this is type safe, the params types will be enforced based on the signature.\n *\n * ### Raw contract call with `resolveMethod`\n *\n * If you don't have the solidity signature of the function you want to call, you can use the `resolveMethod` helper to resolve the method from any deployed contract.\n *\n * Note that this is not type safe, and will also have a 1 time overhead of resolving the contract ABI.\n *\n * ```ts\n * import { getContract, resolveMethod } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { useReadContract } from \"thirdweb/react\";\n *\n * const contract = getContract({\n *   client,\n *   address: \"0x...\",\n *   chain: sepolia,\n * });\n *\n * const { data, isLoading } = useReadContract({\n *   contract,\n *   method: resolveMethod(\"tokenURI\"),\n *   params: [1n],\n * });\n * ```\n */\nexport async function readContract<\n  const TAbi extends Abi,\n  const TMethod extends TAbi extends {\n    length: 0;\n  }\n    ?\n        | AbiFunction\n        | `function ${string}`\n        | ((contract: ThirdwebContract<TAbi>) => Promise<AbiFunction>)\n    : ExtractAbiFunctionNames<TAbi>,\n  const TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n>(\n  options: ReadContractOptions<TAbi, TMethod, TPreparedMethod>,\n): Promise<ReadContractResult<TPreparedMethod[2]>> {\n  type ParsedMethod_ = ParseMethod<TAbi, TMethod>;\n  type PreparedMethod_ = PreparedMethod<ParsedMethod_>;\n  const { contract, method, params } = options;\n\n  const resolvePreparedMethod = async () => {\n    if (Array.isArray(method)) {\n      return method as PreparedMethod_;\n    }\n    if (isAbiFunction(method)) {\n      return prepareMethod(method as ParsedMethod_) as PreparedMethod_;\n    }\n\n    if (typeof method === \"function\") {\n      return prepareMethod(\n        // @ts-expect-error - we're sure it's a function\n        (await method(contract)) as ParsedMethod_,\n      ) as PreparedMethod_;\n    }\n    // if the method starts with the string `function ` we always will want to try to parse it\n    if (typeof method === \"string\" && method.startsWith(\"function \")) {\n      // @ts-expect-error - method *is* string in this case\n      const abiItem = parseAbiItem(method);\n      if (abiItem.type === \"function\") {\n        return prepareMethod(abiItem as ParsedMethod_) as PreparedMethod_;\n      }\n      throw new Error(`\"method\" passed is not of type \"function\"`);\n    }\n    // check if we have a \"abi\" on the contract\n    if (contract.abi && contract.abi?.length > 0) {\n      // extract the abiFunction from it\n      const abiFunction = contract.abi?.find(\n        (item) => item.type === \"function\" && item.name === method,\n      );\n      // if we were able to find it -> return it\n      if (abiFunction) {\n        return prepareMethod(abiFunction as ParsedMethod_) as PreparedMethod_;\n      }\n    }\n    throw new Error(`Could not resolve method \"${method}\".`);\n  };\n\n  // resolve in parallel\n  const [resolvedPreparedMethod, resolvedParams] = await Promise.all([\n    resolvePreparedMethod(),\n    typeof params === \"function\" ? params() : params,\n  ]);\n\n  let encodedData: Hex;\n\n  // if we have no inputs, we know it's just the signature\n  if (resolvedPreparedMethod[1].length === 0) {\n    encodedData = resolvedPreparedMethod[0];\n  } else {\n    // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n    // we can do this because we know the specific formats of the values\n    encodedData = (resolvedPreparedMethod[0] +\n      encodeAbiParameters(\n        resolvedPreparedMethod[1],\n        // @ts-expect-error - TODO: fix this type issue\n        resolvedParams,\n      ).slice(2)) as `${(typeof resolvedPreparedMethod)[0]}${string}`;\n  }\n\n  const rpcRequest = getRpcClient({\n    chain: contract.chain,\n    client: contract.client,\n  });\n\n  const result = await eth_call(rpcRequest, {\n    data: encodedData,\n    from: options.from ? getAddress(options.from) : undefined,\n    to: contract.address,\n  });\n  // use the prepared method to decode the result\n  const decoded = decodeAbiParameters(resolvedPreparedMethod[2], result);\n  if (Array.isArray(decoded) && decoded.length === 1) {\n    return decoded[0];\n  }\n\n  return decoded as ReadContractResult<TPreparedMethod[2]>;\n}\n","import type {\n  BlockTag,\n  EIP1193RequestFn,\n  EIP1474Methods,\n  Hex,\n  RpcStateMapping,\n  RpcStateOverride,\n  RpcTransactionRequest,\n} from \"viem\";\nimport { numberToHex } from \"../../utils/encoding/hex.js\";\n\ntype StateOverride = Record<\n  string,\n  {\n    /**\n     * Fake balance to set for the account before executing the call.\n     */\n    balance?: bigint;\n    /**\n     * Fake nonce to set for the account before executing the call.\n     */\n    nonce?: number;\n    /**\n     * Fake EVM bytecode to inject into the account before executing the call.\n     */\n    code?: Hex;\n    /**\n     * Fake key-value mapping to override **all** slots in the account storage before executing the call.\n     */\n    state?: RpcStateMapping;\n    /**\n     * Fake key-value mapping to override **individual** slots in the account storage before executing the call.\n     */\n    stateDiff?: RpcStateMapping;\n  }\n>;\n\nfunction encodeStateOverrides(overrides: StateOverride): RpcStateOverride {\n  return Object.fromEntries(\n    Object.entries(overrides).map(([address, override]) => {\n      return [\n        address,\n        {\n          balance: override.balance ? numberToHex(override.balance) : undefined,\n          code: override.code,\n          nonce: override.nonce ? numberToHex(override.nonce) : undefined,\n          state: override.state,\n          stateDiff: override.stateDiff,\n        },\n      ];\n    }),\n  );\n}\n\n/**\n * Executes a call or a transaction on the Ethereum network.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for the call or transaction.\n * @returns A promise that resolves to the result of the call or transaction.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_call } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const result = await eth_call(rpcRequest, {\n *  to: \"0x...\",\n *  ...\n * });\n * ```\n */\nexport async function eth_call(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: Partial<RpcTransactionRequest> & {\n    blockNumber?: bigint | number;\n    blockTag?: BlockTag;\n    stateOverrides?: StateOverride;\n  },\n): Promise<Hex> {\n  const { blockNumber, blockTag, ...txRequest } = params;\n  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;\n  // default to \"latest\" if no block is provided\n  const block = blockNumberHex || blockTag || \"latest\";\n\n  return await request({\n    method: \"eth_call\",\n    params: params.stateOverrides\n      ? [\n          txRequest as Partial<RpcTransactionRequest>,\n          block,\n          encodeStateOverrides(params.stateOverrides),\n        ]\n      : [txRequest as Partial<RpcTransactionRequest>, block],\n  });\n}\n"],"names":["FN_SELECTOR","FN_INPUTS","FN_OUTPUTS","components","name","type","async","getInstalledModules","options","readContract","contract","method","params","resolvedPreparedMethod","resolvedParams","Promise","all","_contract$abi","Array","isArray","isAbiFunction","prepareMethod","startsWith","abiItem","parseAbiItem","Error","abi","length","_contract$abi2","abiFunction","find","item","concat","resolvePreparedMethod","encodedData","encodeAbiParameters","slice","rpcRequest","getRpcClient","chain","client","result","request","blockNumber","blockTag","txRequest","_objectWithoutProperties","_excluded","block","numberToHex","undefined","stateOverrides","overrides","Object","fromEntries","entries","map","_ref","address","override","balance","code","nonce","state","stateDiff","eth_call","data","from","getAddress","to","decoded","decodeAbiParameters"],"sourceRoot":""}