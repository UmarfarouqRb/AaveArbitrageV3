"use strict";(self.webpackChunkfrontend=self.webpackChunkfrontend||[]).push([[39858],{17477:(n,t,a)=>{a.d(t,{inAppWalletGetCallsStatus:()=>w,inAppWalletSendCalls:()=>b});var s=a(8),e=a(75666),c=a(72364),o=a(30293),r=a(83583);async function i(n){const t=await(0,o.sendTransaction)(n);return(0,r.L)(t)}var l=a(46325),u=a(79002);var d=a(65304),h=a(41940);const f=new d.A(1e3);async function b(n){const{account:t,calls:a}=n,e=a.map(t=>(0,s.A)((0,s.A)({},t),{},{chain:n.chain})),c=[],o=(0,h.O)(65);if(f.set(o,c),t.sendBatchTransaction){const n=await async function(n){const{account:t,transactions:a}=n;if(!t)throw new Error("not connected");if(0===a.length)throw new Error("No transactions to send");const e=a[0];if(!e)throw new Error("No transactions to send");if(t.sendBatchTransaction){const n=await Promise.all(a.map(async n=>{const[t,a,s,e]=await Promise.all([(0,u.encode)(n),(0,l.r)(n.to),(0,l.r)(n.accessList),(0,l.r)(n.value)]);return{accessList:s,chainId:n.chain.id,data:t,to:a,value:e}})),c=await t.sendBatchTransaction(n);return(0,s.A)((0,s.A)({},c),{},{chain:e.chain,client:e.client})}throw new Error("Account doesn't implement sendBatchTransaction")}({account:t,transactions:e});c.push(n.transactionHash),f.set(o,c)}else for(const s of e){const n=await i({account:t,transaction:s});c.push(n.transactionHash),f.set(o,c)}return o}async function w(n){const{chain:t,client:a,id:s}=n,o=f.get(s);if(!o)throw new Error("Failed to get calls status, unknown bundle id");const r=(0,c.getRpcClient)({chain:t,client:a});let i="success";const l=await Promise.all(o.map(n=>(0,e.l)(r,{hash:n}).then(n=>({blockHash:n.blockHash,blockNumber:n.blockNumber,gasUsed:n.gasUsed,logs:n.logs.map(n=>({address:n.address,data:n.data,topics:n.topics})),status:n.status,transactionHash:n.transactionHash})).catch(()=>(i="pending",null))));return{atomic:!1,chainId:t.id,id:s,receipts:l.filter(n=>null!==n),status:i,statusCode:200,version:"2.0.0"}}},30293:(n,t,a)=>{a.r(t),a.d(t,{sendTransaction:()=>r});var s=a(8);let e=null;var c=a(93258),o=a(3672);async function r(n){let{account:t,transaction:r,gasless:i}=n;const l=e;if(l){const{account:n,transaction:a}=await l({account:t,transaction:r});t=n,r=a}if(t.onTransactionRequested&&await t.onTransactionRequested(r),r.eip712){const{sendEip712Transaction:n}=await a.e(12793).then(a.bind(a,12793));return n({account:t,transaction:r})}const u=await(0,o.$)({from:t,transaction:r});if(i){const{sendGaslessTransaction:n}=await a.e(59255).then(a.bind(a,59255));return n({account:t,gasless:i,serializableTransaction:u,transaction:r})}const d=await t.sendTransaction(u);return(0,c.Kj)({address:t.address,chainId:r.chain.id,transactionHash:d.transactionHash}),(0,s.A)((0,s.A)({},d),{},{chain:r.chain,client:r.client})}},75666:(n,t,a)=>{a.d(t,{l:()=>i});var s=a(8),e=a(67962);var c=a(83213);const o={"0x0":"reverted","0x1":"success"};function r(n){const t=(0,s.A)((0,s.A)({},n),{},{blockNumber:n.blockNumber?BigInt(n.blockNumber):null,contractAddress:n.contractAddress?n.contractAddress:null,cumulativeGasUsed:n.cumulativeGasUsed?BigInt(n.cumulativeGasUsed):null,effectiveGasPrice:n.effectiveGasPrice?BigInt(n.effectiveGasPrice):null,gasUsed:n.gasUsed?BigInt(n.gasUsed):null,logs:n.logs?n.logs.map(n=>function(n){let{args:t,eventName:a}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return(0,s.A)((0,s.A)({},n),{},{blockHash:n.blockHash?n.blockHash:null,blockNumber:n.blockNumber?BigInt(n.blockNumber):null,logIndex:n.logIndex?Number(n.logIndex):null,transactionHash:n.transactionHash?n.transactionHash:null,transactionIndex:n.transactionIndex?Number(n.transactionIndex):null},a?{args:t,eventName:a}:{})}(n)):null,to:n.to?n.to:null,transactionIndex:n.transactionIndex?(0,e.ME)(n.transactionIndex):null,status:n.status?o[n.status]:null,type:n.type?c.b4[n.type]||n.type:null});return n.blobGasPrice&&(t.blobGasPrice=BigInt(n.blobGasPrice)),n.blobGasUsed&&(t.blobGasUsed=BigInt(n.blobGasUsed)),t}async function i(n,t){const a=await n({method:"eth_getTransactionReceipt",params:[t.hash]});if(!a)throw new Error("Transaction receipt not found.");return r(a)}},83583:(n,t,a)=>{a.d(t,{L:()=>g});var s=a(75666),e=a(72364),c=a(62600),o=a(3340);const r=5e3,i=1e3,l=500,u=2,d=10;function h(n,t,a,s){let h,f,b=[],w=[],g=!1;const m=(0,e.getRpcClient)({chain:t,client:n});async function p(){if(!g)return;try{const n=await async function(n){const t=await n({method:"eth_blockNumber"});return(0,o.uU)(t)}(m);if(!h||n>h){let t=[];if(h)for(let s=h+1n;s<=n;s++)t.push(BigInt(s));else t=[n];h=n;const a=Date.now();if(f){const n=(a-f)/t.length;w.push(n),w=w.slice(-d)}f=a;for(const n of t)for(const t of b)t(n)}}catch(e){s?s(e):console.error("[watchBlockNumber]: Failed to poll for latest block number: ".concat(e))}const n=function(n){for(;n.length<d;)n.unshift(i);return n.reduce((n,t)=>n+t,0)/n.length}(w),t=Math.max(l,Math.min(r,Math.max(l,n)));await(0,c.y)(t/(null!==a&&void 0!==a?a:u)),p()}return function(n,t){return b.push(n),g||(h=t,g=!0,p()),function(){b=b.filter(t=>t!==n),0===b.length&&(h=void 0,f=void 0,g=!1)}}}const f=new Map;const b=100,w=new Map;function g(n){var t;const{transactionHash:a,chain:c,client:o}=n,r=c.id,i="".concat(r,":tx_").concat(a),l=null!==(t=n.maxBlocksWaitTime)&&void 0!==t?t:b;if(w.has(i))return w.get(i);const u=new Promise((n,t)=>{a||t(new Error("Transaction has no transactionHash to wait for, did you execute it?"));const r=(0,e.getRpcClient)({chain:c,client:o});let i=-1;const u=function(n){const{client:t,chain:a,onNewBlockNumber:s,overPollRatio:e,latestBlockNumber:c,onError:o}=n,r=a.id;let i=f.get(r);return i||(i=h(t,a,e,o),f.set(r,i)),i(s,c)}({chain:c,client:o,onNewBlockNumber:async()=>{if(i++,i>=l)return u(),void t(new Error("Transaction receipt for ".concat(a," not found after ").concat(l," blocks")));try{const t=await(0,s.l)(r,{hash:a});u(),n(t)}catch(e){}}})}).finally(()=>{w.delete(i)});return w.set(i,u),u}},93258:(n,t,a)=>{function s(n){const t=new Set;let a=n;return{getValue:()=>a,setValue(n){n!==a&&(a=n,(()=>{for(const n of t)n()})())},subscribe:n=>(t.add(n),()=>{t.delete(n)})}}a.d(t,{Kj:()=>c});const e=new Map;function c(n){const{address:t,transactionHash:a,chainId:c}=n,o=function(n){const t=e.get(n);if(t)return t;const a=s([]);return e.set(n,a),a}(t);o.setValue([...o.getValue(),{chainId:c,transactionHash:a}]),e.set(t,o)}}}]);
//# sourceMappingURL=39858.ace68b31.chunk.js.map