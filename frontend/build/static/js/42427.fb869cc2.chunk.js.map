{"version":3,"file":"static/js/42427.fb869cc2.chunk.js","mappings":"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","sources":["../node_modules/thirdweb/src/rpc/actions/eth_getStorageAt.ts","../node_modules/thirdweb/src/utils/bytecode/resolveImplementation.ts","../node_modules/thirdweb/src/utils/bytecode/extractMinimalProxyImplementationAddress.ts","../node_modules/thirdweb/src/transaction/read-contract.ts","../node_modules/thirdweb/src/rpc/actions/eth_call.ts"],"sourcesContent":["import type { BlockTag, EIP1193RequestFn, EIP1474Methods, Hex } from \"viem\";\nimport { getAddress } from \"../../utils/address.js\";\n\ntype GetStorageAtParams = {\n  address: string;\n  position: Hex;\n  blockTag?: BlockTag;\n};\n\n/**\n * Retrieves the value stored at a specific position in the storage of a contract.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for the eth_getStorageAt method.\n * @returns A promise that resolves to the value stored at the specified position.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_getStorageAt } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const storageValue = await eth_getStorageAt(rpcRequest, {\n * address: \"0x...\",\n *  position: 0n,\n * });\n * ```\n */\nexport async function eth_getStorageAt(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: GetStorageAtParams,\n): Promise<Hex> {\n  return await request({\n    method: \"eth_getStorageAt\",\n    params: [\n      getAddress(params.address),\n      params.position,\n      params.blockTag ?? \"latest\",\n    ],\n  });\n}\n","import { getBytecode } from \"../../contract/actions/get-bytecode.js\";\nimport { getContract, type ThirdwebContract } from \"../../contract/contract.js\";\nimport { eth_getStorageAt } from \"../../rpc/actions/eth_getStorageAt.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { readContract } from \"../../transaction/read-contract.js\";\nimport { isAddress } from \"../address.js\";\nimport type { Hex } from \"../encoding/hex.js\";\nimport { extractMinimalProxyImplementationAddress } from \"./extractMinimalProxyImplementationAddress.js\";\n\n// TODO: move to const exports\nconst AddressZero = \"0x0000000000000000000000000000000000000000\";\nconst ZERO_BYTES32 =\n  \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n\n/**\n * Resolves the implementation address and bytecode for a given proxy contract.\n * @param contract The contract to resolve the implementation for.\n * @returns A promise that resolves to an object containing the implementation address and bytecode.\n * @example\n * ```ts\n * import { resolveImplementation } from \"thirdweb/utils\";\n * const implementation = await resolveImplementation(contract);\n * ```\n * @contract\n */\nexport async function resolveImplementation(\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  contract: ThirdwebContract<any>,\n): Promise<{ address: string; bytecode: Hex }> {\n  const [originalBytecode, beacon] = await Promise.all([\n    getBytecode(contract),\n    getBeaconFromStorageSlot(contract),\n  ]);\n  // check minimal proxy first synchronously\n  const minimalProxyImplementationAddress =\n    extractMinimalProxyImplementationAddress(originalBytecode);\n  if (minimalProxyImplementationAddress) {\n    return {\n      address: minimalProxyImplementationAddress,\n      bytecode: await getBytecode(\n        getContract({\n          ...contract,\n          address: minimalProxyImplementationAddress,\n        }),\n      ),\n    };\n  }\n\n  // check other proxy types\n  let implementationAddress: string | undefined;\n\n  if (beacon && beacon !== AddressZero) {\n    // In case of a BeaconProxy, it is setup as BeaconProxy --> Beacon --> Implementation\n    // Hence we replace the proxy address with Beacon address, and continue further resolving below\n    contract = getContract({\n      ...contract,\n      address: beacon,\n    });\n\n    implementationAddress = await getImplementationFromContractCall(contract);\n  } else {\n    implementationAddress = await getImplementationFromStorageSlot(contract);\n  }\n\n  if (\n    implementationAddress &&\n    isAddress(implementationAddress) &&\n    implementationAddress !== AddressZero\n  ) {\n    const implementationBytecode = await getBytecode({\n      ...contract,\n      address: implementationAddress,\n    });\n    // return the original contract bytecode if the implementation bytecode is empty\n    if (implementationBytecode === \"0x\") {\n      return {\n        address: contract.address,\n        bytecode: originalBytecode,\n      };\n    }\n\n    return {\n      address: implementationAddress,\n      bytecode: implementationBytecode,\n    };\n  }\n\n  return { address: contract.address, bytecode: originalBytecode };\n}\n\nasync function getBeaconFromStorageSlot(\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  contract: ThirdwebContract<any>,\n): Promise<string | undefined> {\n  /**\n   * The storage slot of the Beacon as defined in EIP-1967\n   * See https://eips.ethereum.org/EIPS/eip-1967#beacon-contract-address\n   *\n   * bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1))\n   */\n  const rpcRequest = getRpcClient({\n    chain: contract.chain,\n    client: contract.client,\n  });\n\n  try {\n    const proxyStorage = await eth_getStorageAt(rpcRequest, {\n      address: contract.address,\n      position:\n        \"0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50\",\n    });\n    if (proxyStorage.length >= 40) {\n      return `0x${proxyStorage.slice(-40)}`;\n    }\n    return undefined;\n  } catch {\n    return undefined;\n  }\n}\n\nasync function getImplementationFromStorageSlot(\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  contract: ThirdwebContract<any>,\n): Promise<string | undefined> {\n  const rpcRequest = getRpcClient({\n    chain: contract.chain,\n    client: contract.client,\n  });\n\n  try {\n    const proxyStoragePromises = [\n      eth_getStorageAt(rpcRequest, {\n        address: contract.address,\n        position:\n          \"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\",\n      }),\n      eth_getStorageAt(rpcRequest, {\n        address: contract.address,\n        position:\n          // keccak256(\"matic.network.proxy.implementation\") - used in polygon USDT proxy: https://polygonscan.com/address/0xc2132d05d31c914a87c6611c10748aeb04b58e8f#code\n          \"0xbaab7dbf64751104133af04abc7d9979f0fda3b059a322a8333f533d3f32bf7f\",\n      }),\n      eth_getStorageAt(rpcRequest, {\n        address: contract.address,\n        position:\n          // keccak256(\"org.zeppelinos.proxy.implementation\") - e.g. base USDC proxy: https://basescan.org/address/0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913#code\n          \"0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3\",\n      }),\n    ];\n\n    const proxyStorages = await Promise.all(proxyStoragePromises);\n    const proxyStorage = proxyStorages.find(\n      (storage) => storage !== ZERO_BYTES32,\n    );\n\n    return proxyStorage ? `0x${proxyStorage.slice(-40)}` : AddressZero;\n  } catch {\n    return undefined;\n  }\n}\n\nconst UPGRADEABLE_PROXY_ABI = {\n  inputs: [],\n  name: \"implementation\",\n  outputs: [\n    {\n      internalType: \"address\",\n      name: \"\",\n      type: \"address\",\n    },\n  ],\n  stateMutability: \"view\",\n  type: \"function\",\n} as const;\n\nasync function getImplementationFromContractCall(\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  contract: ThirdwebContract<any>,\n): Promise<string | undefined> {\n  try {\n    return await readContract({ contract, method: UPGRADEABLE_PROXY_ABI });\n  } catch {\n    return undefined;\n  }\n}\n","/**\n * Extracts the implementation address from a given bytecode string if it matches any of the known minimal proxy patterns.\n * @param bytecode The bytecode string to extract the implementation address from.\n * @returns The implementation address as a string if a match is found, otherwise undefined.\n * @example\n * ```ts\n * import { extractMinimalProxyImplementationAddress } from \"thirdweb/utils\";\n * const bytecode = \"0x363d3d373d3d3d363d73...\";\n * const implementationAddress = extractMinimalProxyImplementationAddress(bytecode);\n * ```\n * @utils\n */\nexport function extractMinimalProxyImplementationAddress(\n  bytecode: string,\n): string | undefined {\n  if (!bytecode.startsWith(\"0x\")) {\n    bytecode = `0x${bytecode}`;\n  }\n  // EIP-1167 clone minimal proxy - https://eips.ethereum.org/EIPS/eip-1167\n  if (bytecode.startsWith(\"0x363d3d373d3d3d363d73\")) {\n    const implementationAddress = bytecode.slice(22, 62);\n    return `0x${implementationAddress}`;\n  }\n\n  // Minimal Proxy with receive() from 0xSplits - https://github.com/0xSplits/splits-contracts/blob/c7b741926ec9746182d0d1e2c4c2046102e5d337/contracts/libraries/Clones.sol\n  if (bytecode.startsWith(\"0x36603057343d5230\")) {\n    // +40 = size of addr\n    const implementationAddress = bytecode.slice(122, 122 + 40);\n    return `0x${implementationAddress}`;\n  }\n\n  // 0age's minimal proxy - https://medium.com/coinmonks/the-more-minimal-proxy-5756ae08ee48\n  if (bytecode.startsWith(\"0x3d3d3d3d363d3d37363d73\")) {\n    // +40 = size of addr\n    const implementationAddress = bytecode.slice(24, 24 + 40);\n    return `0x${implementationAddress}`;\n  }\n\n  // vyper's minimal proxy (uniswap v1) - https://etherscan.io/address/0x09cabec1ead1c0ba254b09efb3ee13841712be14#code\n  if (bytecode.startsWith(\"0x366000600037611000600036600073\")) {\n    const implementationAddress = bytecode.slice(32, 32 + 40);\n    return `0x${implementationAddress}`;\n  }\n\n  if (bytecode.startsWith(\"0x36600080376020600036600073\")) {\n    const implementationAddress = bytecode.slice(28, 28 + 40);\n    return `0x${implementationAddress}`;\n  }\n\n  // EIP-7511 minimal proxy with PUSH0 opcode - https://eips.ethereum.org/EIPS/eip-7511\n  if (bytecode.startsWith(\"0x365f5f375f5f365f73\")) {\n    const implementationAddress = bytecode.slice(20, 60);\n    return `0x${implementationAddress}`;\n  }\n\n  // EIP-7702 - https://eips.ethereum.org/EIPS/eip-7702#abstract\n  if (bytecode.length === 48 && bytecode.startsWith(\"0xef0100\")) {\n    const implementationAddress = bytecode.slice(8, 48);\n    return `0x${implementationAddress}`;\n  }\n\n  return undefined;\n}\n","import {\n  type Abi,\n  type AbiFunction,\n  type AbiParameter,\n  type AbiParametersToPrimitiveTypes,\n  type ExtractAbiFunctionNames,\n  parseAbiItem,\n} from \"abitype\";\nimport { decodeAbiParameters, type TransactionRequest } from \"viem\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\nimport { eth_call } from \"../rpc/actions/eth_call.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport { encodeAbiParameters } from \"../utils/abi/encodeAbiParameters.js\";\nimport {\n  type PreparedMethod,\n  prepareMethod,\n} from \"../utils/abi/prepare-method.js\";\nimport { getAddress } from \"../utils/address.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\nimport type { PrepareTransactionOptions } from \"./prepare-transaction.js\";\nimport type {\n  BaseTransactionOptions,\n  ParamsOption,\n  ParseMethod,\n} from \"./types.js\";\nimport { isAbiFunction } from \"./utils.js\";\n\nexport type ReadContractResult<outputs extends readonly AbiParameter[]> = // if the outputs are 0 length, return never, invalid case\n  outputs extends { length: 0 }\n    ? never\n    : outputs extends { length: 1 }\n      ? // if the outputs are 1 length, we'll always return the first element\n        AbiParametersToPrimitiveTypes<outputs>[0]\n      : // otherwise we'll return the array\n        AbiParametersToPrimitiveTypes<outputs>;\n\nexport type ReadContractOptions<\n  TAbi extends Abi = [],\n  TMethod extends\n    | AbiFunction\n    | string\n    | ((\n        contract: ThirdwebContract<TAbi>,\n      ) => Promise<AbiFunction>) = TAbi extends { length: 0 }\n    ? AbiFunction | string\n    : ExtractAbiFunctionNames<TAbi>,\n  TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n> = BaseTransactionOptions<\n  Omit<\n    TransactionRequest,\n    | \"from\"\n    | \"to\"\n    | \"data\"\n    | \"value\"\n    | \"accessList\"\n    | \"gas\"\n    | \"gasPrice\"\n    | \"maxFeePerGas\"\n    | \"maxPriorityFeePerGas\"\n    | \"nonce\"\n  > & {\n    method: TMethod | TPreparedMethod;\n    from?: string;\n  } & ParamsOption<TPreparedMethod[1]> &\n    Omit<PrepareTransactionOptions, \"to\" | \"data\" | \"chain\" | \"client\">,\n  TAbi\n>;\n\n/**\n * ### Reads state from a deployed smart contract.\n *\n * Use this for raw read calls from a contract, but you can also use read [extensions](https://portal.thirdweb.com/typescript/v5/extensions/use) for predefined methods for common standards.\n *\n * @param options - The transaction options.\n * @returns A promise that resolves with the result of the read call.\n * @transaction\n * @example\n *\n * ### Raw contract call (recommended)\n *\n * You can read from any contract by using the solidity signature of the function you want to call.\n *\n * ```ts\n * import { getContract } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { useReadContract } from \"thirdweb/react\";\n *\n * const contract = getContract({\n *   client,\n *   address: \"0x...\",\n *   chain: sepolia,\n * });\n *\n * const { data, isLoading } = useReadContract({\n *   contract,\n *   method: \"function tokenURI(uint256 tokenId) returns (string)\",\n *   params: [1n],\n * });\n * ```\n *\n * Note that this is type safe, the params types will be enforced based on the signature.\n *\n * ### Raw contract call with `resolveMethod`\n *\n * If you don't have the solidity signature of the function you want to call, you can use the `resolveMethod` helper to resolve the method from any deployed contract.\n *\n * Note that this is not type safe, and will also have a 1 time overhead of resolving the contract ABI.\n *\n * ```ts\n * import { getContract, resolveMethod } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { useReadContract } from \"thirdweb/react\";\n *\n * const contract = getContract({\n *   client,\n *   address: \"0x...\",\n *   chain: sepolia,\n * });\n *\n * const { data, isLoading } = useReadContract({\n *   contract,\n *   method: resolveMethod(\"tokenURI\"),\n *   params: [1n],\n * });\n * ```\n */\nexport async function readContract<\n  const TAbi extends Abi,\n  const TMethod extends TAbi extends {\n    length: 0;\n  }\n    ?\n        | AbiFunction\n        | `function ${string}`\n        | ((contract: ThirdwebContract<TAbi>) => Promise<AbiFunction>)\n    : ExtractAbiFunctionNames<TAbi>,\n  const TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n>(\n  options: ReadContractOptions<TAbi, TMethod, TPreparedMethod>,\n): Promise<ReadContractResult<TPreparedMethod[2]>> {\n  type ParsedMethod_ = ParseMethod<TAbi, TMethod>;\n  type PreparedMethod_ = PreparedMethod<ParsedMethod_>;\n  const { contract, method, params } = options;\n\n  const resolvePreparedMethod = async () => {\n    if (Array.isArray(method)) {\n      return method as PreparedMethod_;\n    }\n    if (isAbiFunction(method)) {\n      return prepareMethod(method as ParsedMethod_) as PreparedMethod_;\n    }\n\n    if (typeof method === \"function\") {\n      return prepareMethod(\n        // @ts-expect-error - we're sure it's a function\n        (await method(contract)) as ParsedMethod_,\n      ) as PreparedMethod_;\n    }\n    // if the method starts with the string `function ` we always will want to try to parse it\n    if (typeof method === \"string\" && method.startsWith(\"function \")) {\n      // @ts-expect-error - method *is* string in this case\n      const abiItem = parseAbiItem(method);\n      if (abiItem.type === \"function\") {\n        return prepareMethod(abiItem as ParsedMethod_) as PreparedMethod_;\n      }\n      throw new Error(`\"method\" passed is not of type \"function\"`);\n    }\n    // check if we have a \"abi\" on the contract\n    if (contract.abi && contract.abi?.length > 0) {\n      // extract the abiFunction from it\n      const abiFunction = contract.abi?.find(\n        (item) => item.type === \"function\" && item.name === method,\n      );\n      // if we were able to find it -> return it\n      if (abiFunction) {\n        return prepareMethod(abiFunction as ParsedMethod_) as PreparedMethod_;\n      }\n    }\n    throw new Error(`Could not resolve method \"${method}\".`);\n  };\n\n  // resolve in parallel\n  const [resolvedPreparedMethod, resolvedParams] = await Promise.all([\n    resolvePreparedMethod(),\n    typeof params === \"function\" ? params() : params,\n  ]);\n\n  let encodedData: Hex;\n\n  // if we have no inputs, we know it's just the signature\n  if (resolvedPreparedMethod[1].length === 0) {\n    encodedData = resolvedPreparedMethod[0];\n  } else {\n    // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n    // we can do this because we know the specific formats of the values\n    encodedData = (resolvedPreparedMethod[0] +\n      encodeAbiParameters(\n        resolvedPreparedMethod[1],\n        // @ts-expect-error - TODO: fix this type issue\n        resolvedParams,\n      ).slice(2)) as `${(typeof resolvedPreparedMethod)[0]}${string}`;\n  }\n\n  const rpcRequest = getRpcClient({\n    chain: contract.chain,\n    client: contract.client,\n  });\n\n  const result = await eth_call(rpcRequest, {\n    data: encodedData,\n    from: options.from ? getAddress(options.from) : undefined,\n    to: contract.address,\n  });\n  // use the prepared method to decode the result\n  const decoded = decodeAbiParameters(resolvedPreparedMethod[2], result);\n  if (Array.isArray(decoded) && decoded.length === 1) {\n    return decoded[0];\n  }\n\n  return decoded as ReadContractResult<TPreparedMethod[2]>;\n}\n","import type {\n  BlockTag,\n  EIP1193RequestFn,\n  EIP1474Methods,\n  Hex,\n  RpcStateMapping,\n  RpcStateOverride,\n  RpcTransactionRequest,\n} from \"viem\";\nimport { numberToHex } from \"../../utils/encoding/hex.js\";\n\ntype StateOverride = Record<\n  string,\n  {\n    /**\n     * Fake balance to set for the account before executing the call.\n     */\n    balance?: bigint;\n    /**\n     * Fake nonce to set for the account before executing the call.\n     */\n    nonce?: number;\n    /**\n     * Fake EVM bytecode to inject into the account before executing the call.\n     */\n    code?: Hex;\n    /**\n     * Fake key-value mapping to override **all** slots in the account storage before executing the call.\n     */\n    state?: RpcStateMapping;\n    /**\n     * Fake key-value mapping to override **individual** slots in the account storage before executing the call.\n     */\n    stateDiff?: RpcStateMapping;\n  }\n>;\n\nfunction encodeStateOverrides(overrides: StateOverride): RpcStateOverride {\n  return Object.fromEntries(\n    Object.entries(overrides).map(([address, override]) => {\n      return [\n        address,\n        {\n          balance: override.balance ? numberToHex(override.balance) : undefined,\n          code: override.code,\n          nonce: override.nonce ? numberToHex(override.nonce) : undefined,\n          state: override.state,\n          stateDiff: override.stateDiff,\n        },\n      ];\n    }),\n  );\n}\n\n/**\n * Executes a call or a transaction on the Ethereum network.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for the call or transaction.\n * @returns A promise that resolves to the result of the call or transaction.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_call } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const result = await eth_call(rpcRequest, {\n *  to: \"0x...\",\n *  ...\n * });\n * ```\n */\nexport async function eth_call(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: Partial<RpcTransactionRequest> & {\n    blockNumber?: bigint | number;\n    blockTag?: BlockTag;\n    stateOverrides?: StateOverride;\n  },\n): Promise<Hex> {\n  const { blockNumber, blockTag, ...txRequest } = params;\n  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;\n  // default to \"latest\" if no block is provided\n  const block = blockNumberHex || blockTag || \"latest\";\n\n  return await request({\n    method: \"eth_call\",\n    params: params.stateOverrides\n      ? [\n          txRequest as Partial<RpcTransactionRequest>,\n          block,\n          encodeStateOverrides(params.stateOverrides),\n        ]\n      : [txRequest as Partial<RpcTransactionRequest>, block],\n  });\n}\n"],"names":["async","eth_getStorageAt","request","params","_params$blockTag","method","getAddress","address","position","blockTag","AddressZero","ZERO_BYTES32","resolveImplementation","contract","originalBytecode","beacon","Promise","all","getBytecode","getBeaconFromStorageSlot","minimalProxyImplementationAddress","bytecode","startsWith","concat","implementationAddress","slice","length","extractMinimalProxyImplementationAddress","getContract","_objectSpread","readContract","UPGRADEABLE_PROXY_ABI","_unused3","getImplementationFromContractCall","rpcRequest","getRpcClient","chain","client","proxyStoragePromises","proxyStorage","find","storage","_unused2","getImplementationFromStorageSlot","isAddress","implementationBytecode","_unused","inputs","name","outputs","internalType","type","stateMutability","options","resolvedPreparedMethod","resolvedParams","_contract$abi","Array","isArray","isAbiFunction","prepareMethod","abiItem","parseAbiItem","Error","abi","_contract$abi2","abiFunction","item","resolvePreparedMethod","encodedData","encodeAbiParameters","result","blockNumber","txRequest","_objectWithoutProperties","_excluded","block","numberToHex","undefined","stateOverrides","overrides","Object","fromEntries","entries","map","_ref","override","balance","code","nonce","state","stateDiff","eth_call","data","from","to","decoded","decodeAbiParameters"],"sourceRoot":""}