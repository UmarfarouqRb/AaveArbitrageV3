{"version":3,"file":"static/js/99832.5f201f85.chunk.js","mappings":"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","sources":["../node_modules/thirdweb/src/constants/addresses.ts","../node_modules/thirdweb/src/utils/config.ts","../node_modules/thirdweb/src/transaction/actions/send-transaction.ts","../node_modules/thirdweb/src/transaction/read-contract.ts","../node_modules/thirdweb/src/rpc/actions/eth_call.ts","../node_modules/thirdweb/src/wallets/smart/lib/calls.ts","../node_modules/thirdweb/src/reactive/store.ts","../node_modules/thirdweb/src/transaction/transaction-store.ts","../node_modules/thirdweb/src/extensions/erc20/__generated__/IERC20/read/allowance.ts","../node_modules/thirdweb/src/extensions/erc20/__generated__/IERC20/write/approve.ts","../node_modules/thirdweb/src/extensions/erc20/write/approve.ts","../node_modules/thirdweb/src/extensions/erc4337/__generated__/IAccountPermissions/read/getPermissionsForSigner.ts","../node_modules/thirdweb/src/extensions/erc4337/__generated__/IAccountPermissions/write/setPermissionsForSigner.ts","../node_modules/thirdweb/src/utils/date.ts","../node_modules/thirdweb/src/extensions/erc4337/account/types.ts","../node_modules/thirdweb/src/extensions/erc4337/account/common.ts","../node_modules/thirdweb/src/extensions/erc4337/account/addSessionKey.ts","../node_modules/thirdweb/src/utils/types.ts","../node_modules/thirdweb/src/extensions/erc4337/__generated__/IEntryPoint/read/getNonce.ts","../node_modules/thirdweb/src/extensions/erc4337/__generated__/IEntryPoint/read/getUserOpHash.ts","../node_modules/thirdweb/src/extensions/erc4337/__generated__/IEntryPoint_v07/read/getUserOpHash.ts","../node_modules/thirdweb/src/wallets/smart/lib/packUserOp.ts","../node_modules/thirdweb/src/wallets/smart/lib/paymaster.ts","../node_modules/thirdweb/src/wallets/smart/lib/userop.ts","../node_modules/thirdweb/src/wallets/smart/index.ts"],"sourcesContent":["/**\n * The address of the native token.\n */\nexport const NATIVE_TOKEN_ADDRESS =\n  \"0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\";\n\n/**\n * @internal\n */\nexport function isNativeTokenAddress(address: string) {\n  return address.toLowerCase() === NATIVE_TOKEN_ADDRESS;\n}\n\n/**\n * The zero address in Ethereum, represented as a hexadecimal string.\n */\nexport const ZERO_ADDRESS = \"0x0000000000000000000000000000000000000000\";\n","import type { PreparedTransaction } from \"../transaction/prepare-transaction.js\";\nimport type { Account } from \"../wallets/interfaces/wallet.js\";\n\nlet transactionDecorator:\n  | ((args: {\n      account: Account;\n      transaction: PreparedTransaction;\n    }) => Promise<{ account: Account; transaction: PreparedTransaction }>)\n  | null = null;\n\n/**\n * @internal\n */\nexport function setTransactionDecorator(\n  decoratorFunction: (args: {\n    account: Account;\n    transaction: PreparedTransaction;\n  }) => Promise<{ account: Account; transaction: PreparedTransaction }>,\n) {\n  transactionDecorator = decoratorFunction;\n}\n\n/**\n * @internal\n */\nexport function clearTransactionDecorator() {\n  transactionDecorator = null;\n}\n\n/**\n * @internal\n */\nexport function getTransactionDecorator() {\n  return transactionDecorator;\n}\n","import { getTransactionDecorator } from \"../../utils/config.js\";\nimport type { Account } from \"../../wallets/interfaces/wallet.js\";\nimport type { PreparedTransaction } from \"../prepare-transaction.js\";\nimport { addTransactionToStore } from \"../transaction-store.js\";\nimport type { GaslessOptions } from \"./gasless/types.js\";\nimport { toSerializableTransaction } from \"./to-serializable-transaction.js\";\nimport type { WaitForReceiptOptions } from \"./wait-for-tx-receipt.js\";\n\n/** Send transaction options */\nexport interface SendTransactionOptions {\n  /**\n   * The account to send the transaction with\n   */\n  account: Account;\n  /**\n   * The prepared transaction to send\n   */\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any prepared transaction type\n  transaction: PreparedTransaction<any>;\n  /**\n   * Gasless options for the transaction, if applicable\n   */\n  gasless?: GaslessOptions;\n}\n\n/**\n * Sends a transaction using the provided account.\n *\n * You can send a transaction with a [prepared contract call](https://portal.thirdweb.com/references/typescript/v5/prepareContractCall), a [prepared transaction](https://portal.thirdweb.com/references/typescript/v5/prepareTransaction), or using a write [Extension](https://portal.thirdweb.com/typescript/v5/extensions/use).\n * @param options - The options for sending the transaction.\n * @returns A promise that resolves to the transaction result.\n * @throws An error if the transaction reverts.\n * @transaction\n * @example\n *\n * ### Using a prepared contract call\n *\n * ```ts\n * import { sendTransaction, getContract, prepareContractCall } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n *\n * const contract = getContract({\n *   address: \"0x...\",\n *   chain: sepolia,\n *   client,\n * });\n *\n * const transaction = prepareContractCall({\n *   contract,\n *   method: \"function transfer(address to, uint256 value)\",\n *   params: [to, value],\n * });\n *\n * const { transactionHash } = await sendTransaction({\n *  account,\n *  transaction,\n * });\n * ```\n *\n * ### Using a write extension\n *\n * ```ts\n * import { sendTransaction, getContract } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { mintTo } from \"thirdweb/extensions/erc721\";\n *\n * const contract = getContract({\n *   address: \"0x...\",\n *   chain: sepolia,\n *   client,\n * });\n *\n * const transaction = mintTo({\n *   contract,\n *   to: \"0x...\",\n *   nft: {\n *     name: \"NFT Name\",\n *     description: \"NFT Description\",\n *     image: \"https://example.com/image.png\",\n *   },\n * });\n *\n * const { transactionHash } = await sendTransaction({\n *  account,\n *  transaction,\n * });\n * ```\n *\n * ### Using a prepared transaction\n *\n * ```ts\n * import { sendTransaction, getContract, prepareTransaction } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n *\n * const contract = getContract({\n *   address: \"0x...\",\n *   chain: sepolia,\n *   client,\n * });\n *\n * const transaction = prepareTransaction({\n *   contract,\n *   to: \"0x...\",\n *   value: toWei(\"0.1\"),\n * });\n *\n * const { transactionHash } = await sendTransaction({\n *  account,\n *  transaction,\n * });\n * ```\n *\n * ### Send an EIP-7702 Transaction\n *\n * **Note: This feature is in beta and is subject to breaking changes**\n *\n * ```ts\n * import { sendTransaction, prepareTransaction, signAuthorization } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n *\n * const authorization = await signAuthorization({\n *   request: {\n *     address: \"0x...\",\n *     chainId: 1,\n *     nonce: 0n,\n *   },\n *   account: myAccount,\n * });\n *\n * const transaction = prepareTransaction({\n *   chain: sepolia,\n *   client: client,\n *   to: \"0x...\",\n *   value: 0n,\n *   authorizationList: [authorization],\n * });\n *\n * const { transactionHash } = await sendTransaction({\n *  account,\n *  transaction,\n * });\n * ```\n *\n * ### Gasless usage with [thirdweb Engine](https://portal.thirdweb.com/engine)\n * ```ts\n * const { transactionHash } = await sendTransaction({\n *  account,\n *  transaction,\n *  gasless: {\n *    provider: \"engine\",\n *    relayerUrl: \"https://thirdweb.engine-***.thirdweb.com/relayer/***\",\n *    relayerForwarderAddress: \"0x...\",\n *  }\n * });\n * ```\n *\n * ### Gasless usage with OpenZeppelin\n * ```ts\n * const { transactionHash } = await sendTransaction({\n *  account,\n *  transaction,\n *  gasless: {\n *    provider: \"openzeppelin\",\n *    relayerUrl: \"https://...\",\n *    relayerForwarderAddress: \"0x...\",\n *  }\n * });\n * ```\n */\nexport async function sendTransaction(\n  options: SendTransactionOptions,\n): Promise<WaitForReceiptOptions> {\n  let { account, transaction, gasless } = options;\n\n  const decorator = getTransactionDecorator();\n  if (decorator) {\n    const { account: decoratedAccount, transaction: decoratedTransaction } =\n      await decorator({ account, transaction });\n    account = decoratedAccount;\n    transaction = decoratedTransaction;\n  }\n\n  if (account.onTransactionRequested) {\n    await account.onTransactionRequested(transaction);\n  }\n\n  // if zksync transaction params are set, send with eip712\n  if (transaction.eip712) {\n    const { sendEip712Transaction } = await import(\n      \"./zksync/send-eip712-transaction.js\"\n    );\n    return sendEip712Transaction({\n      account,\n      transaction,\n    });\n  }\n\n  const serializableTransaction = await toSerializableTransaction({\n    from: account,\n    transaction: transaction,\n  });\n  // branch for gasless transactions\n  if (gasless) {\n    // lazy load the gasless tx function because it's only needed for gasless transactions\n    const { sendGaslessTransaction } = await import(\n      \"./gasless/send-gasless-transaction.js\"\n    );\n    return sendGaslessTransaction({\n      account,\n      gasless,\n      serializableTransaction,\n      transaction,\n    });\n  }\n\n  const result = await account.sendTransaction(serializableTransaction);\n  // Store the transaction\n  addTransactionToStore({\n    address: account.address,\n    chainId: transaction.chain.id,\n    transactionHash: result.transactionHash,\n  });\n  return { ...result, chain: transaction.chain, client: transaction.client };\n}\n","import {\n  type Abi,\n  type AbiFunction,\n  type AbiParameter,\n  type AbiParametersToPrimitiveTypes,\n  type ExtractAbiFunctionNames,\n  parseAbiItem,\n} from \"abitype\";\nimport { decodeAbiParameters, type TransactionRequest } from \"viem\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\nimport { eth_call } from \"../rpc/actions/eth_call.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport { encodeAbiParameters } from \"../utils/abi/encodeAbiParameters.js\";\nimport {\n  type PreparedMethod,\n  prepareMethod,\n} from \"../utils/abi/prepare-method.js\";\nimport { getAddress } from \"../utils/address.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\nimport type { PrepareTransactionOptions } from \"./prepare-transaction.js\";\nimport type {\n  BaseTransactionOptions,\n  ParamsOption,\n  ParseMethod,\n} from \"./types.js\";\nimport { isAbiFunction } from \"./utils.js\";\n\nexport type ReadContractResult<outputs extends readonly AbiParameter[]> = // if the outputs are 0 length, return never, invalid case\n  outputs extends { length: 0 }\n    ? never\n    : outputs extends { length: 1 }\n      ? // if the outputs are 1 length, we'll always return the first element\n        AbiParametersToPrimitiveTypes<outputs>[0]\n      : // otherwise we'll return the array\n        AbiParametersToPrimitiveTypes<outputs>;\n\nexport type ReadContractOptions<\n  TAbi extends Abi = [],\n  TMethod extends\n    | AbiFunction\n    | string\n    | ((\n        contract: ThirdwebContract<TAbi>,\n      ) => Promise<AbiFunction>) = TAbi extends { length: 0 }\n    ? AbiFunction | string\n    : ExtractAbiFunctionNames<TAbi>,\n  TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n> = BaseTransactionOptions<\n  Omit<\n    TransactionRequest,\n    | \"from\"\n    | \"to\"\n    | \"data\"\n    | \"value\"\n    | \"accessList\"\n    | \"gas\"\n    | \"gasPrice\"\n    | \"maxFeePerGas\"\n    | \"maxPriorityFeePerGas\"\n    | \"nonce\"\n  > & {\n    method: TMethod | TPreparedMethod;\n    from?: string;\n  } & ParamsOption<TPreparedMethod[1]> &\n    Omit<PrepareTransactionOptions, \"to\" | \"data\" | \"chain\" | \"client\">,\n  TAbi\n>;\n\n/**\n * ### Reads state from a deployed smart contract.\n *\n * Use this for raw read calls from a contract, but you can also use read [extensions](https://portal.thirdweb.com/typescript/v5/extensions/use) for predefined methods for common standards.\n *\n * @param options - The transaction options.\n * @returns A promise that resolves with the result of the read call.\n * @transaction\n * @example\n *\n * ### Raw contract call (recommended)\n *\n * You can read from any contract by using the solidity signature of the function you want to call.\n *\n * ```ts\n * import { getContract } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { useReadContract } from \"thirdweb/react\";\n *\n * const contract = getContract({\n *   client,\n *   address: \"0x...\",\n *   chain: sepolia,\n * });\n *\n * const { data, isLoading } = useReadContract({\n *   contract,\n *   method: \"function tokenURI(uint256 tokenId) returns (string)\",\n *   params: [1n],\n * });\n * ```\n *\n * Note that this is type safe, the params types will be enforced based on the signature.\n *\n * ### Raw contract call with `resolveMethod`\n *\n * If you don't have the solidity signature of the function you want to call, you can use the `resolveMethod` helper to resolve the method from any deployed contract.\n *\n * Note that this is not type safe, and will also have a 1 time overhead of resolving the contract ABI.\n *\n * ```ts\n * import { getContract, resolveMethod } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { useReadContract } from \"thirdweb/react\";\n *\n * const contract = getContract({\n *   client,\n *   address: \"0x...\",\n *   chain: sepolia,\n * });\n *\n * const { data, isLoading } = useReadContract({\n *   contract,\n *   method: resolveMethod(\"tokenURI\"),\n *   params: [1n],\n * });\n * ```\n */\nexport async function readContract<\n  const TAbi extends Abi,\n  const TMethod extends TAbi extends {\n    length: 0;\n  }\n    ?\n        | AbiFunction\n        | `function ${string}`\n        | ((contract: ThirdwebContract<TAbi>) => Promise<AbiFunction>)\n    : ExtractAbiFunctionNames<TAbi>,\n  const TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n>(\n  options: ReadContractOptions<TAbi, TMethod, TPreparedMethod>,\n): Promise<ReadContractResult<TPreparedMethod[2]>> {\n  type ParsedMethod_ = ParseMethod<TAbi, TMethod>;\n  type PreparedMethod_ = PreparedMethod<ParsedMethod_>;\n  const { contract, method, params } = options;\n\n  const resolvePreparedMethod = async () => {\n    if (Array.isArray(method)) {\n      return method as PreparedMethod_;\n    }\n    if (isAbiFunction(method)) {\n      return prepareMethod(method as ParsedMethod_) as PreparedMethod_;\n    }\n\n    if (typeof method === \"function\") {\n      return prepareMethod(\n        // @ts-expect-error - we're sure it's a function\n        (await method(contract)) as ParsedMethod_,\n      ) as PreparedMethod_;\n    }\n    // if the method starts with the string `function ` we always will want to try to parse it\n    if (typeof method === \"string\" && method.startsWith(\"function \")) {\n      // @ts-expect-error - method *is* string in this case\n      const abiItem = parseAbiItem(method);\n      if (abiItem.type === \"function\") {\n        return prepareMethod(abiItem as ParsedMethod_) as PreparedMethod_;\n      }\n      throw new Error(`\"method\" passed is not of type \"function\"`);\n    }\n    // check if we have a \"abi\" on the contract\n    if (contract.abi && contract.abi?.length > 0) {\n      // extract the abiFunction from it\n      const abiFunction = contract.abi?.find(\n        (item) => item.type === \"function\" && item.name === method,\n      );\n      // if we were able to find it -> return it\n      if (abiFunction) {\n        return prepareMethod(abiFunction as ParsedMethod_) as PreparedMethod_;\n      }\n    }\n    throw new Error(`Could not resolve method \"${method}\".`);\n  };\n\n  // resolve in parallel\n  const [resolvedPreparedMethod, resolvedParams] = await Promise.all([\n    resolvePreparedMethod(),\n    typeof params === \"function\" ? params() : params,\n  ]);\n\n  let encodedData: Hex;\n\n  // if we have no inputs, we know it's just the signature\n  if (resolvedPreparedMethod[1].length === 0) {\n    encodedData = resolvedPreparedMethod[0];\n  } else {\n    // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n    // we can do this because we know the specific formats of the values\n    encodedData = (resolvedPreparedMethod[0] +\n      encodeAbiParameters(\n        resolvedPreparedMethod[1],\n        // @ts-expect-error - TODO: fix this type issue\n        resolvedParams,\n      ).slice(2)) as `${(typeof resolvedPreparedMethod)[0]}${string}`;\n  }\n\n  const rpcRequest = getRpcClient({\n    chain: contract.chain,\n    client: contract.client,\n  });\n\n  const result = await eth_call(rpcRequest, {\n    data: encodedData,\n    from: options.from ? getAddress(options.from) : undefined,\n    to: contract.address,\n  });\n  // use the prepared method to decode the result\n  const decoded = decodeAbiParameters(resolvedPreparedMethod[2], result);\n  if (Array.isArray(decoded) && decoded.length === 1) {\n    return decoded[0];\n  }\n\n  return decoded as ReadContractResult<TPreparedMethod[2]>;\n}\n","import type {\n  BlockTag,\n  EIP1193RequestFn,\n  EIP1474Methods,\n  Hex,\n  RpcStateMapping,\n  RpcStateOverride,\n  RpcTransactionRequest,\n} from \"viem\";\nimport { numberToHex } from \"../../utils/encoding/hex.js\";\n\ntype StateOverride = Record<\n  string,\n  {\n    /**\n     * Fake balance to set for the account before executing the call.\n     */\n    balance?: bigint;\n    /**\n     * Fake nonce to set for the account before executing the call.\n     */\n    nonce?: number;\n    /**\n     * Fake EVM bytecode to inject into the account before executing the call.\n     */\n    code?: Hex;\n    /**\n     * Fake key-value mapping to override **all** slots in the account storage before executing the call.\n     */\n    state?: RpcStateMapping;\n    /**\n     * Fake key-value mapping to override **individual** slots in the account storage before executing the call.\n     */\n    stateDiff?: RpcStateMapping;\n  }\n>;\n\nfunction encodeStateOverrides(overrides: StateOverride): RpcStateOverride {\n  return Object.fromEntries(\n    Object.entries(overrides).map(([address, override]) => {\n      return [\n        address,\n        {\n          balance: override.balance ? numberToHex(override.balance) : undefined,\n          code: override.code,\n          nonce: override.nonce ? numberToHex(override.nonce) : undefined,\n          state: override.state,\n          stateDiff: override.stateDiff,\n        },\n      ];\n    }),\n  );\n}\n\n/**\n * Executes a call or a transaction on the Ethereum network.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for the call or transaction.\n * @returns A promise that resolves to the result of the call or transaction.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_call } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const result = await eth_call(rpcRequest, {\n *  to: \"0x...\",\n *  ...\n * });\n * ```\n */\nexport async function eth_call(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: Partial<RpcTransactionRequest> & {\n    blockNumber?: bigint | number;\n    blockTag?: BlockTag;\n    stateOverrides?: StateOverride;\n  },\n): Promise<Hex> {\n  const { blockNumber, blockTag, ...txRequest } = params;\n  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;\n  // default to \"latest\" if no block is provided\n  const block = blockNumberHex || blockTag || \"latest\";\n\n  return await request({\n    method: \"eth_call\",\n    params: params.stateOverrides\n      ? [\n          txRequest as Partial<RpcTransactionRequest>,\n          block,\n          encodeStateOverrides(params.stateOverrides),\n        ]\n      : [txRequest as Partial<RpcTransactionRequest>, block],\n  });\n}\n","import type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport {\n  getContract,\n  type ThirdwebContract,\n} from \"../../../contract/contract.js\";\nimport { prepareContractCall } from \"../../../transaction/prepare-contract-call.js\";\nimport type { PreparedTransaction } from \"../../../transaction/prepare-transaction.js\";\nimport { readContract } from \"../../../transaction/read-contract.js\";\nimport { isHex, stringToHex } from \"../../../utils/encoding/hex.js\";\nimport { withCache } from \"../../../utils/promise/withCache.js\";\nimport type { SendTransactionOption } from \"../../interfaces/wallet.js\";\nimport { DEFAULT_ACCOUNT_FACTORY_V0_6 } from \"./constants.js\";\n\n/**\n * Predict the address of a smart account.\n * @param args - The options for predicting the address of a smart account.\n * @returns The predicted address of the smart account.\n * @example\n * ```ts\n * import { predictSmartAccountAddress } from \"thirdweb/wallets/smart\";\n *\n * const predictedAddress = await predictSmartAccountAddress({\n *  client,\n *  chain,\n *  adminAddress,\n * });\n * ```\n * @walletUtils\n */\nexport async function predictSmartAccountAddress(args: {\n  client: ThirdwebClient;\n  chain: Chain;\n  adminAddress: string;\n  factoryAddress?: string;\n  accountSalt?: string;\n}): Promise<string> {\n  return predictAddress({\n    accountSalt: args.accountSalt,\n    adminAddress: args.adminAddress,\n    factoryContract: getContract({\n      address: args.factoryAddress ?? DEFAULT_ACCOUNT_FACTORY_V0_6,\n      chain: args.chain,\n      client: args.client,\n    }),\n  });\n}\n\n/**\n * Predict the address of a smart account.\n * @param args - The options for predicting the address of a smart account.\n * @returns The predicted address of the smart account.\n * @example\n * ```ts\n * import { predictAddress } from \"thirdweb/wallets/smart\";\n *\n * const predictedAddress = await predictAddress({\n *  factoryContract,\n *  adminAddress,\n *  accountSalt,\n * });\n * ```\n * @walletUtils\n * @deprecated Use `predictSmartAccountAddress` instead.\n */\nexport async function predictAddress(args: {\n  factoryContract: ThirdwebContract;\n  predictAddressOverride?: (\n    factoryContract: ThirdwebContract,\n    admin: string,\n  ) => Promise<string>;\n  adminAddress: string;\n  accountSalt?: string;\n  accountAddress?: string;\n}): Promise<string> {\n  const {\n    factoryContract,\n    predictAddressOverride: predictAddress,\n    adminAddress,\n    accountSalt,\n    accountAddress,\n  } = args;\n  if (predictAddress) {\n    return predictAddress(factoryContract, adminAddress);\n  }\n  if (accountAddress) {\n    return accountAddress;\n  }\n  if (!adminAddress) {\n    throw new Error(\n      \"Account address is required to predict the smart wallet address.\",\n    );\n  }\n  return withCache(\n    async () => {\n      const saltHex =\n        accountSalt && isHex(accountSalt)\n          ? accountSalt\n          : stringToHex(accountSalt ?? \"\");\n      let result: string | undefined;\n      let retries = 0;\n      const maxRetries = 3;\n\n      while (retries <= maxRetries) {\n        try {\n          result = await readContract({\n            contract: factoryContract,\n            method: \"function getAddress(address, bytes) returns (address)\",\n            params: [adminAddress, saltHex],\n          });\n          break;\n        } catch (error) {\n          if (retries === maxRetries) {\n            throw error;\n          }\n\n          // Exponential backoff: 2^(retries + 1) * 200ms (400ms, 800ms, 1600ms)\n          const delay = 2 ** (retries + 1) * 200;\n          await new Promise((resolve) => setTimeout(resolve, delay));\n          retries++;\n        }\n      }\n      if (!result) {\n        throw new Error(\n          `No smart account address found for admin address ${adminAddress} and salt ${accountSalt}`,\n        );\n      }\n      return result;\n    },\n    {\n      cacheKey: `${args.factoryContract.chain.id}-${args.factoryContract.address}-${args.adminAddress}-${args.accountSalt}`,\n      cacheTime: 1000 * 60 * 60 * 24, // 1 day\n    },\n  );\n}\n\n/**\n * @internal\n */\nexport function prepareCreateAccount(args: {\n  factoryContract: ThirdwebContract;\n  adminAddress: string;\n  accountSalt?: string;\n  createAccountOverride?: (\n    factoryContract: ThirdwebContract,\n    admin: string,\n  ) => PreparedTransaction;\n}): PreparedTransaction {\n  const {\n    adminAddress,\n    factoryContract,\n    createAccountOverride: createAccount,\n    accountSalt,\n  } = args;\n  if (createAccount) {\n    return createAccount(factoryContract, adminAddress);\n  }\n  const saltHex =\n    accountSalt && isHex(accountSalt)\n      ? accountSalt\n      : stringToHex(accountSalt ?? \"\");\n  return prepareContractCall({\n    contract: factoryContract,\n    method: \"function createAccount(address, bytes) returns (address)\",\n    params: [adminAddress, saltHex],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareExecute(args: {\n  accountContract: ThirdwebContract;\n  transaction: SendTransactionOption;\n  executeOverride?: (\n    accountContract: ThirdwebContract,\n    transaction: SendTransactionOption,\n  ) => PreparedTransaction;\n}): PreparedTransaction {\n  const { accountContract, transaction, executeOverride: execute } = args;\n  if (execute) {\n    return execute(accountContract, transaction);\n  }\n  let value = transaction.value || 0n;\n  // special handling of hedera chains, decimals for native value is 8 instead of 18 when passed as contract params\n  if (transaction.chainId === 295 || transaction.chainId === 296) {\n    value = BigInt(value) / BigInt(10 ** 10);\n  }\n  return prepareContractCall({\n    contract: accountContract,\n    // if gas is specified for the inner tx, use that and add 21k for the execute call on the account contract\n    // this avoids another estimateGas call when bundling the userOp\n    // and also allows for passing custom gas limits for the inner tx\n    gas: transaction.gas ? transaction.gas + 21000n : undefined,\n    method: \"function execute(address, uint256, bytes)\",\n    params: [transaction.to || \"\", value, transaction.data || \"0x\"],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareBatchExecute(args: {\n  accountContract: ThirdwebContract;\n  transactions: SendTransactionOption[];\n  executeBatchOverride?: (\n    accountContract: ThirdwebContract,\n    transactions: SendTransactionOption[],\n  ) => PreparedTransaction;\n}): PreparedTransaction {\n  const {\n    accountContract,\n    transactions,\n    executeBatchOverride: executeBatch,\n  } = args;\n  if (executeBatch) {\n    return executeBatch(accountContract, transactions);\n  }\n  let values = transactions.map((tx) => tx.value || 0n);\n  const chainId = transactions[0]?.chainId;\n  // special handling of hedera chains, decimals for native value is 8 instead of 18 when passed as contract params\n  if (chainId === 295 || chainId === 296) {\n    values = values.map((value) => BigInt(value) / BigInt(10 ** 10));\n  }\n  return prepareContractCall({\n    contract: accountContract,\n    method: \"function executeBatch(address[], uint256[], bytes[])\",\n    params: [\n      transactions.map((tx) => tx.to || \"\"),\n      values,\n      transactions.map((tx) => tx.data || \"0x\"),\n    ],\n  });\n}\n","export type Store<T> = {\n  getValue(): T;\n  setValue(newValue: T): void;\n  subscribe(listener: () => void): () => void;\n};\n\n/**\n * Create a reactive value store\n * @param initialValue - The initial value to store\n * @example\n * ```ts\n * const store = createStore(0);\n * ```\n * @returns A store object\n * @internal\n */\nexport function createStore<T>(initialValue: T): Store<T> {\n  type Listener = () => void;\n  const listeners = new Set<Listener>();\n\n  let value = initialValue;\n\n  const notify = () => {\n    for (const listener of listeners) {\n      listener();\n    }\n  };\n\n  return {\n    getValue() {\n      return value;\n    },\n    setValue(newValue: T) {\n      if (newValue === value) {\n        return;\n      }\n      value = newValue;\n      notify();\n    },\n    subscribe(listener: Listener) {\n      listeners.add(listener);\n      return () => {\n        listeners.delete(listener);\n      };\n    },\n  };\n}\n","import type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { getTransactions } from \"../insight/get-transactions.js\";\nimport { createStore, type Store } from \"../reactive/store.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\n\nexport type StoredTransaction = {\n  transactionHash: Hex;\n  chainId: number;\n  receipt?: {\n    status: \"success\" | \"failed\";\n    to: string;\n  };\n  decoded?: {\n    name: string;\n    signature: string;\n    inputs?: {\n      [key: string]: unknown;\n    };\n  };\n};\n\nconst transactionsByAddress = new Map<string, Store<StoredTransaction[]>>();\n\n/**\n * Retrieve the transaction store for a given address.\n * @param address - The address to retrieve the transaction store for.\n * @returns A store of transactions for the given account to subscribe to.\n * @transaction\n * @example\n * ```ts\n * import { getTransactionStore } from \"thirdweb/transaction\";\n *\n * const store = getTransactionStore(\"0x...\");\n * store.subscribe((transactions) => {\n *   console.log(transactions);\n * });\n * ```\n */\nexport function getTransactionStore(\n  address: string,\n): Store<StoredTransaction[]> {\n  const existingStore = transactionsByAddress.get(address);\n  if (existingStore) {\n    return existingStore;\n  }\n\n  const newStore = createStore<StoredTransaction[]>([]);\n  transactionsByAddress.set(address, newStore);\n\n  return newStore;\n}\n\n/**\n * @internal\n */\nexport function addTransactionToStore(options: {\n  address: string;\n  transactionHash: Hex;\n  chainId: number;\n}) {\n  const { address, transactionHash, chainId } = options;\n  const tranasctionStore = getTransactionStore(address);\n\n  tranasctionStore.setValue([\n    ...tranasctionStore.getValue(),\n    { chainId, transactionHash },\n  ]);\n\n  transactionsByAddress.set(address, tranasctionStore);\n}\n\n/**\n * @internal for now\n */\nexport async function getPastTransactions(options: {\n  walletAddress: string;\n  chain: Chain;\n  client: ThirdwebClient;\n}): Promise<StoredTransaction[]> {\n  const { walletAddress, chain, client } = options;\n  const oneMonthsAgoInSeconds = Math.floor(\n    (Date.now() - 1 * 30 * 24 * 60 * 60 * 1000) / 1000,\n  );\n  const result = await getTransactions({\n    chains: [chain],\n    client,\n    queryOptions: {\n      filter_block_timestamp_gte: oneMonthsAgoInSeconds,\n      limit: 20,\n      decode: true,\n    },\n    walletAddress,\n  });\n  return result.map((tx) => ({\n    chainId:\n      typeof tx.chain_id === \"string\"\n        ? Number(tx.chain_id)\n        : (tx.chain_id as number),\n    receipt: {\n      status: tx.status === 0 ? \"failed\" : \"success\",\n      to: tx.to_address,\n    },\n    transactionHash: tx.hash as Hex,\n    decoded: tx.decoded,\n  }));\n}\n","import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { decodeAbiParameters } from \"viem\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\n\n/**\n * Represents the parameters for the \"allowance\" function.\n */\nexport type AllowanceParams = {\n  owner: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"owner\" }>;\n  spender: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"spender\" }>;\n};\n\nexport const FN_SELECTOR = \"0xdd62ed3e\" as const;\nconst FN_INPUTS = [\n  {\n    name: \"owner\",\n    type: \"address\",\n  },\n  {\n    name: \"spender\",\n    type: \"address\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"uint256\",\n  },\n] as const;\n\n/**\n * Checks if the `allowance` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `allowance` method is supported.\n * @extension ERC20\n * @example\n * ```ts\n * import { isAllowanceSupported } from \"thirdweb/extensions/erc20\";\n * const supported = isAllowanceSupported([\"0x...\"]);\n * ```\n */\nexport function isAllowanceSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"allowance\" function.\n * @param options - The options for the allowance function.\n * @returns The encoded ABI parameters.\n * @extension ERC20\n * @example\n * ```ts\n * import { encodeAllowanceParams } from \"thirdweb/extensions/erc20\";\n * const result = encodeAllowanceParams({\n *  owner: ...,\n *  spender: ...,\n * });\n * ```\n */\nexport function encodeAllowanceParams(options: AllowanceParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.owner, options.spender]);\n}\n\n/**\n * Encodes the \"allowance\" function into a Hex string with its parameters.\n * @param options - The options for the allowance function.\n * @returns The encoded hexadecimal string.\n * @extension ERC20\n * @example\n * ```ts\n * import { encodeAllowance } from \"thirdweb/extensions/erc20\";\n * const result = encodeAllowance({\n *  owner: ...,\n *  spender: ...,\n * });\n * ```\n */\nexport function encodeAllowance(options: AllowanceParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeAllowanceParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the allowance function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC20\n * @example\n * ```ts\n * import { decodeAllowanceResult } from \"thirdweb/extensions/erc20\";\n * const result = decodeAllowanceResultResult(\"...\");\n * ```\n */\nexport function decodeAllowanceResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"allowance\" function on the contract.\n * @param options - The options for the allowance function.\n * @returns The parsed result of the function call.\n * @extension ERC20\n * @example\n * ```ts\n * import { allowance } from \"thirdweb/extensions/erc20\";\n *\n * const result = await allowance({\n *  contract,\n *  owner: ...,\n *  spender: ...,\n * });\n *\n * ```\n */\nexport async function allowance(\n  options: BaseTransactionOptions<AllowanceParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.owner, options.spender],\n  });\n}\n","import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { prepareContractCall } from \"../../../../../transaction/prepare-contract-call.js\";\nimport type {\n  BaseTransactionOptions,\n  WithOverrides,\n} from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport { once } from \"../../../../../utils/promise/once.js\";\n\n/**\n * Represents the parameters for the \"approve\" function.\n */\nexport type ApproveParams = WithOverrides<{\n  spender: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"spender\" }>;\n  value: AbiParameterToPrimitiveType<{ type: \"uint256\"; name: \"value\" }>;\n}>;\n\nexport const FN_SELECTOR = \"0x095ea7b3\" as const;\nconst FN_INPUTS = [\n  {\n    name: \"spender\",\n    type: \"address\",\n  },\n  {\n    name: \"value\",\n    type: \"uint256\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"bool\",\n  },\n] as const;\n\n/**\n * Checks if the `approve` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `approve` method is supported.\n * @extension ERC20\n * @example\n * ```ts\n * import { isApproveSupported } from \"thirdweb/extensions/erc20\";\n *\n * const supported = isApproveSupported([\"0x...\"]);\n * ```\n */\nexport function isApproveSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"approve\" function.\n * @param options - The options for the approve function.\n * @returns The encoded ABI parameters.\n * @extension ERC20\n * @example\n * ```ts\n * import { encodeApproveParams } from \"thirdweb/extensions/erc20\";\n * const result = encodeApproveParams({\n *  spender: ...,\n *  value: ...,\n * });\n * ```\n */\nexport function encodeApproveParams(options: ApproveParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.spender, options.value]);\n}\n\n/**\n * Encodes the \"approve\" function into a Hex string with its parameters.\n * @param options - The options for the approve function.\n * @returns The encoded hexadecimal string.\n * @extension ERC20\n * @example\n * ```ts\n * import { encodeApprove } from \"thirdweb/extensions/erc20\";\n * const result = encodeApprove({\n *  spender: ...,\n *  value: ...,\n * });\n * ```\n */\nexport function encodeApprove(options: ApproveParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeApproveParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Prepares a transaction to call the \"approve\" function on the contract.\n * @param options - The options for the \"approve\" function.\n * @returns A prepared transaction object.\n * @extension ERC20\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n * import { approve } from \"thirdweb/extensions/erc20\";\n *\n * const transaction = approve({\n *  contract,\n *  spender: ...,\n *  value: ...,\n *  overrides: {\n *    ...\n *  }\n * });\n *\n * // Send the transaction\n * await sendTransaction({ transaction, account });\n * ```\n */\nexport function approve(\n  options: BaseTransactionOptions<\n    | ApproveParams\n    | {\n        asyncParams: () => Promise<ApproveParams>;\n      }\n  >,\n) {\n  const asyncOptions = once(async () => {\n    return \"asyncParams\" in options ? await options.asyncParams() : options;\n  });\n\n  return prepareContractCall({\n    accessList: async () => (await asyncOptions()).overrides?.accessList,\n    authorizationList: async () =>\n      (await asyncOptions()).overrides?.authorizationList,\n    contract: options.contract,\n    erc20Value: async () => (await asyncOptions()).overrides?.erc20Value,\n    extraGas: async () => (await asyncOptions()).overrides?.extraGas,\n    gas: async () => (await asyncOptions()).overrides?.gas,\n    gasPrice: async () => (await asyncOptions()).overrides?.gasPrice,\n    maxFeePerGas: async () => (await asyncOptions()).overrides?.maxFeePerGas,\n    maxPriorityFeePerGas: async () =>\n      (await asyncOptions()).overrides?.maxPriorityFeePerGas,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    nonce: async () => (await asyncOptions()).overrides?.nonce,\n    params: async () => {\n      const resolvedOptions = await asyncOptions();\n      return [resolvedOptions.spender, resolvedOptions.value] as const;\n    },\n    value: async () => (await asyncOptions()).overrides?.value,\n  });\n}\n","import type { Address } from \"abitype\";\nimport type {\n  BaseTransactionOptions,\n  WithOverrides,\n} from \"../../../transaction/types.js\";\nimport type { Prettify } from \"../../../utils/type-utils.js\";\nimport { toUnits } from \"../../../utils/units.js\";\nimport { approve as generatedApprove } from \"../__generated__/IERC20/write/approve.js\";\n\n/**\n * Represents the parameters for the `approve` function.\n * @extension ERC20\n */\nexport type ApproveParams = Prettify<\n  WithOverrides<\n    { spender: Address } & (\n      | {\n          amount: number | string;\n        }\n      | {\n          amountWei: bigint;\n        }\n    )\n  >\n>;\n\n/**\n * Approves the spending of tokens by a specific address.\n * @param options - The transaction options.\n * @returns A prepared transaction object.\n * @extension ERC20\n * @example\n * ```ts\n * import { approve } from \"thirdweb/extensions/erc20\";\n * import { sendTransaction } from \"thirdweb\";\n *\n * const transaction = await approve({\n *  contract,\n *  spender: \"0x...\",\n *  amount: 100,\n * });\n *\n * await sendTransaction({ transaction, account });\n * ```\n */\nexport function approve(options: BaseTransactionOptions<ApproveParams>) {\n  return generatedApprove({\n    asyncParams: async () => {\n      let amount: bigint;\n      if (\"amount\" in options) {\n        // if we need to parse the amount from ether to gwei then we pull in the decimals extension\n        const { decimals } = await import(\"../read/decimals.js\");\n        // if this fails we fall back to `18` decimals\n        const d = await decimals(options).catch(() => 18);\n        // turn ether into gwei\n        amount = toUnits(options.amount.toString(), d);\n      } else {\n        amount = options.amountWei;\n      }\n      return {\n        overrides: {\n          erc20Value: {\n            amountWei: amount,\n            tokenAddress: options.contract.address,\n          },\n          ...options.overrides,\n        },\n        spender: options.spender,\n        value: amount,\n      } as const;\n    },\n    contract: options.contract,\n  });\n}\n","import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { decodeAbiParameters } from \"viem\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\n\n/**\n * Represents the parameters for the \"getPermissionsForSigner\" function.\n */\nexport type GetPermissionsForSignerParams = {\n  signer: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"signer\" }>;\n};\n\nexport const FN_SELECTOR = \"0xf15d424e\" as const;\nconst FN_INPUTS = [\n  {\n    name: \"signer\",\n    type: \"address\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    components: [\n      {\n        name: \"signer\",\n        type: \"address\",\n      },\n      {\n        name: \"approvedTargets\",\n        type: \"address[]\",\n      },\n      {\n        name: \"nativeTokenLimitPerTransaction\",\n        type: \"uint256\",\n      },\n      {\n        name: \"startTimestamp\",\n        type: \"uint128\",\n      },\n      {\n        name: \"endTimestamp\",\n        type: \"uint128\",\n      },\n    ],\n    name: \"permissions\",\n    type: \"tuple\",\n  },\n] as const;\n\n/**\n * Checks if the `getPermissionsForSigner` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `getPermissionsForSigner` method is supported.\n * @extension ERC4337\n * @example\n * ```ts\n * import { isGetPermissionsForSignerSupported } from \"thirdweb/extensions/erc4337\";\n * const supported = isGetPermissionsForSignerSupported([\"0x...\"]);\n * ```\n */\nexport function isGetPermissionsForSignerSupported(\n  availableSelectors: string[],\n) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"getPermissionsForSigner\" function.\n * @param options - The options for the getPermissionsForSigner function.\n * @returns The encoded ABI parameters.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetPermissionsForSignerParams } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetPermissionsForSignerParams({\n *  signer: ...,\n * });\n * ```\n */\nexport function encodeGetPermissionsForSignerParams(\n  options: GetPermissionsForSignerParams,\n) {\n  return encodeAbiParameters(FN_INPUTS, [options.signer]);\n}\n\n/**\n * Encodes the \"getPermissionsForSigner\" function into a Hex string with its parameters.\n * @param options - The options for the getPermissionsForSigner function.\n * @returns The encoded hexadecimal string.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetPermissionsForSigner } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetPermissionsForSigner({\n *  signer: ...,\n * });\n * ```\n */\nexport function encodeGetPermissionsForSigner(\n  options: GetPermissionsForSignerParams,\n) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeGetPermissionsForSignerParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the getPermissionsForSigner function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC4337\n * @example\n * ```ts\n * import { decodeGetPermissionsForSignerResult } from \"thirdweb/extensions/erc4337\";\n * const result = decodeGetPermissionsForSignerResultResult(\"...\");\n * ```\n */\nexport function decodeGetPermissionsForSignerResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"getPermissionsForSigner\" function on the contract.\n * @param options - The options for the getPermissionsForSigner function.\n * @returns The parsed result of the function call.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getPermissionsForSigner } from \"thirdweb/extensions/erc4337\";\n *\n * const result = await getPermissionsForSigner({\n *  contract,\n *  signer: ...,\n * });\n *\n * ```\n */\nexport async function getPermissionsForSigner(\n  options: BaseTransactionOptions<GetPermissionsForSignerParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.signer],\n  });\n}\n","import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { prepareContractCall } from \"../../../../../transaction/prepare-contract-call.js\";\nimport type {\n  BaseTransactionOptions,\n  WithOverrides,\n} from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport { once } from \"../../../../../utils/promise/once.js\";\n\n/**\n * Represents the parameters for the \"setPermissionsForSigner\" function.\n */\nexport type SetPermissionsForSignerParams = WithOverrides<{\n  req: AbiParameterToPrimitiveType<{\n    type: \"tuple\";\n    name: \"req\";\n    components: [\n      { type: \"address\"; name: \"signer\" },\n      { type: \"uint8\"; name: \"isAdmin\" },\n      { type: \"address[]\"; name: \"approvedTargets\" },\n      { type: \"uint256\"; name: \"nativeTokenLimitPerTransaction\" },\n      { type: \"uint128\"; name: \"permissionStartTimestamp\" },\n      { type: \"uint128\"; name: \"permissionEndTimestamp\" },\n      { type: \"uint128\"; name: \"reqValidityStartTimestamp\" },\n      { type: \"uint128\"; name: \"reqValidityEndTimestamp\" },\n      { type: \"bytes32\"; name: \"uid\" },\n    ];\n  }>;\n  signature: AbiParameterToPrimitiveType<{ type: \"bytes\"; name: \"signature\" }>;\n}>;\n\nexport const FN_SELECTOR = \"0x5892e236\" as const;\nconst FN_INPUTS = [\n  {\n    components: [\n      {\n        name: \"signer\",\n        type: \"address\",\n      },\n      {\n        name: \"isAdmin\",\n        type: \"uint8\",\n      },\n      {\n        name: \"approvedTargets\",\n        type: \"address[]\",\n      },\n      {\n        name: \"nativeTokenLimitPerTransaction\",\n        type: \"uint256\",\n      },\n      {\n        name: \"permissionStartTimestamp\",\n        type: \"uint128\",\n      },\n      {\n        name: \"permissionEndTimestamp\",\n        type: \"uint128\",\n      },\n      {\n        name: \"reqValidityStartTimestamp\",\n        type: \"uint128\",\n      },\n      {\n        name: \"reqValidityEndTimestamp\",\n        type: \"uint128\",\n      },\n      {\n        name: \"uid\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"req\",\n    type: \"tuple\",\n  },\n  {\n    name: \"signature\",\n    type: \"bytes\",\n  },\n] as const;\nconst FN_OUTPUTS = [] as const;\n\n/**\n * Checks if the `setPermissionsForSigner` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `setPermissionsForSigner` method is supported.\n * @extension ERC4337\n * @example\n * ```ts\n * import { isSetPermissionsForSignerSupported } from \"thirdweb/extensions/erc4337\";\n *\n * const supported = isSetPermissionsForSignerSupported([\"0x...\"]);\n * ```\n */\nexport function isSetPermissionsForSignerSupported(\n  availableSelectors: string[],\n) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"setPermissionsForSigner\" function.\n * @param options - The options for the setPermissionsForSigner function.\n * @returns The encoded ABI parameters.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeSetPermissionsForSignerParams } from \"thirdweb/extensions/erc4337\";\n * const result = encodeSetPermissionsForSignerParams({\n *  req: ...,\n *  signature: ...,\n * });\n * ```\n */\nexport function encodeSetPermissionsForSignerParams(\n  options: SetPermissionsForSignerParams,\n) {\n  return encodeAbiParameters(FN_INPUTS, [options.req, options.signature]);\n}\n\n/**\n * Encodes the \"setPermissionsForSigner\" function into a Hex string with its parameters.\n * @param options - The options for the setPermissionsForSigner function.\n * @returns The encoded hexadecimal string.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeSetPermissionsForSigner } from \"thirdweb/extensions/erc4337\";\n * const result = encodeSetPermissionsForSigner({\n *  req: ...,\n *  signature: ...,\n * });\n * ```\n */\nexport function encodeSetPermissionsForSigner(\n  options: SetPermissionsForSignerParams,\n) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeSetPermissionsForSignerParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Prepares a transaction to call the \"setPermissionsForSigner\" function on the contract.\n * @param options - The options for the \"setPermissionsForSigner\" function.\n * @returns A prepared transaction object.\n * @extension ERC4337\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n * import { setPermissionsForSigner } from \"thirdweb/extensions/erc4337\";\n *\n * const transaction = setPermissionsForSigner({\n *  contract,\n *  req: ...,\n *  signature: ...,\n *  overrides: {\n *    ...\n *  }\n * });\n *\n * // Send the transaction\n * await sendTransaction({ transaction, account });\n * ```\n */\nexport function setPermissionsForSigner(\n  options: BaseTransactionOptions<\n    | SetPermissionsForSignerParams\n    | {\n        asyncParams: () => Promise<SetPermissionsForSignerParams>;\n      }\n  >,\n) {\n  const asyncOptions = once(async () => {\n    return \"asyncParams\" in options ? await options.asyncParams() : options;\n  });\n\n  return prepareContractCall({\n    accessList: async () => (await asyncOptions()).overrides?.accessList,\n    authorizationList: async () =>\n      (await asyncOptions()).overrides?.authorizationList,\n    contract: options.contract,\n    erc20Value: async () => (await asyncOptions()).overrides?.erc20Value,\n    extraGas: async () => (await asyncOptions()).overrides?.extraGas,\n    gas: async () => (await asyncOptions()).overrides?.gas,\n    gasPrice: async () => (await asyncOptions()).overrides?.gasPrice,\n    maxFeePerGas: async () => (await asyncOptions()).overrides?.maxFeePerGas,\n    maxPriorityFeePerGas: async () =>\n      (await asyncOptions()).overrides?.maxPriorityFeePerGas,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    nonce: async () => (await asyncOptions()).overrides?.nonce,\n    params: async () => {\n      const resolvedOptions = await asyncOptions();\n      return [resolvedOptions.req, resolvedOptions.signature] as const;\n    },\n    value: async () => (await asyncOptions()).overrides?.value,\n  });\n}\n","import { toBigInt } from \"./bigint.js\";\n\n/**\n * @internal\n */\nexport function tenYearsFromNow() {\n  return new Date(Date.now() + 1000 * 60 * 60 * 24 * 365 * 10); // 10 years\n}\n\n/**\n * @internal\n */\nexport function dateToSeconds(date: Date) {\n  return toBigInt(Math.floor(date.getTime() / 1000));\n}\n","export type AccountPermissions = {\n  approvedTargets: string[] | \"*\";\n  nativeTokenLimitPerTransaction?: number | string;\n  permissionStartTimestamp?: Date;\n  permissionEndTimestamp?: Date;\n  reqValidityStartTimestamp?: Date;\n  reqValidityEndTimestamp?: Date;\n};\n\nexport const SignerPermissionRequest = [\n  { name: \"signer\", type: \"address\" },\n  { name: \"isAdmin\", type: \"uint8\" },\n  { name: \"approvedTargets\", type: \"address[]\" },\n  { name: \"nativeTokenLimitPerTransaction\", type: \"uint256\" },\n  { name: \"permissionStartTimestamp\", type: \"uint128\" },\n  { name: \"permissionEndTimestamp\", type: \"uint128\" },\n  { name: \"reqValidityStartTimestamp\", type: \"uint128\" },\n  { name: \"reqValidityEndTimestamp\", type: \"uint128\" },\n  { name: \"uid\", type: \"bytes32\" },\n];\n","import { ZERO_ADDRESS } from \"../../../constants/addresses.js\";\nimport type { ThirdwebContract } from \"../../../contract/contract.js\";\nimport { dateToSeconds, tenYearsFromNow } from \"../../../utils/date.js\";\nimport { randomBytesHex } from \"../../../utils/random.js\";\nimport { toWei } from \"../../../utils/units.js\";\nimport type { Account } from \"../../../wallets/interfaces/wallet.js\";\nimport type { SetPermissionsForSignerParams } from \"../__generated__/IAccountPermissions/write/setPermissionsForSigner.js\";\nimport { type AccountPermissions, SignerPermissionRequest } from \"./types.js\";\n\n/**\n * @internal\n */\nexport async function signPermissionRequest(options: {\n  account: Account;\n  contract: ThirdwebContract;\n  req: SetPermissionsForSignerParams[\"req\"];\n}) {\n  const { account, contract, req } = options;\n  const signature = await account.signTypedData({\n    domain: {\n      chainId: contract.chain.id,\n      name: \"Account\",\n      verifyingContract: contract.address,\n      version: \"1\",\n    },\n    message: req,\n    primaryType: \"SignerPermissionRequest\",\n    types: { SignerPermissionRequest },\n  });\n  return { req, signature };\n}\n\n/**\n * @internal\n */\nexport async function toContractPermissions(options: {\n  target: string;\n  permissions: AccountPermissions;\n}): Promise<SetPermissionsForSignerParams[\"req\"]> {\n  const { target, permissions } = options;\n  return {\n    approvedTargets:\n      permissions.approvedTargets === \"*\"\n        ? [ZERO_ADDRESS]\n        : permissions.approvedTargets,\n    isAdmin: 0,\n    nativeTokenLimitPerTransaction: toWei(\n      permissions.nativeTokenLimitPerTransaction?.toString() || \"0\",\n    ),\n    permissionEndTimestamp: dateToSeconds(\n      permissions.permissionEndTimestamp || tenYearsFromNow(),\n    ),\n    permissionStartTimestamp: dateToSeconds(\n      permissions.permissionStartTimestamp || new Date(0),\n    ),\n    reqValidityEndTimestamp: dateToSeconds(tenYearsFromNow()),\n    reqValidityStartTimestamp: 0n,\n    signer: target, // session key flag\n    uid: await randomBytesHex(),\n  };\n}\n\n/**\n * @internal\n */\nexport async function defaultPermissionsForAdmin(options: {\n  target: string;\n  action: \"add-admin\" | \"remove-admin\";\n}): Promise<SetPermissionsForSignerParams[\"req\"]> {\n  const { target, action } = options;\n  return {\n    approvedTargets: [],\n    isAdmin: action === \"add-admin\" ? 1 : action === \"remove-admin\" ? 2 : 0,\n    nativeTokenLimitPerTransaction: 0n,\n    permissionEndTimestamp: 0n,\n    permissionStartTimestamp: 0n,\n    reqValidityEndTimestamp: dateToSeconds(tenYearsFromNow()),\n    reqValidityStartTimestamp: 0n,\n    signer: target,\n    uid: await randomBytesHex(),\n  };\n}\n","import { ZERO_ADDRESS } from \"../../../constants/addresses.js\";\nimport type { ThirdwebContract } from \"../../../contract/contract.js\";\nimport type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { isContractDeployed } from \"../../../utils/bytecode/is-contract-deployed.js\";\nimport { toWei } from \"../../../utils/units.js\";\nimport type { Account } from \"../../../wallets/interfaces/wallet.js\";\nimport { getPermissionsForSigner } from \"../__generated__/IAccountPermissions/read/getPermissionsForSigner.js\";\nimport {\n  isSetPermissionsForSignerSupported,\n  setPermissionsForSigner,\n} from \"../__generated__/IAccountPermissions/write/setPermissionsForSigner.js\";\nimport { signPermissionRequest, toContractPermissions } from \"./common.js\";\nimport type { AccountPermissions } from \"./types.js\";\n\n/**\n * @extension ERC4337\n */\nexport type AddSessionKeyOptions = {\n  /**\n   * The admin account that will perform the operation.\n   */\n  account: Account;\n  /**\n   * The address to add as a session key.\n   */\n  sessionKeyAddress: string;\n  /**\n   * The permissions to assign to the session key.\n   */\n  permissions: AccountPermissions;\n};\n\n/**\n * Adds session key permissions for a specified address.\n * @param options - The options for the removeSessionKey function.\n * @param {Contract} options.contract - The smart account contract to add the session key to\n * @returns The transaction object to be sent.\n * @example\n * ```ts\n * import { addSessionKey } from 'thirdweb/extensions/erc4337';\n * import { sendTransaction } from 'thirdweb';\n *\n * const transaction = addSessionKey({\n * contract,\n * account,\n * sessionKeyAddress,\n * permissions: {\n *  approvedTargets: ['0x...'],\n *  nativeTokenLimitPerTransaction: 0.1, // in ETH\n *  permissionStartTimestamp: new Date(),\n *  permissionEndTimestamp: new Date(Date.now() + 1000 * 60 * 60 * 24 * 365), // 1 year from now\n * }\n * });\n *\n * await sendTransaction({ transaction, account });\n * ```\n * @extension ERC4337\n */\nexport function addSessionKey(\n  options: BaseTransactionOptions<AddSessionKeyOptions>,\n) {\n  const { contract, sessionKeyAddress, account, permissions } = options;\n  return setPermissionsForSigner({\n    async asyncParams() {\n      const { req, signature } = await signPermissionRequest({\n        account,\n        contract,\n        req: await toContractPermissions({\n          permissions,\n          target: sessionKeyAddress,\n        }),\n      });\n      return { req, signature };\n    },\n    contract,\n  });\n}\n\n/**\n * Checks if the `isAddSessionKeySupported` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `isAddSessionKeySupported` method is supported.\n * @extension ERC4337\n * @example\n * ```ts\n * import { isAddSessionKeySupported } from \"thirdweb/extensions/erc4337\";\n *\n * const supported = isAddSessionKeySupported([\"0x...\"]);\n * ```\n */\nexport function isAddSessionKeySupported(availableSelectors: string[]) {\n  return isSetPermissionsForSignerSupported(availableSelectors);\n}\n\n/**\n * Checks if the session key should be updated.\n * @param currentPermissions - The current permissions of the session key.\n * @param newPermissions - The new permissions to set for the session key.\n * @returns A boolean indicating if the session key should be updated.\n * @extension ERC4337\n * @example\n * ```ts\n * import { shouldUpdateSessionKey } from \"thirdweb/extensions/erc4337\";\n *\n * const shouldUpdate = await shouldUpdateSessionKey({ accountContract, sessionKeyAddress, newPermissions });\n * ```\n */\nexport async function shouldUpdateSessionKey(args: {\n  accountContract: ThirdwebContract;\n  sessionKeyAddress: string;\n  newPermissions: AccountPermissions;\n}): Promise<boolean> {\n  const { accountContract, sessionKeyAddress, newPermissions } = args;\n\n  // check if account is deployed\n  const accountDeployed = await isContractDeployed(accountContract);\n  if (!accountDeployed) {\n    return true;\n  }\n\n  // get current permissions\n  const currentPermissions = await getPermissionsForSigner({\n    contract: accountContract,\n    signer: sessionKeyAddress,\n  });\n  // check end time validity\n  if (\n    currentPermissions.endTimestamp &&\n    currentPermissions.endTimestamp < Math.floor(Date.now() / 1000)\n  ) {\n    return true;\n  }\n\n  // check targets\n  if (\n    !areSessionKeyContractTargetsEqual(\n      currentPermissions.approvedTargets,\n      newPermissions.approvedTargets,\n    )\n  ) {\n    return true;\n  }\n\n  // check if the new native token limit is greater than the current one\n  if (\n    toWei(newPermissions.nativeTokenLimitPerTransaction?.toString() ?? \"0\") >\n    currentPermissions.nativeTokenLimitPerTransaction\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction areSessionKeyContractTargetsEqual(\n  currentTargets: readonly string[],\n  newTargets: string[] | \"*\",\n): boolean {\n  // Handle the case where approvedTargets is \"*\"\n  if (\n    newTargets === \"*\" &&\n    currentTargets.length === 1 &&\n    currentTargets[0] === ZERO_ADDRESS\n  ) {\n    return true;\n  }\n  if (newTargets !== \"*\") {\n    return newTargets\n      .map((target) => target.toLowerCase())\n      .every((target) =>\n        currentTargets.map((t) => t.toLowerCase()).includes(target),\n      );\n  }\n  return false;\n}\n","import type * as ox__Bytes from \"ox/Bytes\";\nimport type * as ox__Hex from \"ox/Hex\";\nimport type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport type { Account } from \"../wallets/interfaces/wallet.js\";\nimport type { Prettify } from \"./type-utils.js\";\n\n/**\n * @internal\n */\nexport type ClientAndChain = {\n  client: ThirdwebClient;\n  chain: Chain;\n};\n\n/**\n * @internal\n */\nexport type ClientAndChainAndAccount = Prettify<\n  ClientAndChain & { account: Account }\n>;\n\n/**\n * A message that can be signed, either as in plaintext or as a raw hex string.\n */\nexport type SignableMessage =\n  | string\n  | {\n      /** Raw data representation of the message. */\n      raw: ox__Hex.Hex | ox__Bytes.Bytes;\n    };\n\n/**\n * @internal\n */\nexport const maxUint96 = 2n ** 96n - 1n;\n","import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { decodeAbiParameters } from \"viem\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\n\n/**\n * Represents the parameters for the \"getNonce\" function.\n */\nexport type GetNonceParams = {\n  sender: AbiParameterToPrimitiveType<{ type: \"address\"; name: \"sender\" }>;\n  key: AbiParameterToPrimitiveType<{ type: \"uint192\"; name: \"key\" }>;\n};\n\nexport const FN_SELECTOR = \"0x35567e1a\" as const;\nconst FN_INPUTS = [\n  {\n    name: \"sender\",\n    type: \"address\",\n  },\n  {\n    name: \"key\",\n    type: \"uint192\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    name: \"nonce\",\n    type: \"uint256\",\n  },\n] as const;\n\n/**\n * Checks if the `getNonce` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `getNonce` method is supported.\n * @extension ERC4337\n * @example\n * ```ts\n * import { isGetNonceSupported } from \"thirdweb/extensions/erc4337\";\n * const supported = isGetNonceSupported([\"0x...\"]);\n * ```\n */\nexport function isGetNonceSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"getNonce\" function.\n * @param options - The options for the getNonce function.\n * @returns The encoded ABI parameters.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetNonceParams } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetNonceParams({\n *  sender: ...,\n *  key: ...,\n * });\n * ```\n */\nexport function encodeGetNonceParams(options: GetNonceParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.sender, options.key]);\n}\n\n/**\n * Encodes the \"getNonce\" function into a Hex string with its parameters.\n * @param options - The options for the getNonce function.\n * @returns The encoded hexadecimal string.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetNonce } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetNonce({\n *  sender: ...,\n *  key: ...,\n * });\n * ```\n */\nexport function encodeGetNonce(options: GetNonceParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeGetNonceParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the getNonce function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC4337\n * @example\n * ```ts\n * import { decodeGetNonceResult } from \"thirdweb/extensions/erc4337\";\n * const result = decodeGetNonceResultResult(\"...\");\n * ```\n */\nexport function decodeGetNonceResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"getNonce\" function on the contract.\n * @param options - The options for the getNonce function.\n * @returns The parsed result of the function call.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getNonce } from \"thirdweb/extensions/erc4337\";\n *\n * const result = await getNonce({\n *  contract,\n *  sender: ...,\n *  key: ...,\n * });\n *\n * ```\n */\nexport async function getNonce(\n  options: BaseTransactionOptions<GetNonceParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.sender, options.key],\n  });\n}\n","import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { decodeAbiParameters } from \"viem\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\n\n/**\n * Represents the parameters for the \"getUserOpHash\" function.\n */\nexport type GetUserOpHashParams = {\n  userOp: AbiParameterToPrimitiveType<{\n    type: \"tuple\";\n    name: \"userOp\";\n    components: [\n      { type: \"address\"; name: \"sender\" },\n      { type: \"uint256\"; name: \"nonce\" },\n      { type: \"bytes\"; name: \"initCode\" },\n      { type: \"bytes\"; name: \"callData\" },\n      { type: \"uint256\"; name: \"callGasLimit\" },\n      { type: \"uint256\"; name: \"verificationGasLimit\" },\n      { type: \"uint256\"; name: \"preVerificationGas\" },\n      { type: \"uint256\"; name: \"maxFeePerGas\" },\n      { type: \"uint256\"; name: \"maxPriorityFeePerGas\" },\n      { type: \"bytes\"; name: \"paymasterAndData\" },\n      { type: \"bytes\"; name: \"signature\" },\n    ];\n  }>;\n};\n\nexport const FN_SELECTOR = \"0xa6193531\" as const;\nconst FN_INPUTS = [\n  {\n    components: [\n      {\n        name: \"sender\",\n        type: \"address\",\n      },\n      {\n        name: \"nonce\",\n        type: \"uint256\",\n      },\n      {\n        name: \"initCode\",\n        type: \"bytes\",\n      },\n      {\n        name: \"callData\",\n        type: \"bytes\",\n      },\n      {\n        name: \"callGasLimit\",\n        type: \"uint256\",\n      },\n      {\n        name: \"verificationGasLimit\",\n        type: \"uint256\",\n      },\n      {\n        name: \"preVerificationGas\",\n        type: \"uint256\",\n      },\n      {\n        name: \"maxFeePerGas\",\n        type: \"uint256\",\n      },\n      {\n        name: \"maxPriorityFeePerGas\",\n        type: \"uint256\",\n      },\n      {\n        name: \"paymasterAndData\",\n        type: \"bytes\",\n      },\n      {\n        name: \"signature\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"userOp\",\n    type: \"tuple\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"bytes32\",\n  },\n] as const;\n\n/**\n * Checks if the `getUserOpHash` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `getUserOpHash` method is supported.\n * @extension ERC4337\n * @example\n * ```ts\n * import { isGetUserOpHashSupported } from \"thirdweb/extensions/erc4337\";\n * const supported = isGetUserOpHashSupported([\"0x...\"]);\n * ```\n */\nexport function isGetUserOpHashSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"getUserOpHash\" function.\n * @param options - The options for the getUserOpHash function.\n * @returns The encoded ABI parameters.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetUserOpHashParams } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetUserOpHashParams({\n *  userOp: ...,\n * });\n * ```\n */\nexport function encodeGetUserOpHashParams(options: GetUserOpHashParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.userOp]);\n}\n\n/**\n * Encodes the \"getUserOpHash\" function into a Hex string with its parameters.\n * @param options - The options for the getUserOpHash function.\n * @returns The encoded hexadecimal string.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetUserOpHash } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetUserOpHash({\n *  userOp: ...,\n * });\n * ```\n */\nexport function encodeGetUserOpHash(options: GetUserOpHashParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeGetUserOpHashParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the getUserOpHash function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC4337\n * @example\n * ```ts\n * import { decodeGetUserOpHashResult } from \"thirdweb/extensions/erc4337\";\n * const result = decodeGetUserOpHashResultResult(\"...\");\n * ```\n */\nexport function decodeGetUserOpHashResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"getUserOpHash\" function on the contract.\n * @param options - The options for the getUserOpHash function.\n * @returns The parsed result of the function call.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getUserOpHash } from \"thirdweb/extensions/erc4337\";\n *\n * const result = await getUserOpHash({\n *  contract,\n *  userOp: ...,\n * });\n *\n * ```\n */\nexport async function getUserOpHash(\n  options: BaseTransactionOptions<GetUserOpHashParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.userOp],\n  });\n}\n","import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { decodeAbiParameters } from \"viem\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\n\n/**\n * Represents the parameters for the \"getUserOpHash\" function.\n */\nexport type GetUserOpHashParams = {\n  userOp: AbiParameterToPrimitiveType<{\n    type: \"tuple\";\n    name: \"userOp\";\n    components: [\n      { type: \"address\"; name: \"sender\" },\n      { type: \"uint256\"; name: \"nonce\" },\n      { type: \"bytes\"; name: \"initCode\" },\n      { type: \"bytes\"; name: \"callData\" },\n      { type: \"bytes32\"; name: \"accountGasLimits\" },\n      { type: \"uint256\"; name: \"preVerificationGas\" },\n      { type: \"bytes32\"; name: \"gasFees\" },\n      { type: \"bytes\"; name: \"paymasterAndData\" },\n      { type: \"bytes\"; name: \"signature\" },\n    ];\n  }>;\n};\n\nexport const FN_SELECTOR = \"0x22cdde4c\" as const;\nconst FN_INPUTS = [\n  {\n    components: [\n      {\n        name: \"sender\",\n        type: \"address\",\n      },\n      {\n        name: \"nonce\",\n        type: \"uint256\",\n      },\n      {\n        name: \"initCode\",\n        type: \"bytes\",\n      },\n      {\n        name: \"callData\",\n        type: \"bytes\",\n      },\n      {\n        name: \"accountGasLimits\",\n        type: \"bytes32\",\n      },\n      {\n        name: \"preVerificationGas\",\n        type: \"uint256\",\n      },\n      {\n        name: \"gasFees\",\n        type: \"bytes32\",\n      },\n      {\n        name: \"paymasterAndData\",\n        type: \"bytes\",\n      },\n      {\n        name: \"signature\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"userOp\",\n    type: \"tuple\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"bytes32\",\n  },\n] as const;\n\n/**\n * Checks if the `getUserOpHash` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `getUserOpHash` method is supported.\n * @extension ERC4337\n * @example\n * ```ts\n * import { isGetUserOpHashSupported } from \"thirdweb/extensions/erc4337\";\n * const supported = isGetUserOpHashSupported([\"0x...\"]);\n * ```\n */\nexport function isGetUserOpHashSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"getUserOpHash\" function.\n * @param options - The options for the getUserOpHash function.\n * @returns The encoded ABI parameters.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetUserOpHashParams } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetUserOpHashParams({\n *  userOp: ...,\n * });\n * ```\n */\nexport function encodeGetUserOpHashParams(options: GetUserOpHashParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.userOp]);\n}\n\n/**\n * Encodes the \"getUserOpHash\" function into a Hex string with its parameters.\n * @param options - The options for the getUserOpHash function.\n * @returns The encoded hexadecimal string.\n * @extension ERC4337\n * @example\n * ```ts\n * import { encodeGetUserOpHash } from \"thirdweb/extensions/erc4337\";\n * const result = encodeGetUserOpHash({\n *  userOp: ...,\n * });\n * ```\n */\nexport function encodeGetUserOpHash(options: GetUserOpHashParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeGetUserOpHashParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the getUserOpHash function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC4337\n * @example\n * ```ts\n * import { decodeGetUserOpHashResult } from \"thirdweb/extensions/erc4337\";\n * const result = decodeGetUserOpHashResultResult(\"...\");\n * ```\n */\nexport function decodeGetUserOpHashResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"getUserOpHash\" function on the contract.\n * @param options - The options for the getUserOpHash function.\n * @returns The parsed result of the function call.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getUserOpHash } from \"thirdweb/extensions/erc4337\";\n *\n * const result = await getUserOpHash({\n *  contract,\n *  userOp: ...,\n * });\n *\n * ```\n */\nexport async function getUserOpHash(\n  options: BaseTransactionOptions<GetUserOpHashParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.userOp],\n  });\n}\n","import { concat, type Hex, pad, toHex } from \"viem\";\nimport type { PackedUserOperation, UserOperationV07 } from \"../types.js\";\n\nfunction getInitCode(unpackedUserOperation: UserOperationV07) {\n  return unpackedUserOperation.factory\n    ? concat([\n        unpackedUserOperation.factory as Hex,\n        unpackedUserOperation.factoryData || (\"0x\" as Hex),\n      ])\n    : \"0x\";\n}\n\nfunction getAccountGasLimits(unpackedUserOperation: UserOperationV07) {\n  return concat([\n    pad(toHex(BigInt(unpackedUserOperation.verificationGasLimit)), {\n      size: 16,\n    }),\n    pad(toHex(BigInt(unpackedUserOperation.callGasLimit)), { size: 16 }),\n  ]) as Hex;\n}\n\nfunction getGasLimits(unpackedUserOperation: UserOperationV07) {\n  return concat([\n    pad(toHex(BigInt(unpackedUserOperation.maxPriorityFeePerGas)), {\n      size: 16,\n    }),\n    pad(toHex(BigInt(unpackedUserOperation.maxFeePerGas)), { size: 16 }),\n  ]) as Hex;\n}\n\nfunction getPaymasterAndData(unpackedUserOperation: UserOperationV07) {\n  return unpackedUserOperation.paymaster\n    ? concat([\n        unpackedUserOperation.paymaster as Hex,\n        pad(\n          toHex(\n            BigInt(unpackedUserOperation.paymasterVerificationGasLimit || 0),\n          ),\n          {\n            size: 16,\n          },\n        ),\n        pad(toHex(BigInt(unpackedUserOperation.paymasterPostOpGasLimit || 0)), {\n          size: 16,\n        }),\n        unpackedUserOperation.paymasterData || (\"0x\" as Hex),\n      ])\n    : \"0x\";\n}\n\nexport const getPackedUserOperation = (\n  userOperation: UserOperationV07,\n): PackedUserOperation => {\n  return {\n    accountGasLimits: getAccountGasLimits(userOperation),\n    callData: userOperation.callData,\n    gasFees: getGasLimits(userOperation),\n    initCode: getInitCode(userOperation),\n    nonce: BigInt(userOperation.nonce),\n    paymasterAndData: getPaymasterAndData(userOperation),\n    preVerificationGas: BigInt(userOperation.preVerificationGas),\n    sender: userOperation.sender,\n    signature: userOperation.signature,\n  };\n};\n","import type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport { hexToBigInt } from \"../../../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../../../utils/fetch.js\";\nimport { stringify } from \"../../../utils/json.js\";\nimport type {\n  PaymasterResult,\n  UserOperationV06,\n  UserOperationV07,\n} from \"../types.js\";\nimport { ENTRYPOINT_ADDRESS_v0_6, getDefaultBundlerUrl } from \"./constants.js\";\nimport { hexlifyUserOp } from \"./utils.js\";\n\n/**\n * Get paymaster and data details for a user operation.\n * @param args - The userOp and options\n * @returns - The paymaster and data details for the user operation.\n * @example\n * ```ts\n * import { getPaymasterAndData } from \"thirdweb/wallets/smart\";\n *\n * const userOp = createUnsignedUserOp(...);\n *\n * const paymasterAndData = await getPaymasterAndData({\n *  userOp,\n *  client,\n *  chain,\n * });\n * ```\n * @walletUtils\n */\nexport async function getPaymasterAndData(args: {\n  userOp: UserOperationV06 | UserOperationV07;\n  client: ThirdwebClient;\n  chain: Chain;\n  entrypointAddress?: string;\n  paymasterOverride?: (\n    userOp: UserOperationV06 | UserOperationV07,\n  ) => Promise<PaymasterResult>;\n}): Promise<PaymasterResult> {\n  const { userOp, paymasterOverride, client, chain, entrypointAddress } = args;\n\n  if (paymasterOverride) {\n    return paymasterOverride(userOp);\n  }\n\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/json\",\n  };\n\n  const entrypoint = entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6;\n  const paymasterUrl = getDefaultBundlerUrl(chain);\n\n  const body = {\n    id: 1,\n    jsonrpc: \"2.0\",\n    method: \"pm_sponsorUserOperation\",\n    params: [hexlifyUserOp(userOp), entrypoint],\n  };\n\n  // Ask the paymaster to sign the transaction and return a valid paymasterAndData value.\n  const fetchWithHeaders = getClientFetch(client);\n  const response = await fetchWithHeaders(paymasterUrl, {\n    body: stringify(body),\n    headers,\n    method: \"POST\",\n  });\n\n  if (!response.ok) {\n    const error = (await response.text()) || response.statusText;\n\n    throw new Error(`Paymaster error: ${response.status} - ${error}`);\n  }\n\n  const res = await response.json();\n\n  if (res.result) {\n    // some paymasters return a string, some return an object with more data\n    if (typeof res.result === \"string\") {\n      return {\n        paymasterAndData: res.result,\n      };\n    }\n    // check for policy errors\n    if (res.result.reason) {\n      console.warn(\n        `Paymaster policy rejected this transaction with reason: ${res.result.reason} ${res.result.policyId ? `(policyId: ${res.result.policyId})` : \"\"}`,\n      );\n    }\n\n    return {\n      callGasLimit: res.result.callGasLimit\n        ? hexToBigInt(res.result.callGasLimit)\n        : undefined,\n      paymaster: res.result.paymaster,\n      paymasterAndData: res.result.paymasterAndData,\n      paymasterData: res.result.paymasterData,\n      paymasterPostOpGasLimit: res.result.paymasterPostOpGasLimit\n        ? hexToBigInt(res.result.paymasterPostOpGasLimit)\n        : undefined,\n      paymasterVerificationGasLimit: res.result.paymasterVerificationGasLimit\n        ? hexToBigInt(res.result.paymasterVerificationGasLimit)\n        : undefined,\n      preVerificationGas: res.result.preVerificationGas\n        ? hexToBigInt(res.result.preVerificationGas)\n        : undefined,\n      verificationGasLimit: res.result.verificationGasLimit\n        ? hexToBigInt(res.result.verificationGasLimit)\n        : undefined,\n    };\n  }\n  const error =\n    res.error?.message || res.error || response.statusText || \"unknown error\";\n  throw new Error(`Paymaster error from ${paymasterUrl}: ${error}`);\n}\n","import { maxUint96 } from \"ox/Solidity\";\nimport { concat } from \"viem\";\nimport type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport {\n  getContract,\n  type ThirdwebContract,\n} from \"../../../contract/contract.js\";\nimport { getNonce } from \"../../../extensions/erc4337/__generated__/IEntryPoint/read/getNonce.js\";\nimport { getUserOpHash as getUserOpHashV06 } from \"../../../extensions/erc4337/__generated__/IEntryPoint/read/getUserOpHash.js\";\nimport { getUserOpHash as getUserOpHashV07 } from \"../../../extensions/erc4337/__generated__/IEntryPoint_v07/read/getUserOpHash.js\";\nimport { getDefaultGasOverrides } from \"../../../gas/fee-data.js\";\nimport { encode } from \"../../../transaction/actions/encode.js\";\nimport { toSerializableTransaction } from \"../../../transaction/actions/to-serializable-transaction.js\";\nimport type { PreparedTransaction } from \"../../../transaction/prepare-transaction.js\";\nimport type { TransactionReceipt } from \"../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../utils/abi/encodeAbiParameters.js\";\nimport { isContractDeployed } from \"../../../utils/bytecode/is-contract-deployed.js\";\nimport { type Hex, toHex } from \"../../../utils/encoding/hex.js\";\nimport { hexToBytes } from \"../../../utils/encoding/to-bytes.js\";\nimport { isThirdwebUrl } from \"../../../utils/fetch.js\";\nimport { keccak256 } from \"../../../utils/hashing/keccak256.js\";\nimport { stringify } from \"../../../utils/json.js\";\nimport { resolvePromisedValue } from \"../../../utils/promise/resolve-promised-value.js\";\nimport type { Account } from \"../../interfaces/wallet.js\";\nimport { getEntrypointFromFactory } from \"../index.js\";\nimport type {\n  BundlerOptions,\n  PaymasterResult,\n  SmartWalletOptions,\n  UserOperationV06,\n  UserOperationV07,\n} from \"../types.js\";\nimport {\n  estimateUserOpGas,\n  getUserOpGasFees,\n  getUserOpReceipt,\n} from \"./bundler.js\";\nimport {\n  predictAddress,\n  prepareBatchExecute,\n  prepareCreateAccount,\n  prepareExecute,\n} from \"./calls.js\";\nimport {\n  DUMMY_SIGNATURE,\n  ENTRYPOINT_ADDRESS_v0_6,\n  ENTRYPOINT_ADDRESS_v0_7,\n  getDefaultAccountFactory,\n  getDefaultBundlerUrl,\n  getEntryPointVersion,\n} from \"./constants.js\";\nimport { getPackedUserOperation } from \"./packUserOp.js\";\nimport { getPaymasterAndData } from \"./paymaster.js\";\nimport { generateRandomUint192 } from \"./utils.js\";\n\nconst isDeployingSet: Set<string> = new Set();\n\nconst getKey = (accountContract: ThirdwebContract) => {\n  return `${accountContract.chain.id}:${accountContract.address}`;\n};\n\nconst markAccountDeploying = (accountContract: ThirdwebContract) => {\n  isDeployingSet.add(getKey(accountContract));\n};\n\nexport const clearAccountDeploying = (accountContract: ThirdwebContract) => {\n  isDeployingSet.delete(getKey(accountContract));\n};\n\nconst isAccountDeploying = (accountContract: ThirdwebContract) => {\n  return isDeployingSet.has(getKey(accountContract));\n};\n\n/**\n * Wait for the user operation to be mined.\n * @param args - The options and user operation hash\n * @returns - The transaction receipt\n *\n * @example\n * ```ts\n * import { waitForUserOpReceipt } from \"thirdweb/wallets/smart\";\n *\n * const receipt = await waitForUserOpReceipt({\n *  chain,\n *  client,\n *  userOpHash,\n * });\n * ```\n * @walletUtils\n */\nexport async function waitForUserOpReceipt(\n  args: BundlerOptions & {\n    userOpHash: Hex;\n    timeoutMs?: number;\n    intervalMs?: number;\n  },\n): Promise<TransactionReceipt> {\n  const timeout = args.timeoutMs || 120000; // 2mins\n  const interval = args.intervalMs || 1000; // 1s\n  const endtime = Date.now() + timeout;\n  while (Date.now() < endtime) {\n    const userOpReceipt = await getUserOpReceipt(args);\n    if (userOpReceipt) {\n      return userOpReceipt;\n    }\n    await new Promise((resolve) => setTimeout(resolve, interval));\n  }\n  throw new Error(\n    `Timeout waiting for userOp to be mined on chain ${args.chain.id} with UserOp hash: ${args.userOpHash}`,\n  );\n}\n\n/**\n * Creates an unsigned user operation from a prepared transaction.\n * @param args - The prepared transaction and options\n * @returns - The unsigned user operation\n * @example\n * ```ts\n * import { createUnsignedUserOp } from \"thirdweb/wallets/smart\";\n *\n * const transaction = prepareContractCall(...);\n *\n * const userOp = await createUnsignedUserOp({\n *  transaction,\n *  factoryContract,\n *  accountContract,\n *  adminAddress,\n *  sponsorGas,\n *  overrides,\n * });\n * ```\n * @walletUtils\n */\nexport async function createUnsignedUserOp(args: {\n  transaction: PreparedTransaction;\n  factoryContract: ThirdwebContract;\n  accountContract: ThirdwebContract;\n  adminAddress: string;\n  sponsorGas: boolean;\n  waitForDeployment?: boolean;\n  isDeployedOverride?: boolean;\n  overrides?: SmartWalletOptions[\"overrides\"];\n}): Promise<UserOperationV06 | UserOperationV07> {\n  const {\n    transaction: executeTx,\n    accountContract,\n    factoryContract,\n    adminAddress,\n    overrides,\n    sponsorGas,\n    waitForDeployment = true,\n    isDeployedOverride,\n  } = args;\n  const chain = executeTx.chain;\n  const client = executeTx.client;\n\n  const bundlerOptions = {\n    bundlerUrl: overrides?.bundlerUrl,\n    chain,\n    client,\n    entrypointAddress: overrides?.entrypointAddress,\n  };\n\n  const entrypointVersion = getEntryPointVersion(\n    args.overrides?.entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n  );\n\n  const [isDeployed, callData, callGasLimit, gasFees, nonce] =\n    await Promise.all([\n      typeof isDeployedOverride === \"boolean\"\n        ? isDeployedOverride\n        : isContractDeployed(accountContract).then(\n            (isDeployed) => isDeployed || isAccountDeploying(accountContract),\n          ),\n      encode(executeTx),\n      resolvePromisedValue(executeTx.gas),\n      getGasFees({\n        bundlerOptions,\n        chain,\n        client,\n        executeTx,\n      }),\n      getAccountNonce({\n        accountContract,\n        chain,\n        client,\n        entrypointAddress: overrides?.entrypointAddress,\n        getNonceOverride: overrides?.getAccountNonce,\n      }),\n    ]);\n\n  const { maxFeePerGas, maxPriorityFeePerGas } = gasFees;\n\n  if (entrypointVersion === \"v0.7\") {\n    return populateUserOp_v0_7({\n      accountContract,\n      adminAddress,\n      bundlerOptions,\n      callData,\n      callGasLimit,\n      factoryContract,\n      isDeployed,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      overrides,\n      sponsorGas,\n      waitForDeployment,\n    });\n  }\n\n  // default to v0.6\n  return populateUserOp_v0_6({\n    accountContract,\n    adminAddress,\n    bundlerOptions,\n    callData,\n    callGasLimit,\n    factoryContract,\n    isDeployed,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    overrides,\n    sponsorGas,\n    waitForDeployment,\n  });\n}\n\nasync function getGasFees(args: {\n  executeTx: PreparedTransaction;\n  bundlerOptions: BundlerOptions;\n  chain: Chain;\n  client: ThirdwebClient;\n}): Promise<{\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n}> {\n  const { executeTx, bundlerOptions, chain, client } = args;\n  let { maxFeePerGas, maxPriorityFeePerGas } = executeTx;\n\n  const bundlerUrl = bundlerOptions?.bundlerUrl ?? getDefaultBundlerUrl(chain);\n\n  if (isThirdwebUrl(bundlerUrl)) {\n    // get gas prices from bundler\n    const bundlerGasPrice = await getUserOpGasFees({\n      options: bundlerOptions,\n    });\n    maxFeePerGas = bundlerGasPrice.maxFeePerGas;\n    maxPriorityFeePerGas = bundlerGasPrice.maxPriorityFeePerGas;\n  } else {\n    // Check for explicity values\n    const [resolvedMaxFeePerGas, resolvedMaxPriorityFeePerGas] =\n      await Promise.all([\n        resolvePromisedValue(maxFeePerGas),\n        resolvePromisedValue(maxPriorityFeePerGas),\n      ]);\n\n    if (resolvedMaxFeePerGas && resolvedMaxPriorityFeePerGas) {\n      // Save a network call if the values are provided\n      maxFeePerGas = resolvedMaxFeePerGas;\n      maxPriorityFeePerGas = resolvedMaxPriorityFeePerGas;\n    } else {\n      // Fallback to RPC gas prices if no explicit values provided\n      const feeData = await getDefaultGasOverrides(client, chain);\n\n      // Still check for explicit values in case one is provided and not the other\n      maxPriorityFeePerGas =\n        resolvedMaxPriorityFeePerGas ?? feeData.maxPriorityFeePerGas ?? 0n;\n      maxFeePerGas = resolvedMaxFeePerGas ?? feeData.maxFeePerGas ?? 0n;\n    }\n  }\n  return { maxFeePerGas, maxPriorityFeePerGas };\n}\n\nasync function populateUserOp_v0_7(args: {\n  bundlerOptions: BundlerOptions;\n  factoryContract: ThirdwebContract;\n  accountContract: ThirdwebContract;\n  adminAddress: string;\n  sponsorGas: boolean;\n  overrides?: SmartWalletOptions[\"overrides\"];\n  isDeployed: boolean;\n  nonce: bigint;\n  callData: Hex;\n  callGasLimit?: bigint;\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n  waitForDeployment: boolean;\n}): Promise<UserOperationV07> {\n  const {\n    bundlerOptions,\n    isDeployed,\n    factoryContract,\n    accountContract,\n    adminAddress,\n    sponsorGas,\n    overrides,\n    nonce,\n    callData,\n    callGasLimit,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    waitForDeployment,\n  } = args;\n  const { chain, client } = bundlerOptions;\n\n  let factory: string | undefined;\n  let factoryData: Hex;\n  if (isDeployed) {\n    factoryData = \"0x\";\n    if (waitForDeployment) {\n      // lock until account is deployed if needed to avoid 'sender already created' errors when sending multiple transactions in parallel\n      await waitForAccountDeployed(accountContract);\n    }\n  } else {\n    factory = factoryContract.address;\n    factoryData = await encode(\n      prepareCreateAccount({\n        accountSalt: overrides?.accountSalt,\n        adminAddress,\n        createAccountOverride: overrides?.createAccount,\n        factoryContract: factoryContract,\n      }),\n    );\n    if (waitForDeployment) {\n      markAccountDeploying(accountContract);\n    }\n  }\n\n  const partialOp: UserOperationV07 = {\n    callData,\n    callGasLimit: callGasLimit ?? 0n,\n    factory,\n    factoryData,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    paymaster: undefined,\n    paymasterData: \"0x\",\n    paymasterPostOpGasLimit: 0n,\n    paymasterVerificationGasLimit: 0n,\n    preVerificationGas: 0n,\n    sender: accountContract.address,\n    signature: DUMMY_SIGNATURE,\n    verificationGasLimit: 0n,\n  };\n\n  if (sponsorGas) {\n    const paymasterResult = (await getPaymasterAndData({\n      chain,\n      client,\n      entrypointAddress: overrides?.entrypointAddress,\n      paymasterOverride: overrides?.paymaster,\n      userOp: partialOp,\n    })) as Extract<PaymasterResult, { paymaster: string }>;\n    if (paymasterResult.paymaster && paymasterResult.paymasterData) {\n      partialOp.paymaster = paymasterResult.paymaster;\n      partialOp.paymasterData = paymasterResult.paymasterData as Hex;\n    }\n    // paymaster can have the gas limits in the response\n    if (\n      paymasterResult.callGasLimit &&\n      paymasterResult.verificationGasLimit &&\n      paymasterResult.preVerificationGas &&\n      paymasterResult.paymasterPostOpGasLimit &&\n      paymasterResult.paymasterVerificationGasLimit\n    ) {\n      partialOp.callGasLimit = paymasterResult.callGasLimit;\n      partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;\n      partialOp.preVerificationGas = paymasterResult.preVerificationGas;\n      partialOp.paymasterPostOpGasLimit =\n        paymasterResult.paymasterPostOpGasLimit;\n      partialOp.paymasterVerificationGasLimit =\n        paymasterResult.paymasterVerificationGasLimit;\n    } else {\n      // otherwise fallback to bundler for gas limits\n      const stateOverrides = overrides?.tokenPaymaster\n        ? {\n            [overrides.tokenPaymaster.tokenAddress]: {\n              stateDiff: {\n                [keccak256(\n                  encodeAbiParameters(\n                    [{ type: \"address\" }, { type: \"uint256\" }],\n                    [\n                      accountContract.address,\n                      overrides.tokenPaymaster.balanceStorageSlot,\n                    ],\n                  ),\n                )]: toHex(maxUint96, { size: 32 }),\n              },\n            },\n          }\n        : undefined;\n      const estimates = await estimateUserOpGas(\n        {\n          options: bundlerOptions,\n          userOp: partialOp,\n        },\n        stateOverrides,\n      );\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n      partialOp.paymasterPostOpGasLimit = overrides?.tokenPaymaster\n        ? 500000n // TODO: estimate this better, needed if there's an extra swap needed in the paymaster\n        : estimates.paymasterPostOpGasLimit || 0n;\n      partialOp.paymasterVerificationGasLimit =\n        estimates.paymasterVerificationGasLimit || 0n;\n      // need paymaster to re-sign after estimates\n      const paymasterResult2 = (await getPaymasterAndData({\n        chain,\n        client,\n        entrypointAddress: overrides?.entrypointAddress,\n        paymasterOverride: overrides?.paymaster,\n        userOp: partialOp,\n      })) as Extract<PaymasterResult, { paymaster: string }>;\n      if (paymasterResult2.paymaster && paymasterResult2.paymasterData) {\n        partialOp.paymaster = paymasterResult2.paymaster;\n        partialOp.paymasterData = paymasterResult2.paymasterData as Hex;\n      }\n    }\n  } else {\n    // not gasless, so we just need to estimate gas limits\n    const estimates = await estimateUserOpGas({\n      options: bundlerOptions,\n      userOp: partialOp,\n    });\n    partialOp.callGasLimit = estimates.callGasLimit;\n    partialOp.verificationGasLimit = estimates.verificationGasLimit;\n    partialOp.preVerificationGas = estimates.preVerificationGas;\n    partialOp.paymasterPostOpGasLimit = estimates.paymasterPostOpGasLimit || 0n;\n    partialOp.paymasterVerificationGasLimit =\n      estimates.paymasterVerificationGasLimit || 0n;\n  }\n  return {\n    ...partialOp,\n    signature: \"0x\" as Hex,\n  };\n}\n\nasync function populateUserOp_v0_6(args: {\n  bundlerOptions: BundlerOptions;\n  factoryContract: ThirdwebContract;\n  accountContract: ThirdwebContract;\n  adminAddress: string;\n  sponsorGas: boolean;\n  overrides?: SmartWalletOptions[\"overrides\"];\n  isDeployed: boolean;\n  nonce: bigint;\n  callData: Hex;\n  callGasLimit?: bigint;\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n  waitForDeployment: boolean;\n}): Promise<UserOperationV06> {\n  const {\n    bundlerOptions,\n    isDeployed,\n    factoryContract,\n    accountContract,\n    adminAddress,\n    sponsorGas,\n    overrides,\n    nonce,\n    callData,\n    callGasLimit,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    waitForDeployment,\n  } = args;\n  const { chain, client } = bundlerOptions;\n  let initCode: Hex;\n\n  if (isDeployed) {\n    initCode = \"0x\";\n    if (waitForDeployment) {\n      // lock until account is deployed if needed to avoid 'sender already created' errors when sending multiple transactions in parallel\n      await waitForAccountDeployed(accountContract);\n    }\n  } else {\n    initCode = await getAccountInitCode({\n      accountSalt: overrides?.accountSalt,\n      adminAddress,\n      createAccountOverride: overrides?.createAccount,\n      factoryContract: factoryContract,\n    });\n    if (waitForDeployment) {\n      markAccountDeploying(accountContract);\n    }\n  }\n\n  const partialOp: UserOperationV06 = {\n    callData,\n    callGasLimit: callGasLimit ?? 0n,\n    initCode,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    paymasterAndData: \"0x\",\n    preVerificationGas: 0n,\n    sender: accountContract.address,\n    signature: DUMMY_SIGNATURE,\n    verificationGasLimit: 0n,\n  };\n\n  if (sponsorGas) {\n    const paymasterResult = await getPaymasterAndData({\n      chain,\n      client,\n      entrypointAddress: overrides?.entrypointAddress,\n      paymasterOverride: overrides?.paymaster,\n      userOp: partialOp,\n    });\n    const paymasterAndData =\n      \"paymasterAndData\" in paymasterResult\n        ? paymasterResult.paymasterAndData\n        : \"0x\";\n    if (paymasterAndData && paymasterAndData !== \"0x\") {\n      partialOp.paymasterAndData = paymasterAndData as Hex;\n    }\n    // paymaster can have the gas limits in the response\n    if (\n      paymasterResult.callGasLimit &&\n      paymasterResult.verificationGasLimit &&\n      paymasterResult.preVerificationGas\n    ) {\n      partialOp.callGasLimit = paymasterResult.callGasLimit;\n      partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;\n      partialOp.preVerificationGas = paymasterResult.preVerificationGas;\n    } else {\n      // otherwise fallback to bundler for gas limits\n      const estimates = await estimateUserOpGas({\n        options: bundlerOptions,\n        userOp: partialOp,\n      });\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n      // need paymaster to re-sign after estimates\n      if (paymasterAndData && paymasterAndData !== \"0x\") {\n        const paymasterResult2 = await getPaymasterAndData({\n          chain,\n          client,\n          entrypointAddress: overrides?.entrypointAddress,\n          paymasterOverride: overrides?.paymaster,\n          userOp: partialOp,\n        });\n        const paymasterAndData2 =\n          \"paymasterAndData\" in paymasterResult2\n            ? paymasterResult2.paymasterAndData\n            : \"0x\";\n        if (paymasterAndData2 && paymasterAndData2 !== \"0x\") {\n          partialOp.paymasterAndData = paymasterAndData2 as Hex;\n        }\n      }\n    }\n  } else {\n    // not gasless, so we just need to estimate gas limits\n    const estimates = await estimateUserOpGas({\n      options: bundlerOptions,\n      userOp: partialOp,\n    });\n    partialOp.callGasLimit = estimates.callGasLimit;\n    partialOp.verificationGasLimit = estimates.verificationGasLimit;\n    partialOp.preVerificationGas = estimates.preVerificationGas;\n  }\n  return {\n    ...partialOp,\n    signature: \"0x\" as Hex,\n  };\n}\n\n/**\n * Sign a user operation.\n * @param userOp - The UserOperation to sign (with signature field ignored)\n * @returns - The user operation with the signature field populated\n * @example\n * ```ts\n * import { signUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOp = await createUnsignedUserOp(...);\n *\n * const signedUserOp = await signUserOp({\n *  client,\n *  userOp,\n *  chain,\n *  adminAccount,\n * });\n * ```\n * @walletUtils\n */\nexport async function signUserOp(args: {\n  client: ThirdwebClient;\n  userOp: UserOperationV06 | UserOperationV07;\n  chain: Chain;\n  entrypointAddress?: string;\n  adminAccount: Account;\n}): Promise<UserOperationV06 | UserOperationV07> {\n  const { userOp, chain, entrypointAddress, adminAccount } = args;\n\n  const userOpHash = await getUserOpHash({\n    chain,\n    client: args.client,\n    entrypointAddress,\n    userOp,\n  });\n\n  if (adminAccount.signMessage) {\n    const signature = await adminAccount.signMessage({\n      chainId: chain.id,\n      message: {\n        raw: hexToBytes(userOpHash),\n      },\n      originalMessage: stringify(userOp),\n    });\n    return {\n      ...userOp,\n      signature,\n    };\n  }\n  throw new Error(\"signMessage not implemented in signingAccount\");\n}\n\n/**\n * Get the hash of a user operation.\n * @param args - The options for getting the user operation hash\n * @returns - The user operation hash\n * @example\n * ```ts\n * import { getUserOpHash } from \"thirdweb/wallets/smart\";\n *\n * const userOp = await createUnsignedUserOp(...);\n * const userOpHash = await getUserOpHash({\n *  client,\n *  userOp,\n *  chain,\n * });\n * ```\n * @walletUtils\n */\nexport async function getUserOpHash(args: {\n  client: ThirdwebClient;\n  userOp: UserOperationV06 | UserOperationV07;\n  chain: Chain;\n  entrypointAddress?: string;\n}): Promise<Hex> {\n  const { userOp, chain, entrypointAddress } = args;\n\n  const entrypointVersion = getEntryPointVersion(\n    entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n  );\n\n  let userOpHash: Hex;\n\n  if (entrypointVersion === \"v0.7\") {\n    const packedUserOp = getPackedUserOperation(userOp as UserOperationV07);\n    userOpHash = await getUserOpHashV07({\n      contract: getContract({\n        address: entrypointAddress || ENTRYPOINT_ADDRESS_v0_7,\n        chain,\n        client: args.client,\n      }),\n      userOp: packedUserOp,\n    });\n  } else {\n    userOpHash = await getUserOpHashV06({\n      contract: getContract({\n        address: entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n        chain,\n        client: args.client,\n      }),\n      userOp: userOp as UserOperationV06,\n    });\n  }\n  return userOpHash;\n}\n\nasync function getAccountInitCode(options: {\n  factoryContract: ThirdwebContract;\n  adminAddress: string;\n  accountSalt?: string;\n  createAccountOverride?: (\n    factoryContract: ThirdwebContract,\n    adminAddress: string,\n  ) => PreparedTransaction;\n}): Promise<Hex> {\n  const { factoryContract, adminAddress, accountSalt, createAccountOverride } =\n    options;\n  const deployTx = prepareCreateAccount({\n    accountSalt,\n    adminAddress,\n    createAccountOverride,\n    factoryContract,\n  });\n  return concat([factoryContract.address as Hex, await encode(deployTx)]);\n}\n\nasync function getAccountNonce(options: {\n  accountContract: ThirdwebContract;\n  chain: Chain;\n  client: ThirdwebClient;\n  entrypointAddress?: string;\n  getNonceOverride?: (accountContract: ThirdwebContract) => Promise<bigint>;\n}): Promise<bigint> {\n  const {\n    accountContract,\n    chain,\n    client,\n    entrypointAddress,\n    getNonceOverride,\n  } = options;\n  if (getNonceOverride) {\n    return getNonceOverride(accountContract);\n  }\n  return await getNonce({\n    contract: getContract({\n      address: entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n      chain,\n      client,\n    }),\n    key: generateRandomUint192(),\n    sender: accountContract.address,\n  });\n}\n\n/**\n * Create and sign a user operation.\n * @param options - The options for creating and signing the user operation\n * @returns - The signed user operation\n * @example\n * ```ts\n * import { createAndSignUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOp = await createAndSignUserOp({\n *  client,\n *  adminAccount,\n *  smartWalletOptions,\n *  transactions,\n * });\n * ```\n * @walletUtils\n */\nexport async function createAndSignUserOp(options: {\n  transactions: PreparedTransaction[];\n  adminAccount: Account;\n  client: ThirdwebClient;\n  smartWalletOptions: SmartWalletOptions;\n  waitForDeployment?: boolean;\n  isDeployedOverride?: boolean;\n}) {\n  // if factory is passed, but no entrypoint, try to resolve entrypoint from factory\n  if (\n    options.smartWalletOptions.factoryAddress &&\n    !options.smartWalletOptions.overrides?.entrypointAddress\n  ) {\n    const entrypointAddress = await getEntrypointFromFactory(\n      options.smartWalletOptions.factoryAddress,\n      options.client,\n      options.smartWalletOptions.chain,\n    );\n    if (entrypointAddress) {\n      options.smartWalletOptions.overrides = {\n        ...options.smartWalletOptions.overrides,\n        entrypointAddress,\n      };\n    }\n  }\n  const unsignedUserOp = await prepareUserOp({\n    adminAccount: options.adminAccount,\n    client: options.client,\n    isDeployedOverride: options.isDeployedOverride,\n    smartWalletOptions: options.smartWalletOptions,\n    transactions: options.transactions,\n    waitForDeployment: options.waitForDeployment,\n  });\n  const signedUserOp = await signUserOp({\n    adminAccount: options.adminAccount,\n    chain: options.smartWalletOptions.chain,\n    client: options.client,\n    entrypointAddress: options.smartWalletOptions.overrides?.entrypointAddress,\n    userOp: unsignedUserOp,\n  });\n  return signedUserOp;\n}\n\n/**\n * Prepare a user operation for signing.\n * @param options - The options for preparing the user operation\n * @returns - The prepared user operation\n * @example\n * ```ts\n * import { prepareUserOp } from \"thirdweb/wallets/smart\";\n *\n * const userOp = await prepareUserOp({\n *  transactions,\n *  adminAccount,\n *  client,\n *  smartWalletOptions,\n * });\n * ```\n *\n * You can then sign the user operation with signUserOp(). and send it to the bundler with bundlerUserOp().\n * @walletUtils\n */\nexport async function prepareUserOp(options: {\n  transactions: PreparedTransaction[];\n  adminAccount: Account;\n  client: ThirdwebClient;\n  smartWalletOptions: SmartWalletOptions;\n  waitForDeployment?: boolean;\n  isDeployedOverride?: boolean;\n}) {\n  const config = options.smartWalletOptions;\n  const factoryContract = getContract({\n    address:\n      config.factoryAddress ||\n      getDefaultAccountFactory(config.overrides?.entrypointAddress),\n    chain: config.chain,\n    client: options.client,\n  });\n  const accountAddress = await predictAddress({\n    accountAddress: config.overrides?.accountAddress,\n    accountSalt: config.overrides?.accountSalt,\n    adminAddress: options.adminAccount.address,\n    factoryContract,\n    predictAddressOverride: config.overrides?.predictAddress,\n  });\n  const accountContract = getContract({\n    address: accountAddress,\n    chain: config.chain,\n    client: options.client,\n  });\n\n  let executeTx: PreparedTransaction;\n  if (options.transactions.length === 1) {\n    const tx = options.transactions[0] as PreparedTransaction;\n    // for single tx, simulate fully\n    const serializedTx = await toSerializableTransaction({\n      from: accountAddress,\n      transaction: tx,\n    });\n    executeTx = prepareExecute({\n      accountContract,\n      executeOverride: config.overrides?.execute,\n      transaction: serializedTx,\n    });\n  } else {\n    // for multiple txs, we can't simulate, just encode\n    const serializedTxs = await Promise.all(\n      options.transactions.map(async (tx) => {\n        const [data, to, value] = await Promise.all([\n          encode(tx),\n          resolvePromisedValue(tx.to),\n          resolvePromisedValue(tx.value),\n        ]);\n        return {\n          chainId: tx.chain.id,\n          data,\n          to,\n          value,\n        };\n      }),\n    );\n    executeTx = prepareBatchExecute({\n      accountContract,\n      executeBatchOverride: config.overrides?.executeBatch,\n      transactions: serializedTxs,\n    });\n  }\n\n  return createUnsignedUserOp({\n    accountContract,\n    adminAddress: options.adminAccount.address,\n    factoryContract,\n    isDeployedOverride: options.isDeployedOverride,\n    overrides: config.overrides,\n    sponsorGas: \"sponsorGas\" in config ? config.sponsorGas : config.gasless,\n    transaction: executeTx,\n    waitForDeployment: options.waitForDeployment,\n  });\n}\n\nasync function waitForAccountDeployed(accountContract: ThirdwebContract) {\n  const startTime = Date.now();\n  while (isAccountDeploying(accountContract)) {\n    if (Date.now() - startTime > 60000) {\n      clearAccountDeploying(accountContract); // clear the flag so it doesnt stay stuck in this state\n      throw new Error(\n        \"Account deployment is taking too long (over 1 minute). Please try again.\",\n      );\n    }\n    await new Promise((resolve) => setTimeout(resolve, 500));\n  }\n}\n","import type * as ox__TypedData from \"ox/TypedData\";\nimport { isInsufficientFundsError } from \"../../analytics/track/helpers.js\";\nimport {\n  trackInsufficientFundsError,\n  trackTransaction,\n} from \"../../analytics/track/transaction.js\";\nimport type { Chain } from \"../../chains/types.js\";\nimport { getCachedChain } from \"../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { getContract, type ThirdwebContract } from \"../../contract/contract.js\";\nimport { allowance } from \"../../extensions/erc20/__generated__/IERC20/read/allowance.js\";\nimport { approve } from \"../../extensions/erc20/write/approve.js\";\nimport {\n  addSessionKey,\n  shouldUpdateSessionKey,\n} from \"../../extensions/erc4337/account/addSessionKey.js\";\nimport { sendTransaction } from \"../../transaction/actions/send-transaction.js\";\nimport { toSerializableTransaction } from \"../../transaction/actions/to-serializable-transaction.js\";\nimport type { WaitForReceiptOptions } from \"../../transaction/actions/wait-for-tx-receipt.js\";\nimport {\n  populateEip712Transaction,\n  signEip712Transaction,\n} from \"../../transaction/actions/zksync/send-eip712-transaction.js\";\nimport type { PreparedTransaction } from \"../../transaction/prepare-transaction.js\";\nimport { readContract } from \"../../transaction/read-contract.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { isZkSyncChain } from \"../../utils/any-evm/zksync/isZkSyncChain.js\";\nimport type { Hex } from \"../../utils/encoding/hex.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parse-typed-data.js\";\nimport { maxUint96, type SignableMessage } from \"../../utils/types.js\";\nimport type { Account, SendTransactionOption } from \"../interfaces/wallet.js\";\nimport {\n  broadcastZkTransaction,\n  bundleUserOp,\n  getZkPaymasterData,\n} from \"./lib/bundler.js\";\nimport {\n  predictAddress,\n  prepareBatchExecute,\n  prepareExecute,\n} from \"./lib/calls.js\";\nimport {\n  ENTRYPOINT_ADDRESS_v0_6,\n  ENTRYPOINT_ADDRESS_v0_7,\n  getDefaultAccountFactory,\n  getEntryPointVersion,\n} from \"./lib/constants.js\";\nimport {\n  clearAccountDeploying,\n  createUnsignedUserOp,\n  signUserOp,\n  waitForUserOpReceipt,\n} from \"./lib/userop.js\";\nimport type {\n  BundlerOptions,\n  PaymasterResult,\n  SmartAccountOptions,\n  SmartWalletConnectionOptions,\n  SmartWalletOptions,\n  TokenPaymasterConfig,\n  UserOperationV06,\n  UserOperationV07,\n} from \"./types.js\";\n\nexport { isSmartWallet } from \"./is-smart-wallet.js\";\n\n/**\n * For in-app wallets, the smart wallet creation is implicit so we track these to be able to retrieve the personal account for a smart account on the wallet API.\n * Note: We have to go account to account here and NOT wallet to account because the smart wallet itself is never exposed to the in-app wallet, only the account.\n * @internal\n */\nconst adminAccountToSmartAccountMap = new WeakMap<Account, Account>();\nconst smartAccountToAdminAccountMap = new WeakMap<Account, Account>();\n\n/**\n * @internal\n */\nexport async function connectSmartAccount(\n  connectionOptions: SmartWalletConnectionOptions,\n  creationOptions: SmartWalletOptions,\n): Promise<[Account, Chain]> {\n  const { personalAccount, client } = connectionOptions;\n\n  if (!personalAccount) {\n    throw new Error(\n      \"No personal account provided for smart account connection\",\n    );\n  }\n\n  const options = creationOptions;\n  const chain = creationOptions.chain;\n  const sponsorGas =\n    \"gasless\" in options ? options.gasless : options.sponsorGas;\n  if (await isZkSyncChain(chain)) {\n    return [\n      createZkSyncAccount({\n        chain,\n        connectionOptions,\n        creationOptions,\n        sponsorGas,\n      }),\n      chain,\n    ];\n  }\n\n  // if factory is passed, but no entrypoint, try to resolve entrypoint from factory\n  if (options.factoryAddress && !options.overrides?.entrypointAddress) {\n    const entrypointAddress = await getEntrypointFromFactory(\n      options.factoryAddress,\n      client,\n      chain,\n    );\n    if (entrypointAddress) {\n      options.overrides = {\n        ...options.overrides,\n        entrypointAddress,\n      };\n    }\n  }\n\n  if (\n    options.overrides?.tokenPaymaster &&\n    !options.overrides?.entrypointAddress\n  ) {\n    // if token paymaster is set, but no entrypoint address, set the entrypoint address to v0.7\n    options.overrides = {\n      ...options.overrides,\n      entrypointAddress: ENTRYPOINT_ADDRESS_v0_7,\n    };\n  }\n\n  const factoryAddress =\n    options.factoryAddress ??\n    getDefaultAccountFactory(options.overrides?.entrypointAddress);\n\n  const factoryContract = getContract({\n    address: factoryAddress,\n    chain: chain,\n    client: client,\n  });\n\n  const accountAddress = await predictAddress({\n    accountAddress: options.overrides?.accountAddress,\n    accountSalt: options.overrides?.accountSalt,\n    adminAddress: personalAccount.address,\n    factoryContract,\n    predictAddressOverride: options.overrides?.predictAddress,\n  })\n    .then((address) => address)\n    .catch((err) => {\n      throw new Error(\n        `Failed to get account address with factory contract ${factoryContract.address} on chain ID ${chain.id}: ${err?.message || \"unknown error\"}`,\n        { cause: err },\n      );\n    });\n\n  const accountContract = getContract({\n    address: accountAddress,\n    chain,\n    client,\n  });\n\n  const account = await createSmartAccount({\n    ...options,\n    accountContract,\n    chain,\n    client,\n    factoryContract,\n    personalAccount,\n    sponsorGas,\n  });\n\n  adminAccountToSmartAccountMap.set(personalAccount, account);\n  smartAccountToAdminAccountMap.set(account, personalAccount);\n\n  if (options.sessionKey) {\n    if (\n      await shouldUpdateSessionKey({\n        accountContract,\n        newPermissions: options.sessionKey.permissions,\n        sessionKeyAddress: options.sessionKey.address,\n      })\n    ) {\n      const transaction = addSessionKey({\n        account: personalAccount,\n        contract: accountContract,\n        permissions: options.sessionKey.permissions,\n        sessionKeyAddress: options.sessionKey.address,\n      });\n      await sendTransaction({\n        account: account,\n        transaction,\n      });\n    }\n  }\n\n  return [account, chain] as const;\n}\n\n/**\n * @internal\n */\nexport async function disconnectSmartAccount(account: Account): Promise<void> {\n  // look up the personalAccount for the smart wallet\n  const personalAccount = smartAccountToAdminAccountMap.get(account);\n  if (personalAccount) {\n    // remove the mappings\n    adminAccountToSmartAccountMap.delete(personalAccount);\n    smartAccountToAdminAccountMap.delete(account);\n  }\n}\n\nasync function createSmartAccount(\n  options: SmartAccountOptions,\n): Promise<Account> {\n  const erc20Paymaster = options.overrides?.tokenPaymaster;\n  if (erc20Paymaster) {\n    if (\n      getEntryPointVersion(\n        options.overrides?.entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n      ) !== \"v0.7\"\n    ) {\n      throw new Error(\n        \"Token paymaster is only supported for entrypoint version v0.7\",\n      );\n    }\n  }\n  const sponsorGas = options.sponsorGas;\n  let accountContract = options.accountContract;\n  const account: Account = {\n    address: getAddress(accountContract.address),\n    async onTransactionRequested(transaction) {\n      return options.personalAccount.onTransactionRequested?.(transaction);\n    },\n    async sendBatchTransaction(transactions: SendTransactionOption[]) {\n      const executeTx = prepareBatchExecute({\n        accountContract,\n        executeBatchOverride: options.overrides?.executeBatch,\n        transactions,\n      });\n      if (transactions.length === 0) {\n        throw new Error(\"No transactions to send\");\n      }\n      const firstTx = transactions[0];\n      if (!firstTx) {\n        throw new Error(\"No transactions to send\");\n      }\n      const chain = getCachedChain(firstTx.chainId);\n      const result = await _sendUserOp({\n        executeTx,\n        options: {\n          ...options,\n          accountContract,\n          chain,\n        },\n      });\n      trackTransaction({\n        chainId: chain.id,\n        client: options.client,\n        contractAddress: transactions[0]?.to ?? undefined,\n        transactionHash: result.transactionHash,\n        walletAddress: options.accountContract.address,\n        walletType: \"smart\",\n      });\n      return result;\n    },\n    async sendTransaction(transaction: SendTransactionOption) {\n      // if erc20 paymaster - check allowance and approve if needed\n      let paymasterOverride:\n        | undefined\n        | ((\n            userOp: UserOperationV06 | UserOperationV07,\n          ) => Promise<PaymasterResult>);\n      if (erc20Paymaster) {\n        await approveERC20({\n          accountContract,\n          erc20Paymaster,\n          options,\n        });\n        const paymasterCallback = async (): Promise<PaymasterResult> => {\n          return {\n            paymaster: erc20Paymaster.paymasterAddress as Hex,\n            paymasterData: \"0x\",\n          };\n        };\n        paymasterOverride = options.overrides?.paymaster || paymasterCallback;\n      } else {\n        paymasterOverride = options.overrides?.paymaster;\n      }\n\n      // If this transaction is for a different chain than the initial one, get the account contract for that chain\n      if (transaction.chainId !== accountContract.chain.id) {\n        accountContract = getContract({\n          address: account.address,\n          chain: getCachedChain(transaction.chainId),\n          client: options.client,\n        });\n      }\n\n      const executeTx = prepareExecute({\n        accountContract: accountContract,\n        executeOverride: options.overrides?.execute,\n        transaction,\n      });\n\n      const chain = getCachedChain(transaction.chainId);\n      const result = await _sendUserOp({\n        executeTx,\n        options: {\n          ...options,\n          accountContract,\n          chain,\n          overrides: {\n            ...options.overrides,\n            paymaster: paymasterOverride,\n          },\n        },\n      });\n      trackTransaction({\n        chainId: chain.id,\n        client: options.client,\n        contractAddress: transaction.to ?? undefined,\n        transactionHash: result.transactionHash,\n        walletAddress: options.accountContract.address,\n        walletType: \"smart\",\n      });\n      return result;\n    },\n    async signMessage({ message }: { message: SignableMessage }) {\n      if (options.overrides?.signMessage) {\n        return options.overrides.signMessage({\n          accountContract,\n          adminAccount: options.personalAccount,\n          factoryContract: options.factoryContract,\n          message,\n        });\n      }\n\n      const { smartAccountSignMessage } = await import(\"./lib/signing.js\");\n      return smartAccountSignMessage({\n        accountContract,\n        factoryContract: options.factoryContract,\n        message,\n        options,\n      });\n    },\n    async signTypedData<\n      const typedData extends ox__TypedData.TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(typedData: ox__TypedData.Definition<typedData, primaryType>) {\n      if (options.overrides?.signTypedData) {\n        return options.overrides.signTypedData({\n          accountContract,\n          adminAccount: options.personalAccount,\n          factoryContract: options.factoryContract,\n          typedData,\n        });\n      }\n\n      const { smartAccountSignTypedData } = await import(\"./lib/signing.js\");\n      return smartAccountSignTypedData({\n        accountContract,\n        factoryContract: options.factoryContract,\n        options,\n        typedData,\n      });\n    },\n    sendCalls: async (options) => {\n      const { inAppWalletSendCalls } = await import(\n        \"../in-app/core/eip5792/in-app-wallet-calls.js\"\n      );\n      const firstCall = options.calls[0];\n      if (!firstCall) {\n        throw new Error(\"No calls to send\");\n      }\n      const client = firstCall.client;\n      const chain = firstCall.chain || options.chain;\n      const id = await inAppWalletSendCalls({\n        account: account,\n        calls: options.calls,\n        chain,\n      });\n      return { chain, client, id };\n    },\n    getCallsStatus: async (options) => {\n      const { inAppWalletGetCallsStatus } = await import(\n        \"../in-app/core/eip5792/in-app-wallet-calls.js\"\n      );\n      return inAppWalletGetCallsStatus(options);\n    },\n    getCapabilities: async (options) => {\n      return {\n        [options.chainId ?? 1]: {\n          atomic: {\n            status: \"supported\",\n          },\n          paymasterService: {\n            supported: sponsorGas ?? false,\n          },\n        },\n      };\n    },\n  };\n  return account;\n}\n\nasync function approveERC20(args: {\n  accountContract: ThirdwebContract;\n  options: SmartAccountOptions;\n  erc20Paymaster: TokenPaymasterConfig;\n}) {\n  const { accountContract, erc20Paymaster, options } = args;\n  const tokenAddress = erc20Paymaster.tokenAddress;\n  const tokenContract = getContract({\n    address: tokenAddress,\n    chain: accountContract.chain,\n    client: accountContract.client,\n  });\n  const accountAllowance = await allowance({\n    contract: tokenContract,\n    owner: accountContract.address,\n    spender: erc20Paymaster.paymasterAddress,\n  });\n\n  if (accountAllowance > 0n) {\n    return;\n  }\n\n  const approveTx = approve({\n    amountWei: maxUint96 - 1n,\n    contract: tokenContract,\n    spender: erc20Paymaster.paymasterAddress,\n  });\n  const transaction = await toSerializableTransaction({\n    from: accountContract.address,\n    transaction: approveTx,\n  });\n  const executeTx = prepareExecute({\n    accountContract,\n    executeOverride: options.overrides?.execute,\n    transaction,\n  });\n  await _sendUserOp({\n    executeTx,\n    options: {\n      ...options,\n      overrides: {\n        ...options.overrides,\n        tokenPaymaster: undefined,\n      },\n    },\n  });\n}\n\nfunction createZkSyncAccount(args: {\n  creationOptions: SmartWalletOptions;\n  connectionOptions: SmartWalletConnectionOptions;\n  chain: Chain;\n  sponsorGas: boolean;\n}): Account {\n  const { creationOptions, connectionOptions, chain } = args;\n  const account: Account = {\n    address: getAddress(connectionOptions.personalAccount.address),\n    async onTransactionRequested(transaction) {\n      return connectionOptions.personalAccount.onTransactionRequested?.(\n        transaction,\n      );\n    },\n    async sendTransaction(transaction: SendTransactionOption) {\n      // override passed tx, we have to refetch gas and fees always\n      const prepTx = {\n        chain: getCachedChain(transaction.chainId),\n        client: connectionOptions.client,\n        data: transaction.data,\n        eip712: transaction.eip712,\n        to: transaction.to ?? undefined,\n        value: transaction.value ?? 0n,\n      };\n\n      let serializableTransaction = await populateEip712Transaction({\n        account,\n        transaction: prepTx,\n      });\n\n      if (args.sponsorGas && !serializableTransaction.paymaster) {\n        // get paymaster input\n        const pmData = await getZkPaymasterData({\n          options: {\n            bundlerUrl: creationOptions.overrides?.bundlerUrl,\n            chain,\n            client: connectionOptions.client,\n            entrypointAddress: creationOptions.overrides?.entrypointAddress,\n          },\n          transaction: serializableTransaction,\n        });\n        serializableTransaction = {\n          ...serializableTransaction,\n          ...pmData,\n        };\n      }\n\n      // sign\n      const signedTransaction = await signEip712Transaction({\n        account,\n        chainId: chain.id,\n        eip712Transaction: serializableTransaction,\n      });\n\n      // broadcast via bundler\n      const txHash = await broadcastZkTransaction({\n        options: {\n          bundlerUrl: creationOptions.overrides?.bundlerUrl,\n          chain,\n          client: connectionOptions.client,\n          entrypointAddress: creationOptions.overrides?.entrypointAddress,\n        },\n        signedTransaction,\n        transaction: serializableTransaction,\n      });\n\n      trackTransaction({\n        chainId: chain.id,\n        client: connectionOptions.client,\n        contractAddress: transaction.to ?? undefined,\n        transactionHash: txHash.transactionHash,\n        walletAddress: account.address,\n        walletType: \"smart\",\n      });\n\n      return {\n        chain: chain,\n        client: connectionOptions.client,\n        transactionHash: txHash.transactionHash,\n      };\n    },\n    async signMessage({ message }: { message: SignableMessage }) {\n      return connectionOptions.personalAccount.signMessage({ message });\n    },\n    async signTypedData<\n      const typedData extends ox__TypedData.TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(_typedData: ox__TypedData.Definition<typedData, primaryType>) {\n      const typedData = parseTypedData(_typedData);\n      return connectionOptions.personalAccount.signTypedData(typedData);\n    },\n    sendCalls: async (options) => {\n      const { inAppWalletSendCalls } = await import(\n        \"../in-app/core/eip5792/in-app-wallet-calls.js\"\n      );\n      const firstCall = options.calls[0];\n      if (!firstCall) {\n        throw new Error(\"No calls to send\");\n      }\n      const client = firstCall.client;\n      const chain = firstCall.chain || options.chain;\n      const id = await inAppWalletSendCalls({\n        account: account,\n        calls: options.calls,\n        chain,\n      });\n      return { chain, client, id };\n    },\n    getCallsStatus: async (options) => {\n      const { inAppWalletGetCallsStatus } = await import(\n        \"../in-app/core/eip5792/in-app-wallet-calls.js\"\n      );\n      return inAppWalletGetCallsStatus(options);\n    },\n    getCapabilities: async (options) => {\n      return {\n        [options.chainId ?? 1]: {\n          atomic: {\n            status: \"unsupported\",\n          },\n          paymasterService: {\n            supported: args.sponsorGas ?? false,\n          },\n        },\n      };\n    },\n  };\n  return account;\n}\n\nasync function _sendUserOp(args: {\n  executeTx: PreparedTransaction;\n  options: SmartAccountOptions;\n}): Promise<WaitForReceiptOptions> {\n  const { executeTx, options } = args;\n  try {\n    const unsignedUserOp = await createUnsignedUserOp({\n      accountContract: options.accountContract,\n      adminAddress: options.personalAccount.address,\n      factoryContract: options.factoryContract,\n      overrides: options.overrides,\n      sponsorGas: options.sponsorGas,\n      transaction: executeTx,\n    });\n    const signedUserOp = await signUserOp({\n      adminAccount: options.personalAccount,\n      chain: options.chain,\n      client: options.client,\n      entrypointAddress: options.overrides?.entrypointAddress,\n      userOp: unsignedUserOp,\n    });\n    const bundlerOptions: BundlerOptions = {\n      bundlerUrl: options.overrides?.bundlerUrl,\n      chain: options.chain,\n      client: options.client,\n      entrypointAddress: options.overrides?.entrypointAddress,\n    };\n    const userOpHash = await bundleUserOp({\n      options: bundlerOptions,\n      userOp: signedUserOp,\n    });\n    // wait for tx receipt rather than return the userOp hash\n    const receipt = await waitForUserOpReceipt({\n      ...bundlerOptions,\n      userOpHash,\n    });\n\n    trackTransaction({\n      chainId: options.chain.id,\n      client: options.client,\n      contractAddress: await resolvePromisedValue(executeTx.to ?? undefined),\n      transactionHash: receipt.transactionHash,\n      walletAddress: options.accountContract.address,\n      walletType: \"smart\",\n    });\n\n    return {\n      chain: options.chain,\n      client: options.client,\n      transactionHash: receipt.transactionHash,\n    };\n  } catch (error) {\n    // Track insufficient funds errors\n    if (isInsufficientFundsError(error)) {\n      trackInsufficientFundsError({\n        chainId: options.chain.id,\n        client: options.client,\n        contractAddress: await resolvePromisedValue(executeTx.to ?? undefined),\n        error,\n        transactionValue: await resolvePromisedValue(executeTx.value),\n        walletAddress: options.accountContract.address,\n      });\n    }\n\n    throw error;\n  } finally {\n    // reset the isDeploying flag after every transaction or error\n    clearAccountDeploying(options.accountContract);\n  }\n}\n\nexport async function getEntrypointFromFactory(\n  factoryAddress: string,\n  client: ThirdwebClient,\n  chain: Chain,\n) {\n  const factoryContract = getContract({\n    address: factoryAddress,\n    chain,\n    client,\n  });\n  try {\n    const entrypointAddress = await readContract({\n      contract: factoryContract,\n      method: \"function entrypoint() public view returns (address)\",\n    });\n    return entrypointAddress;\n  } catch {\n    return undefined;\n  }\n}\n"],"names":["ZERO_ADDRESS","transactionDecorator","async","sendTransaction","options","account","transaction","gasless","decorator","decoratedAccount","decoratedTransaction","onTransactionRequested","eip712","sendEip712Transaction","serializableTransaction","toSerializableTransaction","from","sendGaslessTransaction","result","addTransactionToStore","address","chainId","chain","id","transactionHash","_objectSpread","client","readContract","contract","method","params","resolvedPreparedMethod","resolvedParams","Promise","all","_contract$abi","Array","isArray","isAbiFunction","prepareMethod","startsWith","abiItem","parseAbiItem","type","Error","abi","length","_contract$abi2","abiFunction","find","item","name","concat","resolvePreparedMethod","encodedData","encodeAbiParameters","slice","rpcRequest","getRpcClient","request","blockNumber","blockTag","txRequest","_objectWithoutProperties","_excluded","block","numberToHex","undefined","stateOverrides","overrides","Object","fromEntries","entries","map","_ref","override","balance","code","nonce","state","stateDiff","eth_call","data","getAddress","to","decoded","decodeAbiParameters","predictAddress","args","factoryContract","predictAddressOverride","adminAddress","accountSalt","accountAddress","withCache","saltHex","isHex","stringToHex","retries","error","delay","resolve","setTimeout","cacheKey","cacheTime","prepareCreateAccount","createAccountOverride","createAccount","prepareContractCall","prepareExecute","accountContract","executeOverride","execute","value","BigInt","gas","prepareBatchExecute","_transactions$","transactions","executeBatchOverride","executeBatch","values","tx","createStore","initialValue","listeners","Set","getValue","setValue","newValue","notify","listener","subscribe","add","delete","transactionsByAddress","Map","tranasctionStore","existingStore","get","newStore","set","getTransactionStore","FN_SELECTOR","FN_INPUTS","FN_OUTPUTS","approve","asyncOptions","once","asyncParams","accessList","_await$asyncOptions$o","authorizationList","_await$asyncOptions$o2","erc20Value","_await$asyncOptions$o3","extraGas","_await$asyncOptions$o4","_await$asyncOptions$o5","gasPrice","_await$asyncOptions$o6","maxFeePerGas","_await$asyncOptions$o7","maxPriorityFeePerGas","_await$asyncOptions$o8","_await$asyncOptions$o9","resolvedOptions","spender","_await$asyncOptions$o0","generatedApprove","amount","decimals","d","catch","toUnits","toString","amountWei","tokenAddress","components","tenYearsFromNow","Date","now","dateToSeconds","date","toBigInt","Math","floor","getTime","SignerPermissionRequest","toContractPermissions","_permissions$nativeTo","target","permissions","approvedTargets","isAdmin","nativeTokenLimitPerTransaction","toWei","permissionEndTimestamp","permissionStartTimestamp","reqValidityEndTimestamp","reqValidityStartTimestamp","signer","uid","randomBytesHex","addSessionKey","sessionKeyAddress","req","signature","setPermissionsForSigner","signTypedData","domain","verifyingContract","version","message","primaryType","types","signPermissionRequest","shouldUpdateSessionKey","_newPermissions$nativ","_newPermissions$nativ2","newPermissions","isContractDeployed","currentPermissions","getPermissionsForSigner","endTimestamp","currentTargets","newTargets","toLowerCase","every","t","includes","areSessionKeyContractTargetsEqual","maxUint96","getInitCode","unpackedUserOperation","factory","factoryData","getGasLimits","pad","toHex","size","getPaymasterAndData","paymaster","paymasterVerificationGasLimit","paymasterPostOpGasLimit","paymasterData","getPackedUserOperation","userOperation","accountGasLimits","verificationGasLimit","callGasLimit","callData","gasFees","initCode","paymasterAndData","preVerificationGas","sender","_res$error","userOp","paymasterOverride","entrypointAddress","entrypoint","ENTRYPOINT_ADDRESS_v0_6","paymasterUrl","getDefaultBundlerUrl","body","jsonrpc","hexlifyUserOp","fetchWithHeaders","getClientFetch","response","stringify","headers","ok","text","statusText","status","res","json","reason","console","warn","policyId","hexToBigInt","isDeployingSet","getKey","markAccountDeploying","clearAccountDeploying","isAccountDeploying","has","createUnsignedUserOp","_args$overrides","executeTx","sponsorGas","waitForDeployment","isDeployedOverride","bundlerOptions","bundlerUrl","entrypointVersion","getEntryPointVersion","isDeployed","then","encode","resolvePromisedValue","getGasFees","getAccountNonce","getNonceOverride","waitForAccountDeployed","partialOp","DUMMY_SIGNATURE","paymasterResult","tokenPaymaster","keccak256","balanceStorageSlot","estimates","estimateUserOpGas","paymasterResult2","populateUserOp_v0_7","deployTx","getAccountInitCode","paymasterAndData2","populateUserOp_v0_6","_bundlerOptions$bundl","isThirdwebUrl","bundlerGasPrice","getUserOpGasFees","resolvedMaxFeePerGas","resolvedMaxPriorityFeePerGas","_ref2","feeData","getDefaultGasOverrides","signUserOp","adminAccount","userOpHash","packedUserOp","getUserOpHashV07","getContract","ENTRYPOINT_ADDRESS_v0_7","getUserOpHashV06","getUserOpHash","signMessage","raw","hexToBytes","originalMessage","key","getNonce","generateRandomUint192","startTime","adminAccountToSmartAccountMap","WeakMap","smartAccountToAdminAccountMap","connectSmartAccount","connectionOptions","creationOptions","_options$overrides","_options$overrides2","_options$overrides3","_options$factoryAddre","_options$overrides4","_options$overrides5","_options$overrides6","_options$overrides7","personalAccount","isZkSyncChain","createZkSyncAccount","factoryAddress","_unused","getEntrypointFromFactory","getDefaultAccountFactory","err","cause","_options$overrides8","erc20Paymaster","_options$overrides9","_options$personalAcco","_options$personalAcco2","call","sendBatchTransaction","_options$overrides0","_transactions$0$to","firstTx","getCachedChain","_sendUserOp","trackTransaction","contractAddress","walletAddress","walletType","_options$overrides11","_transaction$to","_options$overrides1","_options$overrides14","tokenContract","accountAllowance","owner","allowance","paymasterAddress","approveTx","approveERC20","paymasterCallback","_options$overrides10","_options$overrides12","smartAccountSignMessage","typedData","_options$overrides13","smartAccountSignTypedData","sendCalls","inAppWalletSendCalls","firstCall","calls","getCallsStatus","inAppWalletGetCallsStatus","getCapabilities","_options$chainId","atomic","paymasterService","supported","createSmartAccount","sessionKey","disconnectSmartAccount","_connectionOptions$pe","_connectionOptions$pe2","_transaction$to2","_transaction$value","_creationOptions$over3","_creationOptions$over4","_transaction$to3","prepTx","populateEip712Transaction","_creationOptions$over","_creationOptions$over2","pmData","getZkPaymasterData","signedTransaction","signEip712Transaction","eip712Transaction","txHash","broadcastZkTransaction","_typedData","parseTypedData","_options$chainId2","_args$sponsorGas","_options$overrides15","_options$overrides16","_options$overrides17","_executeTx$to","unsignedUserOp","signedUserOp","bundleUserOp","receipt","timeout","timeoutMs","interval","intervalMs","endtime","userOpReceipt","getUserOpReceipt","waitForUserOpReceipt","_executeTx$to2","isInsufficientFundsError","trackInsufficientFundsError","transactionValue"],"sourceRoot":""}