{"version":3,"file":"static/js/39858.ace68b31.chunk.js","mappings":"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","sources":["../node_modules/thirdweb/src/transaction/actions/send-and-confirm-transaction.ts","../node_modules/thirdweb/src/wallets/in-app/core/eip5792/in-app-wallet-calls.ts","../node_modules/thirdweb/src/transaction/actions/send-batch-transaction.ts","../node_modules/thirdweb/src/utils/config.ts","../node_modules/thirdweb/src/transaction/actions/send-transaction.ts","../node_modules/viem/utils/formatters/transactionReceipt.ts","../node_modules/viem/utils/formatters/log.ts","../node_modules/thirdweb/src/rpc/actions/eth_getTransactionReceipt.ts","../node_modules/thirdweb/src/rpc/watchBlockNumber.ts","../node_modules/thirdweb/src/rpc/actions/eth_blockNumber.ts","../node_modules/thirdweb/src/transaction/actions/wait-for-tx-receipt.ts","../node_modules/thirdweb/src/reactive/store.ts","../node_modules/thirdweb/src/transaction/transaction-store.ts"],"sourcesContent":["import type { TransactionReceipt } from \"../types.js\";\nimport {\n  type SendTransactionOptions,\n  sendTransaction,\n} from \"./send-transaction.js\";\nimport { waitForReceipt } from \"./wait-for-tx-receipt.js\";\n\n/**\n * Sends a transaction using the provided wallet.\n * @param options - The options for sending the transaction.\n * @returns A promise that resolves to the confirmed transaction receipt.\n * @throws An error if the wallet is not connected.\n * @transaction\n * @example\n *\n * ### Basic usage\n * ```ts\n * import { sendAndConfirmTransaction } from \"thirdweb\";\n *\n * const transactionReceipt = await sendAndConfirmTransaction({\n *  account,\n *  transaction\n * });\n * ```\n *\n * ### Gasless usage with [thirdweb Engine](https://portal.thirdweb.com/engine)\n * ```ts\n * const transactionReceipt = await sendAndConfirmTransaction({\n *  account,\n *  transaction,\n *  gasless: {\n *    provider: \"engine\",\n *    relayerUrl: \"https://thirdweb.engine-***.thirdweb.com/relayer/***\",\n *    relayerForwarderAddress: \"0x...\",\n *  }\n * });\n * ```\n *\n * ### Gasless usage with OpenZeppelin\n * ```ts\n * const transactionReceipt = await sendAndConfirmTransaction({\n *  account,\n *  transaction,\n *  gasless: {\n *    provider: \"openzeppelin\",\n *    relayerUrl: \"https://...\",\n *    relayerForwarderAddress: \"0x...\",\n *  }\n * });\n * ```\n */\nexport async function sendAndConfirmTransaction(\n  options: SendTransactionOptions,\n): Promise<TransactionReceipt> {\n  const submittedTx = await sendTransaction(options);\n  return waitForReceipt(submittedTx);\n}\n","import type { Chain } from \"../../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { eth_getTransactionReceipt } from \"../../../../rpc/actions/eth_getTransactionReceipt.js\";\nimport { getRpcClient } from \"../../../../rpc/rpc.js\";\nimport { sendAndConfirmTransaction } from \"../../../../transaction/actions/send-and-confirm-transaction.js\";\nimport { sendBatchTransaction } from \"../../../../transaction/actions/send-batch-transaction.js\";\nimport type { SendTransactionOptions } from \"../../../../transaction/actions/send-transaction.js\";\nimport { LruMap } from \"../../../../utils/caching/lru.js\";\nimport type { Hex } from \"../../../../utils/encoding/hex.js\";\nimport { randomBytesHex } from \"../../../../utils/random.js\";\nimport type { PreparedSendCall } from \"../../../eip5792/send-calls.js\";\nimport type {\n  GetCallsStatusResponse,\n  WalletCallReceipt,\n} from \"../../../eip5792/types.js\";\nimport type { Account } from \"../../../interfaces/wallet.js\";\n\nconst bundlesToTransactions = new LruMap<Hex[]>(1000);\n\n/**\n * @internal\n */\nexport async function inAppWalletSendCalls(args: {\n  account: Account;\n  calls: PreparedSendCall[];\n  chain: Chain;\n}): Promise<string> {\n  const { account, calls } = args;\n\n  const transactions: SendTransactionOptions[\"transaction\"][] = calls.map(\n    (call) => ({\n      ...call,\n      chain: args.chain,\n    }),\n  );\n\n  const hashes: Hex[] = [];\n  const id = randomBytesHex(65);\n  bundlesToTransactions.set(id, hashes);\n  if (account.sendBatchTransaction) {\n    const receipt = await sendBatchTransaction({\n      account,\n      transactions,\n    });\n    hashes.push(receipt.transactionHash);\n    bundlesToTransactions.set(id, hashes);\n  } else {\n    for (const tx of transactions) {\n      const receipt = await sendAndConfirmTransaction({\n        account,\n        transaction: tx,\n      });\n      hashes.push(receipt.transactionHash);\n      bundlesToTransactions.set(id, hashes);\n    }\n  }\n\n  return id;\n}\n\n/**\n * @internal\n */\nexport async function inAppWalletGetCallsStatus(args: {\n  chain: Chain;\n  client: ThirdwebClient;\n  id: string;\n}): Promise<GetCallsStatusResponse> {\n  const { chain, client, id } = args;\n\n  const bundle = bundlesToTransactions.get(id);\n  if (!bundle) {\n    throw new Error(\"Failed to get calls status, unknown bundle id\");\n  }\n\n  const request = getRpcClient({ chain, client });\n  let status: \"pending\" | \"success\" | \"failure\" = \"success\";\n  const receipts: (WalletCallReceipt<bigint, \"success\" | \"reverted\"> | null)[] =\n    await Promise.all(\n      bundle.map((hash) =>\n        eth_getTransactionReceipt(request, { hash })\n          .then((receipt) => ({\n            blockHash: receipt.blockHash,\n            blockNumber: receipt.blockNumber,\n            gasUsed: receipt.gasUsed,\n            logs: receipt.logs.map((l) => ({\n              address: l.address,\n              data: l.data,\n              topics: l.topics,\n            })),\n            status: receipt.status,\n            transactionHash: receipt.transactionHash,\n          }))\n          .catch(() => {\n            status = \"pending\";\n            return null; // Return null if there's an error to filter out later\n          }),\n      ),\n    );\n\n  return {\n    atomic: false,\n    chainId: chain.id,\n    id,\n    receipts: receipts.filter((r) => r !== null),\n    status,\n    statusCode: 200,\n    version: \"2.0.0\",\n  };\n}\n","import { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n} from \"../../wallets/interfaces/wallet.js\";\nimport { encode } from \"./encode.js\";\nimport type { SendTransactionOptions } from \"./send-transaction.js\";\nimport type { WaitForReceiptOptions } from \"./wait-for-tx-receipt.js\";\n\nexport type SendBatchTransactionOptions = {\n  transactions: SendTransactionOptions[\"transaction\"][];\n  account: Account;\n};\n\n/**\n * Sends a batch transaction using the provided options.\n * @param options - The options for sending the batch transaction.\n * @returns A promise that resolves to the options for waiting for the receipt of the first transaction in the batch.\n * @throws An error if the account is not connected, there are no transactions to send, or the account does not implement sendBatchTransaction.\n * @transaction\n * @example\n * ```ts\n * import { sendBatchTransaction } from \"thirdweb\";\n *\n * const waitForReceiptOptions = await sendBatchTransaction({\n *  account,\n *  transactions\n * });\n * ```\n */\nexport async function sendBatchTransaction(\n  options: SendBatchTransactionOptions,\n): Promise<WaitForReceiptOptions> {\n  const { account, transactions } = options;\n  if (!account) {\n    throw new Error(\"not connected\");\n  }\n  if (transactions.length === 0) {\n    throw new Error(\"No transactions to send\");\n  }\n  const firstTx = transactions[0];\n  if (!firstTx) {\n    throw new Error(\"No transactions to send\");\n  }\n  if (account.sendBatchTransaction) {\n    const serializedTxs: SendTransactionOption[] = await Promise.all(\n      transactions.map(async (tx) => {\n        // no need to estimate gas for these, gas will be estimated on the entire batch\n        const [data, to, accessList, value] = await Promise.all([\n          encode(tx),\n          resolvePromisedValue(tx.to),\n          resolvePromisedValue(tx.accessList),\n          resolvePromisedValue(tx.value),\n        ]);\n        const serializedTx: SendTransactionOption = {\n          accessList,\n          chainId: tx.chain.id,\n          data,\n          to,\n          value,\n        };\n        return serializedTx;\n      }),\n    );\n    const result = await account.sendBatchTransaction(serializedTxs);\n    return {\n      ...result,\n      chain: firstTx.chain,\n      client: firstTx.client,\n    };\n  }\n  throw new Error(\"Account doesn't implement sendBatchTransaction\");\n}\n","import type { PreparedTransaction } from \"../transaction/prepare-transaction.js\";\nimport type { Account } from \"../wallets/interfaces/wallet.js\";\n\nlet transactionDecorator:\n  | ((args: {\n      account: Account;\n      transaction: PreparedTransaction;\n    }) => Promise<{ account: Account; transaction: PreparedTransaction }>)\n  | null = null;\n\n/**\n * @internal\n */\nexport function setTransactionDecorator(\n  decoratorFunction: (args: {\n    account: Account;\n    transaction: PreparedTransaction;\n  }) => Promise<{ account: Account; transaction: PreparedTransaction }>,\n) {\n  transactionDecorator = decoratorFunction;\n}\n\n/**\n * @internal\n */\nexport function clearTransactionDecorator() {\n  transactionDecorator = null;\n}\n\n/**\n * @internal\n */\nexport function getTransactionDecorator() {\n  return transactionDecorator;\n}\n","import { getTransactionDecorator } from \"../../utils/config.js\";\nimport type { Account } from \"../../wallets/interfaces/wallet.js\";\nimport type { PreparedTransaction } from \"../prepare-transaction.js\";\nimport { addTransactionToStore } from \"../transaction-store.js\";\nimport type { GaslessOptions } from \"./gasless/types.js\";\nimport { toSerializableTransaction } from \"./to-serializable-transaction.js\";\nimport type { WaitForReceiptOptions } from \"./wait-for-tx-receipt.js\";\n\n/** Send transaction options */\nexport interface SendTransactionOptions {\n  /**\n   * The account to send the transaction with\n   */\n  account: Account;\n  /**\n   * The prepared transaction to send\n   */\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any prepared transaction type\n  transaction: PreparedTransaction<any>;\n  /**\n   * Gasless options for the transaction, if applicable\n   */\n  gasless?: GaslessOptions;\n}\n\n/**\n * Sends a transaction using the provided account.\n *\n * You can send a transaction with a [prepared contract call](https://portal.thirdweb.com/references/typescript/v5/prepareContractCall), a [prepared transaction](https://portal.thirdweb.com/references/typescript/v5/prepareTransaction), or using a write [Extension](https://portal.thirdweb.com/typescript/v5/extensions/use).\n * @param options - The options for sending the transaction.\n * @returns A promise that resolves to the transaction result.\n * @throws An error if the transaction reverts.\n * @transaction\n * @example\n *\n * ### Using a prepared contract call\n *\n * ```ts\n * import { sendTransaction, getContract, prepareContractCall } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n *\n * const contract = getContract({\n *   address: \"0x...\",\n *   chain: sepolia,\n *   client,\n * });\n *\n * const transaction = prepareContractCall({\n *   contract,\n *   method: \"function transfer(address to, uint256 value)\",\n *   params: [to, value],\n * });\n *\n * const { transactionHash } = await sendTransaction({\n *  account,\n *  transaction,\n * });\n * ```\n *\n * ### Using a write extension\n *\n * ```ts\n * import { sendTransaction, getContract } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { mintTo } from \"thirdweb/extensions/erc721\";\n *\n * const contract = getContract({\n *   address: \"0x...\",\n *   chain: sepolia,\n *   client,\n * });\n *\n * const transaction = mintTo({\n *   contract,\n *   to: \"0x...\",\n *   nft: {\n *     name: \"NFT Name\",\n *     description: \"NFT Description\",\n *     image: \"https://example.com/image.png\",\n *   },\n * });\n *\n * const { transactionHash } = await sendTransaction({\n *  account,\n *  transaction,\n * });\n * ```\n *\n * ### Using a prepared transaction\n *\n * ```ts\n * import { sendTransaction, getContract, prepareTransaction } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n *\n * const contract = getContract({\n *   address: \"0x...\",\n *   chain: sepolia,\n *   client,\n * });\n *\n * const transaction = prepareTransaction({\n *   contract,\n *   to: \"0x...\",\n *   value: toWei(\"0.1\"),\n * });\n *\n * const { transactionHash } = await sendTransaction({\n *  account,\n *  transaction,\n * });\n * ```\n *\n * ### Send an EIP-7702 Transaction\n *\n * **Note: This feature is in beta and is subject to breaking changes**\n *\n * ```ts\n * import { sendTransaction, prepareTransaction, signAuthorization } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n *\n * const authorization = await signAuthorization({\n *   request: {\n *     address: \"0x...\",\n *     chainId: 1,\n *     nonce: 0n,\n *   },\n *   account: myAccount,\n * });\n *\n * const transaction = prepareTransaction({\n *   chain: sepolia,\n *   client: client,\n *   to: \"0x...\",\n *   value: 0n,\n *   authorizationList: [authorization],\n * });\n *\n * const { transactionHash } = await sendTransaction({\n *  account,\n *  transaction,\n * });\n * ```\n *\n * ### Gasless usage with [thirdweb Engine](https://portal.thirdweb.com/engine)\n * ```ts\n * const { transactionHash } = await sendTransaction({\n *  account,\n *  transaction,\n *  gasless: {\n *    provider: \"engine\",\n *    relayerUrl: \"https://thirdweb.engine-***.thirdweb.com/relayer/***\",\n *    relayerForwarderAddress: \"0x...\",\n *  }\n * });\n * ```\n *\n * ### Gasless usage with OpenZeppelin\n * ```ts\n * const { transactionHash } = await sendTransaction({\n *  account,\n *  transaction,\n *  gasless: {\n *    provider: \"openzeppelin\",\n *    relayerUrl: \"https://...\",\n *    relayerForwarderAddress: \"0x...\",\n *  }\n * });\n * ```\n */\nexport async function sendTransaction(\n  options: SendTransactionOptions,\n): Promise<WaitForReceiptOptions> {\n  let { account, transaction, gasless } = options;\n\n  const decorator = getTransactionDecorator();\n  if (decorator) {\n    const { account: decoratedAccount, transaction: decoratedTransaction } =\n      await decorator({ account, transaction });\n    account = decoratedAccount;\n    transaction = decoratedTransaction;\n  }\n\n  if (account.onTransactionRequested) {\n    await account.onTransactionRequested(transaction);\n  }\n\n  // if zksync transaction params are set, send with eip712\n  if (transaction.eip712) {\n    const { sendEip712Transaction } = await import(\n      \"./zksync/send-eip712-transaction.js\"\n    );\n    return sendEip712Transaction({\n      account,\n      transaction,\n    });\n  }\n\n  const serializableTransaction = await toSerializableTransaction({\n    from: account,\n    transaction: transaction,\n  });\n  // branch for gasless transactions\n  if (gasless) {\n    // lazy load the gasless tx function because it's only needed for gasless transactions\n    const { sendGaslessTransaction } = await import(\n      \"./gasless/send-gasless-transaction.js\"\n    );\n    return sendGaslessTransaction({\n      account,\n      gasless,\n      serializableTransaction,\n      transaction,\n    });\n  }\n\n  const result = await account.sendTransaction(serializableTransaction);\n  // Store the transaction\n  addTransactionToStore({\n    address: account.address,\n    chainId: transaction.chain.id,\n    transactionHash: result.transactionHash,\n  });\n  return { ...result, chain: transaction.chain, client: transaction.client };\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type {\n  Chain,\n  ExtractChainFormatterReturnType,\n} from '../../types/chain.js'\nimport type { RpcTransactionReceipt } from '../../types/rpc.js'\nimport type { TransactionReceipt } from '../../types/transaction.js'\nimport type { ExactPartial } from '../../types/utils.js'\nimport { hexToNumber } from '../encoding/fromHex.js'\n\nimport { type DefineFormatterErrorType, defineFormatter } from './formatter.js'\nimport { formatLog } from './log.js'\nimport { transactionType } from './transaction.js'\n\nexport type FormattedTransactionReceipt<\n  chain extends Chain | undefined = undefined,\n> = ExtractChainFormatterReturnType<\n  chain,\n  'transactionReceipt',\n  TransactionReceipt\n>\n\nexport const receiptStatuses = {\n  '0x0': 'reverted',\n  '0x1': 'success',\n} as const\n\nexport type FormatTransactionReceiptErrorType = ErrorType\n\nexport function formatTransactionReceipt(\n  transactionReceipt: ExactPartial<RpcTransactionReceipt>,\n) {\n  const receipt = {\n    ...transactionReceipt,\n    blockNumber: transactionReceipt.blockNumber\n      ? BigInt(transactionReceipt.blockNumber)\n      : null,\n    contractAddress: transactionReceipt.contractAddress\n      ? transactionReceipt.contractAddress\n      : null,\n    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed\n      ? BigInt(transactionReceipt.cumulativeGasUsed)\n      : null,\n    effectiveGasPrice: transactionReceipt.effectiveGasPrice\n      ? BigInt(transactionReceipt.effectiveGasPrice)\n      : null,\n    gasUsed: transactionReceipt.gasUsed\n      ? BigInt(transactionReceipt.gasUsed)\n      : null,\n    logs: transactionReceipt.logs\n      ? transactionReceipt.logs.map((log) => formatLog(log))\n      : null,\n    to: transactionReceipt.to ? transactionReceipt.to : null,\n    transactionIndex: transactionReceipt.transactionIndex\n      ? hexToNumber(transactionReceipt.transactionIndex)\n      : null,\n    status: transactionReceipt.status\n      ? receiptStatuses[transactionReceipt.status]\n      : null,\n    type: transactionReceipt.type\n      ? transactionType[\n          transactionReceipt.type as keyof typeof transactionType\n        ] || transactionReceipt.type\n      : null,\n  } as TransactionReceipt\n\n  if (transactionReceipt.blobGasPrice)\n    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice)\n  if (transactionReceipt.blobGasUsed)\n    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed)\n\n  return receipt\n}\n\nexport type DefineTransactionReceiptErrorType =\n  | DefineFormatterErrorType\n  | ErrorType\n\nexport const defineTransactionReceipt = /*#__PURE__*/ defineFormatter(\n  'transactionReceipt',\n  formatTransactionReceipt,\n)\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Log } from '../../types/log.js'\nimport type { RpcLog } from '../../types/rpc.js'\nimport type { ExactPartial } from '../../types/utils.js'\n\nexport type FormatLogErrorType = ErrorType\n\nexport function formatLog(\n  log: ExactPartial<RpcLog>,\n  {\n    args,\n    eventName,\n  }: { args?: unknown | undefined; eventName?: string | undefined } = {},\n) {\n  return {\n    ...log,\n    blockHash: log.blockHash ? log.blockHash : null,\n    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,\n    logIndex: log.logIndex ? Number(log.logIndex) : null,\n    transactionHash: log.transactionHash ? log.transactionHash : null,\n    transactionIndex: log.transactionIndex\n      ? Number(log.transactionIndex)\n      : null,\n    ...(eventName ? { args, eventName } : {}),\n  } as Log\n}\n","import {\n  type EIP1193RequestFn,\n  type EIP1474Methods,\n  formatTransactionReceipt,\n  type GetTransactionReceiptParameters,\n  type TransactionReceipt,\n} from \"viem\";\n\n/**\n * Retrieves the transaction receipt for a given transaction hash.\n * Throws an error if the receipt is not found.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for retrieving the transaction receipt.\n * @returns A promise that resolves to the transaction receipt.\n * @throws An error if the transaction receipt is not found.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_getTransactionReceipt } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const transactionReceipt = await eth_getTransactionReceipt(rpcRequest, {\n *  hash: \"0x...\",\n * });\n * ```\n */\nexport async function eth_getTransactionReceipt(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: GetTransactionReceiptParameters,\n): Promise<TransactionReceipt> {\n  const receipt = await request({\n    method: \"eth_getTransactionReceipt\",\n    params: [params.hash],\n  });\n\n  if (!receipt) {\n    throw new Error(\"Transaction receipt not found.\");\n  }\n\n  return formatTransactionReceipt(receipt);\n}\n","import type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { sleep } from \"../utils/sleep.js\";\nimport { eth_blockNumber } from \"./actions/eth_blockNumber.js\";\nimport { getRpcClient } from \"./rpc.js\";\n\nconst MAX_POLL_DELAY = 5000; // 5 seconds\nconst DEFAULT_POLL_DELAY = 1000; // 1 second\nconst MIN_POLL_DELAY = 500; // 500 milliseconds\nconst DEFAULT_OVERPOLL_RATIO = 2; // poll twice as often as the average block time by default\n\nconst SLIDING_WINDOW_SIZE = 10; // always keep track of the last 10 block times\n\n/**\n * TODO: document\n * @internal\n */\nfunction getAverageBlockTime(blockTimes: number[]): number {\n  // left-pad the blocktimes Array with the DEFAULT_POLL_DELAY\n  while (blockTimes.length < SLIDING_WINDOW_SIZE) {\n    blockTimes.unshift(DEFAULT_POLL_DELAY);\n  }\n\n  const sum = blockTimes.reduce((acc, blockTime) => acc + blockTime, 0);\n  return sum / blockTimes.length;\n}\n\n/**\n * TODO: document\n * @internal\n */\nfunction createBlockNumberPoller(\n  client: ThirdwebClient,\n  chain: Chain,\n  overPollRatio?: number,\n  onError?: (error: Error) => void,\n) {\n  let subscribers: Array<(blockNumber: bigint) => void> = [];\n  let blockTimesWindow: number[] = [];\n\n  let isActive = false;\n  let lastBlockNumber: bigint | undefined;\n  let lastBlockAt: number | undefined;\n\n  const rpcRequest = getRpcClient({ chain, client });\n\n  /**\n   * TODO: document\n   * @internal\n   */\n  async function poll() {\n    // stop polling if there are no more subscriptions\n    if (!isActive) {\n      return;\n    }\n\n    try {\n      const blockNumber = await eth_blockNumber(rpcRequest);\n\n      if (!lastBlockNumber || blockNumber > lastBlockNumber) {\n        let newBlockNumbers = [];\n        if (lastBlockNumber) {\n          for (let i = lastBlockNumber + 1n; i <= blockNumber; i++) {\n            newBlockNumbers.push(BigInt(i));\n          }\n        } else {\n          newBlockNumbers = [blockNumber];\n        }\n        lastBlockNumber = blockNumber;\n        const currentTime = Date.now();\n        if (lastBlockAt) {\n          // if we skipped a block we need to adjust the block time down to that level\n          const blockTime =\n            (currentTime - lastBlockAt) / newBlockNumbers.length;\n\n          blockTimesWindow.push(blockTime);\n          blockTimesWindow = blockTimesWindow.slice(-SLIDING_WINDOW_SIZE);\n        }\n        lastBlockAt = currentTime;\n        // for all new blockNumbers...\n        for (const b of newBlockNumbers) {\n          // ... call all current subscribers\n          for (const subscriberCallback of subscribers) {\n            subscriberCallback(b);\n          }\n        }\n      }\n    } catch (err: unknown) {\n      if (onError) {\n        onError(err as Error);\n      } else {\n        console.error(\n          `[watchBlockNumber]: Failed to poll for latest block number: ${err}`,\n        );\n      }\n    }\n\n    const currentApproximateBlockTime = getAverageBlockTime(blockTimesWindow);\n\n    // make sure we never poll faster than our minimum poll delay or slower than our maximum poll delay\n    const pollDelay = Math.max(\n      MIN_POLL_DELAY,\n      Math.min(\n        MAX_POLL_DELAY,\n        Math.max(MIN_POLL_DELAY, currentApproximateBlockTime),\n      ),\n    );\n\n    // sleep for the pollDelay for this chain (divided by the overPollRatio, which defaults to 2)\n    await sleep(pollDelay / (overPollRatio ?? DEFAULT_OVERPOLL_RATIO));\n    // poll again\n    poll();\n  }\n\n  // return the \"subscribe\" function\n  return function subscribe(\n    callBack: (blockNumber: bigint) => void,\n    initialBlockNumber?: bigint,\n  ) {\n    subscribers.push(callBack);\n    // if we are currently not active -> start polling\n    if (!isActive) {\n      lastBlockNumber = initialBlockNumber;\n      isActive = true;\n      poll();\n    }\n\n    // return the \"unsubscribe\" function (meaning the caller can unsubscribe)\n    return function unSubscribe() {\n      // filter out the callback from the subscribers\n      subscribers = subscribers.filter((fn) => fn !== callBack);\n      // if the new subscribers Array is empty (aka we were the last subscriber) -> stop polling\n      if (subscribers.length === 0) {\n        lastBlockNumber = undefined;\n        lastBlockAt = undefined;\n        isActive = false;\n      }\n    };\n  };\n}\n\nconst existingPollers = new Map<\n  number,\n  ReturnType<typeof createBlockNumberPoller>\n>();\n\nexport type WatchBlockNumberOptions = {\n  client: ThirdwebClient;\n  chain: Chain;\n  onNewBlockNumber: (blockNumber: bigint) => void;\n  onError?: (error: Error) => void;\n  overPollRatio?: number;\n  latestBlockNumber?: bigint;\n};\n\n/**\n * Watches the block number for a specific chain.\n * @param opts - The options for watching the block number.\n * @returns The unwatch function.\n * @example\n * ```ts\n * import { watchBlockNumber } from \"thirdweb\";\n * const unwatch = watchBlockNumber({\n *  client,\n *  chainId,\n *  onNewBlockNumber: (blockNumber) => {\n *    // do something with the block number\n *  },\n *  onError: (err) => {\n *    // do something if getting the block number fails\n *  },\n * });\n *\n * // later stop watching\n * unwatch();\n * ```\n * @rpc\n */\nexport function watchBlockNumber(opts: WatchBlockNumberOptions) {\n  const {\n    client,\n    chain,\n    onNewBlockNumber,\n    overPollRatio,\n    latestBlockNumber,\n    onError,\n  } = opts;\n  const chainId = chain.id;\n  // if we already have a poller for this chainId -> use it.\n  let poller = existingPollers.get(chainId);\n  // otherwise create a new poller\n  if (!poller) {\n    poller = createBlockNumberPoller(client, chain, overPollRatio, onError);\n    // and store it for later use\n    existingPollers.set(chainId, poller);\n  }\n  // subscribe to the poller and return the unSubscribe function to the caller\n  return poller(onNewBlockNumber, latestBlockNumber);\n}\n","import type { EIP1193RequestFn, EIP1474Methods } from \"viem\";\nimport { hexToBigInt } from \"../../utils/encoding/hex.js\";\n\n/**\n * Retrieves the current block number from the Ethereum blockchain.\n * @param request - The EIP1193 request function.\n * @returns A promise that resolves to the current block number as a bigint.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_blockNumber } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const blockNumber = await eth_blockNumber(rpcRequest);\n * ```\n */\nexport async function eth_blockNumber(\n  request: EIP1193RequestFn<EIP1474Methods>,\n): Promise<bigint> {\n  const blockNumberHex = await request({\n    method: \"eth_blockNumber\",\n  });\n  return hexToBigInt(blockNumberHex);\n}\n","import type { Hex } from \"viem\";\nimport type { Chain } from \"../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { eth_getTransactionReceipt } from \"../../rpc/actions/eth_getTransactionReceipt.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { watchBlockNumber } from \"../../rpc/watchBlockNumber.js\";\nimport type { Prettify } from \"../../utils/type-utils.js\";\nimport type { SendTransactionResult, TransactionReceipt } from \"../types.js\";\n\nconst DEFAULT_MAX_BLOCKS_WAIT_TIME = 100;\n\nconst map = new Map<string, Promise<TransactionReceipt>>();\n\nexport type WaitForReceiptOptions = Prettify<\n  SendTransactionResult & {\n    client: ThirdwebClient;\n    chain: Chain;\n    maxBlocksWaitTime?: number;\n  }\n>;\n\n/**\n * Waits for the transaction receipt of a given transaction hash on a specific contract.\n * @param options - The options for waiting for the receipt.\n * By default, it's 100 blocks.\n * @returns A promise that resolves with the transaction receipt.\n * @transaction\n * @example\n * ```ts\n * import { waitForReceipt } from \"thirdweb\";\n * const receipt = await waitForReceipt({\n *   client,\n *   chain,\n *   transactionHash: \"0x123...\",\n * });\n * ```\n */\nexport function waitForReceipt(\n  options: WaitForReceiptOptions,\n): Promise<TransactionReceipt> {\n  const { transactionHash, chain, client } = options;\n\n  const chainId = chain.id;\n  const key = `${chainId}:tx_${transactionHash}`;\n  const maxBlocksWaitTime =\n    options.maxBlocksWaitTime ?? DEFAULT_MAX_BLOCKS_WAIT_TIME;\n\n  if (map.has(key)) {\n    // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set\n    return map.get(key)!;\n  }\n  const promise = new Promise<TransactionReceipt>((resolve, reject) => {\n    if (!transactionHash) {\n      reject(\n        new Error(\n          \"Transaction has no transactionHash to wait for, did you execute it?\",\n        ),\n      );\n    }\n\n    const request = getRpcClient({ chain, client });\n\n    // start at -1 because the first block doesn't count\n    let blocksWaited = -1;\n\n    const unwatch = watchBlockNumber({\n      chain: chain,\n      client: client,\n      onNewBlockNumber: async () => {\n        blocksWaited++;\n        if (blocksWaited >= maxBlocksWaitTime) {\n          unwatch();\n          reject(\n            new Error(\n              `Transaction receipt for ${transactionHash} not found after ${maxBlocksWaitTime} blocks`,\n            ),\n          );\n          return;\n        }\n        try {\n          const receipt = await eth_getTransactionReceipt(request, {\n            hash: transactionHash as Hex,\n          });\n\n          // stop the polling\n          unwatch();\n          // resolve the top level promise with the receipt\n          resolve(receipt);\n        } catch {\n          // noop, we'll try again on the next blocks\n        }\n      },\n    });\n    // remove the promise from the map when it's done (one way or the other)\n  }).finally(() => {\n    map.delete(key);\n  });\n\n  map.set(key, promise);\n  return promise;\n}\n","export type Store<T> = {\n  getValue(): T;\n  setValue(newValue: T): void;\n  subscribe(listener: () => void): () => void;\n};\n\n/**\n * Create a reactive value store\n * @param initialValue - The initial value to store\n * @example\n * ```ts\n * const store = createStore(0);\n * ```\n * @returns A store object\n * @internal\n */\nexport function createStore<T>(initialValue: T): Store<T> {\n  type Listener = () => void;\n  const listeners = new Set<Listener>();\n\n  let value = initialValue;\n\n  const notify = () => {\n    for (const listener of listeners) {\n      listener();\n    }\n  };\n\n  return {\n    getValue() {\n      return value;\n    },\n    setValue(newValue: T) {\n      if (newValue === value) {\n        return;\n      }\n      value = newValue;\n      notify();\n    },\n    subscribe(listener: Listener) {\n      listeners.add(listener);\n      return () => {\n        listeners.delete(listener);\n      };\n    },\n  };\n}\n","import type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { getTransactions } from \"../insight/get-transactions.js\";\nimport { createStore, type Store } from \"../reactive/store.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\n\nexport type StoredTransaction = {\n  transactionHash: Hex;\n  chainId: number;\n  receipt?: {\n    status: \"success\" | \"failed\";\n    to: string;\n  };\n  decoded?: {\n    name: string;\n    signature: string;\n    inputs?: {\n      [key: string]: unknown;\n    };\n  };\n};\n\nconst transactionsByAddress = new Map<string, Store<StoredTransaction[]>>();\n\n/**\n * Retrieve the transaction store for a given address.\n * @param address - The address to retrieve the transaction store for.\n * @returns A store of transactions for the given account to subscribe to.\n * @transaction\n * @example\n * ```ts\n * import { getTransactionStore } from \"thirdweb/transaction\";\n *\n * const store = getTransactionStore(\"0x...\");\n * store.subscribe((transactions) => {\n *   console.log(transactions);\n * });\n * ```\n */\nexport function getTransactionStore(\n  address: string,\n): Store<StoredTransaction[]> {\n  const existingStore = transactionsByAddress.get(address);\n  if (existingStore) {\n    return existingStore;\n  }\n\n  const newStore = createStore<StoredTransaction[]>([]);\n  transactionsByAddress.set(address, newStore);\n\n  return newStore;\n}\n\n/**\n * @internal\n */\nexport function addTransactionToStore(options: {\n  address: string;\n  transactionHash: Hex;\n  chainId: number;\n}) {\n  const { address, transactionHash, chainId } = options;\n  const tranasctionStore = getTransactionStore(address);\n\n  tranasctionStore.setValue([\n    ...tranasctionStore.getValue(),\n    { chainId, transactionHash },\n  ]);\n\n  transactionsByAddress.set(address, tranasctionStore);\n}\n\n/**\n * @internal for now\n */\nexport async function getPastTransactions(options: {\n  walletAddress: string;\n  chain: Chain;\n  client: ThirdwebClient;\n}): Promise<StoredTransaction[]> {\n  const { walletAddress, chain, client } = options;\n  const oneMonthsAgoInSeconds = Math.floor(\n    (Date.now() - 1 * 30 * 24 * 60 * 60 * 1000) / 1000,\n  );\n  const result = await getTransactions({\n    chains: [chain],\n    client,\n    queryOptions: {\n      filter_block_timestamp_gte: oneMonthsAgoInSeconds,\n      limit: 20,\n      decode: true,\n    },\n    walletAddress,\n  });\n  return result.map((tx) => ({\n    chainId:\n      typeof tx.chain_id === \"string\"\n        ? Number(tx.chain_id)\n        : (tx.chain_id as number),\n    receipt: {\n      status: tx.status === 0 ? \"failed\" : \"success\",\n      to: tx.to_address,\n    },\n    transactionHash: tx.hash as Hex,\n    decoded: tx.decoded,\n  }));\n}\n"],"names":["async","sendAndConfirmTransaction","options","submittedTx","sendTransaction","waitForReceipt","bundlesToTransactions","LruMap","inAppWalletSendCalls","args","account","calls","transactions","map","call","_objectSpread","chain","hashes","id","randomBytesHex","set","sendBatchTransaction","receipt","Error","length","firstTx","serializedTxs","Promise","all","data","to","accessList","value","encode","tx","resolvePromisedValue","chainId","result","client","push","transactionHash","transaction","inAppWalletGetCallsStatus","bundle","get","request","getRpcClient","status","receipts","hash","eth_getTransactionReceipt","then","blockHash","blockNumber","gasUsed","logs","l","address","topics","catch","atomic","filter","r","statusCode","version","transactionDecorator","gasless","decorator","decoratedAccount","decoratedTransaction","onTransactionRequested","eip712","sendEip712Transaction","serializableTransaction","toSerializableTransaction","from","sendGaslessTransaction","addTransactionToStore","receiptStatuses","formatTransactionReceipt","transactionReceipt","BigInt","contractAddress","cumulativeGasUsed","effectiveGasPrice","log","eventName","arguments","undefined","logIndex","Number","transactionIndex","formatLog","hexToNumber","type","transactionType","blobGasPrice","blobGasUsed","params","method","MAX_POLL_DELAY","DEFAULT_POLL_DELAY","MIN_POLL_DELAY","DEFAULT_OVERPOLL_RATIO","SLIDING_WINDOW_SIZE","createBlockNumberPoller","overPollRatio","onError","lastBlockNumber","lastBlockAt","subscribers","blockTimesWindow","isActive","rpcRequest","poll","blockNumberHex","hexToBigInt","eth_blockNumber","newBlockNumbers","i","currentTime","Date","now","blockTime","slice","b","subscriberCallback","err","console","error","concat","currentApproximateBlockTime","blockTimes","unshift","reduce","acc","getAverageBlockTime","pollDelay","Math","max","min","sleep","callBack","initialBlockNumber","fn","existingPollers","Map","DEFAULT_MAX_BLOCKS_WAIT_TIME","_options$maxBlocksWai","key","maxBlocksWaitTime","has","promise","resolve","reject","blocksWaited","unwatch","opts","onNewBlockNumber","latestBlockNumber","poller","watchBlockNumber","_unused","finally","delete","createStore","initialValue","listeners","Set","getValue","setValue","newValue","notify","listener","subscribe","add","transactionsByAddress","tranasctionStore","existingStore","newStore","getTransactionStore"],"sourceRoot":""}