{"version":3,"file":"static/js/62239.66c9e9ee.chunk.js","mappings":"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","sources":["../node_modules/thirdweb/src/transaction/actions/send-and-confirm-transaction.ts","../node_modules/thirdweb/src/wallets/in-app/core/eip5792/in-app-wallet-calls.ts","../node_modules/thirdweb/src/transaction/actions/send-batch-transaction.ts","../node_modules/thirdweb/src/utils/sleep.ts","../node_modules/viem/utils/formatters/transactionReceipt.ts","../node_modules/viem/utils/formatters/log.ts","../node_modules/thirdweb/src/rpc/actions/eth_getTransactionReceipt.ts","../node_modules/thirdweb/src/rpc/watchBlockNumber.ts","../node_modules/thirdweb/src/rpc/actions/eth_blockNumber.ts","../node_modules/thirdweb/src/transaction/actions/wait-for-tx-receipt.ts"],"sourcesContent":["import type { TransactionReceipt } from \"../types.js\";\nimport {\n  type SendTransactionOptions,\n  sendTransaction,\n} from \"./send-transaction.js\";\nimport { waitForReceipt } from \"./wait-for-tx-receipt.js\";\n\n/**\n * Sends a transaction using the provided wallet.\n * @param options - The options for sending the transaction.\n * @returns A promise that resolves to the confirmed transaction receipt.\n * @throws An error if the wallet is not connected.\n * @transaction\n * @example\n *\n * ### Basic usage\n * ```ts\n * import { sendAndConfirmTransaction } from \"thirdweb\";\n *\n * const transactionReceipt = await sendAndConfirmTransaction({\n *  account,\n *  transaction\n * });\n * ```\n *\n * ### Gasless usage with [thirdweb Engine](https://portal.thirdweb.com/engine)\n * ```ts\n * const transactionReceipt = await sendAndConfirmTransaction({\n *  account,\n *  transaction,\n *  gasless: {\n *    provider: \"engine\",\n *    relayerUrl: \"https://thirdweb.engine-***.thirdweb.com/relayer/***\",\n *    relayerForwarderAddress: \"0x...\",\n *  }\n * });\n * ```\n *\n * ### Gasless usage with OpenZeppelin\n * ```ts\n * const transactionReceipt = await sendAndConfirmTransaction({\n *  account,\n *  transaction,\n *  gasless: {\n *    provider: \"openzeppelin\",\n *    relayerUrl: \"https://...\",\n *    relayerForwarderAddress: \"0x...\",\n *  }\n * });\n * ```\n */\nexport async function sendAndConfirmTransaction(\n  options: SendTransactionOptions,\n): Promise<TransactionReceipt> {\n  const submittedTx = await sendTransaction(options);\n  return waitForReceipt(submittedTx);\n}\n","import type { Chain } from \"../../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { eth_getTransactionReceipt } from \"../../../../rpc/actions/eth_getTransactionReceipt.js\";\nimport { getRpcClient } from \"../../../../rpc/rpc.js\";\nimport { sendAndConfirmTransaction } from \"../../../../transaction/actions/send-and-confirm-transaction.js\";\nimport { sendBatchTransaction } from \"../../../../transaction/actions/send-batch-transaction.js\";\nimport type { SendTransactionOptions } from \"../../../../transaction/actions/send-transaction.js\";\nimport { LruMap } from \"../../../../utils/caching/lru.js\";\nimport type { Hex } from \"../../../../utils/encoding/hex.js\";\nimport { randomBytesHex } from \"../../../../utils/random.js\";\nimport type { PreparedSendCall } from \"../../../eip5792/send-calls.js\";\nimport type {\n  GetCallsStatusResponse,\n  WalletCallReceipt,\n} from \"../../../eip5792/types.js\";\nimport type { Account } from \"../../../interfaces/wallet.js\";\n\nconst bundlesToTransactions = new LruMap<Hex[]>(1000);\n\n/**\n * @internal\n */\nexport async function inAppWalletSendCalls(args: {\n  account: Account;\n  calls: PreparedSendCall[];\n  chain: Chain;\n}): Promise<string> {\n  const { account, calls } = args;\n\n  const transactions: SendTransactionOptions[\"transaction\"][] = calls.map(\n    (call) => ({\n      ...call,\n      chain: args.chain,\n    }),\n  );\n\n  const hashes: Hex[] = [];\n  const id = randomBytesHex(65);\n  bundlesToTransactions.set(id, hashes);\n  if (account.sendBatchTransaction) {\n    const receipt = await sendBatchTransaction({\n      account,\n      transactions,\n    });\n    hashes.push(receipt.transactionHash);\n    bundlesToTransactions.set(id, hashes);\n  } else {\n    for (const tx of transactions) {\n      const receipt = await sendAndConfirmTransaction({\n        account,\n        transaction: tx,\n      });\n      hashes.push(receipt.transactionHash);\n      bundlesToTransactions.set(id, hashes);\n    }\n  }\n\n  return id;\n}\n\n/**\n * @internal\n */\nexport async function inAppWalletGetCallsStatus(args: {\n  chain: Chain;\n  client: ThirdwebClient;\n  id: string;\n}): Promise<GetCallsStatusResponse> {\n  const { chain, client, id } = args;\n\n  const bundle = bundlesToTransactions.get(id);\n  if (!bundle) {\n    throw new Error(\"Failed to get calls status, unknown bundle id\");\n  }\n\n  const request = getRpcClient({ chain, client });\n  let status: \"pending\" | \"success\" | \"failure\" = \"success\";\n  const receipts: (WalletCallReceipt<bigint, \"success\" | \"reverted\"> | null)[] =\n    await Promise.all(\n      bundle.map((hash) =>\n        eth_getTransactionReceipt(request, { hash })\n          .then((receipt) => ({\n            blockHash: receipt.blockHash,\n            blockNumber: receipt.blockNumber,\n            gasUsed: receipt.gasUsed,\n            logs: receipt.logs.map((l) => ({\n              address: l.address,\n              data: l.data,\n              topics: l.topics,\n            })),\n            status: receipt.status,\n            transactionHash: receipt.transactionHash,\n          }))\n          .catch(() => {\n            status = \"pending\";\n            return null; // Return null if there's an error to filter out later\n          }),\n      ),\n    );\n\n  return {\n    atomic: false,\n    chainId: chain.id,\n    id,\n    receipts: receipts.filter((r) => r !== null),\n    status,\n    statusCode: 200,\n    version: \"2.0.0\",\n  };\n}\n","import { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n} from \"../../wallets/interfaces/wallet.js\";\nimport { encode } from \"./encode.js\";\nimport type { SendTransactionOptions } from \"./send-transaction.js\";\nimport type { WaitForReceiptOptions } from \"./wait-for-tx-receipt.js\";\n\nexport type SendBatchTransactionOptions = {\n  transactions: SendTransactionOptions[\"transaction\"][];\n  account: Account;\n};\n\n/**\n * Sends a batch transaction using the provided options.\n * @param options - The options for sending the batch transaction.\n * @returns A promise that resolves to the options for waiting for the receipt of the first transaction in the batch.\n * @throws An error if the account is not connected, there are no transactions to send, or the account does not implement sendBatchTransaction.\n * @transaction\n * @example\n * ```ts\n * import { sendBatchTransaction } from \"thirdweb\";\n *\n * const waitForReceiptOptions = await sendBatchTransaction({\n *  account,\n *  transactions\n * });\n * ```\n */\nexport async function sendBatchTransaction(\n  options: SendBatchTransactionOptions,\n): Promise<WaitForReceiptOptions> {\n  const { account, transactions } = options;\n  if (!account) {\n    throw new Error(\"not connected\");\n  }\n  if (transactions.length === 0) {\n    throw new Error(\"No transactions to send\");\n  }\n  const firstTx = transactions[0];\n  if (!firstTx) {\n    throw new Error(\"No transactions to send\");\n  }\n  if (account.sendBatchTransaction) {\n    const serializedTxs: SendTransactionOption[] = await Promise.all(\n      transactions.map(async (tx) => {\n        // no need to estimate gas for these, gas will be estimated on the entire batch\n        const [data, to, accessList, value] = await Promise.all([\n          encode(tx),\n          resolvePromisedValue(tx.to),\n          resolvePromisedValue(tx.accessList),\n          resolvePromisedValue(tx.value),\n        ]);\n        const serializedTx: SendTransactionOption = {\n          accessList,\n          chainId: tx.chain.id,\n          data,\n          to,\n          value,\n        };\n        return serializedTx;\n      }),\n    );\n    const result = await account.sendBatchTransaction(serializedTxs);\n    return {\n      ...result,\n      chain: firstTx.chain,\n      client: firstTx.client,\n    };\n  }\n  throw new Error(\"Account doesn't implement sendBatchTransaction\");\n}\n","/**\n * Delay an async thread\n * @param ms Sleep time in millisecond\n * @internal\n */\nexport function sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type {\n  Chain,\n  ExtractChainFormatterReturnType,\n} from '../../types/chain.js'\nimport type { RpcTransactionReceipt } from '../../types/rpc.js'\nimport type { TransactionReceipt } from '../../types/transaction.js'\nimport type { ExactPartial } from '../../types/utils.js'\nimport { hexToNumber } from '../encoding/fromHex.js'\n\nimport { type DefineFormatterErrorType, defineFormatter } from './formatter.js'\nimport { formatLog } from './log.js'\nimport { transactionType } from './transaction.js'\n\nexport type FormattedTransactionReceipt<\n  chain extends Chain | undefined = undefined,\n> = ExtractChainFormatterReturnType<\n  chain,\n  'transactionReceipt',\n  TransactionReceipt\n>\n\nexport const receiptStatuses = {\n  '0x0': 'reverted',\n  '0x1': 'success',\n} as const\n\nexport type FormatTransactionReceiptErrorType = ErrorType\n\nexport function formatTransactionReceipt(\n  transactionReceipt: ExactPartial<RpcTransactionReceipt>,\n) {\n  const receipt = {\n    ...transactionReceipt,\n    blockNumber: transactionReceipt.blockNumber\n      ? BigInt(transactionReceipt.blockNumber)\n      : null,\n    contractAddress: transactionReceipt.contractAddress\n      ? transactionReceipt.contractAddress\n      : null,\n    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed\n      ? BigInt(transactionReceipt.cumulativeGasUsed)\n      : null,\n    effectiveGasPrice: transactionReceipt.effectiveGasPrice\n      ? BigInt(transactionReceipt.effectiveGasPrice)\n      : null,\n    gasUsed: transactionReceipt.gasUsed\n      ? BigInt(transactionReceipt.gasUsed)\n      : null,\n    logs: transactionReceipt.logs\n      ? transactionReceipt.logs.map((log) => formatLog(log))\n      : null,\n    to: transactionReceipt.to ? transactionReceipt.to : null,\n    transactionIndex: transactionReceipt.transactionIndex\n      ? hexToNumber(transactionReceipt.transactionIndex)\n      : null,\n    status: transactionReceipt.status\n      ? receiptStatuses[transactionReceipt.status]\n      : null,\n    type: transactionReceipt.type\n      ? transactionType[\n          transactionReceipt.type as keyof typeof transactionType\n        ] || transactionReceipt.type\n      : null,\n  } as TransactionReceipt\n\n  if (transactionReceipt.blobGasPrice)\n    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice)\n  if (transactionReceipt.blobGasUsed)\n    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed)\n\n  return receipt\n}\n\nexport type DefineTransactionReceiptErrorType =\n  | DefineFormatterErrorType\n  | ErrorType\n\nexport const defineTransactionReceipt = /*#__PURE__*/ defineFormatter(\n  'transactionReceipt',\n  formatTransactionReceipt,\n)\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Log } from '../../types/log.js'\nimport type { RpcLog } from '../../types/rpc.js'\nimport type { ExactPartial } from '../../types/utils.js'\n\nexport type FormatLogErrorType = ErrorType\n\nexport function formatLog(\n  log: ExactPartial<RpcLog>,\n  {\n    args,\n    eventName,\n  }: { args?: unknown | undefined; eventName?: string | undefined } = {},\n) {\n  return {\n    ...log,\n    blockHash: log.blockHash ? log.blockHash : null,\n    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,\n    logIndex: log.logIndex ? Number(log.logIndex) : null,\n    transactionHash: log.transactionHash ? log.transactionHash : null,\n    transactionIndex: log.transactionIndex\n      ? Number(log.transactionIndex)\n      : null,\n    ...(eventName ? { args, eventName } : {}),\n  } as Log\n}\n","import {\n  type EIP1193RequestFn,\n  type EIP1474Methods,\n  formatTransactionReceipt,\n  type GetTransactionReceiptParameters,\n  type TransactionReceipt,\n} from \"viem\";\n\n/**\n * Retrieves the transaction receipt for a given transaction hash.\n * Throws an error if the receipt is not found.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for retrieving the transaction receipt.\n * @returns A promise that resolves to the transaction receipt.\n * @throws An error if the transaction receipt is not found.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_getTransactionReceipt } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const transactionReceipt = await eth_getTransactionReceipt(rpcRequest, {\n *  hash: \"0x...\",\n * });\n * ```\n */\nexport async function eth_getTransactionReceipt(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: GetTransactionReceiptParameters,\n): Promise<TransactionReceipt> {\n  const receipt = await request({\n    method: \"eth_getTransactionReceipt\",\n    params: [params.hash],\n  });\n\n  if (!receipt) {\n    throw new Error(\"Transaction receipt not found.\");\n  }\n\n  return formatTransactionReceipt(receipt);\n}\n","import type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { sleep } from \"../utils/sleep.js\";\nimport { eth_blockNumber } from \"./actions/eth_blockNumber.js\";\nimport { getRpcClient } from \"./rpc.js\";\n\nconst MAX_POLL_DELAY = 5000; // 5 seconds\nconst DEFAULT_POLL_DELAY = 1000; // 1 second\nconst MIN_POLL_DELAY = 500; // 500 milliseconds\nconst DEFAULT_OVERPOLL_RATIO = 2; // poll twice as often as the average block time by default\n\nconst SLIDING_WINDOW_SIZE = 10; // always keep track of the last 10 block times\n\n/**\n * TODO: document\n * @internal\n */\nfunction getAverageBlockTime(blockTimes: number[]): number {\n  // left-pad the blocktimes Array with the DEFAULT_POLL_DELAY\n  while (blockTimes.length < SLIDING_WINDOW_SIZE) {\n    blockTimes.unshift(DEFAULT_POLL_DELAY);\n  }\n\n  const sum = blockTimes.reduce((acc, blockTime) => acc + blockTime, 0);\n  return sum / blockTimes.length;\n}\n\n/**\n * TODO: document\n * @internal\n */\nfunction createBlockNumberPoller(\n  client: ThirdwebClient,\n  chain: Chain,\n  overPollRatio?: number,\n  onError?: (error: Error) => void,\n) {\n  let subscribers: Array<(blockNumber: bigint) => void> = [];\n  let blockTimesWindow: number[] = [];\n\n  let isActive = false;\n  let lastBlockNumber: bigint | undefined;\n  let lastBlockAt: number | undefined;\n\n  const rpcRequest = getRpcClient({ chain, client });\n\n  /**\n   * TODO: document\n   * @internal\n   */\n  async function poll() {\n    // stop polling if there are no more subscriptions\n    if (!isActive) {\n      return;\n    }\n\n    try {\n      const blockNumber = await eth_blockNumber(rpcRequest);\n\n      if (!lastBlockNumber || blockNumber > lastBlockNumber) {\n        let newBlockNumbers = [];\n        if (lastBlockNumber) {\n          for (let i = lastBlockNumber + 1n; i <= blockNumber; i++) {\n            newBlockNumbers.push(BigInt(i));\n          }\n        } else {\n          newBlockNumbers = [blockNumber];\n        }\n        lastBlockNumber = blockNumber;\n        const currentTime = Date.now();\n        if (lastBlockAt) {\n          // if we skipped a block we need to adjust the block time down to that level\n          const blockTime =\n            (currentTime - lastBlockAt) / newBlockNumbers.length;\n\n          blockTimesWindow.push(blockTime);\n          blockTimesWindow = blockTimesWindow.slice(-SLIDING_WINDOW_SIZE);\n        }\n        lastBlockAt = currentTime;\n        // for all new blockNumbers...\n        for (const b of newBlockNumbers) {\n          // ... call all current subscribers\n          for (const subscriberCallback of subscribers) {\n            subscriberCallback(b);\n          }\n        }\n      }\n    } catch (err: unknown) {\n      if (onError) {\n        onError(err as Error);\n      } else {\n        console.error(\n          `[watchBlockNumber]: Failed to poll for latest block number: ${err}`,\n        );\n      }\n    }\n\n    const currentApproximateBlockTime = getAverageBlockTime(blockTimesWindow);\n\n    // make sure we never poll faster than our minimum poll delay or slower than our maximum poll delay\n    const pollDelay = Math.max(\n      MIN_POLL_DELAY,\n      Math.min(\n        MAX_POLL_DELAY,\n        Math.max(MIN_POLL_DELAY, currentApproximateBlockTime),\n      ),\n    );\n\n    // sleep for the pollDelay for this chain (divided by the overPollRatio, which defaults to 2)\n    await sleep(pollDelay / (overPollRatio ?? DEFAULT_OVERPOLL_RATIO));\n    // poll again\n    poll();\n  }\n\n  // return the \"subscribe\" function\n  return function subscribe(\n    callBack: (blockNumber: bigint) => void,\n    initialBlockNumber?: bigint,\n  ) {\n    subscribers.push(callBack);\n    // if we are currently not active -> start polling\n    if (!isActive) {\n      lastBlockNumber = initialBlockNumber;\n      isActive = true;\n      poll();\n    }\n\n    // return the \"unsubscribe\" function (meaning the caller can unsubscribe)\n    return function unSubscribe() {\n      // filter out the callback from the subscribers\n      subscribers = subscribers.filter((fn) => fn !== callBack);\n      // if the new subscribers Array is empty (aka we were the last subscriber) -> stop polling\n      if (subscribers.length === 0) {\n        lastBlockNumber = undefined;\n        lastBlockAt = undefined;\n        isActive = false;\n      }\n    };\n  };\n}\n\nconst existingPollers = new Map<\n  number,\n  ReturnType<typeof createBlockNumberPoller>\n>();\n\nexport type WatchBlockNumberOptions = {\n  client: ThirdwebClient;\n  chain: Chain;\n  onNewBlockNumber: (blockNumber: bigint) => void;\n  onError?: (error: Error) => void;\n  overPollRatio?: number;\n  latestBlockNumber?: bigint;\n};\n\n/**\n * Watches the block number for a specific chain.\n * @param opts - The options for watching the block number.\n * @returns The unwatch function.\n * @example\n * ```ts\n * import { watchBlockNumber } from \"thirdweb\";\n * const unwatch = watchBlockNumber({\n *  client,\n *  chainId,\n *  onNewBlockNumber: (blockNumber) => {\n *    // do something with the block number\n *  },\n *  onError: (err) => {\n *    // do something if getting the block number fails\n *  },\n * });\n *\n * // later stop watching\n * unwatch();\n * ```\n * @rpc\n */\nexport function watchBlockNumber(opts: WatchBlockNumberOptions) {\n  const {\n    client,\n    chain,\n    onNewBlockNumber,\n    overPollRatio,\n    latestBlockNumber,\n    onError,\n  } = opts;\n  const chainId = chain.id;\n  // if we already have a poller for this chainId -> use it.\n  let poller = existingPollers.get(chainId);\n  // otherwise create a new poller\n  if (!poller) {\n    poller = createBlockNumberPoller(client, chain, overPollRatio, onError);\n    // and store it for later use\n    existingPollers.set(chainId, poller);\n  }\n  // subscribe to the poller and return the unSubscribe function to the caller\n  return poller(onNewBlockNumber, latestBlockNumber);\n}\n","import type { EIP1193RequestFn, EIP1474Methods } from \"viem\";\nimport { hexToBigInt } from \"../../utils/encoding/hex.js\";\n\n/**\n * Retrieves the current block number from the Ethereum blockchain.\n * @param request - The EIP1193 request function.\n * @returns A promise that resolves to the current block number as a bigint.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_blockNumber } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const blockNumber = await eth_blockNumber(rpcRequest);\n * ```\n */\nexport async function eth_blockNumber(\n  request: EIP1193RequestFn<EIP1474Methods>,\n): Promise<bigint> {\n  const blockNumberHex = await request({\n    method: \"eth_blockNumber\",\n  });\n  return hexToBigInt(blockNumberHex);\n}\n","import type { Hex } from \"viem\";\nimport type { Chain } from \"../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { eth_getTransactionReceipt } from \"../../rpc/actions/eth_getTransactionReceipt.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\nimport { watchBlockNumber } from \"../../rpc/watchBlockNumber.js\";\nimport type { Prettify } from \"../../utils/type-utils.js\";\nimport type { SendTransactionResult, TransactionReceipt } from \"../types.js\";\n\nconst DEFAULT_MAX_BLOCKS_WAIT_TIME = 100;\n\nconst map = new Map<string, Promise<TransactionReceipt>>();\n\nexport type WaitForReceiptOptions = Prettify<\n  SendTransactionResult & {\n    client: ThirdwebClient;\n    chain: Chain;\n    maxBlocksWaitTime?: number;\n  }\n>;\n\n/**\n * Waits for the transaction receipt of a given transaction hash on a specific contract.\n * @param options - The options for waiting for the receipt.\n * By default, it's 100 blocks.\n * @returns A promise that resolves with the transaction receipt.\n * @transaction\n * @example\n * ```ts\n * import { waitForReceipt } from \"thirdweb\";\n * const receipt = await waitForReceipt({\n *   client,\n *   chain,\n *   transactionHash: \"0x123...\",\n * });\n * ```\n */\nexport function waitForReceipt(\n  options: WaitForReceiptOptions,\n): Promise<TransactionReceipt> {\n  const { transactionHash, chain, client } = options;\n\n  const chainId = chain.id;\n  const key = `${chainId}:tx_${transactionHash}`;\n  const maxBlocksWaitTime =\n    options.maxBlocksWaitTime ?? DEFAULT_MAX_BLOCKS_WAIT_TIME;\n\n  if (map.has(key)) {\n    // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set\n    return map.get(key)!;\n  }\n  const promise = new Promise<TransactionReceipt>((resolve, reject) => {\n    if (!transactionHash) {\n      reject(\n        new Error(\n          \"Transaction has no transactionHash to wait for, did you execute it?\",\n        ),\n      );\n    }\n\n    const request = getRpcClient({ chain, client });\n\n    // start at -1 because the first block doesn't count\n    let blocksWaited = -1;\n\n    const unwatch = watchBlockNumber({\n      chain: chain,\n      client: client,\n      onNewBlockNumber: async () => {\n        blocksWaited++;\n        if (blocksWaited >= maxBlocksWaitTime) {\n          unwatch();\n          reject(\n            new Error(\n              `Transaction receipt for ${transactionHash} not found after ${maxBlocksWaitTime} blocks`,\n            ),\n          );\n          return;\n        }\n        try {\n          const receipt = await eth_getTransactionReceipt(request, {\n            hash: transactionHash as Hex,\n          });\n\n          // stop the polling\n          unwatch();\n          // resolve the top level promise with the receipt\n          resolve(receipt);\n        } catch {\n          // noop, we'll try again on the next blocks\n        }\n      },\n    });\n    // remove the promise from the map when it's done (one way or the other)\n  }).finally(() => {\n    map.delete(key);\n  });\n\n  map.set(key, promise);\n  return promise;\n}\n"],"names":["async","sendAndConfirmTransaction","options","submittedTx","sendTransaction","waitForReceipt","bundlesToTransactions","LruMap","inAppWalletSendCalls","args","account","calls","transactions","map","call","_objectSpread","chain","hashes","id","randomBytesHex","set","sendBatchTransaction","receipt","Error","length","firstTx","serializedTxs","Promise","all","data","to","accessList","value","encode","tx","resolvePromisedValue","chainId","result","client","push","transactionHash","transaction","inAppWalletGetCallsStatus","bundle","get","request","getRpcClient","status","receipts","hash","eth_getTransactionReceipt","then","blockHash","blockNumber","gasUsed","logs","l","address","topics","catch","atomic","filter","r","statusCode","version","sleep","ms","resolve","setTimeout","receiptStatuses","formatTransactionReceipt","transactionReceipt","BigInt","contractAddress","cumulativeGasUsed","effectiveGasPrice","log","eventName","arguments","undefined","logIndex","Number","transactionIndex","formatLog","hexToNumber","type","transactionType","blobGasPrice","blobGasUsed","params","method","MAX_POLL_DELAY","DEFAULT_POLL_DELAY","MIN_POLL_DELAY","DEFAULT_OVERPOLL_RATIO","SLIDING_WINDOW_SIZE","createBlockNumberPoller","overPollRatio","onError","lastBlockNumber","lastBlockAt","subscribers","blockTimesWindow","isActive","rpcRequest","poll","blockNumberHex","hexToBigInt","eth_blockNumber","newBlockNumbers","i","currentTime","Date","now","blockTime","slice","b","subscriberCallback","err","console","error","concat","currentApproximateBlockTime","blockTimes","unshift","reduce","acc","getAverageBlockTime","pollDelay","Math","max","min","callBack","initialBlockNumber","fn","existingPollers","Map","DEFAULT_MAX_BLOCKS_WAIT_TIME","_options$maxBlocksWai","key","maxBlocksWaitTime","has","promise","reject","blocksWaited","unwatch","opts","onNewBlockNumber","latestBlockNumber","poller","watchBlockNumber","_unused","finally","delete"],"sourceRoot":""}