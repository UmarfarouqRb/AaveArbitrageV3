{"version":3,"file":"static/js/71965.53a3702e.chunk.js","mappings":"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","sources":["../node_modules/thirdweb/src/auth/constants.ts","../node_modules/thirdweb/src/auth/serialize-erc6492-signature.ts","../node_modules/thirdweb/src/extensions/erc1271/__generated__/isValidSignature/read/isValidSignature.ts","../node_modules/thirdweb/src/auth/verify-hash.ts","../node_modules/thirdweb/src/utils/hashing/hashMessage.ts","../node_modules/thirdweb/src/utils/hashing/hashTypedData.ts","../node_modules/thirdweb/src/wallets/smart/lib/signing.ts"],"sourcesContent":["export const ERC_6492_MAGIC_VALUE =\n  \"0x6492649264926492649264926492649264926492649264926492649264926492\" as const;\n","import { encodeAbiParameters } from \"../utils/abi/encodeAbiParameters.js\";\nimport { concatHex } from \"../utils/encoding/helpers/concat-hex.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\nimport { ERC_6492_MAGIC_VALUE } from \"./constants.js\";\nimport type { Erc6492Signature } from \"./types.js\";\n\n/**\n * Serializes a signature for use with [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492). The signature must be generated by a signer for an [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337) Account Factory account with counterfactual deployment addresses.\n *\n * @param {@link Erc6492Signature} signature  The signature object to serialize into Hex format\n * @param {string} signature.address The ERC-4337 Account Factory address\n * @param {Hex} signature.data Account deployment calldata (if not deployed) for counterfactual verification\n * @param {Hex} signature.signature The original signature\n *\n * @returns {Hex} The serialized signature\n *\n * @example\n * ```ts\n * import { serializeErc6492Signature } from 'thirdweb/auth';\n *\n * const serializedSignature = serializeErc6492Signature({\n *  address: '0x...',\n *  data: '0x...',\n *  signature: '0x...',\n * });\n * // 0x000000000000000000000000cafebabecafebabecafebabecafebabecafebabe000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004deadbeef000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041a461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492\n * ```\n * @auth\n */\nexport function serializeErc6492Signature({\n  address,\n  data,\n  signature,\n}: Erc6492Signature): Hex {\n  return concatHex([\n    encodeAbiParameters(\n      [{ type: \"address\" }, { type: \"bytes\" }, { type: \"bytes\" }],\n      [address, data, signature],\n    ),\n    ERC_6492_MAGIC_VALUE,\n  ]);\n}\n","import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { decodeAbiParameters } from \"viem\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\n\n/**\n * Represents the parameters for the \"isValidSignature\" function.\n */\nexport type IsValidSignatureParams = {\n  hash: AbiParameterToPrimitiveType<{ type: \"bytes32\"; name: \"hash\" }>;\n  signature: AbiParameterToPrimitiveType<{ type: \"bytes\"; name: \"signature\" }>;\n};\n\nexport const FN_SELECTOR = \"0x1626ba7e\" as const;\nconst FN_INPUTS = [\n  {\n    name: \"hash\",\n    type: \"bytes32\",\n  },\n  {\n    name: \"signature\",\n    type: \"bytes\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"bytes4\",\n  },\n] as const;\n\n/**\n * Checks if the `isValidSignature` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `isValidSignature` method is supported.\n * @extension ERC1271\n * @example\n * ```ts\n * import { isIsValidSignatureSupported } from \"thirdweb/extensions/erc1271\";\n * const supported = isIsValidSignatureSupported([\"0x...\"]);\n * ```\n */\nexport function isIsValidSignatureSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"isValidSignature\" function.\n * @param options - The options for the isValidSignature function.\n * @returns The encoded ABI parameters.\n * @extension ERC1271\n * @example\n * ```ts\n * import { encodeIsValidSignatureParams } from \"thirdweb/extensions/erc1271\";\n * const result = encodeIsValidSignatureParams({\n *  hash: ...,\n *  signature: ...,\n * });\n * ```\n */\nexport function encodeIsValidSignatureParams(options: IsValidSignatureParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.hash, options.signature]);\n}\n\n/**\n * Encodes the \"isValidSignature\" function into a Hex string with its parameters.\n * @param options - The options for the isValidSignature function.\n * @returns The encoded hexadecimal string.\n * @extension ERC1271\n * @example\n * ```ts\n * import { encodeIsValidSignature } from \"thirdweb/extensions/erc1271\";\n * const result = encodeIsValidSignature({\n *  hash: ...,\n *  signature: ...,\n * });\n * ```\n */\nexport function encodeIsValidSignature(options: IsValidSignatureParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeIsValidSignatureParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the isValidSignature function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC1271\n * @example\n * ```ts\n * import { decodeIsValidSignatureResult } from \"thirdweb/extensions/erc1271\";\n * const result = decodeIsValidSignatureResultResult(\"...\");\n * ```\n */\nexport function decodeIsValidSignatureResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"isValidSignature\" function on the contract.\n * @param options - The options for the isValidSignature function.\n * @returns The parsed result of the function call.\n * @extension ERC1271\n * @example\n * ```ts\n * import { isValidSignature } from \"thirdweb/extensions/erc1271\";\n *\n * const result = await isValidSignature({\n *  contract,\n *  hash: ...,\n *  signature: ...,\n * });\n *\n * ```\n */\nexport async function isValidSignature(\n  options: BaseTransactionOptions<IsValidSignatureParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.hash, options.signature],\n  });\n}\n","import * as ox__Abi from \"ox/Abi\";\nimport * as ox__AbiConstructor from \"ox/AbiConstructor\";\nimport * as ox__AbiFunction from \"ox/AbiFunction\";\nimport { WrappedSignature as ox__WrappedSignature } from \"ox/erc6492\";\nimport * as ox__Signature from \"ox/Signature\";\nimport type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { getContract, type ThirdwebContract } from \"../contract/contract.js\";\nimport { isValidSignature } from \"../extensions/erc1271/__generated__/isValidSignature/read/isValidSignature.js\";\nimport { eth_call } from \"../rpc/actions/eth_call.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport type { Address } from \"../utils/address.js\";\nimport { isZkSyncChain } from \"../utils/any-evm/zksync/isZkSyncChain.js\";\nimport { isContractDeployed } from \"../utils/bytecode/is-contract-deployed.js\";\nimport { fromBytes } from \"../utils/encoding/from-bytes.js\";\nimport { type Hex, hexToBool, isHex } from \"../utils/encoding/hex.js\";\nimport { serializeErc6492Signature } from \"./serialize-erc6492-signature.js\";\n\nexport type VerifyHashParams = {\n  hash: Hex;\n  signature: string | Uint8Array | ox__Signature.Signature;\n  address: string;\n  client: ThirdwebClient;\n  chain: Chain;\n  accountFactory?: {\n    address: string;\n    verificationCalldata: Hex;\n  };\n};\n\nconst ZKSYNC_VALIDATOR_ADDRESS: Address =\n  \"0xfB688330379976DA81eB64Fe4BF50d7401763B9C\";\n\n/**\n * Verify that an address created the provided signature for a given hash using [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492). This function is interoperable with all wallet types, including EOAs.\n * This function should rarely be used directly, instead use @see {import(\"./verify-signature.js\")} and @see {import(\"./verify-typed-data.js\")}}\n *\n * @param {Hex} options.hash The hash that was signed\n * @param {string | Uint8Array | Signature} options.signature The signature that was signed\n * @param {string} options.address The address that signed the hash\n * @param {ThirdwebClient} options.client The Thirdweb client\n * @param {Chain} options.chain The chain that the address is on. For an EOA, this can be any chain.\n * @param {string} [options.accountFactory.address] The address of the account factory that created the account if using a smart account with a custom account factory\n * @param {Hex} [options.accountFactory.verificationCalldata] The calldata that was used to create the account if using a smart account with a custom account factory\n *\n * @returns {Promise<boolean>} A promise that resolves to `true` if the signature is valid, or `false` otherwise.\n *\n * @example\n * ```ts\n * import { verifyHash } from \"thirdweb/utils\";\n * const isValid = await verifyHash({\n *   hash: \"0x1234\",\n *   signature: \"0x1234\",\n *   address: \"0x1234\",\n *   client,\n *   chain,\n * });\n * ```\n *\n * @auth\n */\nexport async function verifyHash({\n  hash,\n  signature,\n  address,\n  client,\n  chain,\n  accountFactory,\n}: VerifyHashParams): Promise<boolean> {\n  const signatureHex = (() => {\n    if (isHex(signature)) return signature;\n    if (typeof signature === \"object\" && \"r\" in signature && \"s\" in signature)\n      return ox__Signature.toHex(signature);\n    if (signature instanceof Uint8Array) return fromBytes(signature, \"hex\");\n    // We should never hit this but TS doesn't know that\n    throw new Error(\n      `Invalid signature type for signature ${signature}: ${typeof signature}`,\n    );\n  })();\n\n  const isDeployed = await isContractDeployed(\n    getContract({\n      address,\n      chain,\n      client,\n    }),\n  );\n\n  if (isDeployed) {\n    const validEip1271 = await verifyEip1271Signature({\n      contract: getContract({\n        address,\n        chain,\n        client,\n      }),\n      hash,\n      signature: signatureHex,\n    }).catch((err) => {\n      console.error(\"Error verifying EIP-1271 signature\", err);\n      return false;\n    });\n    if (validEip1271) {\n      return true;\n    }\n  }\n\n  // contract not deployed, use erc6492 validator to verify signature\n  const wrappedSignature: Hex = await (async () => {\n    // If no factory is provided, we have to assume its already deployed or is an EOA\n    // TODO: Figure out how to automatically tell if our default factory was used\n    if (!accountFactory) return signatureHex;\n\n    // If this sigature was already wrapped for ERC-6492, carry on\n    if (ox__WrappedSignature.validate(signatureHex)) return signatureHex;\n\n    // Otherwise, serialize the signature for ERC-6492 validation\n    return serializeErc6492Signature({\n      address: accountFactory.address,\n      data: accountFactory.verificationCalldata,\n      signature: signatureHex,\n    });\n  })();\n\n  let verificationData: {\n    to?: Address;\n    data: Hex;\n  };\n\n  const zkSyncChain = await isZkSyncChain(chain);\n  const abi = ox__Abi.from(ox__WrappedSignature.universalSignatureValidatorAbi);\n  if (zkSyncChain) {\n    // zksync chains dont support deploying code with eth_call\n    // need to call a deployed contract instead\n    verificationData = {\n      data: ox__AbiFunction.encodeData(\n        ox__AbiFunction.fromAbi(abi, \"isValidSig\"),\n        [address, hash, wrappedSignature],\n      ),\n      to: ZKSYNC_VALIDATOR_ADDRESS,\n    };\n  } else {\n    const validatorConstructor = ox__AbiConstructor.fromAbi(abi);\n    verificationData = {\n      data: ox__AbiConstructor.encode(validatorConstructor, {\n        args: [address, hash, wrappedSignature],\n        bytecode: ox__WrappedSignature.universalSignatureValidatorBytecode,\n      }),\n    };\n  }\n\n  const rpcRequest = getRpcClient({\n    chain,\n    client,\n  });\n\n  try {\n    const result = await eth_call(rpcRequest, verificationData);\n    return hexToBool(result);\n  } catch {\n    // Some chains do not support the eth_call simulation and will fail, so we fall back to regular EIP1271 validation\n    const validEip1271 = await verifyEip1271Signature({\n      contract: getContract({\n        address,\n        chain,\n        client,\n      }),\n      hash,\n      signature: signatureHex,\n    }).catch((err) => {\n      console.error(\"Error verifying EIP-1271 signature\", err);\n      return false;\n    });\n    if (validEip1271) {\n      return true;\n    }\n    // TODO: Improve overall RPC error handling so we can tell if this was an actual verification failure or some other error\n    // Verification failed somehow\n    return false;\n  }\n}\n\nconst EIP_1271_MAGIC_VALUE = \"0x1626ba7e\";\nexport async function verifyEip1271Signature({\n  hash,\n  signature,\n  contract,\n}: {\n  hash: Hex;\n  signature: Hex;\n  contract: ThirdwebContract;\n}): Promise<boolean> {\n  try {\n    const result = await isValidSignature({\n      contract,\n      hash,\n      signature,\n    });\n    return result === EIP_1271_MAGIC_VALUE;\n  } catch (err) {\n    console.error(\"Error verifying EIP-1271 signature\", err);\n    return false;\n  }\n}\n","import * as ox__Bytes from \"ox/Bytes\";\nimport type { Hex } from \"../encoding/hex.js\";\nimport { stringToBytes, toBytes } from \"../encoding/to-bytes.js\";\nimport type { SignableMessage } from \"../types.js\";\nimport { keccak256 } from \"./keccak256.js\";\n\nconst presignMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\ntype To = \"hex\" | \"bytes\";\n\ntype HashMessage<TTo extends To> =\n  | (TTo extends \"bytes\" ? ox__Bytes.Bytes : never)\n  | (TTo extends \"hex\" ? Hex : never);\n\n/**\n * Ethereum Signed Message hashing\n * @param message - The message to hash, either as a string, a Uint8Array, or an object with a `raw` property containing a Uint8Array.\n * @param to_ - The desired output format of the hash (optional). Defaults to 'hex'.\n * @example\n * ```ts\n * import { hashMessage } from \"thirdweb/utils\";\n * const hash = hashMessage(\"hello world\");\n * ```\n * @returns The Ethereum Signed Message hash of the message in the specified format.\n * @utils\n */\nexport function hashMessage<TTo extends To = \"hex\">(\n  message: SignableMessage,\n  to_?: TTo,\n): HashMessage<TTo> {\n  const messageBytes = (() => {\n    if (typeof message === \"string\") {\n      return stringToBytes(message);\n    }\n    if (message.raw instanceof Uint8Array) {\n      return message.raw;\n    }\n    return toBytes(message.raw);\n  })();\n  const prefixBytes = stringToBytes(\n    `${presignMessagePrefix}${messageBytes.length}`,\n  );\n  return keccak256(ox__Bytes.concat(prefixBytes, messageBytes), to_);\n}\n","import type * as ox__AbiParameters from \"ox/AbiParameters\";\nimport * as ox__Bytes from \"ox/Bytes\";\nimport * as ox__TypedData from \"ox/TypedData\";\nimport { encodeAbiParameters } from \"../abi/encodeAbiParameters.js\";\nimport { type Hex, toHex } from \"../encoding/hex.js\";\nimport { keccak256 } from \"./keccak256.js\";\n\ntype MessageTypeProperty = {\n  name: string;\n  type: string;\n};\n\nexport type HashTypedDataParams<\n  typedData extends\n    | ox__TypedData.TypedData\n    | Record<string, unknown> = ox__TypedData.TypedData,\n  primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n> = ox__TypedData.Definition<typedData, primaryType>;\n\n/**\n * @internal\n */\nexport function hashTypedData<\n  const typedData extends ox__TypedData.TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | \"EIP712Domain\",\n>(parameters: HashTypedDataParams<typedData, primaryType>): Hex {\n  const {\n    domain = {},\n    message,\n    primaryType,\n  } = parameters as HashTypedDataParams;\n  const types = {\n    EIP712Domain: ox__TypedData.extractEip712DomainTypes(domain),\n    ...parameters.types,\n  };\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  ox__TypedData.validate({\n    domain,\n    message,\n    primaryType,\n    types,\n  });\n\n  const parts: Hex[] = [\"0x1901\"];\n  if (domain)\n    parts.push(\n      ox__TypedData.hashDomain({\n        domain,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    );\n\n  if (primaryType !== \"EIP712Domain\") {\n    const hashedStruct = (() => {\n      const encoded = encodeData({\n        data: message,\n        primaryType,\n        types: types as Record<string, MessageTypeProperty[]>,\n      });\n      return keccak256(encoded);\n    })();\n\n    parts.push(hashedStruct);\n  }\n\n  return keccak256(ox__Bytes.concat(...parts.map((p) => ox__Bytes.fromHex(p))));\n}\n\nfunction encodeData({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>;\n  primaryType: string;\n  types: Record<string, MessageTypeProperty[]>;\n}) {\n  const encodedTypes: ox__AbiParameters.Parameter[] = [{ type: \"bytes32\" }];\n  const encodedValues: unknown[] = [hashType({ primaryType, types })];\n\n  if (!types[primaryType]) throw new Error(\"Invalid types\");\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      name: field.name,\n      type: field.type,\n      types,\n      value: data[field.name],\n    });\n    encodedTypes.push(type);\n    encodedValues.push(value);\n  }\n\n  return encodeAbiParameters(encodedTypes, encodedValues);\n}\n\nfunction hashType({\n  primaryType,\n  types,\n}: {\n  primaryType: string;\n  types: Record<string, MessageTypeProperty[]>;\n}) {\n  const encodedHashType = toHex(encodeType({ primaryType, types }));\n  return keccak256(encodedHashType);\n}\n\nfunction encodeType({\n  primaryType,\n  types,\n}: {\n  primaryType: string;\n  types: Record<string, MessageTypeProperty[]>;\n}) {\n  let result = \"\";\n  const unsortedDeps = findTypeDependencies({ primaryType, types });\n  unsortedDeps.delete(primaryType);\n\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];\n  for (const type of deps) {\n    if (!types[type]) throw new Error(\"Invalid types\");\n    result += `${type}(${types[type]\n      .map(({ name, type: t }) => `${t} ${name}`)\n      .join(\",\")})`;\n  }\n\n  return result;\n}\n\nfunction findTypeDependencies(\n  {\n    primaryType: primaryType_,\n    types,\n  }: {\n    primaryType: string;\n    types: Record<string, MessageTypeProperty[]>;\n  },\n  results: Set<string> = new Set(),\n): Set<string> {\n  const match = primaryType_.match(/^\\w*/u);\n  const primaryType = match?.[0] as string;\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results;\n  }\n\n  results.add(primaryType);\n\n  for (const field of types[primaryType]) {\n    findTypeDependencies({ primaryType: field.type, types }, results);\n  }\n  return results;\n}\n\nfunction encodeField({\n  types,\n  name,\n  type,\n  value,\n}: {\n  types: Record<string, MessageTypeProperty[]>;\n  name: string;\n  type: string;\n  // biome-ignore lint/suspicious/noExplicitAny: Can't anticipate types of nested values\n  value: any;\n  // biome-ignore lint/suspicious/noExplicitAny: Can't anticipate types of nested values\n}): [type: ox__AbiParameters.Parameter, value: any] {\n  if (types[type] !== undefined) {\n    return [\n      { type: \"bytes32\" },\n      keccak256(encodeData({ data: value, primaryType: type, types })),\n    ];\n  }\n\n  if (type === \"bytes\") {\n    const prepend = value.length % 2 ? \"0\" : \"\";\n    value = `0x${prepend + value.slice(2)}`;\n    return [{ type: \"bytes32\" }, keccak256(value)];\n  }\n\n  if (type === \"string\") return [{ type: \"bytes32\" }, keccak256(toHex(value))];\n\n  if (type.lastIndexOf(\"]\") === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf(\"[\"));\n    const typeValuePairs =\n      // biome-ignore lint/suspicious/noExplicitAny: Can't anticipate types of nested values\n      (value as [ox__AbiParameters.Parameter, any][]).map((item) =>\n        encodeField({\n          name,\n          type: parsedType,\n          types,\n          value: item,\n        }),\n      );\n    return [\n      { type: \"bytes32\" },\n      keccak256(\n        encodeAbiParameters(\n          typeValuePairs.map(([t]) => t),\n          typeValuePairs.map(([, v]) => v),\n        ),\n      ),\n    ];\n  }\n\n  return [{ type }, value];\n}\n","import type * as ox__TypedData from \"ox/TypedData\";\nimport { serializeErc6492Signature } from \"../../../auth/serialize-erc6492-signature.js\";\nimport { verifyEip1271Signature } from \"../../../auth/verify-hash.js\";\nimport type { Chain } from \"../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../client/client.js\";\nimport type { ThirdwebContract } from \"../../../contract/contract.js\";\nimport { encode } from \"../../../transaction/actions/encode.js\";\nimport { encodeAbiParameters } from \"../../../utils/abi/encodeAbiParameters.js\";\nimport { isContractDeployed } from \"../../../utils/bytecode/is-contract-deployed.js\";\nimport { hashMessage } from \"../../../utils/hashing/hashMessage.js\";\nimport { hashTypedData } from \"../../../utils/hashing/hashTypedData.js\";\nimport type { SignableMessage } from \"../../../utils/types.js\";\nimport type { Account } from \"../../../wallets/interfaces/wallet.js\";\nimport type { SmartAccountOptions } from \"../types.js\";\nimport { prepareCreateAccount } from \"./calls.js\";\n\n/**\n * If the account is already deployed, generate an ERC-1271 signature.\n * If the account is not deployed, generate an ERC-6492 signature unless otherwise specified.\n *\n * @internal\n */\nexport async function smartAccountSignMessage({\n  accountContract,\n  factoryContract,\n  options,\n  message,\n}: {\n  accountContract: ThirdwebContract;\n  factoryContract: ThirdwebContract;\n  options: SmartAccountOptions;\n  message: SignableMessage;\n}) {\n  const originalMsgHash = hashMessage(message);\n\n  let sig: `0x${string}`;\n  const wrappedMessageHash = encodeAbiParameters(\n    [{ type: \"bytes32\" }],\n    [originalMsgHash],\n  );\n\n  sig = await options.personalAccount.signTypedData({\n    domain: {\n      chainId: options.chain.id,\n      name: \"Account\",\n      verifyingContract: accountContract.address,\n      version: \"1\",\n    },\n    message: { message: wrappedMessageHash },\n    primaryType: \"AccountMessage\",\n    types: { AccountMessage: [{ name: \"message\", type: \"bytes\" }] },\n  });\n\n  const isDeployed = await isContractDeployed(accountContract);\n  if (isDeployed) {\n    const isValid = await verifyEip1271Signature({\n      contract: accountContract,\n      hash: originalMsgHash,\n      signature: sig,\n    });\n    if (isValid) {\n      return sig;\n    }\n    throw new Error(\"Failed to verify signature\");\n  } else {\n    const deployTx = prepareCreateAccount({\n      accountSalt: options.overrides?.accountSalt,\n      adminAddress: options.personalAccount.address,\n      createAccountOverride: options.overrides?.createAccount,\n      factoryContract,\n    });\n    if (!deployTx) {\n      throw new Error(\"Create account override not provided\");\n    }\n    const initCode = await encode(deployTx);\n    const erc6492Sig = serializeErc6492Signature({\n      address: factoryContract.address,\n      data: initCode,\n      signature: sig,\n    });\n\n    return erc6492Sig;\n  }\n}\n\nexport async function smartAccountSignTypedData<\n  const typedData extends ox__TypedData.TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n>({\n  accountContract,\n  factoryContract,\n  options,\n  typedData,\n}: {\n  accountContract: ThirdwebContract;\n  factoryContract: ThirdwebContract;\n  options: SmartAccountOptions;\n  typedData: ox__TypedData.Definition<typedData, primaryType>;\n}) {\n  const isSelfVerifyingContract =\n    (\n      typedData.domain as ox__TypedData.Domain\n    )?.verifyingContract?.toLowerCase() ===\n    accountContract.address?.toLowerCase();\n\n  if (isSelfVerifyingContract) {\n    // if the contract is self-verifying, we can just sign the message with the EOA (ie. adding a session key)\n    return options.personalAccount.signTypedData(typedData);\n  }\n\n  const originalMsgHash = hashTypedData(typedData);\n\n  let sig: `0x${string}`;\n  const wrappedMessageHash = encodeAbiParameters(\n    [{ type: \"bytes32\" }],\n    [originalMsgHash],\n  );\n  sig = await options.personalAccount.signTypedData({\n    domain: {\n      chainId: options.chain.id,\n      name: \"Account\",\n      verifyingContract: accountContract.address,\n      version: \"1\",\n    },\n    message: { message: wrappedMessageHash },\n    primaryType: \"AccountMessage\",\n    types: { AccountMessage: [{ name: \"message\", type: \"bytes\" }] },\n  });\n\n  const isDeployed = await isContractDeployed(accountContract);\n  if (isDeployed) {\n    const isValid = await verifyEip1271Signature({\n      contract: accountContract,\n      hash: originalMsgHash,\n      signature: sig,\n    });\n    if (isValid) {\n      return sig;\n    }\n    throw new Error(\"Failed to verify signature\");\n  } else {\n    const deployTx = prepareCreateAccount({\n      accountSalt: options.overrides?.accountSalt,\n      adminAddress: options.personalAccount.address,\n      createAccountOverride: options.overrides?.createAccount,\n      factoryContract,\n    });\n    if (!deployTx) {\n      throw new Error(\"Create account override not provided\");\n    }\n    const initCode = await encode(deployTx);\n    const erc6492Sig = serializeErc6492Signature({\n      address: factoryContract.address,\n      data: initCode,\n      signature: sig,\n    });\n\n    return erc6492Sig;\n  }\n}\n\nexport async function confirmContractDeployment(args: {\n  accountContract: ThirdwebContract;\n}) {\n  const { accountContract } = args;\n  const startTime = Date.now();\n  const timeout = 60000; // wait 1 minute max\n  const { isContractDeployed } = await import(\n    \"../../../utils/bytecode/is-contract-deployed.js\"\n  );\n  let isDeployed = await isContractDeployed(accountContract);\n  while (!isDeployed) {\n    if (Date.now() - startTime > timeout) {\n      throw new Error(\n        \"Timeout: Smart account deployment not confirmed after 1 minute\",\n      );\n    }\n    await new Promise((resolve) => setTimeout(resolve, 500));\n    isDeployed = await isContractDeployed(accountContract);\n  }\n}\n\n/**\n * Deployes a smart account via a dummy transaction. If the account is already deployed, this will do nothing.\n *\n * @param args - Arguments for the deployment.\n * @param args.smartAccount - The smart account to deploy.\n * @param args.chain - The chain to deploy on.\n * @param args.client - The client to use for the deployment.\n * @param args.accountContract - The account contract to deploy.\n *\n * @example\n * ```ts\n * import { deploySmartAccount } from \"thirdweb\";\n *\n * const account = await deploySmartAccount({\n *   smartAccount,\n *   chain,\n *   client,\n *   accountContract,\n * });\n * ```\n *\n * @wallet\n */\nexport async function deploySmartAccount(args: {\n  smartAccount: Account;\n  chain: Chain;\n  client: ThirdwebClient;\n  accountContract: ThirdwebContract;\n}) {\n  const { chain, client, smartAccount, accountContract } = args;\n  const isDeployed = await isContractDeployed(accountContract);\n  if (isDeployed) {\n    return;\n  }\n\n  const [{ sendTransaction }, { prepareTransaction }] = await Promise.all([\n    import(\"../../../transaction/actions/send-transaction.js\"),\n    import(\"../../../transaction/prepare-transaction.js\"),\n  ]);\n  const dummyTx = prepareTransaction({\n    chain: chain,\n    client: client,\n    gas: 50000n,\n    to: accountContract.address,\n    value: 0n, // force gas to avoid simulation error\n  });\n  const deployResult = await sendTransaction({\n    account: smartAccount,\n    transaction: dummyTx,\n  });\n\n  await confirmContractDeployment({\n    accountContract,\n  });\n\n  return deployResult;\n}\n"],"names":["ERC_6492_MAGIC_VALUE","serializeErc6492Signature","_ref","address","data","signature","concatHex","encodeAbiParameters","type","FN_SELECTOR","FN_INPUTS","name","FN_OUTPUTS","EIP_1271_MAGIC_VALUE","async","verifyEip1271Signature","_ref2","hash","contract","options","readContract","method","params","isValidSignature","err","console","error","presignMessagePrefix","encodeData","primaryType","types","encodedTypes","encodedValues","hashType","Error","field","value","encodeField","push","encodedHashType","toHex","_ref3","result","unsortedDeps","findTypeDependencies","delete","deps","Array","from","sort","concat","map","_ref4","t","join","encodeType","keccak256","_ref5","primaryType_","results","arguments","length","undefined","Set","match","has","add","_ref6","prepend","slice","lastIndexOf","parsedType","typeValuePairs","item","_ref7","_ref8","v","smartAccountSignMessage","accountContract","factoryContract","message","originalMsgHash","to_","messageBytes","stringToBytes","raw","Uint8Array","toBytes","prefixBytes","ox__Bytes","hashMessage","sig","wrappedMessageHash","personalAccount","signTypedData","domain","chainId","chain","id","verifyingContract","version","AccountMessage","isContractDeployed","_options$overrides","_options$overrides2","deployTx","prepareCreateAccount","accountSalt","overrides","adminAddress","createAccountOverride","createAccount","initCode","encode","smartAccountSignTypedData","_typedData$domain","_accountContract$addr","typedData","toLowerCase","parameters","_objectSpread","EIP712Domain","ox__TypedData","parts","hashedStruct","encoded","p","hashTypedData","_options$overrides3","_options$overrides4"],"sourceRoot":""}