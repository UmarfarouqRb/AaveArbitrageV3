{"version":3,"file":"static/js/45177.fc463b3f.chunk.js","mappings":"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","sources":["../node_modules/thirdweb/src/transaction/actions/gasless/providers/openzeppelin.ts","../node_modules/thirdweb/src/transaction/read-contract.ts","../node_modules/thirdweb/src/rpc/actions/eth_call.ts"],"sourcesContent":["import type { Address } from \"abitype\";\nimport { getContract } from \"../../../../contract/contract.js\";\nimport { isHex } from \"../../../../utils/encoding/helpers/is-hex.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nimport type { Account } from \"../../../../wallets/interfaces/wallet.js\";\nimport type { PreparedTransaction } from \"../../../prepare-transaction.js\";\nimport { readContract } from \"../../../read-contract.js\";\nimport type { SerializableTransaction } from \"../../../serialize-transaction.js\";\nimport type { WaitForReceiptOptions } from \"../../wait-for-tx-receipt.js\";\n\n/**\n * @transaction\n */\nexport type OpenZeppelinOptions = {\n  provider: \"openzeppelin\";\n  relayerUrl: string;\n  relayerForwarderAddress: Address;\n  domainName?: string; // default: \"GSNv2 Forwarder\"\n  domainVersion?: string; // default: \"0.0.1\"\n  domainSeparatorVersion?: string; // default: \"1\"\n  experimentalChainlessSupport?: boolean; // default: false\n};\n\ntype SendOpenZeppelinTransactionOptions = {\n  account: Account;\n  // TODO: update this to `Transaction<\"prepared\">` once the type is available to ensure only prepared transactions are accepted\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any prepared transaction type\n  transaction: PreparedTransaction<any>;\n  serializableTransaction: SerializableTransaction;\n  gasless: OpenZeppelinOptions;\n};\n\n/**\n * @internal - only exported for testing\n */\nexport async function prepareOpenZeppelinTransaction({\n  account,\n  serializableTransaction,\n  transaction,\n  gasless,\n}: SendOpenZeppelinTransactionOptions) {\n  const forrwaderContract = getContract({\n    address: gasless.relayerForwarderAddress,\n    chain: transaction.chain,\n    client: transaction.client,\n  });\n\n  const nonce = await readContract({\n    contract: forrwaderContract,\n    method: \"function getNonce(address) view returns (uint256)\",\n    params: [account.address],\n  });\n\n  const [signature, message] = await (async () => {\n    // TODO: handle special case for `approve` -> `permit` transactions\n\n    if (!serializableTransaction.to) {\n      throw new Error(\"OpenZeppelin transactions must have a 'to' address\");\n    }\n    if (!serializableTransaction.gas) {\n      throw new Error(\"OpenZeppelin transactions must have a 'gas' value\");\n    }\n    if (!serializableTransaction.data) {\n      throw new Error(\"OpenZeppelin transactions must have a 'data' value\");\n    }\n    // chainless support!\n    if (gasless.experimentalChainlessSupport) {\n      const message = {\n        chainid: BigInt(transaction.chain.id),\n        data: serializableTransaction.data,\n        from: account.address,\n        gas: serializableTransaction.gas,\n        nonce: nonce,\n        to: serializableTransaction.to,\n        value: 0n,\n      } as const;\n      return [\n        await account.signTypedData({\n          domain: {\n            name: \"GSNv2 Forwarder\",\n            verifyingContract: forrwaderContract.address,\n            version: \"0.0.1\",\n          },\n          message,\n          primaryType: \"ForwardRequest\",\n          types: { ForwardRequest: ChainAwareForwardRequest },\n        }),\n        message,\n      ] as const;\n    }\n    // else non-chainless support\n    const message = {\n      data: serializableTransaction.data,\n      from: account.address,\n      gas: serializableTransaction.gas,\n      nonce: nonce,\n      to: serializableTransaction.to,\n      value: 0n,\n    } as const;\n    return [\n      await account.signTypedData({\n        domain: {\n          chainId: transaction.chain.id,\n          name: gasless.domainName ?? \"GSNv2 Forwarder\",\n          verifyingContract: forrwaderContract.address,\n          version: gasless.domainVersion ?? \"0.0.1\",\n        },\n        message,\n        primaryType: \"ForwardRequest\",\n        types: { ForwardRequest },\n      }),\n      message,\n    ] as const;\n  })();\n  // TODO: handle special case for `approve` -> `permit`\n  const messageType = \"forward\";\n\n  return { message, messageType, signature } as const;\n}\n\nconst ForwardRequest = [\n  { name: \"from\", type: \"address\" },\n  { name: \"to\", type: \"address\" },\n  { name: \"value\", type: \"uint256\" },\n  { name: \"gas\", type: \"uint256\" },\n  { name: \"nonce\", type: \"uint256\" },\n  { name: \"data\", type: \"bytes\" },\n] as const;\n\nconst ChainAwareForwardRequest = [\n  { name: \"from\", type: \"address\" },\n  { name: \"to\", type: \"address\" },\n  { name: \"value\", type: \"uint256\" },\n  { name: \"gas\", type: \"uint256\" },\n  { name: \"nonce\", type: \"uint256\" },\n  { name: \"data\", type: \"bytes\" },\n  { name: \"chainid\", type: \"uint256\" },\n] as const;\n\n/**\n * @internal\n */\nexport async function relayOpenZeppelinTransaction(\n  options: SendOpenZeppelinTransactionOptions,\n): Promise<WaitForReceiptOptions> {\n  const { message, messageType, signature } =\n    await prepareOpenZeppelinTransaction(options);\n\n  const response = await fetch(options.gasless.relayerUrl, {\n    body: stringify({\n      forwarderAddress: options.gasless.relayerForwarderAddress,\n      request: message,\n      signature,\n      type: messageType,\n    }),\n    method: \"POST\",\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to send transaction: ${await response.text()}`);\n  }\n  const json = await response.json();\n  if (!json.result) {\n    throw new Error(`Relay transaction failed: ${json.message}`);\n  }\n  const transactionHash = JSON.parse(json.result).txHash;\n  if (isHex(transactionHash)) {\n    return {\n      chain: options.transaction.chain,\n      client: options.transaction.client,\n      transactionHash,\n    };\n  }\n\n  throw new Error(`Failed to send transaction: ${stringify(json)}`);\n}\n","import {\n  type Abi,\n  type AbiFunction,\n  type AbiParameter,\n  type AbiParametersToPrimitiveTypes,\n  type ExtractAbiFunctionNames,\n  parseAbiItem,\n} from \"abitype\";\nimport { decodeAbiParameters, type TransactionRequest } from \"viem\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\nimport { eth_call } from \"../rpc/actions/eth_call.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport { encodeAbiParameters } from \"../utils/abi/encodeAbiParameters.js\";\nimport {\n  type PreparedMethod,\n  prepareMethod,\n} from \"../utils/abi/prepare-method.js\";\nimport { getAddress } from \"../utils/address.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\nimport type { PrepareTransactionOptions } from \"./prepare-transaction.js\";\nimport type {\n  BaseTransactionOptions,\n  ParamsOption,\n  ParseMethod,\n} from \"./types.js\";\nimport { isAbiFunction } from \"./utils.js\";\n\nexport type ReadContractResult<outputs extends readonly AbiParameter[]> = // if the outputs are 0 length, return never, invalid case\n  outputs extends { length: 0 }\n    ? never\n    : outputs extends { length: 1 }\n      ? // if the outputs are 1 length, we'll always return the first element\n        AbiParametersToPrimitiveTypes<outputs>[0]\n      : // otherwise we'll return the array\n        AbiParametersToPrimitiveTypes<outputs>;\n\nexport type ReadContractOptions<\n  TAbi extends Abi = [],\n  TMethod extends\n    | AbiFunction\n    | string\n    | ((\n        contract: ThirdwebContract<TAbi>,\n      ) => Promise<AbiFunction>) = TAbi extends { length: 0 }\n    ? AbiFunction | string\n    : ExtractAbiFunctionNames<TAbi>,\n  TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n> = BaseTransactionOptions<\n  Omit<\n    TransactionRequest,\n    | \"from\"\n    | \"to\"\n    | \"data\"\n    | \"value\"\n    | \"accessList\"\n    | \"gas\"\n    | \"gasPrice\"\n    | \"maxFeePerGas\"\n    | \"maxPriorityFeePerGas\"\n    | \"nonce\"\n  > & {\n    method: TMethod | TPreparedMethod;\n    from?: string;\n  } & ParamsOption<TPreparedMethod[1]> &\n    Omit<PrepareTransactionOptions, \"to\" | \"data\" | \"chain\" | \"client\">,\n  TAbi\n>;\n\n/**\n * ### Reads state from a deployed smart contract.\n *\n * Use this for raw read calls from a contract, but you can also use read [extensions](https://portal.thirdweb.com/typescript/v5/extensions/use) for predefined methods for common standards.\n *\n * @param options - The transaction options.\n * @returns A promise that resolves with the result of the read call.\n * @transaction\n * @example\n *\n * ### Raw contract call (recommended)\n *\n * You can read from any contract by using the solidity signature of the function you want to call.\n *\n * ```ts\n * import { getContract } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { useReadContract } from \"thirdweb/react\";\n *\n * const contract = getContract({\n *   client,\n *   address: \"0x...\",\n *   chain: sepolia,\n * });\n *\n * const { data, isLoading } = useReadContract({\n *   contract,\n *   method: \"function tokenURI(uint256 tokenId) returns (string)\",\n *   params: [1n],\n * });\n * ```\n *\n * Note that this is type safe, the params types will be enforced based on the signature.\n *\n * ### Raw contract call with `resolveMethod`\n *\n * If you don't have the solidity signature of the function you want to call, you can use the `resolveMethod` helper to resolve the method from any deployed contract.\n *\n * Note that this is not type safe, and will also have a 1 time overhead of resolving the contract ABI.\n *\n * ```ts\n * import { getContract, resolveMethod } from \"thirdweb\";\n * import { sepolia } from \"thirdweb/chains\";\n * import { useReadContract } from \"thirdweb/react\";\n *\n * const contract = getContract({\n *   client,\n *   address: \"0x...\",\n *   chain: sepolia,\n * });\n *\n * const { data, isLoading } = useReadContract({\n *   contract,\n *   method: resolveMethod(\"tokenURI\"),\n *   params: [1n],\n * });\n * ```\n */\nexport async function readContract<\n  const TAbi extends Abi,\n  const TMethod extends TAbi extends {\n    length: 0;\n  }\n    ?\n        | AbiFunction\n        | `function ${string}`\n        | ((contract: ThirdwebContract<TAbi>) => Promise<AbiFunction>)\n    : ExtractAbiFunctionNames<TAbi>,\n  const TPreparedMethod extends PreparedMethod<\n    ParseMethod<TAbi, TMethod>\n  > = PreparedMethod<ParseMethod<TAbi, TMethod>>,\n>(\n  options: ReadContractOptions<TAbi, TMethod, TPreparedMethod>,\n): Promise<ReadContractResult<TPreparedMethod[2]>> {\n  type ParsedMethod_ = ParseMethod<TAbi, TMethod>;\n  type PreparedMethod_ = PreparedMethod<ParsedMethod_>;\n  const { contract, method, params } = options;\n\n  const resolvePreparedMethod = async () => {\n    if (Array.isArray(method)) {\n      return method as PreparedMethod_;\n    }\n    if (isAbiFunction(method)) {\n      return prepareMethod(method as ParsedMethod_) as PreparedMethod_;\n    }\n\n    if (typeof method === \"function\") {\n      return prepareMethod(\n        // @ts-expect-error - we're sure it's a function\n        (await method(contract)) as ParsedMethod_,\n      ) as PreparedMethod_;\n    }\n    // if the method starts with the string `function ` we always will want to try to parse it\n    if (typeof method === \"string\" && method.startsWith(\"function \")) {\n      // @ts-expect-error - method *is* string in this case\n      const abiItem = parseAbiItem(method);\n      if (abiItem.type === \"function\") {\n        return prepareMethod(abiItem as ParsedMethod_) as PreparedMethod_;\n      }\n      throw new Error(`\"method\" passed is not of type \"function\"`);\n    }\n    // check if we have a \"abi\" on the contract\n    if (contract.abi && contract.abi?.length > 0) {\n      // extract the abiFunction from it\n      const abiFunction = contract.abi?.find(\n        (item) => item.type === \"function\" && item.name === method,\n      );\n      // if we were able to find it -> return it\n      if (abiFunction) {\n        return prepareMethod(abiFunction as ParsedMethod_) as PreparedMethod_;\n      }\n    }\n    throw new Error(`Could not resolve method \"${method}\".`);\n  };\n\n  // resolve in parallel\n  const [resolvedPreparedMethod, resolvedParams] = await Promise.all([\n    resolvePreparedMethod(),\n    typeof params === \"function\" ? params() : params,\n  ]);\n\n  let encodedData: Hex;\n\n  // if we have no inputs, we know it's just the signature\n  if (resolvedPreparedMethod[1].length === 0) {\n    encodedData = resolvedPreparedMethod[0];\n  } else {\n    // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n    // we can do this because we know the specific formats of the values\n    encodedData = (resolvedPreparedMethod[0] +\n      encodeAbiParameters(\n        resolvedPreparedMethod[1],\n        // @ts-expect-error - TODO: fix this type issue\n        resolvedParams,\n      ).slice(2)) as `${(typeof resolvedPreparedMethod)[0]}${string}`;\n  }\n\n  const rpcRequest = getRpcClient({\n    chain: contract.chain,\n    client: contract.client,\n  });\n\n  const result = await eth_call(rpcRequest, {\n    data: encodedData,\n    from: options.from ? getAddress(options.from) : undefined,\n    to: contract.address,\n  });\n  // use the prepared method to decode the result\n  const decoded = decodeAbiParameters(resolvedPreparedMethod[2], result);\n  if (Array.isArray(decoded) && decoded.length === 1) {\n    return decoded[0];\n  }\n\n  return decoded as ReadContractResult<TPreparedMethod[2]>;\n}\n","import type {\n  BlockTag,\n  EIP1193RequestFn,\n  EIP1474Methods,\n  Hex,\n  RpcStateMapping,\n  RpcStateOverride,\n  RpcTransactionRequest,\n} from \"viem\";\nimport { numberToHex } from \"../../utils/encoding/hex.js\";\n\ntype StateOverride = Record<\n  string,\n  {\n    /**\n     * Fake balance to set for the account before executing the call.\n     */\n    balance?: bigint;\n    /**\n     * Fake nonce to set for the account before executing the call.\n     */\n    nonce?: number;\n    /**\n     * Fake EVM bytecode to inject into the account before executing the call.\n     */\n    code?: Hex;\n    /**\n     * Fake key-value mapping to override **all** slots in the account storage before executing the call.\n     */\n    state?: RpcStateMapping;\n    /**\n     * Fake key-value mapping to override **individual** slots in the account storage before executing the call.\n     */\n    stateDiff?: RpcStateMapping;\n  }\n>;\n\nfunction encodeStateOverrides(overrides: StateOverride): RpcStateOverride {\n  return Object.fromEntries(\n    Object.entries(overrides).map(([address, override]) => {\n      return [\n        address,\n        {\n          balance: override.balance ? numberToHex(override.balance) : undefined,\n          code: override.code,\n          nonce: override.nonce ? numberToHex(override.nonce) : undefined,\n          state: override.state,\n          stateDiff: override.stateDiff,\n        },\n      ];\n    }),\n  );\n}\n\n/**\n * Executes a call or a transaction on the Ethereum network.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for the call or transaction.\n * @returns A promise that resolves to the result of the call or transaction.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_call } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const result = await eth_call(rpcRequest, {\n *  to: \"0x...\",\n *  ...\n * });\n * ```\n */\nexport async function eth_call(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: Partial<RpcTransactionRequest> & {\n    blockNumber?: bigint | number;\n    blockTag?: BlockTag;\n    stateOverrides?: StateOverride;\n  },\n): Promise<Hex> {\n  const { blockNumber, blockTag, ...txRequest } = params;\n  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;\n  // default to \"latest\" if no block is provided\n  const block = blockNumberHex || blockTag || \"latest\";\n\n  return await request({\n    method: \"eth_call\",\n    params: params.stateOverrides\n      ? [\n          txRequest as Partial<RpcTransactionRequest>,\n          block,\n          encodeStateOverrides(params.stateOverrides),\n        ]\n      : [txRequest as Partial<RpcTransactionRequest>, block],\n  });\n}\n"],"names":["ForwardRequest","name","type","ChainAwareForwardRequest","async","relayOpenZeppelinTransaction","options","message","messageType","signature","_ref","account","serializableTransaction","transaction","gasless","forrwaderContract","getContract","address","relayerForwarderAddress","chain","client","nonce","readContract","contract","method","params","_gasless$domainName","_gasless$domainVersio","to","Error","gas","data","experimentalChainlessSupport","chainid","BigInt","id","from","value","signTypedData","domain","verifyingContract","version","primaryType","types","chainId","domainName","domainVersion","prepareOpenZeppelinTransaction","response","fetch","relayerUrl","body","stringify","forwarderAddress","request","ok","concat","text","json","result","transactionHash","JSON","parse","txHash","isHex","resolvedPreparedMethod","resolvedParams","Promise","all","_contract$abi","Array","isArray","isAbiFunction","prepareMethod","startsWith","abiItem","parseAbiItem","abi","length","_contract$abi2","abiFunction","find","item","resolvePreparedMethod","encodedData","encodeAbiParameters","slice","rpcRequest","getRpcClient","blockNumber","blockTag","txRequest","_objectWithoutProperties","_excluded","block","numberToHex","undefined","stateOverrides","overrides","Object","fromEntries","entries","map","override","balance","code","state","stateDiff","eth_call","getAddress","decoded","decodeAbiParameters"],"sourceRoot":""}